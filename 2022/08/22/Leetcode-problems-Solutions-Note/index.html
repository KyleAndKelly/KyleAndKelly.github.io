<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":400,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="Leetcode problems Solutions Note">
<meta property="og:url" content="http://example.com/2022/08/22/Leetcode-problems-Solutions-Note/index.html">
<meta property="og:site_name" content="Kyle Chen&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8984e78f-719b-4640-a513-787d3b23d9ce.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a31ff962-6681-4f7c-8888-acccb902ddf6.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f28df7df-9f6a-4428-8716-43437dbb7779.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f5a5009f-b372-4ff7-b09b-9fccd294c442.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/9949d0b3-c8b0-4e41-9117-458fa434ec6d.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/be1e0e85-5bb2-4832-8fe5-3b4aeea1ed1d.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/b7b13ea4-d13d-4598-94ce-ec786ecf8b35.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/446d76db-4a42-44f6-a05e-c86ab53f9f3a.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/2fffdd14-ecfd-44ae-be8e-cc052773364c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/64d338a3-86ff-4faa-bff8-1527f2709f45.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4ac75bae-a807-4e46-b70e-041156c86e71.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/648936e5-1214-439f-9b79-8a72dd0b1b8a.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/bb3a62d2-9b82-4f3b-9ef2-3acc64df36c3.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/892e94bc-1ad6-4b50-8aab-590affd655c2.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f18021ba-0576-4c1b-9b86-f0ef68b32522.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7e901ea4-a7d6-452a-beab-674122765685.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/3e32c7e8-7f40-431c-9d99-b1e1f7f829ca.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/b6203b58-422b-45b9-a11e-da067cdd12be.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f59126b1-98b9-4e33-bc6c-d259cc0f55ab.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/9e16db80-4a17-41b8-9d9d-cdef5be73f58.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/10427a40-975c-4b6b-85ff-d17cc899c623.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/eb7c965d-59c0-4b08-8d6a-6d3943f10cf5.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7821e311-00aa-40b0-8ab9-57471419d97b.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/cd61b224-e4ae-4271-bef4-076a650f65b3.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e078bf30-d641-4c56-b4c9-8d1da707d807.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e4fa6f50-22c9-41c7-8f6c-e43aab780585.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/beeb899a-9927-4525-b0d1-3d241c00ccb4.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e1be0f97-6680-4f55-a373-3a484128fe6a.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/86d145b9-6845-402d-9358-b943bffcdebc.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f8953b4b-43ee-4d3f-a31f-82cd8b633bce.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/423b6ac9-a7bd-4bd4-9840-3813d62617b5.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ec008965-da09-4c78-9ad1-83de91a31f4c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ae78465c-a8c5-4cb3-9bc4-cc6a7f3f1498.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e7e675f6-8b74-4492-a32d-b6c704015af1.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/60ec6cc2-9148-40df-ad8e-2969def89c43.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a5922411-7a62-4a02-8d89-737ddad9f426.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d207a0eb-649a-47c3-94d2-ae381b200eaa.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/3a8da8b9-8e2a-4d67-9b85-61f5438d72f7.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/19d7f700-92c7-4591-bef6-efe163c000f3.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/0c2f4579-0b43-40cb-9b3d-8acd25411140.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/6a5118f3-ceff-4fd5-bed5-37e3eb1d1d63.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/403a3990-3546-4736-98f7-813c0e0093b9.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/684b77e1-27e3-43d2-9fd1-52958d131620.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5f787c97-ba90-4805-a6d6-b04d9f9c957c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8a4705a4-439c-4262-bdce-8186ee916289.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5700074e-68cb-427a-9e58-a1858ab736e1.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/82c123a3-94d3-4b42-8966-eeb5964b1047.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4a4d21b3-ff48-457a-a612-9723074e0647.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5984996e-8148-4ae1-8ed9-8198e3625d2f.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/2a2a7ca4-66f7-4eb4-b733-68a3f4238ee1.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7a667e7d-fb86-49d5-9c3a-bafcc9e7b164.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/707aac6e-eec8-4f5a-8f0f-b7b45d344451.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ebc2117f-b989-4c3d-b852-4b2b26c77453.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e18c6e12-5f03-4540-b1ed-23f59e1d2c55.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/2d101957-45f0-493d-9bc6-ab743496916e.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d775142c-564b-4176-a366-0baecb016c91.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/69a37149-f011-4fef-9a55-272abfbc9b68.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/9ffae3b2-d6d0-4698-add8-49795aaafaf1.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5536a636-d181-42b9-a760-57aff155691a.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/9d910293-a6c0-4c4b-bfd8-c8e32fae01e8.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8079c50a-6dbe-4779-9b7d-ff76f481397d.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/317b8a93-0319-40c0-9273-c7d6ea72516a.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/73a115c9-da59-46f5-888c-2a70cd01953f.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/19e5cf6f-0c41-4a7c-804d-9d81beac4123.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8ef92a66-0286-4473-88b6-76fd2e9613ed.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/3c123721-1909-4e2c-91e3-c2d357b57458.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/2f69c7c1-c466-4ba5-aeb7-ee8d57b4bc1c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/1082c59b-c9b3-44b1-a291-78fb192b9ea4.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ce693fb0-6d34-4939-93b2-58af527f3ab4.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/836dc250-a4b3-4acd-80a8-5202dbd8266b.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/144ef974-6b43-473c-9b4e-76efb177144a.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/b2f8f7dd-d476-4624-bed2-09ed94cd6f74.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/bc43d48c-bd11-4ebe-816d-8df25edec96b.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/be81cb56-2d21-4267-81ff-c1fe308261cd.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/863165d0-8403-42e8-abcb-4387abc6f8d3.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f05af832-f82d-4a9a-85c8-880b56b213a8.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/0db9683d-96ad-462b-9c2f-e80cb835f227.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/828bd8c8-3c46-49e2-8d18-ae06aa6d3582.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/03a1de17-c22e-4c59-9494-1f0b2d174b29.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/9522e217-e06b-4346-84a0-eb8263b04f93.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7b12d053-d366-4765-bfe4-75826f938e07.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ca057ccb-65b9-48c8-9fee-a4024d76d47c.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4ac49557-f581-4661-a123-af48b849ece1.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/9056d59a-86ef-4471-b065-a0a89df02627.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/19b73a26-c4e0-4af9-b278-52185b8bc40c.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e0b97aff-77d6-44a0-905d-ddf01528b962.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/6fb39538-c320-49bd-b472-3e6dc981eb4d.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/2fe78d28-cb51-4119-a5e7-2d289ee647c7.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5587729c-faa6-4969-9c44-33c350aac1a6.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7bc821d7-1447-46ae-899c-cd1196d3e8fe.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c2a7b9ac-91b4-4ecd-ac11-9c6f89d76202.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/83c47edf-7580-482f-9d47-83717761349c.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/623c9607-ca24-41cb-a43c-64e5a071ed00.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/3d092f02-d8a2-49fe-9ae9-a89efccf9907.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/fcfc655c-34c8-49b5-8ab9-09d72d74a3cb.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/05eda67c-4389-4973-9617-02aefee2129f.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f5cbc2d0-8659-47c7-b189-9da1f9840224.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/2345cdfb-b295-4124-83a5-4cf212022be0.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/58a66c05-9434-4a32-89b8-ec1b10ba4c88.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d57e3684-a3f8-4baa-a8e1-0909a9b5c969.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5c8a5c07-af35-4430-8d91-b7a975b4ba33.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e7b49339-91b4-4ada-a0b5-14ec5d3cb9d9.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/77577f23-520d-480a-b4d1-94f1e25aeed7.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c6f390b2-c832-408a-ab8e-587085f4faf8.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/bb53951f-2e43-453c-b6f6-0383e670e50f.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/76ff413d-adba-4dd6-a6f7-14af4914335c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4c7ba032-9897-4231-bb99-98f8ecdcc362.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c5e2d5e5-ba77-4e29-9aa1-9e78c0599f01.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d8bbcdd3-9968-4deb-b8db-b0c7f87e0856.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/34b15e82-e8e8-4a37-8eb6-89773c3e5b12.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7d866548-cf10-4e94-b709-7f71ef98a483.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/3b246e5f-80a9-4142-afcc-f87821e72388.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/40509b75-a36f-4c79-88d3-5bfc2084e109.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a871d490-3098-4744-acd1-27faa3facd1e.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/861c46f5-40c1-4452-bae1-d1fe40b46687.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/65b0b068-a855-410f-833f-0cd18b42c057.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/127549f9-fa4e-440b-9f58-7e2ec00d19dc.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/1da2c2bf-57a1-4e47-87f9-613dbee436fb.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7d2f2092-3b35-4543-806a-3426630f698d.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c27eca08-3f9b-4813-b858-da16881adde7.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5d0202cd-9252-47fc-bb24-c44a7962fc24.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c072ce6a-4174-41b0-b176-459494233b1e.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/01f7eaa0-e02c-4bf6-9dbb-4efcf67513b5.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/34777dfe-25ba-4a81-883e-b66110b1a8c9.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8b223432-03ba-43a5-8968-584c7c8d8068.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/36ee0f58-1bce-411c-b3fc-308d769ad869.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a150914f-1207-4dc6-8091-639f11405933.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d66220b0-0d89-479e-9313-6adce6816e8c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/17bcb971-2dd2-4659-a84f-24493a37c88e.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/6128b483-caa2-4730-a94c-7b53e02cb7b0.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/183fb47d-cb82-4909-bfae-8f78c632e7ea.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c9037420-1a61-4305-bad1-b4227ec9707f.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f5098755-cba5-4145-9804-8e4cbff4dd48.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e3138c17-60bb-411d-9843-f6639bd0abd7.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/2c2e1f87-d654-46f1-a83f-c36c34189b47.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d51c2fab-43eb-470b-8d20-9408f94774ed.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c672b522-c4ab-424a-b872-59264a5bd13e.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/77a88286-4f3b-40a2-8aa5-6513bef59e05.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/64dedead-67bc-48c3-b39b-b7eefdecdbf3.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c5329093-56fd-4e91-8ee1-7c045e22310f.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a89ccc07-d81b-4c4c-9430-b0c3096d59c0.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f23d7252-0e97-4d3c-890a-434c8b5803d5.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a2d7a7ea-4135-46f9-9ce9-0601312f2e95.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/2c27e439-fff2-4f5e-a3e7-d35da3dd0250.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ddadda37-15c0-4593-9817-db62669441a3.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/aefe8796-fac3-4849-a19c-fce0f029ba08.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/070d05a3-3ee3-4b0a-90da-bed5c1c2b9a8.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a730fbab-4997-4af9-a608-85ffe0bcac07.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/442400a3-6855-4a90-a088-8d14c10099fd.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f3d44400-5e6a-4005-be47-2a20e288383f.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c1843e98-f7e0-4e0b-b053-3bdb40abb586.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7cb88611-e8e0-4de4-a0e0-c34d8a78df3d.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f9a6f9ba-1a2e-4ef2-8799-6b93c635519c.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a8df6972-ea60-4073-a9ed-c607c5017b21.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ba15565c-2189-4cda-b8eb-92ada72b826f.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/166bca4c-bcc2-4718-b6f4-1576acf3ff36.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/35a4e4dc-eb76-4d87-ba29-735a5042bfe1.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/3f09955d-d39b-41e9-8495-445cf9b35418.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/bdcd019a-a049-4e57-ac75-c491a552e1e0.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/6aa612fa-c6de-4c45-bcb7-0ed123b1a063.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f28b6ed7-01b5-4a89-952f-d626edf15d9e.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/988437b9-f65e-4111-8cde-79a687333027.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c915e202-251b-48cd-816b-cfcabdbf2214.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/04aefe28-f537-4f0f-a96c-e08abbe1030f.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/de302c02-3172-4795-81bf-b52f9a497fcf.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/48c2dc78-d14d-4a7d-b5fd-0ca2431b377a.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/fb683879-39db-4823-890b-e02d5deeb48c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/69e49a83-545c-483f-8a37-ec3b834d2e93.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/b09171cd-4ad6-4049-bd68-cb3ac6236510.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e65a5f5c-4e4e-4bb7-857a-f5fd4309020f.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/815f7215-0047-455e-8cc3-fa211fc82157.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/eb69f29d-548d-4414-bd1f-27b9944ac200.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5f3de36e-929d-4f22-adcb-a8070f305409.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/1ab57d58-3c53-4974-885c-d0b997487df7.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/9abc4082-7aba-4bf2-95ab-8151841c8777.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/dbda7684-ec6b-4517-89ef-8415d7f95a32.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5cd09d98-bd6d-413f-a699-5d03755f5802.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/66e5f430-7a71-4480-8d2b-930a4ea9a2df.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5bfffdd4-470d-482c-849d-e4e82e2b40d8.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f6e5ea9e-b6b4-4545-97c5-2ef86e5fbd08.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/b3fb36fb-92e9-417d-9c00-60756ed04c17.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/1d658e59-2c76-4ade-a9c5-39a2ff20161f.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7fc31992-dc5b-4e11-bb5e-7c61942e6e57.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4097f955-844e-4ceb-a4c1-513342bc6e37.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4bab35d7-99bc-45ab-9bc4-cccdbe223a0c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/731a9af6-7a21-42e7-9a1b-f4b2d9cfddba.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/97cb5a3b-6aaa-4be9-9b17-dde9d86f17ab.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/80714af6-4b56-4b6d-965a-6d0e396c1b63.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/6225fcf0-251b-4649-92fa-65307499a714.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/3b831fba-7be3-423c-87d3-d1f5f499cd9c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7e984502-8307-4144-85fa-134adc4a304f.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/997007a2-0e00-49d3-88fc-6865a7578af8.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/21a7a3a3-e652-45a8-99cb-f56b22227301.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/bd454bbc-41fb-4383-8f76-57b770d4b60d.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/6fc73b94-e500-4182-a9f9-e1d8a4e29a32.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e8db6a23-fe74-4f65-b6a6-6cafbddff0bc.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/319c806f-a568-403a-9a39-c4ac50f30308.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/846120fb-5574-4fde-bd23-c798e938fa6e.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d99bbb87-979c-426b-b6e5-647acf2cad20.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/1a1aae99-5b02-4641-9e50-5bd0913d1e4d.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8aeff7af-53ed-467e-aebc-7835db5b52f5.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5be86979-df7c-4994-a29c-088dc60e24e6.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a825eedd-e311-4153-bc5b-ed31be497911.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/1d9b3377-72f8-4c1b-8451-a2e484bfdc1c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/fb453ee9-27d8-4bad-86ea-346219e70b18.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/bd915655-54ae-4387-8d94-22cabd830f19.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4391ada0-91de-488d-a3a9-23fa346ea804.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f65c3a6a-debe-4c68-ac3b-171b07af7262.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/9add3a1c-b13f-4277-a2b6-e511bf914864.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/1411c0a9-8a0f-452f-8fc6-ff371d70d1d0.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/fc7adb50-508e-4b31-b28e-f3f11eea8217.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/335701cf-1815-4ee0-a266-d54c6c35669b.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/725fc0e8-c8e6-4660-b971-9c47beb3c888.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7323d75f-2b46-4b8a-9908-4f5c654281f5.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d5233fdc-b942-4252-b385-aeaa32428270.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/76432652-12d7-4385-8ea8-6dae686cd490.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e7ac0fe5-7797-4094-a619-f13588081fd5.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f40bfb53-0680-426d-b458-8de6820f7bae.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ca4fbbe4-2cea-43f3-ac48-3d192c40bacf.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/0b64394f-ee13-447f-835a-965086697e94.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a01bf43a-aa9c-45e4-8e02-e38f1a09bba3.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5f397d41-0fd5-406a-befb-20bb996d6862.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/6ed11899-abbb-4316-b5f5-0905cc477414.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/eef3c25b-9218-4dd9-83d7-392ec8df5f36.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a181f628-892e-4ab3-9509-236d9b01c497.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a1ffabf9-420e-46a6-a2e1-ae5db89d9a6e.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/edd0b34a-aae0-4667-8e36-645c0c1fbd04.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4f33e6e4-017a-4f41-81a0-7f60d1d578f0.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/eb446da9-85b1-4898-b238-ee7548e16cc1.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d6347f35-ca4c-425c-b8ca-6b7e2ae2ab07.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a8de2fa0-7abe-474d-a113-bca524a5c19d.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f451fbd9-f97d-4b05-9a25-92f9f405369b.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/90ee8419-0d4e-4f4f-9e93-06007789a613.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/724583f7-e9bf-46be-a2e9-235ba7e2d358.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/971e09e6-1b22-4c78-a3bc-956a6d4f1827.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/df37bbbe-bbbb-4e52-b5ae-5ba6fd84cd30.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/cd09a3b7-fdbb-469a-8609-f64f592fda01.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/b2e898e8-a1bf-4e57-88b2-00546145e9d0.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/bb70337e-337f-4525-9b82-628e0ababa73.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/6b0ad4c7-d06d-477f-a7be-fc2e043a0db5.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/30ba428f-42b6-472b-8b8b-23aaef1c23b6.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f14525cf-e0bb-44a5-a385-54ae95316f9b.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/75306b0a-0beb-4576-a53e-49b2835d09c8.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/04e73830-74d3-4ebe-9b91-a8058dd5f0d8.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/37f7ba54-f044-48a7-a5fc-c2d9a82f7b3c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/44e2b2c5-3a86-4e20-97d1-45502d4bfc29.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/aa634f7b-decf-4a6c-8e21-80efe413f3c1.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/9f8c8e11-c866-4407-8346-5dee64d57879.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ad0cf225-2160-4223-8147-528ce599990c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/feb1c7fb-24cf-4081-a9db-574dc3b46711.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7a9ccbf5-4ed2-4bdd-aaeb-5b91d2e4c7a1.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/3cd35f16-15b6-4698-8053-935ffdd85349.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7ee6b978-400a-44f6-8197-a9507c8e058b.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/86154c4e-b8da-4890-ab23-b2612d4c5777.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f6a63c36-aafb-4e9c-a5c7-3eac3a044410.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4484458a-b006-4fe8-a7a8-ea586342ca22.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/448bc91c-0af2-4a4b-af89-c01fa606a5b7.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/00e1d4fd-e285-4863-8b0b-3060766bb525.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/cc8a492c-a4e6-4df7-a90d-320f17769205.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f5955143-7685-4b34-b5dd-9b24fa5290ce.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8faa0b82-6c1d-4433-abc3-8bb1ef5df8b6.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8c0e907f-f383-48da-98e6-ed531d6bd93a.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c13f7729-4dce-428f-8f31-b5f9317a5ce2.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a9da96c8-01ef-4845-9aae-aa779466e765.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/802538d5-95df-4c84-9c65-31ac4b52eff3.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/bc9e3a37-edc5-498a-b026-882a06a64125.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/654af93a-97e3-4f83-88fb-c27a32ac905a.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/201501bf-a7cf-4604-9d0c-860c89a8eeb9.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/9aed981d-b202-4bc8-b0a1-1e9080dc85c1.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/61447011-c76d-459e-be76-ed35d1d0edeb.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/32ee1091-199d-4e97-be7e-8c82cd1a5660.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/9d0654e6-75ac-4ef1-9309-aa410463028e.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8c154642-a002-4b1e-a451-679ecaab6052.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/aa8f67bb-f725-4ac9-b288-f00702b84a55.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ac2814f5-9f64-451b-8a2f-167966444bc9.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/89471a17-0dc3-4180-9b34-d9d5c6c4f9da.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/bfd3a090-de97-4eff-a66b-be9cddb9bbc8.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/57e2bfe5-e188-42e3-9460-4fa79082ecd2.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/702de056-c52b-45b9-9965-8112d4131454.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/48ae75e0-df07-48f0-bfea-017869bac869.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/0052ac37-a066-4e57-97fd-4ebe72e6418e.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a4c9016a-3529-492d-a5c4-4172619a5168.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/cf2db259-ce16-4284-97f8-6e048c789bd5.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/544a41e4-a185-4dff-941f-79e6a60d6e79.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f0bf9bc6-9c7f-434c-b924-cba7405ed0fb.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/446462c6-005a-4165-81a4-213042a92492.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/207854fc-5451-44e1-84a6-51cde0d77f0f.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/15ea384d-bb95-4dbf-8d73-ba9536ff3f95.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/50bd7865-2516-4f4d-bdf7-4de2f00cdf80.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/620df582-d9ad-49fd-a069-2b6bb56fa29c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a39d57a7-49a2-4353-a4a4-68361420e23e.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/19234557-e889-43c9-84a6-e55b36d24aec.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/15a63a92-7b41-4707-a824-964718554f58.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/91669611-5065-4e62-9bcc-ba187bda8268.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/297b7397-78fa-402f-9848-36a3e6baeafc.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ff5136fb-3f4c-4caa-900f-e4d562a63e80.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e329b323-7662-4aa8-bef3-0ecf293c49de.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f01b0278-174b-461f-8ac7-191f13995a3b.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/bac74319-f5dc-4b47-8f63-1cc381458756.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4a32da04-9232-437a-98df-26863d85179e.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/aee56655-c266-45ae-aeda-2cb3e1573c71.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/6713148f-44c9-472b-9956-90bcad147d34.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e9aeb4c3-d429-4dbd-ad0a-9d7ae18c6b50.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/9011acac-108a-45de-a940-7dc0cbe33807.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/94ef5c0b-92a5-437e-8920-e808dbf6cc4d.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/433263e7-9556-438c-8f3d-c260225dbf1d.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4614ddda-961b-4eed-8ee4-cc50ffb25935.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/50faf577-63ab-4b9c-bd6f-59ed0c2ce516.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c918777d-7c9e-42a2-95fb-576b4618efd1.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/6afab0e0-5928-483e-a44d-bd6fa19e36dd.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/63b82d8b-42d1-4360-b5e7-224ad1ccb987.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7134c1a6-a705-41e0-b994-d9df133ffd06.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a5fa6552-4f5e-434b-a31e-38bf09a2cdab.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8accb7cf-0178-49e7-a907-44da8c41ca8e.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5e428394-3fd2-480c-9c7e-2bd099118a10.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/56115b51-a2ce-4bca-8a39-7c4ac2e070e6.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e92fd7e3-d208-4978-bdf6-fd51492fbeb6.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/6d46c580-ca37-4f4d-89cb-b250a209b90a.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/52bf9fe5-269b-46c3-8f40-dac13d75ecdb.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4254d052-fced-468a-a06b-80a9c388b798.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ba0409e5-fa6d-4d7e-9292-f5be87a8fd13.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f7b719a0-e068-42c3-b6f8-6f20301194df.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4ef04808-5bea-4610-9567-9fe0c028d63c.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/bad95909-e879-4f70-97f2-f9d01d7f5d22.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ec7c4226-3a47-4a54-bfdc-740e523ceaac.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/06c76a5a-8e15-4971-9fa9-4702abdf8348.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/3bbe711c-cbeb-459c-ad4b-e00d7b508cb4.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/67ec0ae6-0a3c-4dc0-bc54-2f6bfa7b6d5d.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5ad4608e-ae3f-4ea6-abc5-01ccba98b8bd.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/bdc5a0f5-514e-4994-97ae-4aa2b468d4a1.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e7287e83-0a0f-4c88-97a9-70c01dd6b61a.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/12f83946-efa1-4c45-aefb-cf2385b1e4e0.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/014f2c8d-e879-4228-a24e-3c902a6366cf.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/aa420d60-feec-41e4-b141-ad2d40924901.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a0be23ac-6081-411c-96cb-9f2c79fcabb1.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7c65b823-1c0b-4d4f-8a13-554fb12cf314.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e648c0ad-b283-4b66-90d7-4bc23329dd5a.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/64f8d26f-c230-49c3-b398-df245f234505.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/92daf8e2-3349-475e-af48-4ad83be8a41e.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/174e0c93-01d3-41d0-8a49-c894760318e3.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/31bcba36-c886-412a-a41d-069f5cd29713.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/81edb05f-482a-48d2-a709-9c012a5a148c.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/56fac4ed-d7a0-42b3-b63c-5ae4151b4d95.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/979f2ad7-bb3d-4d06-8f1e-56c11921e810.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/eee786ba-73e5-4de7-9cc8-b82b80c56364.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f5e179e8-5c9b-40e5-b110-75d3cb245491.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c8d08da7-0629-49fc-b47b-55d8f9ec7c71.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/2d61a58f-d344-424e-8716-5ab9c5653f6e.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e5f2d5b8-6440-4910-9eb2-20848cebe369.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/08f457d6-d730-4b87-bff8-e9211b8332bd.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/86763d3e-dcd7-46e9-bbe3-d0b14813dc5b.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/11abbaeb-d616-4866-9bd8-029b298f1f97.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/074c12a8-524a-4f31-8abd-878e9aca33be.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c5bfa348-f61c-44be-b5a6-797e736ece90.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/90f1cfd8-35b9-44aa-8281-b9fc3097c54a.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d1fcc62e-aeaa-4ccf-b224-ab724f90ae37.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d3a4ed92-b21e-4237-87cd-5bfb2bee545e.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/0f99a883-da18-46ca-9985-d7ba4a46092d.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d5a6910c-41c0-471f-b8c3-3b79ae583be8.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/252bc915-1dc7-43e6-9498-e75607502c81.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/81e7a78b-6e9b-4804-b4bc-f32031fdd571.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/30ad2757-a9f8-4d82-8c7f-c651fdf864de.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c3f4eaeb-9f8f-4265-9009-1a4b808cb5e6.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a1c451b7-b2eb-4545-b354-c7c37a1ab8e0.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d7e4710d-6ea2-41b2-9aba-1dca85dcd9d3.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/6f172e79-74e2-452d-ab77-a7149388bb74.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/98e33881-29f0-4462-9991-2012f94ae9f1.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d5945a88-399a-4b88-a5b5-20e6fe7e7e99.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f8c0d53a-9c66-4d00-857c-cab81d087035.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/0e795a17-567a-42d3-a1bb-677b12f407e8.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/152a336e-c600-4937-850c-d0f1fd5a4c4f.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f075ebdf-3df9-4229-be81-efdca44423d4.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/55e84e02-f0b6-4e27-ace1-28039e20c7ef.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7b8def0f-7d26-40fb-8936-24236b14e7af.jpg">
<meta property="article:published_time" content="2022-08-22T14:45:47.000Z">
<meta property="article:modified_time" content="2023-02-25T14:43:47.237Z">
<meta property="article:author" content="陈同学">
<meta property="article:tag" content="Leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://files.mdnice.com/user/1489/8984e78f-719b-4640-a513-787d3b23d9ce.jpg">

<link rel="canonical" href="http://example.com/2022/08/22/Leetcode-problems-Solutions-Note/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Leetcode problems Solutions Note | Kyle Chen's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Kyle Chen's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Kyle Chen's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Action speaks louder than Words</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/22/Leetcode-problems-Solutions-Note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="陈同学">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kyle Chen's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Leetcode problems Solutions Note
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-22 22:45:47" itemprop="dateCreated datePublished" datetime="2022-08-22T22:45:47+08:00">2022-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-25 22:43:47" itemprop="dateModified" datetime="2023-02-25T22:43:47+08:00">2023-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
                </span>
            </span>

          
            <div class="post-description"> </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <meta name="referrer" content="no-referrer"/>

<p>@<a href="Content">toc</a></p>
<h1 id="回溯-字符串的排列"><a href="#回溯-字符串的排列" class="headerlink" title="回溯: 字符串的排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof">回溯: 字符串的排列</a></h1><p><img src="https://files.mdnice.com/user/1489/8984e78f-719b-4640-a513-787d3b23d9ce.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/a31ff962-6681-4f7c-8888-acccb902ddf6.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/f28df7df-9f6a-4428-8716-43437dbb7779.jpg"></p>
<h1 id="回溯：78-子集"><a href="#回溯：78-子集" class="headerlink" title="回溯：78. 子集"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/subsets/">回溯：78. 子集</a></h1><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3]<br>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]<br>示例 2：</p>
<p>输入：nums &#x3D; [0]<br>输出：[[],[0]]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10<br>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10<br>nums 中的所有元素 互不相同</p>
<p><img src="https://files.mdnice.com/user/1489/f5a5009f-b372-4ff7-b09b-9fccd294c442.png"></p>
<h2 id="Solution1-回溯"><a href="#Solution1-回溯" class="headerlink" title="Solution1 回溯"></a>Solution1 回溯</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/subsets/comments/1011321">https://leetcode.com/problems/subsets/comments/1011321</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/">https://leetcode.com/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line">    void backtracking(vector&lt;int&gt;&amp; nums, int startIndex) &#123;</span><br><span class="line">        result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉自己</span><br><span class="line">        if (startIndex &gt;= nums.size()) &#123; // 终止条件可以不加</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = startIndex; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            path.push_back(nums[i]);</span><br><span class="line">            backtracking(nums, i + 1);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        backtracking(nums, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="回溯：-39-组合总和"><a href="#回溯：-39-组合总和" class="headerlink" title="回溯： 39. 组合总和"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum/">回溯： 39. 组合总和</a></h1><h2 id="Solution1-暴力"><a href="#Solution1-暴力" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-回溯"><a href="#Solution2-回溯" class="headerlink" title="Solution2 回溯"></a>Solution2 回溯</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;int&gt;&amp; candidates, int target, vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt;&amp; combine, int idx) &#123;</span><br><span class="line">        if (idx == candidates.size()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (target == 0) &#123;</span><br><span class="line">            ans.emplace_back(combine);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 直接跳过</span><br><span class="line">        dfs(candidates, target, ans, combine, idx + 1);</span><br><span class="line">        // 选择当前数</span><br><span class="line">        if (target - candidates[idx] &gt;= 0) &#123;</span><br><span class="line">            combine.emplace_back(candidates[idx]);</span><br><span class="line">            dfs(candidates, target - candidates[idx], ans, combine, idx);</span><br><span class="line">            combine.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        vector&lt;int&gt; combine;</span><br><span class="line">        dfs(candidates, target, ans, combine, 0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://files.mdnice.com/user/1489/9949d0b3-c8b0-4e41-9117-458fa434ec6d.png"></p>
<p><img src="https://files.mdnice.com/user/1489/be1e0e85-5bb2-4832-8fe5-3b4aeea1ed1d.png"></p>
<h1 id="回溯：-40-组合总和-II"><a href="#回溯：-40-组合总和-II" class="headerlink" title="回溯： 40. 组合总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/combination-sum-ii/">回溯： 40. 组合总和 II</a></h1><h2 id="Solution1-回溯-1"><a href="#Solution1-回溯-1" class="headerlink" title="Solution1 回溯"></a>Solution1 回溯</h2><p>方法一：回溯<br>思路与算法</p>
<p>由于我们需要求出所有和为 \textit{target}target 的组合，并且每个数只能使用一次，因此我们可以使用递归 + 回溯的方法来解决这个问题：</p>
<p>我们用 \textit{dfs}(\textit{pos}, \textit{rest})dfs(pos,rest) 表示递归的函数，其中 \textit{pos}pos 表示我们当前递归到了数组 \textit{candidates}candidates 中的第 \textit{pos}pos 个数，而 \textit{rest}rest 表示我们还需要选择和为 \textit{rest}rest 的数放入列表作为一个组合；</p>
<p>对于当前的第 \textit{pos}pos 个数，我们有两种方法：选或者不选。如果我们选了这个数，那么我们调用 \textit{dfs}(\textit{pos} + 1, \textit{rest} - \textit{candidates}[\textit{pos}])dfs(pos+1,rest−candidates[pos]) 进行递归，注意这里必须满足 \textit{rest} \geq \textit{candidates}[\textit{pos}]rest≥candidates[pos]。如果我们不选这个数，那么我们调用 \textit{dfs}(\textit{pos} + 1, \textit{rest})dfs(pos+1,rest) 进行递归；</p>
<p>在某次递归开始前，如果 \textit{rest}rest 的值为 00，说明我们找到了一个和为 \textit{target}target 的组合，将其放入答案中。每次调用递归函数前，如果我们选了那个数，就需要将其放入列表的末尾，该列表中存储了我们选的所有数。在回溯时，如果我们选了那个数，就要将其从列表的末尾删除。</p>
<p>上述算法就是一个标准的递归 + 回溯算法，但是它并不适用于本题。这是因为题目描述中规定了解集不能包含重复的组合，而上述的算法中并没有去除重复的组合。</p>
<p>例如当 \textit{candidates} &#x3D; [2, 2]candidates&#x3D;[2,2]，\textit{target} &#x3D; 2target&#x3D;2 时，上述算法会将列表 [2][2] 放入答案两次。</p>
<p>因此，我们需要改进上述算法，在求出组合的过程中就进行去重的操作。我们可以考虑将相同的数放在一起进行处理，也就是说，如果数 \textit{x}x 出现了 yy 次，那么在递归时一次性地处理它们，即分别调用选择 0, 1, \cdots, y0,1,⋯,y 次 xx 的递归函数。这样我们就不会得到重复的组合。具体地：</p>
<p>我们使用一个哈希映射（HashMap）统计数组 \textit{candidates}candidates 中每个数出现的次数。在统计完成之后，我们将结果放入一个列表 \textit{freq}freq 中，方便后续的递归使用。</p>
<p>列表 \textit{freq}freq 的长度即为数组 \textit{candidates}candidates 中不同数的个数。其中的每一项对应着哈希映射中的一个键值对，即某个数以及它出现的次数。<br>在递归时，对于当前的第 \textit{pos}pos 个数，它的值为 \textit{freq}[\textit{pos}][0]freq[pos][0]，出现的次数为 \textit{freq}[\textit{pos}][1]freq[pos][1]，那么我们可以调用</p>
<p>\textit{dfs}(\textit{pos} + 1, \textit{rest} - i \times \textit{freq}[\textit{pos}][0])<br>dfs(pos+1,rest−i×freq[pos][0])</p>
<p>即我们选择了这个数 ii 次。这里 ii 不能大于这个数出现的次数，并且 i \times \textit{freq}[\textit{pos}][0]i×freq[pos][0] 也不能大于 \textit{rest}rest。同时，我们需要将 ii 个 \textit{freq}[\textit{pos}][0]freq[pos][0] 放入列表中。</p>
<p>这样一来，我们就可以不重复地枚举所有的组合了。</p>
<p>我们还可以进行什么优化（剪枝）呢？一种比较常用的优化方法是，我们将 \textit{freq}freq 根据数从小到大排序，这样我们在递归时会先选择小的数，再选择大的数。这样做的好处是，当我们递归到 \textit{dfs}(\textit{pos}, \textit{rest})dfs(pos,rest) 时，如果 \textit{freq}[\textit{pos}][0]freq[pos][0] 已经大于 \textit{rest}rest，那么后面还没有递归到的数也都大于 \textit{rest}rest，这就说明不可能再选择若干个和为 \textit{rest}rest 的数放入列表了。此时，我们就可以直接回溯。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; freq;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    vector&lt;int&gt; sequence;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void dfs(int pos, int rest) &#123;</span><br><span class="line">        if (rest == 0) &#123;</span><br><span class="line">            ans.push_back(sequence);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (pos == freq.size() || rest &lt; freq[pos].first) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(pos + 1, rest);</span><br><span class="line"></span><br><span class="line">        int most = min(rest / freq[pos].first, freq[pos].second);</span><br><span class="line">        for (int i = 1; i &lt;= most; ++i) &#123;</span><br><span class="line">            sequence.push_back(freq[pos].first);</span><br><span class="line">            dfs(pos + 1, rest - i * freq[pos].first);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= most; ++i) &#123;</span><br><span class="line">            sequence.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        for (int num: candidates) &#123;</span><br><span class="line">            if (freq.empty() || num != freq.back().first) &#123;</span><br><span class="line">                freq.emplace_back(num, 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ++freq.back().second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(0, target);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://files.mdnice.com/user/1489/b7b13ea4-d13d-4598-94ce-ec786ecf8b35.png"></p>
<p><img src="https://files.mdnice.com/user/1489/446d76db-4a42-44f6-a05e-c86ab53f9f3a.png"></p>
<p><img src="https://files.mdnice.com/user/1489/2fffdd14-ecfd-44ae-be8e-cc052773364c.png"></p>
<p><img src="https://files.mdnice.com/user/1489/64d338a3-86ff-4faa-bff8-1527f2709f45.png"></p>
<p><img src="https://files.mdnice.com/user/1489/4ac75bae-a807-4e46-b70e-041156c86e71.png"></p>
<p><img src="https://files.mdnice.com/user/1489/648936e5-1214-439f-9b79-8a72dd0b1b8a.png"></p>
<h1 id="回溯：-46-全排列"><a href="#回溯：-46-全排列" class="headerlink" title="回溯： 46. 全排列"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations/">回溯： 46. 全排列</a></h1><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]<br>示例 2：</p>
<p>输入：nums &#x3D; [0,1]<br>输出：[[0,1],[1,0]]<br>示例 3：</p>
<p>输入：nums &#x3D; [1]<br>输出：[[1]]
 </p>
<h2 id="Solution1-暴力-1"><a href="#Solution1-暴力-1" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-回溯-1"><a href="#Solution2-回溯-1" class="headerlink" title="Solution2 回溯"></a>Solution2 回溯</h2><p><img src="https://files.mdnice.com/user/1489/bb3a62d2-9b82-4f3b-9ef2-3acc64df36c3.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void backtrack(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; output, int first, int len)&#123;</span><br><span class="line">        // 所有数都填完了</span><br><span class="line">        if (first == len) &#123;</span><br><span class="line">            res.emplace_back(output);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = first; i &lt; len; ++i) &#123;</span><br><span class="line">            // 动态维护数组</span><br><span class="line">            swap(output[i], output[first]);</span><br><span class="line">            // 继续递归填下一个数</span><br><span class="line">            backtrack(res, output, first + 1, len);</span><br><span class="line">            // 撤销操作</span><br><span class="line">            swap(output[i], output[first]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">        backtrack(res, nums, 0, (int)nums.size());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="回溯：22-括号生成"><a href="#回溯：22-括号生成" class="headerlink" title="回溯：22. 括号生成"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/generate-parentheses/">回溯：22. 括号生成</a></h1><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
<p>示例 1：</p>
<p>输入：n &#x3D; 3<br>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]<br>示例 2：</p>
<p>输入：n &#x3D; 1<br>输出：[“()”]</p>
<p>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 8</p>
<p><img src="https://files.mdnice.com/user/1489/892e94bc-1ad6-4b50-8aab-590affd655c2.png"></p>
<p><img src="https://files.mdnice.com/user/1489/f18021ba-0576-4c1b-9b86-f0ef68b32522.png"></p>
<p><img src="https://files.mdnice.com/user/1489/7e901ea4-a7d6-452a-beab-674122765685.png"></p>
<p><img src="https://files.mdnice.com/user/1489/3e32c7e8-7f40-431c-9d99-b1e1f7f829ca.png"></p>
<p><img src="https://files.mdnice.com/user/1489/b6203b58-422b-45b9-a11e-da067cdd12be.png"></p>
<p><img src="https://files.mdnice.com/user/1489/f59126b1-98b9-4e33-bc6c-d259cc0f55ab.png"></p>
<h2 id="Solution1-暴力-2"><a href="#Solution1-暴力-2" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><p><img src="https://files.mdnice.com/user/1489/9e16db80-4a17-41b8-9d9d-cdef5be73f58.png"></p>
<h2 id="Solution2-递归-剪枝"><a href="#Solution2-递归-剪枝" class="headerlink" title="Solution2 递归 + 剪枝"></a>Solution2 递归 + 剪枝</h2><p><img src="https://files.mdnice.com/user/1489/10427a40-975c-4b6b-85ff-d17cc899c623.png"></p>
<h1 id="回溯-17-电话号码的字母组合"><a href="#回溯-17-电话号码的字母组合" class="headerlink" title="回溯: 17. 电话号码的字母组合"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/">回溯: 17. 电话号码的字母组合</a></h1><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：digits &#x3D; “23”<br>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]<br>示例 2：</p>
<p>输入：digits &#x3D; “”<br>输出：[]<br>示例 3：</p>
<p>输入：digits &#x3D; “2”<br>输出：[“a”,”b”,”c”]
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; digits.length &lt;&#x3D; 4<br>digits[i] 是范围 [‘2’, ‘9’] 的一个数字。</p>
<h2 id="Solution-1-暴力"><a href="#Solution-1-暴力" class="headerlink" title="Solution 1  暴力"></a>Solution 1  暴力</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Simple and efficient iterative solution.</span><br><span class="line"></span><br><span class="line">Explanation with sample input &quot;123&quot;</span><br><span class="line"></span><br><span class="line">Initial state:</span><br><span class="line"></span><br><span class="line">result = &#123;&quot;&quot;&#125;</span><br><span class="line">Stage 1 for number &quot;1&quot;:</span><br><span class="line"></span><br><span class="line">result has &#123;&quot;&quot;&#125;</span><br><span class="line">candiate is &quot;abc&quot;</span><br><span class="line">generate three strings &quot;&quot; + &quot;a&quot;, &quot;&quot;+&quot;b&quot;, &quot;&quot;+&quot;c&quot; and put into tmp,</span><br><span class="line">tmp = &#123;&quot;a&quot;, &quot;b&quot;,&quot;c&quot;&#125;</span><br><span class="line">swap result and tmp (swap does not take memory copy)</span><br><span class="line">Now result has &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</span><br><span class="line">Stage 2 for number &quot;2&quot;:</span><br><span class="line"></span><br><span class="line">result has &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</span><br><span class="line">candidate is &quot;def&quot;</span><br><span class="line">generate nine strings and put into tmp,</span><br><span class="line">&quot;a&quot; + &quot;d&quot;, &quot;a&quot;+&quot;e&quot;, &quot;a&quot;+&quot;f&quot;,</span><br><span class="line">&quot;b&quot; + &quot;d&quot;, &quot;b&quot;+&quot;e&quot;, &quot;b&quot;+&quot;f&quot;,</span><br><span class="line">&quot;c&quot; + &quot;d&quot;, &quot;c&quot;+&quot;e&quot;, &quot;c&quot;+&quot;f&quot;</span><br><span class="line">so tmp has &#123;&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot; &#125;</span><br><span class="line">swap result and tmp</span><br><span class="line">Now result has &#123;&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot; &#125;</span><br><span class="line">Stage 3 for number &quot;3&quot;:</span><br><span class="line"></span><br><span class="line">result has &#123;&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot; &#125;</span><br><span class="line">candidate is &quot;ghi&quot;</span><br><span class="line">generate 27 strings and put into tmp,</span><br><span class="line">add &quot;g&quot; for each of &quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;</span><br><span class="line">add &quot;h&quot; for each of &quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;</span><br><span class="line">add &quot;h&quot; for each of &quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;</span><br><span class="line">so, tmp has</span><br><span class="line">&#123;&quot;adg&quot;, &quot;aeg&quot;, &quot;afg&quot;, &quot;bdg&quot;, &quot;beg&quot;, &quot;bfg&quot;, &quot;cdg&quot;, &quot;ceg&quot;, &quot;cfg&quot;</span><br><span class="line">&quot;adh&quot;, &quot;aeh&quot;, &quot;afh&quot;, &quot;bdh&quot;, &quot;beh&quot;, &quot;bfh&quot;, &quot;cdh&quot;, &quot;ceh&quot;, &quot;cfh&quot;</span><br><span class="line">&quot;adi&quot;, &quot;aei&quot;, &quot;afi&quot;, &quot;bdi&quot;, &quot;bei&quot;, &quot;bfi&quot;, &quot;cdi&quot;, &quot;cei&quot;, &quot;cfi&quot; &#125;</span><br><span class="line">swap result and tmp</span><br><span class="line">Now result has</span><br><span class="line">&#123;&quot;adg&quot;, &quot;aeg&quot;, &quot;afg&quot;, &quot;bdg&quot;, &quot;beg&quot;, &quot;bfg&quot;, &quot;cdg&quot;, &quot;ceg&quot;, &quot;cfg&quot;</span><br><span class="line">&quot;adh&quot;, &quot;aeh&quot;, &quot;afh&quot;, &quot;bdh&quot;, &quot;beh&quot;, &quot;bfh&quot;, &quot;cdh&quot;, &quot;ceh&quot;, &quot;cfh&quot;</span><br><span class="line">&quot;adi&quot;, &quot;aei&quot;, &quot;afi&quot;, &quot;bdi&quot;, &quot;bei&quot;, &quot;bfi&quot;, &quot;cdi&quot;, &quot;cei&quot;, &quot;cfi&quot; &#125;</span><br><span class="line">Finally, return result.</span><br></pre></td></tr></table></figure>

<h2 id="Soulution-2-回溯"><a href="#Soulution-2-回溯" class="headerlink" title="Soulution 2  回溯"></a>Soulution 2  回溯</h2><p><img src="https://files.mdnice.com/user/1489/eb7c965d-59c0-4b08-8d6a-6d3943f10cf5.png"><br><img src="https://files.mdnice.com/user/1489/7821e311-00aa-40b0-8ab9-57471419d97b.png"></p>
<h2 id="Solution-3-队列"><a href="#Solution-3-队列" class="headerlink" title="Solution 3  队列"></a>Solution 3  队列</h2><p><img src="https://files.mdnice.com/user/1489/cd61b224-e4ae-4271-bef4-076a650f65b3.png"></p>
<p><img src="https://files.mdnice.com/user/1489/e078bf30-d641-4c56-b4c9-8d1da707d807.png"></p>
<p><img src="https://files.mdnice.com/user/1489/e4fa6f50-22c9-41c7-8f6c-e43aab780585.png"></p>
<h1 id="二分：0-n-1中缺失的数字"><a href="#二分：0-n-1中缺失的数字" class="headerlink" title="二分：0~n-1中缺失的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof">二分：0~n-1中缺失的数字</a></h1><p><img src="https://files.mdnice.com/user/1489/beeb899a-9927-4525-b0d1-3d241c00ccb4.jpg"><br><img src="https://files.mdnice.com/user/1489/e1be0f97-6680-4f55-a373-3a484128fe6a.jpg"></p>
<h1 id="二分：162-寻找峰值"><a href="#二分：162-寻找峰值" class="headerlink" title="二分：162. 寻找峰值"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-peak-element/">二分：162. 寻找峰值</a></h1><p>峰值元素是指其值严格大于左右相邻值的元素。</p>
<p>给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</p>
<p>你可以假设 nums[-1] &#x3D; nums[n] &#x3D; -∞ 。</p>
<p>你必须实现时间复杂度为 O(log n) 的算法来解决此问题。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3,1]<br>输出：2<br>解释：3 是峰值元素，你的函数应该返回其索引 2。<br>示例 2：</p>
<p>输入：nums &#x3D; [1,2,1,3,5,6,4]<br>输出：1 或 5<br>解释：你的函数可以返回索引 1，其峰值元素为 2；<br>     或者返回索引 5， 其峰值元素为 6。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 1000<br>-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1<br>对于所有有效的 i 都有 nums[i] !&#x3D; nums[i + 1]</p>
<p><img src="https://files.mdnice.com/user/1489/86d145b9-6845-402d-9358-b943bffcdebc.png"></p>
<p><img src="https://files.mdnice.com/user/1489/f8953b4b-43ee-4d3f-a31f-82cd8b633bce.png"></p>
<h2 id="Solution1-暴力-3"><a href="#Solution1-暴力-3" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><p><img src="https://files.mdnice.com/user/1489/423b6ac9-a7bd-4bd4-9840-3813d62617b5.png"></p>
<h2 id="Solution2-二分法"><a href="#Solution2-二分法" class="headerlink" title="Solution2 二分法"></a>Solution2 二分法</h2><p><img src="https://files.mdnice.com/user/1489/ec008965-da09-4c78-9ad1-83de91a31f4c.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int findPeakElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int left = 0, right = nums.size() - 1;</span><br><span class="line">    while (left &lt; right ) &#123;</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if (nums[mid] &lt; nums[mid + 1]) &#123;</span><br><span class="line">            left = mid+1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right = mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="二分-旋转数组的最小数字"><a href="#二分-旋转数组的最小数字" class="headerlink" title="二分: 旋转数组的最小数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof">二分: 旋转数组的最小数字</a></h1><p><img src="https://files.mdnice.com/user/1489/ae78465c-a8c5-4cb3-9bc4-cc6a7f3f1498.jpg"><br><img src="https://files.mdnice.com/user/1489/e7e675f6-8b74-4492-a32d-b6c704015af1.jpg"></p>
<h1 id="二分：33-搜索旋转排序数组"><a href="#二分：33-搜索旋转排序数组" class="headerlink" title="二分：33. 搜索旋转排序数组"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-in-rotated-sorted-array/">二分：33. 搜索旋转排序数组</a></h1><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
<p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0<br>输出：4<br>示例 2：</p>
<p>输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3<br>输出：-1<br>示例 3：</p>
<p>输入：nums &#x3D; [1], target &#x3D; 0<br>输出：-1
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 5000<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>nums 中的每个值都 独一无二<br>题目数据保证 nums 在预先未知的某个下标上进行了旋转<br>-104 &lt;&#x3D; target &lt;&#x3D; 104</p>
<h2 id="Solution1-暴力-4"><a href="#Solution1-暴力-4" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-二分查找"><a href="#Solution2-二分查找" class="headerlink" title="Solution2 二分查找"></a>Solution2 二分查找</h2><p><img src="https://files.mdnice.com/user/1489/60ec6cc2-9148-40df-ad8e-2969def89c43.png"></p>
<p><img src="https://files.mdnice.com/user/1489/a5922411-7a62-4a02-8d89-737ddad9f426.png"></p>
<h1 id="二分：34-在排序数组中查找元素的第一个和最后一个位置"><a href="#二分：34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="二分：34. 在排序数组中查找元素的第一个和最后一个位置"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">二分：34. 在排序数组中查找元素的第一个和最后一个位置</a></h1><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8<br>输出：[3,4]<br>示例 2：</p>
<p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6<br>输出：[-1,-1]<br>示例 3：</p>
<p>输入：nums &#x3D; [], target &#x3D; 0<br>输出：[-1,-1]
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>nums 是一个非递减数组<br>-109 &lt;&#x3D; target &lt;&#x3D; 109</p>
<h2 id="Solution1-暴力-5"><a href="#Solution1-暴力-5" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-二分"><a href="#Solution2-二分" class="headerlink" title="Solution2 二分"></a>Solution2 二分</h2><p><img src="https://files.mdnice.com/user/1489/d207a0eb-649a-47c3-94d2-ae381b200eaa.png"></p>
<p><img src="https://files.mdnice.com/user/1489/3a8da8b9-8e2a-4d67-9b85-61f5438d72f7.png"></p>
<p>二分搜索讲解<br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1fA4y1o715?spm_id_from=0.0.header_right.history_list.click">https://www.bilibili.com/video/BV1fA4y1o715?spm_id_from=0.0.header_right.history_list.click</a></p>
<p>寻找target在数组里的左右边界，有如下三种情况：</p>
<ul>
<li>情况一：target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1}</li>
<li>情况二：target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1}</li>
<li>情况三：target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{1, 1}</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int leftBorder = getLeftBorder(nums, target);</span><br><span class="line">        int rightBorder = getRightBorder(nums, target);</span><br><span class="line">        // 情况一</span><br><span class="line">        if (leftBorder == -2 || rightBorder == -2) return &#123;-1, -1&#125;;</span><br><span class="line">        // 情况三</span><br><span class="line">        if (rightBorder - leftBorder &gt; 1) return &#123;leftBorder + 1, rightBorder - 1&#125;;</span><br><span class="line">        // 情况二</span><br><span class="line">        return &#123;-1, -1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">     int getRightBorder(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.size() - 1;</span><br><span class="line">        int rightBorder = -2; // 记录一下rightBorder没有被赋值的情况</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int middle = left + ((right - left) / 2);</span><br><span class="line">            if (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - 1;</span><br><span class="line">            &#125; else &#123; // 寻找右边界，nums[middle] == target的时候更新left</span><br><span class="line">                left = middle + 1;</span><br><span class="line">                rightBorder = left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rightBorder;</span><br><span class="line">    &#125;</span><br><span class="line">    int getLeftBorder(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.size() - 1;</span><br><span class="line">        int leftBorder = -2; // 记录一下leftBorder没有被赋值的情况</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int middle = left + ((right - left) / 2);</span><br><span class="line">            if (nums[middle] &gt;= target) &#123; // 寻找左边界，nums[middle] == target的时候更新right</span><br><span class="line">                right = middle - 1;</span><br><span class="line">                leftBorder = right;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left = middle + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return leftBorder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="二分：-35-搜索插入位置"><a href="#二分：-35-搜索插入位置" class="headerlink" title="二分： 35. 搜索插入位置"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/">二分： 35. 搜索插入位置</a></h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 O(log n) 的算法。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 5<br>输出: 2<br>示例 2:</p>
<p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 2<br>输出: 1<br>示例 3:</p>
<p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 7<br>输出: 4</p>
<h2 id="Solution1-暴力-6"><a href="#Solution1-暴力-6" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int searchInsert(int[] nums, int target) &#123;</span><br><span class="line">    for(int i = 0; i &lt; nums.length;i++)&#123;</span><br><span class="line">        if(nums[i] &gt;= target)&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-二分-1"><a href="#Solution2-二分-1" class="headerlink" title="Solution2 二分"></a>Solution2 二分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = n; // 定义target在左闭右开的区间里，[left, right)  target</span><br><span class="line">        while (left &lt; right) &#123; // 因为left == right的时候，在[left, right)是无效的空间</span><br><span class="line">            int middle = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">            if (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle; // target 在左区间，在[left, middle)中</span><br><span class="line">            &#125; else if (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + 1; // target 在右区间，在 [middle+1, right)中</span><br><span class="line">            &#125; else &#123; // nums[middle] == target</span><br><span class="line">                return middle; // 数组中找到目标值的情况，直接返回下标</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 分别处理如下四种情况</span><br><span class="line">        // 目标值在数组所有元素之前 [0,0)</span><br><span class="line">        // 目标值等于数组中某一个元素 return middle</span><br><span class="line">        // 目标值插入数组中的位置 [left, right) ，return right 即可</span><br><span class="line">        // 目标值在数组所有元素之后的情况 [left, right)，这是右开区间，return right 即可</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="二分：69-x-的平方根"><a href="#二分：69-x-的平方根" class="headerlink" title="二分：69. x 的平方根 "></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sqrtx/">二分：69. x 的平方根 </a></h1><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p>
<p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p>
<p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：x &#x3D; 4<br>输出：2<br>示例 2：</p>
<p>输入：x &#x3D; 8<br>输出：2<br>解释：8 的算术平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; x &lt;&#x3D; 231 - 1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Time Complexity: O(logn) | due to binary search using while loop.</span><br><span class="line">Space Complexity: O(1) | as only 4 variables are initialized at the beginning. Which is constant irrespective of given input.</span><br><span class="line"></span><br><span class="line">long long s=0, e=x, ans, mid;   //long long due to some of test cases overflows integer limit.</span><br><span class="line">        while(s&lt;=e)&#123;             </span><br><span class="line">            mid=(s+e)/2;</span><br><span class="line">            if(mid*mid==x) return mid;     //if the &#x27;mid&#x27; value ever gives the result, we simply return it.</span><br><span class="line">            else if(mid*mid&lt;x)&#123;             </span><br><span class="line">                s=mid+1;        //if &#x27;mid&#x27; value encounterted gives lower result, we simply discard all the values lower than mid.</span><br><span class="line">                ans=mid;        //an extra pointer &#x27;ans&#x27; is maintained to keep track of only lowest &#x27;mid&#x27; value. </span><br><span class="line">            &#125;</span><br><span class="line">            else e=mid-1;       //if &#x27;mid&#x27; value encountered gives greater result, we simply discard all the values greater than mid. </span><br><span class="line">        &#125;</span><br><span class="line">        return ans;   </span><br></pre></td></tr></table></figure>

<h2 id="Solution1-暴力-7"><a href="#Solution1-暴力-7" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-二分搜索"><a href="#Solution2-二分搜索" class="headerlink" title="Solution2 二分搜索"></a>Solution2 二分搜索</h2><p><img src="https://files.mdnice.com/user/1489/19d7f700-92c7-4591-bef6-efe163c000f3.png"></p>
<h1 id="：287-寻找重复数"><a href="#：287-寻找重复数" class="headerlink" title="：287. 寻找重复数"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-the-duplicate-number/">：287. 寻找重复数</a></h1><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</p>
<p>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</p>
<p>你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,3,4,2,2]<br>输出：2<br>示例 2：</p>
<p>输入：nums &#x3D; [3,1,3,4,2]<br>输出：3
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 105<br>nums.length &#x3D;&#x3D; n + 1<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; n<br>nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次
 </p>
<p>进阶：</p>
<p>如何证明 nums 中至少存在一个重复的数字?<br>你可以设计一个线性级时间复杂度 O(n) 的解决方案吗？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">Overview</span><br><span class="line">Finding the Duplicate Number is a classic problem, and as such there are many different ways to approach it; a total of 7 approaches are presented here. The first 4 approaches involve rearranging or modifying elements of the array, and hence do not meet the constraints specified in the problem statement. However, they are included here since they are more feasible to come up with as the first approach in an interview setting. Since each approach is independent of the other approaches, they can be read in any order.</span><br><span class="line"></span><br><span class="line">Proof</span><br><span class="line">Proving that at least one duplicate must exist in numsnums is an application of the pigeonhole principle. Here, each number in numsnums is a &quot;pigeon&quot; and each distinct number that can appear in numsnums is a &quot;pigeonhole.&quot; Because there are n+1n+1 numbers and nn distinct possible numbers, the pigeonhole principle implies that if you were to put each of the n + 1n+1 pigeons into nn pigeonholes, at least one of the pigeonholes would have 2 or more pigeons.</span><br><span class="line"></span><br><span class="line">Approach 1: Sort</span><br><span class="line">Note: This approach modifies individual elements and does not use constant space, and hence does not meet the problem constraints. However, it utilizes a fundamental concept that can help solve similar problems.</span><br><span class="line"></span><br><span class="line">Intuition</span><br><span class="line"></span><br><span class="line">In an unsorted array, duplicate elements may be scattered across the array. However, in a sorted array, duplicate numbers will be next to each other.</span><br><span class="line"></span><br><span class="line">Algorithm</span><br><span class="line"></span><br><span class="line">Sort the input array (numsnums).</span><br><span class="line"></span><br><span class="line">Iterate through the array, comparing the current number to the previous number (i.e. compare nums[i]nums[i] to nums[i - 1]nums[i−1] where i &gt; 0i&gt;0).</span><br><span class="line"></span><br><span class="line">Return the first number that is equal to its predecessor.</span><br><span class="line">Complexity Analysis</span><br><span class="line"></span><br><span class="line">Time Complexity: O(n \log n)O(nlogn)</span><br><span class="line"></span><br><span class="line">Sorting takes O(n \log n)O(nlogn) time. This is followed by a linear scan, resulting in a total of O(n \log n)O(nlogn) + O(n)O(n) = O(n \log n)O(nlogn) time.</span><br><span class="line"></span><br><span class="line">Space Complexity: O(\log n)O(logn) or O(n)O(n)</span><br><span class="line"></span><br><span class="line">The space complexity of the sorting algorithm depends on the implementation of each programming language:</span><br><span class="line"></span><br><span class="line">In Java, Arrays.sort() for primitives is implemented using a variant of the Quick Sort algorithm, which has a space complexity of O(\log n)O(logn)</span><br><span class="line">In C++, the sort() function provided by STL uses a hybrid of Quick Sort, Heap Sort and Insertion Sort, with a worst case space complexity of O(\log n)O(logn)</span><br><span class="line">In Python, the sort() function is implemented using the Timsort algorithm, which has a worst-case space complexity of O(n)O(n)</span><br><span class="line">Approach 2: Set</span><br><span class="line">Note: This approach does not use constant space, and hence does not meet the problem constraints. However, it utilizes a fundamental concept that can help solve similar problems.</span><br><span class="line"></span><br><span class="line">Intuition</span><br><span class="line"></span><br><span class="line">As we traverse the array, we need a way to &quot;remember&quot; values that we&#x27;ve seen. If we come across a number that we&#x27;ve seen before, we&#x27;ve found the duplicate. An efficient way to record the seen values is by adding each number to a set as we iterate over the numsnums array.</span><br><span class="line"></span><br><span class="line">Algorithm</span><br><span class="line"></span><br><span class="line">In order to achieve linear time complexity, we need to be able to insert elements into a data structure and look them up in constant time. A HashSet/unordered_set is well suited for this purpose. Initialize an empty hashset, seenseen.</span><br><span class="line"></span><br><span class="line">Iterate over the array and first check if the current element exists in the hashset (seenseen).</span><br><span class="line"></span><br><span class="line">If it does exist in the hashset, that number is the duplicate and can be returned right away.</span><br><span class="line">Otherwise, insert the current element into seenseen, move to the next element in the array and repeat step 2.</span><br><span class="line"></span><br><span class="line">Complexity Analysis</span><br><span class="line"></span><br><span class="line">Time Complexity: O(n)O(n)</span><br><span class="line"></span><br><span class="line">HashSet insertions and lookups have amortized constant time complexities. Hence, this algorithm requires linear time, since it consists of a single for loop that iterates over each element, looking up the element and inserting it into the set at most once.</span><br><span class="line"></span><br><span class="line">Space Complexity: O(n)O(n)</span><br><span class="line"></span><br><span class="line">We use a set that may need to store at most nn elements, leading to a linear space complexity of O(n)O(n).</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-二分法"><a href="#Solution1-二分法" class="headerlink" title="Solution1 二分法"></a>Solution1 二分法</h2><p><img src="https://files.mdnice.com/user/1489/0c2f4579-0b43-40cb-9b3d-8acd25411140.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int l = 1, r = n - 1, ans = -1;</span><br><span class="line">        while (l &lt;= r) &#123;</span><br><span class="line">            int mid = (l + r) &gt;&gt; 1;</span><br><span class="line">            int cnt = 0;</span><br><span class="line">            for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">                cnt += nums[i] &lt;= mid;</span><br><span class="line">            &#125;</span><br><span class="line">            if (cnt &lt;= mid) &#123;</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                r = mid - 1;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Solution2-二进制"><a href="#Solution2-二进制" class="headerlink" title="Solution2 二进制"></a>Solution2 二进制</h2><p><img src="https://files.mdnice.com/user/1489/6a5118f3-ceff-4fd5-bed5-37e3eb1d1d63.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size(), ans = 0;</span><br><span class="line">        // 确定二进制下最高位是多少</span><br><span class="line">        int bit_max = 31;</span><br><span class="line">        while (!((n - 1) &gt;&gt; bit_max)) &#123;</span><br><span class="line">            bit_max -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int bit = 0; bit &lt;= bit_max; ++bit) &#123;</span><br><span class="line">            int x = 0, y = 0;</span><br><span class="line">            for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">                if (nums[i] &amp; (1 &lt;&lt; bit)) &#123;</span><br><span class="line">                    x += 1;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i &gt;= 1 &amp;&amp; (i &amp; (1 &lt;&lt; bit))) &#123;</span><br><span class="line">                    y += 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (x &gt; y) &#123;</span><br><span class="line">                ans |= 1 &lt;&lt; bit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution3-快慢指针"><a href="#Solution3-快慢指针" class="headerlink" title="Solution3 快慢指针"></a>Solution3 快慢指针</h2><p><img src="https://files.mdnice.com/user/1489/403a3990-3546-4736-98f7-813c0e0093b9.png"></p>
<p><img src="https://files.mdnice.com/user/1489/684b77e1-27e3-43d2-9fd1-52958d131620.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int slow = 0, fast = 0;</span><br><span class="line">        do &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125; while (slow != fast);</span><br><span class="line">        slow = 0;</span><br><span class="line">        while (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="动态规划：53-最大子数组和"><a href="#动态规划：53-最大子数组和" class="headerlink" title="动态规划：53. 最大子数组和"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-subarray/">动态规划：53. 最大子数组和</a></h1><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>子数组 是数组中的一个连续部分。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。<br>示例 2：</p>
<p>输入：nums &#x3D; [1]<br>输出：1<br>示例 3：</p>
<p>输入：nums &#x3D; [5,4,-1,7,8]<br>输出：23
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104
 </p>
<h2 id="Solution1-暴力-8"><a href="#Solution1-暴力-8" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-动态规划"><a href="#Solution2-动态规划" class="headerlink" title="Solution2 动态规划"></a>Solution2 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/5f787c97-ba90-4805-a6d6-b04d9f9c957c.png"></p>
<p><img src="https://files.mdnice.com/user/1489/8a4705a4-439c-4262-bdce-8186ee916289.png"></p>
<p><img src="https://files.mdnice.com/user/1489/5700074e-68cb-427a-9e58-a1858ab736e1.png"></p>
<h2 id="Solution3-分治"><a href="#Solution3-分治" class="headerlink" title="Solution3 分治"></a>Solution3 分治</h2><p><img src="https://files.mdnice.com/user/1489/82c123a3-94d3-4b42-8966-eeb5964b1047.png"></p>
<h1 id="动态规划：62-不同路径"><a href="#动态规划：62-不同路径" class="headerlink" title="动态规划：62. 不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-paths/">动态规划：62. 不同路径</a></h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p> </p>
<p>示例 1：</p>
<p>输入：m &#x3D; 3, n &#x3D; 7<br>输出：28<br>示例 2：</p>
<p>输入：m &#x3D; 3, n &#x3D; 2<br>输出：3<br>解释：<br>从左上角开始，总共有 3 条路径可以到达右下角。</p>
<ol>
<li>向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右</li>
<li>向下 -&gt; 向右 -&gt; 向下<br>示例 3：</li>
</ol>
<p>输入：m &#x3D; 7, n &#x3D; 3<br>输出：28<br>示例 4：</p>
<p>输入：m &#x3D; 3, n &#x3D; 3<br>输出：6
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; m, n &lt;&#x3D; 100<br>题目数据保证答案小于等于 2 * 109</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Since the robot can only move right and down, when it arrives at a point, it either arrives from left or above. If we use dp[i][j] for the number of unique paths to arrive at the point (i, j), then the state equation is dp[i][j] = dp[i][j - 1] + dp[i - 1][j]. Moreover, we have the base cases dp[0][j] = dp[i][0] = 1 for all valid i and j.</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 1));</span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">The above solution runs in O(m * n) time and costs O(m * n) space. However, you may have noticed that each time when we update dp[i][j], we only need dp[i - 1][j] (at the previous row) and dp[i][j - 1] (at the current row). So we can reduce the memory usage to just two rows (O(n)).</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        vector&lt;int&gt; pre(n, 1), cur(n, 1);</span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">                cur[j] = pre[j] + cur[j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">            swap(pre, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        return pre[n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Further inspecting the above code, pre[j] is just the cur[j] before the update. So we can further reduce the memory usage to one row.</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        vector&lt;int&gt; cur(n, 1);</span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">                cur[j] += cur[j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur[n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Now, you may wonder whether we can further reduce the memory usage to just O(1) space since the above code seems to use only two variables (cur[j] and cur[j - 1]). However, since the whole row cur needs to be updated for m - 1 times (the outer loop) based on old values, all of its values need to be saved and thus O(1)-space is impossible. However, if you are having a DP problem without the outer loop and just the inner one, then it will be possible.</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-排列组合"><a href="#Solution1-排列组合" class="headerlink" title="Solution1 排列组合"></a>Solution1 排列组合</h2><p><img src="https://files.mdnice.com/user/1489/4a4d21b3-ff48-457a-a612-9723074e0647.png"></p>
<h2 id="Solution2-动态规划-1"><a href="#Solution2-动态规划-1" class="headerlink" title="Solution2 动态规划"></a>Solution2 动态规划</h2><p>我们令 dp[i][j] 是到达 i, j 最多路径</p>
<p>动态方程：dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1]</p>
<p>注意，对于第一行 dp[0][j]，或者第一列 dp[i][0]，由于都是在边界，所以只能为 1</p>
<p>时间复杂度：O(m*n)O(m∗n)</p>
<p>空间复杂度：O(m * n)O(m∗n)</p>
<p>优化：因为我们每次只需要 dp[i-1][j],dp[i][j-1]</p>
<p>所以我们只要记录这两个数，直接看代码吧！</p>
<p>思路二：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[][] dp = new int[m][n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) dp[0][i] = 1;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) dp[i][0] = 1;</span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m - 1][n - 1];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>优化1：空间复杂度 O(2n)O(2n)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[] pre = new int[n];</span><br><span class="line">        int[] cur = new int[n];</span><br><span class="line">        Arrays.fill(pre, 1);</span><br><span class="line">        Arrays.fill(cur,1);</span><br><span class="line">        for (int i = 1; i &lt; m;i++)&#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++)&#123;</span><br><span class="line">                cur[j] = cur[j-1] + pre[j];</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        return pre[n-1]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化2：空间复杂度 O(n)O(n)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[] cur = new int[n];</span><br><span class="line">        Arrays.fill(cur,1);</span><br><span class="line">        for (int i = 1; i &lt; m;i++)&#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++)&#123;</span><br><span class="line">                cur[j] += cur[j-1] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur[n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="动态规划：64-最小路径和"><a href="#动态规划：64-最小路径和" class="headerlink" title="动态规划：64. 最小路径和"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-path-sum/">动态规划：64. 最小路径和</a></h1><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。<br>示例 2：</p>
<p>输入：grid &#x3D; [[1,2,3],[4,5,6]]<br>输出：12
 </p>
<p>提示：</p>
<p>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 200<br>0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 100</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">his is a typical DP problem. Suppose the minimum path sum of arriving at point (i, j) is S[i][j], then the state equation is S[i][j] = min(S[i - 1][j], S[i][j - 1]) + grid[i][j].</span><br><span class="line"></span><br><span class="line">Well, some boundary conditions need to be handled. The boundary conditions happen on the topmost row (S[i - 1][j] does not exist) and the leftmost column (S[i][j - 1] does not exist). Suppose grid is like [1, 1, 1, 1], then the minimum sum to arrive at each point is simply an accumulation of previous points and the result is [1, 2, 3, 4].</span><br><span class="line"></span><br><span class="line">Now we can write down the following (unoptimized) code.</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int m = grid.size();</span><br><span class="line">        int n = grid[0].size(); </span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; sum(m, vector&lt;int&gt;(n, grid[0][0]));</span><br><span class="line">        for (int i = 1; i &lt; m; i++)</span><br><span class="line">            sum[i][0] = sum[i - 1][0] + grid[i][0];</span><br><span class="line">        for (int j = 1; j &lt; n; j++)</span><br><span class="line">            sum[0][j] = sum[0][j - 1] + grid[0][j];</span><br><span class="line">        for (int i = 1; i &lt; m; i++)</span><br><span class="line">            for (int j = 1; j &lt; n; j++)</span><br><span class="line">                sum[i][j]  = min(sum[i - 1][j], sum[i][j - 1]) + grid[i][j];</span><br><span class="line">        return sum[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">As can be seen, each time when we update sum[i][j], we only need sum[i - 1][j] (at the current column) and sum[i][j - 1] (at the left column). So we need not maintain the full m*n matrix. Maintaining two columns is enough and now we have the following code.</span><br></pre></td></tr></table></figure>
<h2 id="Solution0-暴力"><a href="#Solution0-暴力" class="headerlink" title="Solution0 暴力"></a>Solution0 暴力</h2><h2 id="Solution1-动态规划"><a href="#Solution1-动态规划" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/5984996e-8148-4ae1-8ed9-8198e3625d2f.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minPathSum(int[][] grid) &#123;</span><br><span class="line">        for(int i = 0; i &lt; grid.length; i++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; grid[0].length; j++) &#123;</span><br><span class="line">                if(i == 0 &amp;&amp; j == 0) continue;</span><br><span class="line">                else if(i == 0)  grid[i][j] = grid[i][j - 1] + grid[i][j];</span><br><span class="line">                else if(j == 0)  grid[i][j] = grid[i - 1][j] + grid[i][j];</span><br><span class="line">                else grid[i][j] = Math.min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return grid[grid.length - 1][grid[0].length - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="动态规划：70-爬楼梯"><a href="#动态规划：70-爬楼梯" class="headerlink" title="动态规划：70. 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/climbing-stairs/">动态规划：70. 爬楼梯</a></h1><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶<br>示例 2：</li>
</ol>
<p>输入：n &#x3D; 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
<p> </p>
<p>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 45</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">The problem seems to be a dynamic programming one. Hint: the tag also suggests that!</span><br><span class="line">Here are the steps to get the solution incrementally.</span><br><span class="line"></span><br><span class="line">Base cases:</span><br><span class="line">if n &lt;= 0, then the number of ways should be zero.</span><br><span class="line">if n == 1, then there is only way to climb the stair.</span><br><span class="line">if n == 2, then there are two ways to climb the stairs. One solution is one step by another; the other one is two steps at one time.</span><br><span class="line"></span><br><span class="line">The key intuition to solve the problem is that given a number of stairs n, if we know the number ways to get to the points [n-1] and [n-2] respectively, denoted as n1 and n2 , then the total ways to get to the point [n] is n1 + n2. Because from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.</span><br><span class="line"></span><br><span class="line">The solutions calculated by the above approach are complete and non-redundant. The two solution sets (n1 and n2) cover all the possible cases on how the final step is taken. And there would be NO overlapping among the final solutions constructed from these two solution sets, because they differ in the final step.</span><br><span class="line"></span><br><span class="line">Now given the above intuition, one can construct an array where each node stores the solution for each number n. Or if we look at it closer, it is clear that this is basically a fibonacci number, with the starting numbers as 1 and 2, instead of 1 and 1.</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-递归"><a href="#Solution1-递归" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">      int dp0=1;</span><br><span class="line">       int dp1=1;</span><br><span class="line">        for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">            int tmp=dp0;</span><br><span class="line">            dp0=dp1;</span><br><span class="line">            dp1=tmp+dp1;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp1;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="动态规划-91-解码方法"><a href="#动态规划-91-解码方法" class="headerlink" title="动态规划 91. 解码方法"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/decode-ways/">动态规划 91. 解码方法</a></h1><p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p>
<p>‘A’ -&gt; “1”<br>‘B’ -&gt; “2”<br>…<br>‘Z’ -&gt; “26”<br>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p>
<p>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)<br>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p>
<p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p>
<p>题目数据保证答案肯定是一个 32 位 的整数。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “12”<br>输出：2<br>解释：它可以解码为 “AB”（1 2）或者 “L”（12）。<br>示例 2：</p>
<p>输入：s &#x3D; “226”<br>输出：3<br>解释：它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。<br>示例 3：</p>
<p>输入：s &#x3D; “0”<br>输出：0<br>解释：没有字符映射到以 0 开头的数字。<br>含有 0 的有效映射是 ‘J’ -&gt; “10” 和 ‘T’-&gt; “20” 。<br>由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 100<br>s 只包含数字，并且可能包含前导零。<br>通过次数235,094提交次数721,617</p>
<p><img src="https://files.mdnice.com/user/1489/2a2a7ca4-66f7-4eb4-b733-68a3f4238ee1.png"></p>
<p><img src="https://files.mdnice.com/user/1489/7a667e7d-fb86-49d5-9c3a-bafcc9e7b164.png"></p>
<h2 id="Solution1-动态规划-1"><a href="#Solution1-动态规划-1" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/707aac6e-eec8-4f5a-8f0f-b7b45d344451.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numDecodings(string s) &#123;</span><br><span class="line">        if (s[0] == &#x27;0&#x27;) return 0;</span><br><span class="line">        vector&lt;int&gt; dp(s.size()+1);</span><br><span class="line">        dp[0]=1;dp[1]=1;</span><br><span class="line">        for (int i =1; i &lt; s.size(); i++) &#123;</span><br><span class="line">            if (s[i] == &#x27;0&#x27;)//1.s[i]为0的情况</span><br><span class="line">                if (s[i - 1] == &#x27;1&#x27; || s[i - 1] == &#x27;2&#x27;) //s[i - 1]等于1或2的情况</span><br><span class="line">                    dp[i+1] = dp[i-1];//由于s[1]指第二个下标，对应为dp[2],所以dp的下标要比s大1，故为dp[i+1]</span><br><span class="line">                else </span><br><span class="line">                    return 0;</span><br><span class="line">            else //2.s[i]不为0的情况</span><br><span class="line">                if (s[i - 1] == &#x27;1&#x27; || (s[i - 1] == &#x27;2&#x27; &amp;&amp; s[i] &lt;= &#x27;6&#x27;))//s[i-1]s[i]两位数要小于26的情况</span><br><span class="line">                    dp[i+1] = dp[i]+dp[i-1];</span><br><span class="line">                else//其他情况</span><br><span class="line">                    dp[i+1] = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-动态规划-空间复杂度优化为O-1"><a href="#Solution2-动态规划-空间复杂度优化为O-1" class="headerlink" title="Solution2 动态规划 空间复杂度优化为O(1)"></a>Solution2 动态规划 空间复杂度优化为O(1)</h2><p><img src="https://files.mdnice.com/user/1489/ebc2117f-b989-4c3d-b852-4b2b26c77453.png"></p>
<h1 id="树-x2F-动态规划：-96-不同的二叉搜索树"><a href="#树-x2F-动态规划：-96-不同的二叉搜索树" class="headerlink" title="树&#x2F;动态规划： 96. 不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-binary-search-trees/">树&#x2F;动态规划： 96. 不同的二叉搜索树</a></h1><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 3<br>输出：5<br>示例 2：</p>
<p>输入：n &#x3D; 1<br>输出：1
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 19</p>
<p><img src="https://files.mdnice.com/user/1489/e18c6e12-5f03-4540-b1ed-23f59e1d2c55.png"></p>
<p><img src="https://files.mdnice.com/user/1489/2d101957-45f0-493d-9bc6-ab743496916e.png"></p>
<p><img src="https://files.mdnice.com/user/1489/d775142c-564b-4176-a366-0baecb016c91.png"></p>
<h2 id="Solution1-动态规划-2"><a href="#Solution1-动态规划-2" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p>结题思路：假设n个节点存在二叉排序树的个数是G(n)，1为根节点，2为根节点，…，n为根节点，<br>当1为根节点时，其左子树节点个数为0，右子树节点个数为n-1，<br>同理当2为根节点时，其左子树节点个数为1，右子树节点为n-2，<br>所以可得G(n) &#x3D; G(0)<em>G(n-1)+G(1)</em>(n-2)+…+G(n-1)*G(0)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numTrees(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n + 1);</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j - 1] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h1 id="动态规划：121-买卖股票的最佳时机"><a href="#动态规划：121-买卖股票的最佳时机" class="headerlink" title="动态规划：121. 买卖股票的最佳时机"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">动态规划：121. 买卖股票的最佳时机</a></h1><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。<br>     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br>示例 2：</p>
<p>输入：prices &#x3D; [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; prices.length &lt;&#x3D; 105<br>0 &lt;&#x3D; prices[i] &lt;&#x3D; 104</p>
<p><img src="https://files.mdnice.com/user/1489/69a37149-f011-4fef-9a55-272abfbc9b68.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">I hope now question, approach is absolute clear.</span><br><span class="line"></span><br><span class="line">code each line explained : Similar for C++, Java</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">        int lsf = Integer.MAX_VALUE; // least so far</span><br><span class="line">        int op = 0; // overall profit</span><br><span class="line">        int pist = 0; // profit if sold today</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; prices.length; i++)&#123;</span><br><span class="line">            if(prices[i] &lt; lsf)&#123; // if we found new buy value which is more smaller then previous one</span><br><span class="line">                lsf = prices[i]; // update our least so far</span><br><span class="line">            &#125;</span><br><span class="line">            pist = prices[i] - lsf; // calculating profit if sold today by, Buy - sell</span><br><span class="line">            if(op &lt; pist)&#123; // if pist is more then our previous overall profit</span><br><span class="line">                op = pist; // update overall profit</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return op; // return op </span><br></pre></td></tr></table></figure>

<h2 id="Solution0-暴力解法"><a href="#Solution0-暴力解法" class="headerlink" title="Solution0 暴力解法"></a>Solution0 暴力解法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int n = (int)prices.size(), ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            for (int j = i + 1; j &lt; n; ++j) &#123;</span><br><span class="line">                ans = max(ans, prices[j] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-动态规划-3"><a href="#Solution1-动态规划-3" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p>动态规划 前i天的最大收益 &#x3D; max{前i-1天的最大收益，第i天的价格-前i-1天中的最小价格}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        if(prices.length &lt;= 1)</span><br><span class="line">            return 0;</span><br><span class="line">        int min = prices[0], max = 0;</span><br><span class="line">        for(int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, prices[i] - min);</span><br><span class="line">            min = Math.min(min, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="动态规划：122-买卖股票的最佳时机-II"><a href="#动态规划：122-买卖股票的最佳时机-II" class="headerlink" title="动态规划：122. 买卖股票的最佳时机 II"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">动态规划：122. 买卖股票的最佳时机 II</a></h1><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p>
<p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p>
<p>返回 你能获得的 最大 利润 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：prices &#x3D; [7,1,5,3,6,4]<br>输出：7<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。<br>     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6 - 3 &#x3D; 3 。<br>     总利润为 4 + 3 &#x3D; 7 。<br>示例 2：</p>
<p>输入：prices &#x3D; [1,2,3,4,5]<br>输出：4<br>解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。<br>     总利润为 4 。<br>示例 3：</p>
<p>输入：prices &#x3D; [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; prices.length &lt;&#x3D; 3 * 104<br>0 &lt;&#x3D; prices[i] &lt;&#x3D; 104</p>
<p><img src="https://files.mdnice.com/user/1489/9ffae3b2-d6d0-4698-add8-49795aaafaf1.png"></p>
<h2 id="Solution1-贪心算法"><a href="#Solution1-贪心算法" class="headerlink" title="Solution1 贪心算法"></a>Solution1 贪心算法</h2><p><img src="https://files.mdnice.com/user/1489/5536a636-d181-42b9-a760-57aff155691a.png"></p>
<h2 id="Solution2-动态规划-2"><a href="#Solution2-动态规划-2" class="headerlink" title="Solution2 动态规划"></a>Solution2 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/9d910293-a6c0-4c4b-bfd8-c8e32fae01e8.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int [] dp = new int [prices.length+1];//这里从第0天开始，到底i天</span><br><span class="line">        dp[0] = 0;//第0天没有股票，最大利润为0</span><br><span class="line">        dp[1] = 0;//第一天只能买，不能买，因此最大利润也是0</span><br><span class="line">        for(int i = 1;i&lt;prices.length;i++)&#123;</span><br><span class="line">            int A =dp[i]+prices[i]-prices[i-1];//第一种选择</span><br><span class="line">            int B = dp[i];//第二种选择</span><br><span class="line">            dp[i+1] = A&gt;B ? A : B;//i从0开始，所以dp[I＋1]是当前天数 </span><br><span class="line">        &#125;</span><br><span class="line">        return dp[prices.length];</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="动态规划：139-单词拆分"><a href="#动态规划：139-单词拆分" class="headerlink" title="动态规划：139. 单词拆分"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/word-break/">动态规划：139. 单词拆分</a></h1><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</p>
<p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<p> </p>
<p>示例 1：</p>
<p>输入: s &#x3D; “leetcode”, wordDict &#x3D; [“leet”, “code”]<br>输出: true<br>解释: 返回 true 因为 “leetcode” 可以由 “leet” 和 “code” 拼接成。<br>示例 2：</p>
<p>输入: s &#x3D; “applepenapple”, wordDict &#x3D; [“apple”, “pen”]<br>输出: true<br>解释: 返回 true 因为 “applepenapple” 可以由 “apple” “pen” “apple” 拼接成。<br>     注意，你可以重复使用字典中的单词。<br>示例 3：</p>
<p>输入: s &#x3D; “catsandog”, wordDict &#x3D; [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出: false
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 300<br>1 &lt;&#x3D; wordDict.length &lt;&#x3D; 1000<br>1 &lt;&#x3D; wordDict[i].length &lt;&#x3D; 20<br>s 和 wordDict[i] 仅有小写英文字母组成<br>wordDict 中的所有字符串 互不相同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">We use a boolean vector dp[]. dp[i] is set to true if a valid word (word sequence) ends there. The optimization is to look from current position i back and only substring and do dictionary look up in case the preceding position j with dp[j] == true is found.</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-动态规划-4"><a href="#Solution1-动态规划-4" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</span><br><span class="line">    vector&lt;bool&gt; dp(s.size()+1, false);</span><br><span class="line">    unordered_set&lt;string&gt; m(wordDict.begin(), wordDict.end());</span><br><span class="line">    dp[0] = true;</span><br><span class="line">    for (int i = 1; i &lt;= s.size(); ++i)&#123;</span><br><span class="line">        for (int j = 0; j &lt; i; ++j)&#123;</span><br><span class="line">            if (dp[j] &amp;&amp; m.find(s.substr(j, i-j)) != m.end())&#123;</span><br><span class="line">                dp[i] = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[s.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-动态规划-优化版"><a href="#Solution2-动态规划-优化版" class="headerlink" title="Solution2 动态规划 优化版"></a>Solution2 动态规划 优化版</h2><p>【优化】对于以上代码可以优化。每次并不需要从s[0]开始搜索。因为wordDict中的字符串长度是有限的。只需要从i-maxWordLength开始搜索就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</span><br><span class="line">    vector&lt;bool&gt; dp(s.size()+1, false);</span><br><span class="line">    unordered_set&lt;string&gt; m(wordDict.begin(), wordDict.end());</span><br><span class="line">    dp[0] = true;</span><br><span class="line">    //获取最长字符串长度</span><br><span class="line">    int maxWordLength = 0;</span><br><span class="line">    for (int i = 0; i &lt; wordDict.size(); ++i)&#123;</span><br><span class="line">        maxWordLength = std::max(maxWordLength, (int)wordDict[i].size());</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= s.size(); ++i)&#123;</span><br><span class="line">        for (int j = std::max(i-maxWordLength, 0); j &lt; i; ++j)&#123;</span><br><span class="line">            if (dp[j] &amp;&amp; m.find(s.substr(j, i-j)) != m.end())&#123;</span><br><span class="line">                dp[i] = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[s.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="动态规划：152-乘积最大子数组"><a href="#动态规划：152-乘积最大子数组" class="headerlink" title="动态规划：152. 乘积最大子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-product-subarray/">动态规划：152. 乘积最大子数组</a></h1><p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>测试用例的答案是一个 32-位 整数。</p>
<p>子数组 是数组的连续子序列。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: nums &#x3D; [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。<br>示例 2:</p>
<p>输入: nums &#x3D; [-2,0,-1]<br>输出: 0<br>解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
 </p>
<p>提示:</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 104<br>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10<br>nums 的任何前缀或后缀的乘积都 保证 是一个 32-位 整数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">There can be Mutliple ways to frame the solution once we get the intuition right !! So, what should the intuition be ? Let&#x27;s discuss that out !</span><br><span class="line"></span><br><span class="line">Let&#x27;s consider array to have no 0s (for the moment)......</span><br><span class="line">So, on what factor does the answer depends now ?? It surely depends on the count of negative numbers in the array !!</span><br><span class="line"></span><br><span class="line">There are 2 possibilities - either the count of -ve numbers is even or odd.... ---&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line">If the count is even, then obviously we would want to include all of them(in fact the whole array) to maximise the product. As multiplying an even number of -ve numbers would make the result +ve.</span><br><span class="line"></span><br><span class="line">If the count is odd, then we would want to exclude one -ve number from our product, so that the product gets maximised. So, now the question is, which -ve number to exclude? Example ---&gt; arr=&#123;-2,-3,-1,-4,-5&#125; which number should be excluded ? On observing it , we should get one fact clear, that the number which is going to get ignored is either going to be the first one or the last one.</span><br><span class="line"></span><br><span class="line">Note that, we cannot exclude a -ve number that is not the first or the last, because, if we do so, we will need to exclude all(because you are breaking the product at this point) other -ve nums following that -ve number and then that needn&#x27;t result in the maximum product.</span><br><span class="line">Having said all that, now the question is whether to exclude the first -ve num or the last -ve num in the array. We can only know the answer by trying both.</span><br><span class="line">So, firstly we will take the product from the beginning of the array and we will include the first -ve number and will leave out the last one !!</span><br><span class="line">And will do the vice-versa for checking the other scenario !!</span><br><span class="line">So , in that example we would leave the first -ve number... (-2 and then total_product will be product of rest of the numbers in array) or we would leave the last number...(-5) ... And maximum of those 2 cases will be the answer !!</span><br><span class="line">Now, what if array has zeroes? Well, it changes nothing much to be honest, we can consider the part on both the side of 0 as the subarrays and the maximum product that way will be the max(subarray1_ans, subarray2_ans) .... And how to mark the division point ? How do we seperate the subarrays????...</span><br><span class="line">Thats pretty simple and we have done it in kadane&#x27;s algo, just make the curr_ongoing_prod=1 !! And maintain one maxm_prod variable seperately ....</span><br><span class="line"></span><br><span class="line">Example --&gt;&gt;&gt; arr=&#123;-2,1,4,5,0,-3,4,6,1,-2&#125; .... so we can consider subarray1=&#123;-2,1,4,5&#125; and subarray2=&#123;-3,4,6,-2&#125; and then the max_ans(subarray1,subarray2) will be our answer !!</span><br><span class="line"></span><br><span class="line">Let&#x27;s have a look on our code now ....</span><br></pre></td></tr></table></figure>

<h2 id="Solution0-暴力-1"><a href="#Solution0-暴力-1" class="headerlink" title="Solution0 暴力"></a>Solution0 暴力</h2><h2 id="Solution1-动态规划-5"><a href="#Solution1-动态规划-5" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/8079c50a-6dbe-4779-9b7d-ff76f481397d.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if(n == 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else if(n == 1) &#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        int p = nums[0];</span><br><span class="line">        int maxP = nums[0];</span><br><span class="line">        int minP = nums[0];</span><br><span class="line">        for(int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            int t = maxP;</span><br><span class="line">            maxP = max(max(maxP * nums[i], nums[i]), minP *nums[i]);</span><br><span class="line">            minP = min(min(t * nums[i], nums[i]), minP * nums[i]);</span><br><span class="line">            p = max(maxP, p);</span><br><span class="line">        &#125;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="动态规划：198-打家劫舍"><a href="#动态规划：198-打家劫舍" class="headerlink" title="动态规划：198. 打家劫舍"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/house-robber/">动态规划：198. 打家劫舍</a></h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。<br>示例 2：</p>
<p>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。<br>     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 400</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">This is a classic 1D-DP problem where at every step we have a choice to make ...</span><br><span class="line">So the first and foremost thing in any DP problem is to find the reccurence relation !!</span><br><span class="line">At every ith house robber has 2 options: a) rob current house i. b) don&#x27;t rob current house.</span><br><span class="line"></span><br><span class="line">In case he is robbing the (i)th house, the money he can get till the i-th house == money robbed till (i-2)th house + money robbed at (i)th house....let&#x27;s say total money robbed in this case equals to X.</span><br><span class="line">In case he is not robbing, money robbed till i-th house==money robbed till (i-1)th house...lets say total money robbed in this case equals to Y.</span><br><span class="line">So , the maxm money he gets till i-th house is the max(X,Y).</span><br><span class="line">Example of case (a) --&gt; nums=&#123;2,3,2&#125; ... Here, the robber will rob the house at index-2 as nums[index-2] + nums[index-0] &gt; nums[index-1]</span><br><span class="line">Example of case (b)--&gt; nums=&#123;2,7,3&#125; ... here maximum money robbed till index-2 will not be equal to nums[index-2] + nums[index-0]... as nums[index-1] is greater than the sum of money at both those houses ...</span><br><span class="line"></span><br><span class="line">We can achieve the desired solution to this problem via mutliple ways, let&#x27;s start with the simpler ones and then will look forward to optimize the Time and Space Complexities</span><br><span class="line"></span><br><span class="line">Simple Recursion</span><br><span class="line">Time Complexcity : O ( 2^n ) Gives us TLE</span><br><span class="line">Space Complexcity : O( 1 )</span><br></pre></td></tr></table></figure>
<h2 id="Solution1-动态规划-6"><a href="#Solution1-动态规划-6" class="headerlink" title="Solution1  动态规划"></a>Solution1  动态规划</h2><p>dp 方程 dp[i] &#x3D; max(dp[i-2]+nums[i], dp[i-1])</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.empty()) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        if (size == 1) &#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; dp = vector&lt;int&gt;(size, 0);</span><br><span class="line">        dp[0] = nums[0];</span><br><span class="line">        dp[1] = max(nums[0], nums[1]);</span><br><span class="line">        for (int i = 2; i &lt; size; i++) &#123;</span><br><span class="line">            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[size - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-动态规划-3"><a href="#Solution2-动态规划-3" class="headerlink" title="Solution2 动态规划"></a>Solution2 动态规划</h2><p>上述方法使用了数组存储结果。考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.empty()) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        if (size == 1) &#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        int first = nums[0], second = max(nums[0], nums[1]);</span><br><span class="line">        for (int i = 2; i &lt; size; i++) &#123;</span><br><span class="line">            int temp = second;</span><br><span class="line">            second = max(first + nums[i], second);</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 是数组长度。只需要对数组遍历一次。</p>
<p>空间复杂度：O(1)O(1)。使用滚动数组，可以只存储前两间房屋的最高总金额，而不需要存储整个数组的结果，因此空间复杂度是 O(1)O(1)。</p>
<h1 id="动态规划：221-最大正方形"><a href="#动态规划：221-最大正方形" class="headerlink" title="动态规划：221. 最大正方形"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximal-square/">动态规划：221. 最大正方形</a></h1><p><img src="https://files.mdnice.com/user/1489/317b8a93-0319-40c0-9273-c7d6ea72516a.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Approach 1: Brute Force</span><br><span class="line">The simplest approach consists of trying to find out every possible square of 1’s that can be formed from within the matrix. The question now is – how to go for it?</span><br><span class="line"></span><br><span class="line">We use a variable to contain the size of the largest square found so far and another variable to store the size of the current, both initialized to 0. Starting from the left uppermost point in the matrix, we search for a 1. No operation needs to be done for a 0. Whenever a 1 is found, we try to find out the largest square that can be formed including that 1. For this, we move diagonally (right and downwards), i.e. we increment the row index and column index temporarily and then check whether all the elements of that row and column are 1 or not. If all the elements happen to be 1, we move diagonally further as previously. If even one element turns out to be 0, we stop this diagonal movement and update the size of the largest square. Now we, continue the traversal of the matrix from the element next to the initial 1 found, till all the elements of the matrix have been traversed.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Complexity Analysis</span><br><span class="line"></span><br><span class="line">Time complexity : O((mn)^2）</span><br><span class="line">In worst case, we need to traverse the complete matrix for every 1.</span><br><span class="line">Space complexity : O(1)O(1). No extra space is used.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://files.mdnice.com/user/1489/73a115c9-da59-46f5-888c-2a70cd01953f.png"></p>
<h2 id="Solution0-暴力法"><a href="#Solution0-暴力法" class="headerlink" title="Solution0 暴力法"></a>Solution0 暴力法</h2><p><img src="https://files.mdnice.com/user/1489/19e5cf6f-0c41-4a7c-804d-9d81beac4123.png"></p>
<h2 id="Solution1-动态规划-7"><a href="#Solution1-动态规划-7" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p>class Solution {<br>    public int maximalSquare(char[][] matrix) {<br>        &#x2F;**<br>        dp[i][j]表示以第i行第j列为右下角所能构成的最大正方形边长, 则递推式为:<br>        dp[i][j] &#x3D; 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]);<br>        **&#x2F;<br>        int m &#x3D; matrix.length;<br>        if(m &lt; 1) return 0;<br>        int n &#x3D; matrix[0].length;<br>        int max &#x3D; 0;<br>        int[][] dp &#x3D; new int[m+1][n+1];</p>
<pre><code>    for(int i = 1; i &lt;= m; ++i) &#123;
        for(int j = 1; j &lt;= n; ++j) &#123;
            if(matrix[i-1][j-1] == &#39;1&#39;) &#123;
                dp[i][j] = 1 + Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1]));
                max = Math.max(max, dp[i][j]); 
            &#125;
        &#125;
    &#125;
    
    return max*max;
&#125;
</code></pre>
<p>}</p>
<h1 id="动态规划：279-完全平方数"><a href="#动态规划：279-完全平方数" class="headerlink" title="动态规划：279. 完全平方数"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/perfect-squares/">动态规划：279. 完全平方数</a></h1><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p>
<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 12<br>输出：3<br>解释：12 &#x3D; 4 + 4 + 4<br>示例 2：</p>
<p>输入：n &#x3D; 13<br>输出：2<br>解释：13 &#x3D; 4 + 9</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Idea:</span><br><span class="line">This question is very similar to coin change https://leetcode.com/problems/coin-change/discuss/1104203/C%2B%2B-Super-Simple-and-Short-Dynamic-Programming-Solution.</span><br><span class="line">The only difference is that in coin change we get a vector of coins and here we know that the coins are all the perfect squares.</span><br><span class="line">So our first step will be to construct a &quot;coin&quot; vector.</span><br><span class="line">Then, we do it the same way as coin change.</span><br></pre></td></tr></table></figure>
<h2 id="Solution1-动态规划-8"><a href="#Solution1-动态规划-8" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/8ef92a66-0286-4473-88b6-76fd2e9613ed.png"></p>
<h2 id="Solution2-数学"><a href="#Solution2-数学" class="headerlink" title="Solution2  数学"></a>Solution2  数学</h2><p><img src="https://files.mdnice.com/user/1489/3c123721-1909-4e2c-91e3-c2d357b57458.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 判断是否为完全平方数</span><br><span class="line">    bool isPerfectSquare(int x) &#123;</span><br><span class="line">        int y = sqrt(x);</span><br><span class="line">        return y * y == x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断是否能表示为 4^k*(8m+7)</span><br><span class="line">    bool checkAnswer4(int x) &#123;</span><br><span class="line">        while (x % 4 == 0) &#123;</span><br><span class="line">            x /= 4;</span><br><span class="line">        &#125;</span><br><span class="line">        return x % 8 == 7;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int numSquares(int n) &#123;</span><br><span class="line">        if (isPerfectSquare(n)) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (checkAnswer4(n)) &#123;</span><br><span class="line">            return 4;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i * i &lt;= n; i++) &#123;</span><br><span class="line">            int j = n - i * i;</span><br><span class="line">            if (isPerfectSquare(j)) &#123;</span><br><span class="line">                return 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="动态规划：300-最长递增子序列"><a href="#动态规划：300-最长递增子序列" class="headerlink" title="动态规划：300. 最长递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-increasing-subsequence/">动态规划：300. 最长递增子序列</a></h1><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p> <br>示例 1：</p>
<p>输入：nums &#x3D; [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。<br>示例 2：</p>
<p>输入：nums &#x3D; [0,1,0,3,2,3]<br>输出：4<br>示例 3：</p>
<p>输入：nums &#x3D; [7,7,7,7,7,7,7]<br>输出：1
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 2500<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104
 </p>
<p>进阶：</p>
<p>你能将算法的时间复杂度降低到 O(n log(n)) 吗?</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">✔️ Solution 1: Dynamic Programming</span><br><span class="line"></span><br><span class="line">This is a classic Dynamic Programming problem.</span><br><span class="line">Let dp[i] is the longest increase subsequence of nums[0..i] which has nums[i] as the end element of the subsequence.</span><br><span class="line"></span><br><span class="line">Complexity</span><br><span class="line"></span><br><span class="line">Time: O(N^2), where N &lt;= 2500 is the number of elements in array nums.</span><br><span class="line">Space: O(N)</span><br><span class="line">✔️ Solution 2: Greedy with Binary Search</span><br><span class="line"></span><br><span class="line">Let&#x27;s construct the idea from following example.</span><br><span class="line">Consider the example nums = [2, 6, 8, 3, 4, 5, 1], let&#x27;s try to build the increasing subsequences starting with an empty one: sub1 = [].</span><br><span class="line">Let pick the first element, sub1 = [2].</span><br><span class="line">6 is greater than previous number, sub1 = [2, 6]</span><br><span class="line">8 is greater than previous number, sub1 = [2, 6, 8]</span><br><span class="line">3 is less than previous number, we can&#x27;t extend the subsequence sub1, but we must keep 3 because in the future there may have the longest subsequence start with [2, 3], sub1 = [2, 6, 8], sub2 = [2, 3].</span><br><span class="line">With 4, we can&#x27;t extend sub1, but we can extend sub2, so sub1 = [2, 6, 8], sub2 = [2, 3, 4].</span><br><span class="line">With 5, we can&#x27;t extend sub1, but we can extend sub2, so sub1 = [2, 6, 8], sub2 = [2, 3, 4, 5].</span><br><span class="line">With 1, we can&#x27;t extend neighter sub1 nor sub2, but we need to keep 1, so sub1 = [2, 6, 8], sub2 = [2, 3, 4, 5], sub3 = [1].</span><br><span class="line">Finally, length of longest increase subsequence = len(sub2) = 4.</span><br><span class="line">In the above steps, we need to keep different sub arrays (sub1, sub2..., subk) which causes poor performance. But we notice that we can just keep one sub array, when new number x is not greater than the last element of the subsequence sub, we do binary search to find the smallest element &gt;= x in sub, and replace with number x.</span><br><span class="line">Let&#x27;s run that example nums = [2, 6, 8, 3, 4, 5, 1] again:</span><br><span class="line">Let pick the first element, sub = [2].</span><br><span class="line">6 is greater than previous number, sub = [2, 6]</span><br><span class="line">8 is greater than previous number, sub = [2, 6, 8]</span><br><span class="line">3 is less than previous number, so we can&#x27;t extend the subsequence sub. We need to find the smallest number &gt;= 3 in sub, it&#x27;s 6. Then we overwrite it, now sub = [2, 3, 8].</span><br><span class="line">4 is less than previous number, so we can&#x27;t extend the subsequence sub. We overwrite 8 by 4, so sub = [2, 3, 4].</span><br><span class="line">5 is greater than previous number, sub = [2, 3, 4, 5].</span><br><span class="line">1 is less than previous number, so we can&#x27;t extend the subsequence sub. We overwrite 2 by 1, so sub = [1, 3, 4, 5].</span><br><span class="line">Finally, length of longest increase subsequence = len(sub) = 4.</span><br><span class="line"></span><br><span class="line">Complexity</span><br><span class="line"></span><br><span class="line">Time: O(N * logN), where N &lt;= 2500 is the number of elements in array nums.</span><br><span class="line">Space: O(N), we can achieve O(1) in space by overwriting values of sub into original nums array.</span><br><span class="line"></span><br><span class="line">Complexity:</span><br><span class="line"></span><br><span class="line">Time: O(N * logN)</span><br><span class="line">Space: O(N)</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-动态规划-9"><a href="#Solution1-动态规划-9" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/2f69c7c1-c466-4ba5-aeb7-ee8d57b4bc1c.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = (int)nums.size();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; dp(n, 0);</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = 1;</span><br><span class="line">            for (int j = 0; j &lt; i; ++j) &#123;</span><br><span class="line">                if (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return *max_element(dp.begin(), dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="https://files.mdnice.com/user/1489/1082c59b-c9b3-44b1-a291-78fb192b9ea4.png"></p>
<h2 id="Solution2-贪心"><a href="#Solution2-贪心" class="headerlink" title="Solution2  贪心"></a>Solution2  贪心</h2><p><img src="https://files.mdnice.com/user/1489/ce693fb0-6d34-4939-93b2-58af527f3ab4.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len = 1, n = (int)nums.size();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; d(n + 1, 0);</span><br><span class="line">        d[len] = nums[0];</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            if (nums[i] &gt; d[len]) &#123;</span><br><span class="line">                d[++len] = nums[i];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int l = 1, r = len, pos = 0; // 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0</span><br><span class="line">                while (l &lt;= r) &#123;</span><br><span class="line">                    int mid = (l + r) &gt;&gt; 1;</span><br><span class="line">                    if (d[mid] &lt; nums[i]) &#123;</span><br><span class="line">                        pos = mid;</span><br><span class="line">                        l = mid + 1;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        r = mid - 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d[pos + 1] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="动态规划：313-超级丑数"><a href="#动态规划：313-超级丑数" class="headerlink" title="动态规划：313. 超级丑数"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/super-ugly-number/">动态规划：313. 超级丑数</a></h1><p>超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。</p>
<p>给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。</p>
<p>题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 12, primes &#x3D; [2,7,13,19]<br>输出：32<br>解释：给定长度为 4 的质数数组 primes &#x3D; [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。<br>示例 2：</p>
<p>输入：n &#x3D; 1, primes &#x3D; [2,3,5]<br>输出：1<br>解释：1 不含质因数，因此它的所有质因数都在质数数组 primes &#x3D; [2,3,5] 中。<br> <br>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 105<br>1 &lt;&#x3D; primes.length &lt;&#x3D; 100<br>2 &lt;&#x3D; primes[i] &lt;&#x3D; 1000<br>题目数据 保证 primes[i] 是一个质数<br>primes 中的所有值都 互不相同 ，且按 递增顺序 排列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">It is actually like how we merge k sorted list:</span><br><span class="line"></span><br><span class="line">ugly number                       k sorted list</span><br><span class="line">    1                            2     7    13   19     1 * [2,7,13,19]</span><br><span class="line">    |                            |     |    |    |</span><br><span class="line">    2                            4     14   26   38     2 * [2,7,13,19]</span><br><span class="line">    |                            |     |    |    |</span><br><span class="line">    4                            8     28   52   76     4 * [2,7,13,19]</span><br><span class="line">    |                            |     |    |    |              </span><br><span class="line">    7                            14    49   91   133    7 * [2,7,13,19]</span><br><span class="line">    |                            |     |    |    |</span><br><span class="line">    8                            16    56   ...   ...   8 * [2,7,13,19]</span><br><span class="line">    |                            |     |    |     |</span><br><span class="line">    .                            .     .     .    .</span><br><span class="line">    .                            .     .     .    .</span><br><span class="line">    .                            .     .     .    .</span><br><span class="line">We can see that each prime number in primes[] form a sorted list, and now our job is to merge them and find the nth minimum.</span><br><span class="line"></span><br><span class="line">Here we don&#x27;t have the next pointer for each node to trace the next potential candidate. But as we can see in the graph, we can make use of the ugly number we have produced so far!</span><br></pre></td></tr></table></figure>
<h2 id="Solution1-最小堆"><a href="#Solution1-最小堆" class="headerlink" title="Solution1 最小堆"></a>Solution1 最小堆</h2><p><img src="https://files.mdnice.com/user/1489/836dc250-a4b3-4acd-80a8-5202dbd8266b.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int nthSuperUglyNumber(int n, int[] primes) &#123;</span><br><span class="line">      PriorityQueue&lt;Long&gt;queue=new PriorityQueue&lt;&gt;();</span><br><span class="line">        long res=1;</span><br><span class="line">        for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">            for(int prime:primes)&#123;</span><br><span class="line">                queue.add(prime*res);</span><br><span class="line">            &#125;</span><br><span class="line">            res=queue.poll();</span><br><span class="line">            while(!queue.isEmpty()&amp;&amp;res==queue.peek()) queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        return (int)res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-动态规划-4"><a href="#Solution2-动态规划-4" class="headerlink" title="Solution2 动态规划"></a>Solution2 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/144ef974-6b43-473c-9b4e-76efb177144a.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int nthSuperUglyNumber(int n, vector&lt;int&gt;&amp; primes) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n + 1);  //用来存储丑数序列</span><br><span class="line">        dp[1] = 1;          //第一个丑数是1</span><br><span class="line">        int m = primes.size();</span><br><span class="line">        vector&lt;int&gt; nums(m);     //记录新丑数序列</span><br><span class="line">        vector&lt;int&gt; pointers(m, 1); //记录质数该与哪一位丑数做乘积</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            int minn = INT_MAX;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                nums[j] = dp[pointers[j]] * primes[j]; //旧丑数 * 质数序列 = 新丑数序列</span><br><span class="line">                minn = min(minn, nums[j]);  //寻找所有新丑数中最小的丑数</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = minn;</span><br><span class="line">            for (int j = 0; j &lt; m; j++)</span><br><span class="line">                if (minn == nums[j])        //如果此位置已经诞生过最小丑数</span><br><span class="line">                    pointers[j]++;          //让此位置所取旧丑数向后推一位</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="动态规划-x2F-递归：322-零钱兑换"><a href="#动态规划-x2F-递归：322-零钱兑换" class="headerlink" title="动态规划&#x2F;递归：322. 零钱兑换"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/coin-change/">动态规划&#x2F;递归：322. 零钱兑换</a></h1><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11<br>输出：3<br>解释：11 &#x3D; 5 + 5 + 1<br>示例 2：</p>
<p>输入：coins &#x3D; [2], amount &#x3D; 3<br>输出：-1<br>示例 3：</p>
<p>输入：coins &#x3D; [1], amount &#x3D; 0<br>输出：0
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; coins.length &lt;&#x3D; 12<br>1 &lt;&#x3D; coins[i] &lt;&#x3D; 231 - 1<br>0 &lt;&#x3D; amount &lt;&#x3D; 104</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">If you carefully observe the below 3 codes. You will see that the DP Memoization is dervied from the Recursion code just by changing 3 lines and the DP Tabulation is derived from the DP Memoization.</span><br><span class="line"></span><br><span class="line">Recursion</span><br><span class="line">Time: O(2^n)</span><br><span class="line">Space: O(n)</span><br><span class="line"></span><br><span class="line">Writing a recursive function is all about find two things:</span><br><span class="line"></span><br><span class="line">The base case: Just calculate the output for the smallest possible input</span><br><span class="line">The choice diagram: For any given input, just see what all choices do we have.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DP Memoization</span><br><span class="line">Time: O(n.m)</span><br><span class="line">Space: O(n.m)</span><br><span class="line"></span><br><span class="line">In the above recursive case, we were doing repeated work in the form of subproblems. Hence we store the results of those subproblems in a table to reduce the number of recursive calls.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DP Tabulation</span><br><span class="line">Time: O(n.m)</span><br><span class="line">Space: O(n.m)</span><br><span class="line"></span><br><span class="line">We have reached the best conceivable run time for this question but since we have recursive calls in the previous algorithm. It might lead to stackoverflow error in the worst case when recursive calls are a lot. Hence we want to totally emit the notion of recursions. To do that, we simply convert the recursion into iterative code.</span><br><span class="line"></span><br><span class="line">The below code is bottom up dynamic programming because we are starting from the first element in the 2D array and filling the DP from this first element till the last element. And eventually, the last cell stores our final result.</span><br></pre></td></tr></table></figure>
<h2 id="Solution1-动态规划-10"><a href="#Solution1-动态规划-10" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/b2f8f7dd-d476-4624-bed2-09ed94cd6f74.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</span><br><span class="line">        int Max = amount + 1;</span><br><span class="line">        vector&lt;int&gt; dp(amount + 1, Max);</span><br><span class="line">        dp[0] = 0;</span><br><span class="line">        for (int i = 1; i &lt;= amount; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; (int)coins.size(); ++j) &#123;</span><br><span class="line">                if (coins[j] &lt;= i) &#123;</span><br><span class="line">                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[amount] &gt; amount ? -1 : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Solution2-贪心-回溯-剪枝"><a href="#Solution2-贪心-回溯-剪枝" class="headerlink" title="Solution2 贪心+回溯+剪枝"></a>Solution2 贪心+回溯+剪枝</h2><p><img src="https://files.mdnice.com/user/1489/bc43d48c-bd11-4ebe-816d-8df25edec96b.png"></p>
<p><img src="https://files.mdnice.com/user/1489/be81cb56-2d21-4267-81ff-c1fe308261cd.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void coinChange(vector&lt;int&gt;&amp; coins, int amount, int c_index, int count, int&amp; ans) &#123;</span><br><span class="line">    if (amount == 0) &#123;</span><br><span class="line">        ans = min(ans, count);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (c_index == coins.size()) return;</span><br><span class="line"></span><br><span class="line">    for (int k = amount / coins[c_index]; k &gt;= 0 &amp;&amp; k + count &lt; ans; k--) &#123;</span><br><span class="line">        coinChange(coins, amount - k * coins[c_index], c_index + 1, count + k, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</span><br><span class="line">    if (amount == 0) return 0;</span><br><span class="line">    sort(coins.rbegin(), coins.rend());</span><br><span class="line">    int ans = INT_MAX;</span><br><span class="line">    coinChange(coins, amount, 0, 0, ans);</span><br><span class="line">    return ans == INT_MAX ? -1 : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="树-x2F-动态规划-337-打家劫舍-III"><a href="#树-x2F-动态规划-337-打家劫舍-III" class="headerlink" title="树&#x2F;动态规划: 337. 打家劫舍 III"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/house-robber-iii/">树&#x2F;动态规划: 337. 打家劫舍 III</a></h1><p><img src="https://files.mdnice.com/user/1489/863165d0-8403-42e8-abcb-4387abc6f8d3.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Step I -- Think naively</span><br><span class="line"></span><br><span class="line">At first glance, the problem exhibits the feature of &quot;optimal substructure&quot;: if we want to rob maximum amount of money from current binary tree (rooted at root), we surely hope that we can do the same to its left and right subtrees.</span><br><span class="line"></span><br><span class="line">So going along this line, let&#x27;s define the function rob(root) which will return the maximum amount of money that we can rob for the binary tree rooted at root; the key now is to construct the solution to the original problem from solutions to its subproblems, i.e., how to get rob(root) from rob(root.left), rob(root.right), ... etc.</span><br><span class="line"></span><br><span class="line">Apparently the analyses above suggest a recursive solution. And for recursion, it&#x27;s always worthwhile figuring out the following two properties:</span><br><span class="line"></span><br><span class="line">Termination condition: when do we know the answer to rob(root) without any calculation? Of course when the tree is empty ---- we&#x27;ve got nothing to rob so the amount of money is zero.</span><br><span class="line"></span><br><span class="line">Recurrence relation: i.e., how to get rob(root) from rob(root.left), rob(root.right), ... etc. From the point of view of the tree root, there are only two scenarios at the end: root is robbed or is not. If it is, due to the constraint that &quot;we cannot rob any two directly-linked houses&quot;, the next level of subtrees that are available would be the four &quot;grandchild-subtrees&quot; (root.left.left, root.left.right, root.right.left, root.right.right). However if root is not robbed, the next level of available subtrees would just be the two &quot;child-subtrees&quot; (root.left, root.right). We only need to choose the scenario which yields the larger amount of money.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">However the solution runs very slowly (1186 ms) and barely got accepted (the time complexity turns out to be exponential, see my comments below).</span><br><span class="line"></span><br><span class="line">Step II -- Think one step further</span><br><span class="line"></span><br><span class="line">In step I, we only considered the aspect of &quot;optimal substructure&quot;, but think little about the possibilities of overlapping of the subproblems. For example, to obtain rob(root), we need rob(root.left), rob(root.right), rob(root.left.left), rob(root.left.right), rob(root.right.left), rob(root.right.right); but to get rob(root.left), we also need rob(root.left.left), rob(root.left.right), similarly for rob(root.right). The naive solution above computed these subproblems repeatedly, which resulted in bad time performance. Now if you recall the two conditions for dynamic programming (DP): &quot;optimal substructure&quot; + &quot;overlapping of subproblems&quot;, we actually have a DP problem. A naive way to implement DP here is to use a hash map to record the results for visited subtrees.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Step III -- Think one step back</span><br><span class="line"></span><br><span class="line">In step I, we defined our problem as rob(root), which will yield the maximum amount of money that can be robbed of the binary tree rooted at root. This leads to the DP problem summarized in step II.</span><br><span class="line"></span><br><span class="line">Now let&#x27;s take one step back and ask why we have overlapping subproblems. If you trace all the way back to the beginning, you&#x27;ll find the answer lies in the way how we have defined rob(root). As I mentioned, for each tree root, there are two scenarios: it is robbed or is not. rob(root) does not distinguish between these two cases, so &quot;information is lost as the recursion goes deeper and deeper&quot;, which results in repeated subproblems.</span><br><span class="line"></span><br><span class="line">If we were able to maintain the information about the two scenarios for each tree root, let&#x27;s see how it plays out. Redefine rob(root) as a new function which will return an array of two elements, the first element of which denotes the maximum amount of money that can be robbed if root is not robbed, while the second element signifies the maximum amount of money robbed if it is robbed.</span><br><span class="line"></span><br><span class="line">Let&#x27;s relate rob(root) to rob(root.left) and rob(root.right)..., etc. For the 1st element of rob(root), we only need to sum up the larger elements of rob(root.left) and rob(root.right), respectively, since root is not robbed and we are free to rob its left and right subtrees. For the 2nd element of rob(root), however, we only need to add up the 1st elements of rob(root.left) and rob(root.right), respectively, plus the value robbed from root itself, since in this case it&#x27;s guaranteed that we cannot rob the nodes of root.left and root.right.</span><br><span class="line"></span><br><span class="line">As you can see, by keeping track of the information of both scenarios, we decoupled the subproblems and the solution essentially boiled down to a greedy one. Here is the program:</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-动态规划-11"><a href="#Solution1-动态规划-11" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/f05af832-f82d-4a9a-85c8-880b56b213a8.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map &lt;TreeNode*, int&gt; f, g;</span><br><span class="line"></span><br><span class="line">    void dfs(TreeNode* node) &#123;</span><br><span class="line">        if (!node) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node-&gt;left);</span><br><span class="line">        dfs(node-&gt;right);</span><br><span class="line">        f[node] = node-&gt;val + g[node-&gt;left] + g[node-&gt;right];</span><br><span class="line">        g[node] = max(f[node-&gt;left], g[node-&gt;left]) + max(f[node-&gt;right], g[node-&gt;right]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int rob(TreeNode* root) &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        return max(f[root], g[root]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="动态规划-x2F-背包：分割等和子集"><a href="#动态规划-x2F-背包：分割等和子集" class="headerlink" title="动态规划&#x2F;背包：分割等和子集"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/partition-equal-subset-sum/">动态规划&#x2F;背包：分割等和子集</a></h1><p>背包问题 后面和回溯问题一起搞定</p>
<p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,5,11,5]<br>输出：true<br>解释：数组可以分割成 [1, 5, 5] 和 [11] 。<br>示例 2：</p>
<p>输入：nums &#x3D; [1,2,3,5]<br>输出：false<br>解释：数组不能分割成两个元素和相等的子集。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">❌ Solution - I (Brute-Force)</span><br><span class="line"></span><br><span class="line">Let&#x27;s try solving it using brute-force approach. We need to partition the array into two subsets. This means that for each element of the array, we can either place it in 1st subset, or place it in 2nd subset.</span><br><span class="line"></span><br><span class="line">Since we are only concerned with the sums of subset being equal, we will maintain 1st subset&#x27;s sum: sum1 &amp; 2nd subset&#x27;s sum: sum2. For each element, we try both possible options of either placing it in 1st subset and increasing sum1 or placing it in 2nd subset &amp; increasing sum2. Finally, once we reach the end of array, we can check if the current placements gave equal sum. If none of the possible placements give equal sum, we will return false.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">We can slightly optimize the above approach by observing that equal partion are only possible when the total sum of array can be equally split, i.e, it is even. This effectively allows us to directly return false if the sum is odd. When the sum is even, we only need to check if we can construct one subset with its sum equal to total_sum / 2 (the other will automatically have the same sum, so we dont need to care about it). Thus the above can be optimized to -</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Time Complexity : O(2N), where N is the number of elements in nums. For each element, we try both choices of including or excluding an element from subset leading to recursive branches 2*2*2..N times which give time complexity of O(2N)</span><br><span class="line">Space Complexity : O(N), required by recursive stack</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">✔️ Solution - II (Dynamic Programming - Memoization)</span><br><span class="line"></span><br><span class="line">The above solution times out because we were performing repeated calculations over and over unnecessarily. The result for a given parameters sum, i (can we achieve subset sum = sum starting from i index?) will always be the same. So once we have calculated it, we dont need to repea the whole calculation again when it is called from another recursive branch. Instead we can save the result for this state and return it whenever we called again.</span><br><span class="line"></span><br><span class="line">Thus, we can use dynamic programming here. We use a dp array where dp[i][sum] denotes whether subset-sum = sum can be achieved or not starting from the ith index.</span><br><span class="line"></span><br><span class="line">Initially all elements in dp are initialized to -1 denoting that we have not computed that state</span><br><span class="line">If dp[i][sum] == 1 means that we can achieve sum starting from ith index</span><br><span class="line">If dp[i][sum] == 0 means we cant achieve that sum starting from the ith index</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Time Complexity : O(N*sum), where N is the number of elements in nums &amp; sum is the sum of all elements in nums.</span><br><span class="line">Space Complexity : O(N*sum), required by dp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">✔️ Solution - III (Optimized Dynamic Programming - Memoization)</span><br><span class="line"></span><br><span class="line">I am not sure if my reasoning is correct for this approach or it passes due to weak test cases. All other solutions I have seen are 2D memo. I initially thought this approach would fail but seems like it passes (tried on other OJs too).</span><br><span class="line"></span><br><span class="line">We can further optimize the above memoization approach by reducing the state that we memoize. We used dp[i][sum] in the above approach to denote if sum can be achieved starting from ith element in nums. But we dont really care if we achieve the sum starting from i index or not. We are only concerned with whether we can achieve it or not. Thus, we can reduce the state down to 1D dp where dp[sum] denotes whether sum is possible to be achived from nums or not.</span><br><span class="line"></span><br><span class="line">It is essential that we 1st recurse by choosing the current element and only then try the branch of not choosing. This prevents the recursive function from going all the way down the recursion tree by not choosing any elements and incorrectly marking sums as not achievable which could have been achievable if we had chosen earlier elements that we skipped.</span><br><span class="line"></span><br><span class="line">I am not sure if this is best explanation but if someone can better explain or provide some kind of proof/reasoning as to why recursing by 1st picking the element &amp; then not picking will guarantee correct answer, do comment below.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Time Complexity : O(N*sum)</span><br><span class="line"></span><br><span class="line">Check the below image for illustration (Credits: @SanjayMarreddi)</span><br><span class="line">Space Complexity : O(sum), required by dp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">✔️ Solution - IV (Dynamic Programming - Tabulation)</span><br><span class="line"></span><br><span class="line">We can convert the dp approach to iterative version. Here we will again use dp array, where dp[sum] will denote whether sum is achievable or not. Initially, we have dp[0] = true since a 0 sum is always achievable. Then for each element num, we will iterate &amp; find if it is possible to form a sum j by adding num to some previously formable sum.</span><br><span class="line"></span><br><span class="line">One thing to note that it is essential to iterate from right to left in the below inner loop to avoid marking multiple sum, say j1 as achievable and then again using that result to mark another bigger sum j2 (j2=j1+num) as achievable. This would be wrong since it would mean choosing num multiple times. So we start from right to left to avoid overwriting previous results updated in the current loop.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Time Complexity : O(N*sum)</span><br><span class="line">Space Complexity : O(sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">✔️ Solution - V (Dynamic Programming using bitmask)</span><br><span class="line"></span><br><span class="line">We can use bitmasking to condense the inner loop of previous approach into a single bit-shift operation. Here we will use bitset in C++ consisting of sum number of bits (other language can use bigInt or whatever support is provided for such operations).</span><br><span class="line"></span><br><span class="line">Each bit in bitset (dp[i]) will denote whether sum i is possible or not. Now, when we get a new number num, it can be added to every sum already possible, i.e, every dp[i] bit which is already 1. This operation can be performed using bit shift as dp &lt;&lt; num. How? See the following example</span><br><span class="line"></span><br><span class="line">Suppose current dp = 1011</span><br><span class="line">This means sums 0, 1 and 3 are possible to achieve.</span><br><span class="line">Let the next number we get: num = 5. </span><br><span class="line">Now we can achieve (0, 1 &amp; 3) which were already possible and (5, 6, 8) which are new sum after adding &#x27;num=5&#x27; to previous sums</span><br><span class="line"></span><br><span class="line">1. &#x27;dp &lt;&lt; num&#x27;: This operation will add num to every bit .</span><br><span class="line">                         3 2 1 0                                8 7 6 5 4 3 2 1 0                     </span><br><span class="line">                So, dp = 1 0 1 1 will be transformed to  dp  =  1 0 1 1 0 0 0 0 0   (after 5 shifts to left)</span><br><span class="line">			    Note that new dp now denotes 5, 6, 8 which are the new sums possible.</span><br><span class="line">			    We will combine it with previous sums using &#x27;|&#x27; operation</span><br><span class="line">				</span><br><span class="line">                      8 7 6 5 4 3 2 1 0</span><br><span class="line">2. &#x27;dp | dp &lt;&lt; num&#x27; = 1 0 1 1 0 1 0 1 1</span><br><span class="line"></span><br><span class="line">And now we have every possible sum after combining new num with previous possible sums.</span><br><span class="line">Finally, we will return dp[halfSum] denoting whether half sum is achievable or not.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Time Complexity : O(N*sum)</span><br><span class="line">Space Complexity : O(sum)</span><br></pre></td></tr></table></figure>

<h1 id="动态规划-礼物的最大价值"><a href="#动态规划-礼物的最大价值" class="headerlink" title="动态规划:礼物的最大价值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof">动态规划:礼物的最大价值</a></h1><p><img src="https://files.mdnice.com/user/1489/0db9683d-96ad-462b-9c2f-e80cb835f227.jpg"></p>
<h1 id="动态规划-连续子数组的最大和"><a href="#动态规划-连续子数组的最大和" class="headerlink" title="动态规划: 连续子数组的最大和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof">动态规划: 连续子数组的最大和</a></h1><p><img src="https://files.mdnice.com/user/1489/828bd8c8-3c46-49e2-8d18-ae06aa6d3582.jpg"></p>
<h1 id="动态规划-剪绳子"><a href="#动态规划-剪绳子" class="headerlink" title="动态规划:剪绳子"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jian-sheng-zi-ii-lcof">动态规划:剪绳子</a></h1><p><img src="https://files.mdnice.com/user/1489/03a1de17-c22e-4c59-9494-1f0b2d174b29.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/9522e217-e06b-4346-84a0-eb8263b04f93.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/7b12d053-d366-4765-bfe4-75826f938e07.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/ca057ccb-65b9-48c8-9fee-a4024d76d47c.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/4ac49557-f581-4661-a123-af48b849ece1.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/9056d59a-86ef-4471-b065-a0a89df02627.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/19b73a26-c4e0-4af9-b278-52185b8bc40c.jpg"></p>
<h1 id="动态规划-青蛙跳台阶"><a href="#动态规划-青蛙跳台阶" class="headerlink" title="动态规划: 青蛙跳台阶"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof">动态规划: 青蛙跳台阶</a></h1><p><img src="https://files.mdnice.com/user/1489/e0b97aff-77d6-44a0-905d-ddf01528b962.jpg"><br><img src="https://files.mdnice.com/user/1489/6fb39538-c320-49bd-b472-3e6dc981eb4d.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/2fe78d28-cb51-4119-a5e7-2d289ee647c7.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/5587729c-faa6-4969-9c44-33c350aac1a6.jpg"></p>
<h1 id="动态规划-最长重复子数组"><a href="#动态规划-最长重复子数组" class="headerlink" title="动态规划: 最长重复子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-length-of-repeated-subarray">动态规划: 最长重复子数组</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Approach #1: Brute Force with Initial Character Map [Time Limit Exceeded]</span><br><span class="line">Intuition and Algorithm</span><br><span class="line"></span><br><span class="line">In a typical brute force, for all starting indices i of A and j of B, we will check for the longest matching subarray A[i:i+k] == B[j:j+k] of length k. This would look roughly like the following psuedocode:</span><br><span class="line"></span><br><span class="line">ans = 0</span><br><span class="line">for i in [0 .. A.length - 1]:</span><br><span class="line">    for j in [0 .. B.length - 1]:</span><br><span class="line">        k = 0</span><br><span class="line">        while (A[i+k] == B[j+k]): k += 1 #and i+k &lt; A.length etc.</span><br><span class="line">        ans = max(ans, k)</span><br><span class="line">Our insight is that in typical cases, most of the time A[i] != B[j]. We could instead keep a hashmap Bstarts[A[i]] = all j such that B[j] == A[i], and only loop through those in our j loop.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Approach #2: Binary Search with Naive Check [Time Limit Exceeded]</span><br><span class="line">Intuition</span><br><span class="line"></span><br><span class="line">If there is a length k subarray common to A and B, then there is a length j &lt;= k subarray as well.</span><br><span class="line"></span><br><span class="line">Let check(length) be the answer to the question &quot;Is there a subarray with length length, common to A and B?&quot; This is a function with range that must take the form [True, True, ..., True, False, False, ..., False] with at least one True. We can binary search on this function.</span><br><span class="line"></span><br><span class="line">Algorithm</span><br><span class="line"></span><br><span class="line">Focusing on the binary search, our invariant is that check(hi) will always be False. We&#x27;ll start with hi = min(len(A), len(B)) + 1; clearly check(hi) is False.</span><br><span class="line"></span><br><span class="line">Now we perform our check in the midpoint mi of lo and hi. When it is possible, then lo = mi + 1, and when it isn&#x27;t, hi = mi. This maintains the invariant. At the end of our binary search, hi == lo and lo is the lowest value such that check(lo) is False, so we want lo - 1.</span><br><span class="line"></span><br><span class="line">As for the check itself, we can naively check whether any A[i:i+k] == B[j:j+k] using set structures.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Approach #3: Dynamic Programming [Accepted]</span><br><span class="line">Intuition and Algorithm</span><br><span class="line"></span><br><span class="line">Since a common subarray of A and B must start at some A[i] and B[j], let dp[i][j] be the longest common prefix of A[i:] and B[j:]. Whenever A[i] == B[j], we know dp[i][j] = dp[i+1][j+1] + 1. Also, the answer is max(dp[i][j]) over all i, j.</span><br><span class="line"></span><br><span class="line">We can perform bottom-up dynamic programming to find the answer based on this recurrence. Our loop invariant is that the answer is already calculated correctly and stored in dp for any larger i, j.</span><br></pre></td></tr></table></figure>
<p><img src="https://files.mdnice.com/user/1489/7bc821d7-1447-46ae-899c-cd1196d3e8fe.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/c2a7b9ac-91b4-4ecd-ac11-9c6f89d76202.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/83c47edf-7580-482f-9d47-83717761349c.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/623c9607-ca24-41cb-a43c-64e5a071ed00.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/3d092f02-d8a2-49fe-9ae9-a89efccf9907.jpg"><br><img src="https://files.mdnice.com/user/1489/fcfc655c-34c8-49b5-8ab9-09d72d74a3cb.jpg"></p>
<h1 id="动态规划：和为K的子数组"><a href="#动态规划：和为K的子数组" class="headerlink" title="动态规划：和为K的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/subarray-sum-equals-k/">动态规划：和为K的子数组</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Brief note about Question-</span><br><span class="line"></span><br><span class="line">We have to return the total number of continuous subarrays whose sum equals to k.</span><br><span class="line">Let&#x27;s take an example not given in the question by taking negative numbers</span><br><span class="line">Suppose our arr is arr[]: [-1, -1, 1]  &amp;&amp; k = 0</span><br><span class="line"></span><br><span class="line">So, the answer should be &#x27;1&#x27; as their is only one subarray whose sum is 0 i.e (-1 + 1)</span><br><span class="line">Solution - I (Brute force, TLE)-</span><br><span class="line"></span><br><span class="line">Since we are very obedient person and don&#x27;t want to do anything extra from our side.</span><br><span class="line">So, we will try to generate the sum of each subarray and if matches withk , then increment our answer.</span><br><span class="line">Like, this is the most basic thing we can do.</span><br><span class="line">Time Complexity --&gt; O(n ^ 2) // where n is the size of the array</span><br><span class="line">Space Complexity --&gt; O(1) // we are not using anything extra from our side</span><br><span class="line">It paases [ 85 / 89 ] in built test cases</span><br></pre></td></tr></table></figure>
<p><img src="https://files.mdnice.com/user/1489/05eda67c-4389-4973-9617-02aefee2129f.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/f5cbc2d0-8659-47c7-b189-9da1f9840224.jpg"><br><img src="https://files.mdnice.com/user/1489/2345cdfb-b295-4124-83a5-4cf212022be0.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/58a66c05-9434-4a32-89b8-ec1b10ba4c88.jpg"></p>
<h1 id="动态规划-最长回文子串"><a href="#动态规划-最长回文子串" class="headerlink" title="动态规划:最长回文子串"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindromic-substring">动态规划:最长回文子串</a></h1><p><img src="https://files.mdnice.com/user/1489/d57e3684-a3f8-4baa-a8e1-0909a9b5c969.png"></p>
<p><img src="https://files.mdnice.com/user/1489/5c8a5c07-af35-4430-8d91-b7a975b4ba33.png"></p>
<p><img src="https://files.mdnice.com/user/1489/e7b49339-91b4-4ada-a0b5-14ec5d3cb9d9.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/77577f23-520d-480a-b4d1-94f1e25aeed7.jpg"><br><img src="https://files.mdnice.com/user/1489/c6f390b2-c832-408a-ab8e-587085f4faf8.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/bb53951f-2e43-453c-b6f6-0383e670e50f.jpg"></p>
<h1 id="位运算-268-丢失的数字"><a href="#位运算-268-丢失的数字" class="headerlink" title="位运算:268. 丢失的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/missing-number/">位运算:268. 丢失的数字</a></h1><p>给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [3,0,1]<br>输出：2<br>解释：n &#x3D; 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。<br>示例 2：</p>
<p>输入：nums &#x3D; [0,1]<br>输出：2<br>解释：n &#x3D; 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。<br>示例 3：</p>
<p>输入：nums &#x3D; [9,6,4,2,3,5,7,0,1]<br>输出：8<br>解释：n &#x3D; 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。<br>示例 4：</p>
<p>输入：nums &#x3D; [0]<br>输出：1<br>解释：n &#x3D; 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。
 </p>
<p>提示：</p>
<p>n &#x3D;&#x3D; nums.length<br>1 &lt;&#x3D; n &lt;&#x3D; 104<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; n<br>nums 中的所有数字都 独一无二</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The basic idea is to use XOR operation. We all know that a^b^b =a, which means two xor operations with the same number will eliminate the number and reveal the original number.</span><br><span class="line">In this solution, I apply XOR operation to both the index and value of the array. In a complete array with no missing numbers, the index and value should be perfectly corresponding( nums[index] = index), so in a missing array, what left finally is the missing number.</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-排序"><a href="#Solution1-排序" class="headerlink" title="Solution1 排序"></a>Solution1 排序</h2><p><img src="https://files.mdnice.com/user/1489/76ff413d-adba-4dd6-a6f7-14af4914335c.png"></p>
<h2 id="Solution2-求和"><a href="#Solution2-求和" class="headerlink" title="Solution2 求和"></a>Solution2 求和</h2><p><img src="https://files.mdnice.com/user/1489/4c7ba032-9897-4231-bb99-98f8ecdcc362.png"></p>
<h2 id="Solution3-位运算"><a href="#Solution3-位运算" class="headerlink" title="Solution3 位运算"></a>Solution3 位运算</h2><p><img src="https://files.mdnice.com/user/1489/c5e2d5e5-ba77-4e29-9aa1-9e78c0599f01.png"></p>
<h2 id="Solution4-哈希"><a href="#Solution4-哈希" class="headerlink" title="Solution4 哈希"></a>Solution4 哈希</h2><p><img src="https://files.mdnice.com/user/1489/d8bbcdd3-9968-4deb-b8db-b0c7f87e0856.png"></p>
<h1 id="位运算：338-比特位计数"><a href="#位运算：338-比特位计数" class="headerlink" title="位运算：338. 比特位计数\"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/counting-bits/">位运算：338. 比特位计数</a>\</h1><p>给你一个整数 n ，对于 0 &lt;&#x3D; i &lt;&#x3D; n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 2<br>输出：[0,1,1]<br>解释：<br>0 –&gt; 0<br>1 –&gt; 1<br>2 –&gt; 10<br>示例 2：</p>
<p>输入：n &#x3D; 5<br>输出：[0,1,1,2,1,2]<br>解释：<br>0 –&gt; 0<br>1 –&gt; 1<br>2 –&gt; 10<br>3 –&gt; 11<br>4 –&gt; 100<br>5 –&gt; 101
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; n &lt;&#x3D; 105
 </p>
<p>进阶：</p>
<p>很容易就能实现时间复杂度为 O(n log n) 的解决方案，你可以在线性时间复杂度 O(n) 内用一趟扫描解决此问题吗？<br>你能不使用任何内置函数解决此问题吗？（如，C++ 中的 __builtin_popcount ）</p>
<p><img src="https://files.mdnice.com/user/1489/34b15e82-e8e8-4a37-8eb6-89773c3e5b12.png"></p>
<h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p>方法一：i &amp; (i - 1)可以去掉i最右边的一个1（如果有），因此 i &amp; (i - 1）是比 i 小的，而且i &amp; (i - 1)的1的个数已经在前面算过了，所以i的1的个数就是 i &amp; (i - 1)的1的个数加上1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">public int[] countBits(int num) &#123;</span><br><span class="line">    int[] res = new int[num + 1];</span><br><span class="line">    for(int i = 1;i&lt;= num;i++)&#123;  //注意要从1开始，0不满足</span><br><span class="line">        res[i] = res[i &amp; (i - 1)] + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p>方法二：i &gt;&gt; 1会把最低位去掉，因此i &gt;&gt; 1 也是比i小的，同样也是在前面的数组里算过。当 i 的最低位是0，则 i 中1的个数和i &gt;&gt; 1中1的个数相同；当i的最低位是1，i 中1的个数是 i &gt;&gt; 1中1的个数再加1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int[] countBits(int num) &#123;</span><br><span class="line">    int[] res = new int[num + 1];</span><br><span class="line">    for(int i = 0;i&lt;= num;i++)&#123;</span><br><span class="line">        res[i] = res[i &gt;&gt; 1] + (i &amp; 1);  //注意i&amp;1需要加括号</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3"></a>Solution3</h2><p>分奇数和偶数：</p>
<p>偶数的二进制1个数超级简单，因为偶数是相当于被某个更小的数乘2，乘2怎么来的？在二进制运算中，就是左移一位，也就是在低位多加1个0，那样就说明dp[i] &#x3D; dp[i &#x2F; 2]<br>奇数稍微难想到一点，奇数由不大于该数的偶数+1得到，偶数+1在二进制位上会发生什么？会在低位多加1个1，那样就说明dp[i] &#x3D; dp[i-1] + 1，当然也可以写成dp[i] &#x3D; dp[i &#x2F; 2] + 1<br>就这么简单！！！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; countBits(int num) &#123;</span><br><span class="line">        int i = 1;</span><br><span class="line">        vector&lt;int&gt; ans(num + 1);</span><br><span class="line">        for (int i = 0; i &lt;= num; i++) &#123;</span><br><span class="line">            if (i % 2 == 0) </span><br><span class="line">                ans[i] = ans[i / 2];</span><br><span class="line">            else </span><br><span class="line">                ans[i] = ans[i / 2] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="位运算-371-两整数之和"><a href="#位运算-371-两整数之和" class="headerlink" title="位运算:371. 两整数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sum-of-two-integers/">位运算:371. 两整数之和</a></h1><p>给你两个整数 a 和 b ，不使用 运算符 + 和 - ​​​​​​​，计算并返回两整数之和。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：a &#x3D; 1, b &#x3D; 2<br>输出：3<br>示例 2：</p>
<p>输入：a &#x3D; 2, b &#x3D; 3<br>输出：5
 </p>
<p>提示：</p>
<p>-1000 &lt;&#x3D; a, b &lt;&#x3D; 1000</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">Now we can not use the + operator, which means it is obvious that we have to use some sort of bit manupulation. But the real question is how?</span><br><span class="line">The ans lies within the procedure of the addition, which I am going to show you below.</span><br><span class="line"></span><br><span class="line">from binary level, how do we exactly add two numbers, let us see --&gt;</span><br><span class="line"></span><br><span class="line">         _</span><br><span class="line">a = 2 = 010</span><br><span class="line">b = 3 = 011</span><br><span class="line">------------</span><br><span class="line">c = 5 = 101</span><br><span class="line">In the position, where we have a dash above, there we are generating a carry, which will be carried over to the next bit, and added to that next bit. So, the addition pattern goes like -</span><br><span class="line"></span><br><span class="line">  0         0         1         1</span><br><span class="line">+ 0        +1       + 0       + 1</span><br><span class="line">----      ----      ----      ----</span><br><span class="line">  0         1         1         0 (with a carry 1)</span><br><span class="line">Is this pattern similar to you? Have you seen this in the XOR table? Let&#x27;s see the XOR table quickly -</span><br><span class="line"></span><br><span class="line">a b | XOR</span><br><span class="line">- - | - -</span><br><span class="line">0 0 | 0</span><br><span class="line">0 1 | 1</span><br><span class="line">1 0 | 1</span><br><span class="line">1 1 | 0</span><br><span class="line">These are the exact same, hence for addition, we need to use the XOR operator. But what to do with the carry? Hey, we need to add that carry to the next bit, right? That is what we have seen in the implementation of the addition as well. We will do that only, but we can NOT use addition anyway.</span><br><span class="line">But, before that, let&#x27;s do the XOR for 2 and 3 example.</span><br><span class="line"></span><br><span class="line">-- Doing only XOR --</span><br><span class="line">a = 2 = 010</span><br><span class="line">b = 3 = 011</span><br><span class="line">------------</span><br><span class="line">c = 1 = 001</span><br><span class="line">1 is NOT our answer, and in this procedure, we have left the carry out, which is 100. Now what&#x27;s the pattern for finding the carry? It is after we AND the two numbers, we will LEFT-SHIFT the result by 1. Didn&#x27;t get it?</span><br><span class="line"></span><br><span class="line">-- Doing only AND --</span><br><span class="line">a = 2 = 010</span><br><span class="line">b = 3 = 011</span><br><span class="line">------------</span><br><span class="line">c = 2 = 010</span><br><span class="line">-----------</span><br><span class="line">Doing Left-Shift by 1 (&lt;&lt;1)</span><br><span class="line">-----------</span><br><span class="line">c = 4 = 100</span><br><span class="line">So, we found out the carry as well, and believe me or not, but it is the entire Algorithm. You have to repeat the steps of 1. XOR and 2. AND with Left-Shift, until the step no 2. becomes 0, and you will have your answer.</span><br><span class="line"></span><br><span class="line">Example -</span><br><span class="line"></span><br><span class="line">a = 2 = 010</span><br><span class="line">b = 3 = 011</span><br><span class="line">-----------</span><br><span class="line">x = 1 = 001 = a</span><br><span class="line">c = 4 = 100 = b</span><br><span class="line">-----------</span><br><span class="line">x = 5 = 101</span><br><span class="line">c = 0 = 000</span><br><span class="line"></span><br><span class="line">x = XOR &amp; c = AND with Left-Shift</span><br><span class="line">Since carry becomes 0, hence our answer is the XOR result = 5.</span><br><span class="line"></span><br><span class="line">Below is the working code for the same, and you can run this code to find the desired answer.</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int getSum(int a, int b) &#123;</span><br><span class="line">        while(b != 0)&#123;</span><br><span class="line">            int temp = (a&amp;b)&lt;&lt;1;</span><br><span class="line">            a = a ^ b;</span><br><span class="line">            b = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Time Complexity: O(1)</span><br><span class="line">Space Complexity: O(1)</span><br><span class="line"></span><br><span class="line">Time is O(1), because the max and min bounds are 1000 and -1000 respectively, which means the input will NOT be arbitrarily large, and it will be in the limits, hence the time will be constant.</span><br><span class="line"></span><br><span class="line">The code for c and c++ will be very similar, and python will be a little different. If you like this approach, then please give me a thumbs up.</span><br><span class="line"></span><br><span class="line">Thanks &amp; Happy Coding :)</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-位运算"><a href="#Solution1-位运算" class="headerlink" title="Solution1 位运算"></a>Solution1 位运算</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int getSum(int a, int b) </span><br><span class="line">&#123;</span><br><span class="line">    int sum, carry; </span><br><span class="line">    sum = a ^ b;  //异或这里可看做是相加但是不显现进位，比如5 ^ 3</span><br><span class="line">                 /*0 1 0 1</span><br><span class="line">                   0 0 1 1</span><br><span class="line">                 ------------</span><br><span class="line">                   0 1 1 0      </span><br><span class="line">              上面的如果看成传统的加法，不就是1+1=2，进1得0，但是这里没有显示进位出来，仅是相加，0+1或者是1+0都不用进位*/</span><br><span class="line">    </span><br><span class="line">    carry = (a &amp; b) &lt;&lt; 1;</span><br><span class="line">    </span><br><span class="line">                //相与为了让进位显现出来，比如5 &amp; 3</span><br><span class="line">                /* 0 1 0 1</span><br><span class="line">                   0 0 1 1</span><br><span class="line">                 ------------</span><br><span class="line">                   0 0 0 1</span><br><span class="line">              上面的最低位1和1相与得1，而在二进制加法中，这里1+1也应该是要进位的，所以刚好吻合，但是这个进位1应该要再往前一位，所以左移一位*/</span><br><span class="line">    </span><br><span class="line">    if(carry != 0)  //经过上面这两步，如果进位不等于0，那么就是说还要把进位给加上去，所以用了尾递归，一直递归到进位是0。</span><br><span class="line">    &#123;</span><br><span class="line">        return getSum(sum, carry);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="位运算：数组中数字出现的次数"><a href="#位运算：数组中数字出现的次数" class="headerlink" title="位运算：数组中数字出现的次数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof">位运算：数组中数字出现的次数</a></h1><p><img src="https://files.mdnice.com/user/1489/7d866548-cf10-4e94-b709-7f71ef98a483.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/3b246e5f-80a9-4142-afcc-f87821e72388.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/40509b75-a36f-4c79-88d3-5bfc2084e109.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/a871d490-3098-4744-acd1-27faa3facd1e.jpg"></p>
<h1 id="位运算：不用加减乘除做加法"><a href="#位运算：不用加减乘除做加法" class="headerlink" title="位运算：不用加减乘除做加法"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof">位运算：不用加减乘除做加法</a></h1><p><img src="https://files.mdnice.com/user/1489/861c46f5-40c1-4452-bae1-d1fe40b46687.jpg"></p>
<h1 id="位运算-汉明距离"><a href="#位运算-汉明距离" class="headerlink" title="位运算:汉明距离"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/hamming-distance">位运算:汉明距离</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Solution I:</span><br><span class="line">We use XOR bitwise operatoin to get all the bits that are set either in x or in y, not both.</span><br><span class="line">Then we count the number of such bits and we&#x27;re done!</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hammingDistance(int x, int y) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int num = x^y;</span><br><span class="line">        while (num) &#123;</span><br><span class="line">            res += num % 2;</span><br><span class="line">            num &gt;&gt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Solution II - Without XOR:</span><br><span class="line">We iterate x and y in parallel.</span><br><span class="line">If (x % 2 != y % 2) - only one of the rightmost bits are set - we add one to res.</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hammingDistance(int x, int y) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        while (x || y) &#123;</span><br><span class="line">            res += (x % 2 != y % 2);</span><br><span class="line">            x &gt;&gt;= 1, y &gt;&gt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://files.mdnice.com/user/1489/65b0b068-a855-410f-833f-0cd18b42c057.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/127549f9-fa4e-440b-9f58-7e2ec00d19dc.jpg"></p>
<h1 id="位运算-二进制中1的个数"><a href="#位运算-二进制中1的个数" class="headerlink" title="位运算:二进制中1的个数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof">位运算:二进制中1的个数</a></h1><p><img src="https://files.mdnice.com/user/1489/1da2c2bf-57a1-4e47-87f9-613dbee436fb.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/7d2f2092-3b35-4543-806a-3426630f698d.jpg"></p>
<h1 id="位运算：数字的补数"><a href="#位运算：数字的补数" class="headerlink" title="位运算：数字的补数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-complement/">位运算：数字的补数</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">✔️ Solution - I (Brute-Force)</span><br><span class="line"></span><br><span class="line">We can simply iterate and find the leftmost bit (MSB) that is set. From that point onwards, we flip every bit till we reach the rightmost bit (LSB). To flip a bit, we can use ^ 1 (XOR 1) operation. This will flip a bit to 0 if it is set and flip to 1 if it is unset.</span><br><span class="line"></span><br><span class="line">C++</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findComplement(int num) &#123;</span><br><span class="line">        int i = 31;</span><br><span class="line">        while((num &amp; 1 &lt;&lt; i) == 0) i--;   // skip the left 0 bits till we reach the 1st set bit from left</span><br><span class="line">        while(i &gt;= 0)</span><br><span class="line">            num ^= 1 &lt;&lt; i--;              // flip all bits by XORing with 1</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Python</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def findComplement(self, num):</span><br><span class="line">        i = 31</span><br><span class="line">        while (num &amp; 1 &lt;&lt; i) == 0: </span><br><span class="line">            i -= 1</span><br><span class="line">        while i &gt;= 0:</span><br><span class="line">            num ^= 1 &lt;&lt; i</span><br><span class="line">            i -= 1</span><br><span class="line">        return num</span><br><span class="line">Time Complexity : O(N), where N is the number of bits. In this case, since we are starting from i=31, it should be constant but I am denoting time complexity of this approach as generalized O(N)</span><br><span class="line">Space Complexity : O(1)</span><br><span class="line"></span><br><span class="line">✔️ Solution - II (Bit-Manipulation Tricks)</span><br><span class="line"></span><br><span class="line">The above method basically finds the leftmost set bit and XORs the remaining bits with 1. A more efficient way to do the same would be to simply XOR num with another number having all bits to the right of nums&#x27;s 1st set bit as 1 and rest bit to left as 0. This would achieve the same thing as above.</span><br><span class="line"></span><br><span class="line">For eg. num = 13</span><br><span class="line">=&gt;  num  = 13  (1101)</span><br><span class="line">=&gt;  mask = 15  (1111)</span><br><span class="line">--------------------</span><br><span class="line">   ^       2   (0010)    We got all the bits flipped</span><br><span class="line">But how to get mask?</span><br><span class="line"></span><br><span class="line">A simple way would be to initialize mask = 0 and keep flipping bits of it to 1 starting from the rightmost bit (LSB) till we reach the leftmost set bit of num.</span><br><span class="line">Now, how do we know that we reached the leftmost set bit in num?</span><br><span class="line"></span><br><span class="line">We use another variable tmp = num. Each time, we will rightshift tmp essentially removing the rightmost bit. When we remove the leftmost set bit from it, it will become 0. Thus, we loop till tmp is not 0.</span><br><span class="line">C++</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findComplement(int num) &#123;</span><br><span class="line">        int mask = 0;                                 // all bits in mask are initially 0</span><br><span class="line">        for(int tmp = num; tmp; tmp &gt;&gt;= 1)            // set bits in mask to 1 till we reach leftmost set bit in num</span><br><span class="line">            mask = (mask &lt;&lt; 1) | 1;                   // leftshifts and sets the rightmost bit to 1</span><br><span class="line">			</span><br><span class="line">        return mask ^ num;                            // finally XORing with mask will flip all bits in num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Python</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def findComplement(self, num):</span><br><span class="line">        mask, tmp = 0, num</span><br><span class="line">        while tmp:</span><br><span class="line">            mask = (mask &lt;&lt; 1) | 1</span><br><span class="line">            tmp &gt;&gt;= 1</span><br><span class="line">        return mask ^ num</span><br><span class="line">Another way to do the same would be to the other way around and start with mask with all bits as 1. Then we keep setting rightmost bits in mask to 0 one by one till there are no common set bits left in num and mask (num &amp; mask == 0 when no common set bits are present).</span><br><span class="line"></span><br><span class="line">For eg. num = 13 (1101)  and  mask = -1 (111...1111)  [all 32 set bits are set in -1 binary representation]</span><br><span class="line"> </span><br><span class="line">1. num =  000...1101 </span><br><span class="line">   mask = 111...1110   =&gt; we still have common set bits</span><br><span class="line">   </span><br><span class="line">2. num =  000...1101 </span><br><span class="line">   mask = 111...1100   =&gt; we still have common set bits   </span><br><span class="line">  </span><br><span class="line">3. num =  000...1101</span><br><span class="line">   mask = 111...1000   =&gt; we still have common set bits  </span><br><span class="line">   </span><br><span class="line">4. num =  000...1101 </span><br><span class="line">   mask = 111...0000   =&gt; no more common bits left</span><br><span class="line">Now what?</span><br><span class="line"></span><br><span class="line">Now we can simply flip all bits in mask (using ~ operator). It will now have all rightmost bits set to one starting from leftmost set bit in num, i.e, we now have the same mask that we had in previous approach.</span><br><span class="line">Now, we can XOR it with num and we get the flipped result</span><br><span class="line">C++</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findComplement(int num) &#123;</span><br><span class="line">        uint mask = -1;                             // -1 is represented in binary as all bits set to 1</span><br><span class="line">        while(mask &amp; num) mask &lt;&lt;= 1;               // remove rightmost bits 1 by 1 till no common bits are left</span><br><span class="line">        return ~mask ^ num;                         // XORs with 1 &amp; flips all bits in num starting from the leftmost set bit </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Python</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def findComplement(self, num):</span><br><span class="line">        mask = -1</span><br><span class="line">        while mask &amp; num: mask &lt;&lt;= 1</span><br><span class="line">        return ~mask ^ num</span><br><span class="line">This approach used 1 less operation inside loop (1st approach used 3 operations: right-shift &gt;&gt; on tmp, left-shift &lt;&lt; on mask and | with 1 to set rightmost bit. This one uses 2: &amp; to check if there are common bits in mask and num and left-shift &lt;&lt; to remove the right set bits one by one)</span><br><span class="line"></span><br><span class="line">Time Complexity : O(P) / O(log num), where P is the position of leftmost set bit in num. O(P) ~ O(log2(num))</span><br><span class="line">Space Complexity : O(1)</span><br><span class="line"></span><br><span class="line">✔️ Solution - III (Flip Bits from Right to Left)</span><br><span class="line"></span><br><span class="line">We can start from the right-end and flip bits one by one. This is somewhat similar to 1st solution in above appraoch. But here we will not use mask but rather a bit starting with i=1 and just directly XOR it with num, then left-shift it &amp; repeat thus flipping the bits in num one by one.</span><br><span class="line"></span><br><span class="line">So, how do we know when to stop? We stop as soon i &gt; num. This denotes that we have passed the leftmost set bit in num and thus we have flipped all the bits that needed to be flipped.</span><br><span class="line"></span><br><span class="line">C++</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findComplement(int num) &#123;</span><br><span class="line">        int i = 1;</span><br><span class="line">        while(i &lt;= num)</span><br><span class="line">            num ^= i,</span><br><span class="line">            i &lt;&lt;= 1;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Python</span><br><span class="line"></span><br><span class="line">class Solution():</span><br><span class="line">    def findComplement(self, num):</span><br><span class="line">        i = 1</span><br><span class="line">        while i &lt;= num:</span><br><span class="line">            num ^= i</span><br><span class="line">            i &lt;&lt;= 1</span><br><span class="line">        return num    </span><br><span class="line">Time Complexity : O(P) / O(log num)</span><br><span class="line">Space Complexity : O(1)</span><br></pre></td></tr></table></figure>
<p><img src="https://files.mdnice.com/user/1489/c27eca08-3f9b-4813-b858-da16881adde7.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/5d0202cd-9252-47fc-bb24-c44a7962fc24.jpg"></p>
<h1 id="递归：-24-两两交换链表中的节点"><a href="#递归：-24-两两交换链表中的节点" class="headerlink" title="递归： 24. 两两交换链表中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/swap-nodes-in-pairs/">递归： 24. 两两交换链表中的节点</a></h1><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4]<br>输出：[2,1,4,3]<br>示例 2：</p>
<p>输入：head &#x3D; []<br>输出：[]<br>示例 3：</p>
<p>输入：head &#x3D; [1]<br>输出：[1]</p>
<h2 id="Solution1-递归-1"><a href="#Solution1-递归-1" class="headerlink" title="Solution1  递归"></a>Solution1  递归</h2><p><img src="https://files.mdnice.com/user/1489/c072ce6a-4174-41b0-b176-459494233b1e.png"></p>
<p><img src="https://files.mdnice.com/user/1489/01f7eaa0-e02c-4bf6-9dbb-4efcf67513b5.png"></p>
<p><img src="https://files.mdnice.com/user/1489/34777dfe-25ba-4a81-883e-b66110b1a8c9.png"></p>
<h2 id="Solution2-迭代"><a href="#Solution2-迭代" class="headerlink" title="Solution2 迭代"></a>Solution2 迭代</h2><p><img src="https://files.mdnice.com/user/1489/8b223432-03ba-43a5-8968-584c7c8d8068.png"></p>
<p><img src="https://files.mdnice.com/user/1489/36ee0f58-1bce-411c-b3fc-308d769ad869.png"></p>
<h1 id="树-x2F-递归：95-不同的二叉搜索树-II"><a href="#树-x2F-递归：95-不同的二叉搜索树-II" class="headerlink" title="树&#x2F;递归：95. 不同的二叉搜索树 II"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-binary-search-trees-ii/">树&#x2F;递归：95. 不同的二叉搜索树 II</a></h1><p>给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 3<br>输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]<br>示例 2：</p>
<p>输入：n &#x3D; 1<br>输出：[[1]]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 8</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The basic idea is that we can construct the result of n node tree just from the result of n-1 node tree.</span><br><span class="line">Here&#x27;s how we do it: only 2 conditions: 1) The nth node is the new root, so newroot-&gt;left = oldroot;</span><br><span class="line">2) the nth node is not root, we traverse the old tree, every time the node in the old tree has a right child, we can perform: old node-&gt;right = nth node, nth node -&gt;left = right child; and when we reach the end of the tree, don&#x27;t forget we can also add the nth node here.</span><br><span class="line">One thing to notice is that every time we push a TreeNode in our result, I push the clone version of the root, and I recover what I do to the old node immediately. This is because you may use the old tree for several times.</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-回溯-2"><a href="#Solution1-回溯-2" class="headerlink" title="Solution1 回溯"></a>Solution1 回溯</h2><p><img src="https://files.mdnice.com/user/1489/a150914f-1207-4dc6-8091-639f11405933.png"></p>
<p><img src="https://files.mdnice.com/user/1489/d66220b0-0d89-479e-9313-6adce6816e8c.png"></p>
<h1 id="树-x2F-递归：98-验证二叉搜索树"><a href="#树-x2F-递归：98-验证二叉搜索树" class="headerlink" title="树&#x2F;递归：98. 验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/validate-binary-search-tree/">树&#x2F;递归：98. 验证二叉搜索树</a></h1><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p>有效 二叉搜索树定义如下：</p>
<p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。
 </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [2,1,3]<br>输出：true<br>示例 2：</p>
<p>输入：root &#x3D; [5,1,4,null,null,3,6]<br>输出：false<br>解释：根节点的值是 5 ，但是右子节点的值是 4 。
 </p>
<p>提示：</p>
<p>树中节点数目范围在[1, 104] 内<br>-231 &lt;&#x3D; Node.val &lt;&#x3D; 231 - 1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">For the recursive solution, we set a lower bound and a upper bound for the tree. When we recurse on the left subtree, the upper bound becomes the value of its root. When we recurse on the right subtree, the lower bound becomes the value of its root.</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-递归-2"><a href="#Solution1-递归-2" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><p>方法一: 递归<br>思路和算法</p>
<p>要解决这道题首先我们要了解二叉搜索树有什么性质可以给我们利用，由题目给出的信息我们可以知道：如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。</p>
<p>这启示我们设计一个递归函数 helper(root, lower, upper) 来递归判断，函数表示考虑以 root 为根的子树，判断子树中所有节点的值是否都在 (l,r)(l,r) 的范围内（注意是开区间）。如果 root 节点的值 val 不在 (l,r)(l,r) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。</p>
<p>那么根据二叉搜索树的性质，在递归调用左子树时，我们需要把上界 upper 改为 root.val，即调用 helper(root.left, lower, root.val)，因为左子树里所有节点的值均小于它的根节点的值。同理递归调用右子树时，我们需要把下界 lower 改为 root.val，即调用 helper(root.right, root.val, upper)。</p>
<p>函数递归调用的入口为 helper(root, -inf, +inf)， inf 表示一个无穷大的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool helper(TreeNode* root, long long lower, long long upper) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root -&gt; val &lt;= lower || root -&gt; val &gt;= upper) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return helper(root -&gt; left, lower, root -&gt; val) &amp;&amp; helper(root -&gt; right, root -&gt; val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        return helper(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 为二叉树的节点个数。在递归调用的时候二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)O(n)。</p>
<p>空间复杂度：O(n)O(n)，其中 nn 为二叉树的节点个数。递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，即二叉树的高度。最坏情况下二叉树为一条链，树的高度为 nn ，递归最深达到 nn 层，故最坏情况下空间复杂度为 O(n)O(n) 。</p>
<h2 id="Solution2-中序遍历为升序"><a href="#Solution2-中序遍历为升序" class="headerlink" title="Solution2 中序遍历为升序"></a>Solution2 中序遍历为升序</h2><p>基于方法一中提及的性质，我们可以进一步知道二叉搜索树「中序遍历」得到的值构成的序列一定是升序的，这启示我们在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。如果均大于说明这个序列是升序的，整棵树是二叉搜索树，否则不是，下面的代码我们使用栈来模拟中序遍历的过程。</p>
<p>可能有读者不知道中序遍历是什么，我们这里简单提及。中序遍历是二叉树的一种遍历方式，它先遍历左子树，再遍历根节点，最后遍历右子树。而我们二叉搜索树保证了左子树的节点的值均小于根节点的值，根节点的值均小于右子树的值，因此中序遍历以后得到的序列一定是升序序列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stack;</span><br><span class="line">        long long inorder = (long long)INT_MIN - 1;</span><br><span class="line"></span><br><span class="line">        while (!stack.empty() || root != nullptr) &#123;</span><br><span class="line">            while (root != nullptr) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root -&gt; left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.top();</span><br><span class="line">            stack.pop();</span><br><span class="line">            // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树</span><br><span class="line">            if (root -&gt; val &lt;= inorder) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            inorder = root -&gt; val;</span><br><span class="line">            root = root -&gt; right;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 为二叉树的节点个数。二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)O(n)。</p>
<p>空间复杂度：O(n)O(n)，其中 nn 为二叉树的节点个数。栈最多存储 nn 个节点，因此需要额外的 O(n)O(n) 的空间。</p>
<h1 id="树-x2F-递归：101-对称二叉树"><a href="#树-x2F-递归：101-对称二叉树" class="headerlink" title="树&#x2F;递归：101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/symmetric-tree/">树&#x2F;递归：101. 对称二叉树</a></h1><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,2,2,3,4,4,3]<br>输出：true<br>示例 2：</p>
<p>输入：root &#x3D; [1,2,2,null,3,null,3]<br>输出：false
 </p>
<p>提示：</p>
<p>树中节点数目在范围 [1, 1000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100
 </p>
<p>进阶：你可以运用递归和迭代两种方法解决这个问题吗？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Explanation :</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool solve(TreeNode * r1, TreeNode * r2)</span><br><span class="line">    &#123;</span><br><span class="line">        // See the tree diagram are r1 and r2 null ? No, so this line dont execute</span><br><span class="line">        if(r1 == NULL &amp;&amp; r2 == NULL)</span><br><span class="line">            return true; </span><br><span class="line">		</span><br><span class="line">        // Is any one of r1 or r2 null ? Or are these values different ? No. Both values are</span><br><span class="line">        // same so this else if wont execute either</span><br><span class="line">        else if(r1 == NULL || r2 == NULL || r1-&gt;val != r2-&gt;val)</span><br><span class="line">            return false; </span><br><span class="line">        </span><br><span class="line">        // Now comes the main part, we are calling 2 seperate function calls </span><br><span class="line">        return solve(r1-&gt;left, r2-&gt;right) &amp;&amp; solve(r1-&gt;right, r2-&gt;left);</span><br><span class="line">        // First solve() before &amp;&amp; will execute</span><br><span class="line">        // r1-&gt;left is 3 and r2-&gt;right = 3</span><br><span class="line">        // Both values are same , they will by pass both if and else if statement</span><br><span class="line">        // Now again r1-&gt;left is null and r2-&gt;right is null</span><br><span class="line">        // So they will return true from first if condtion</span><br><span class="line">        // Now the scene is : we have executed first solve() before &amp;&amp; and it has</span><br><span class="line">        // returned us True so expression becomes &#x27; return true &amp;&amp; solve() &#x27;</span><br><span class="line">        // Now solve after &amp;&amp; will execute </span><br><span class="line">        // Similarly it will check for 4 and 4 , it will by pass if else statements</span><br><span class="line">        // next time both will become null, so will return true</span><br><span class="line">        // Thus 2nd solve() at the end will also hold true</span><br><span class="line">        // and we know &#x27;true &amp;&amp; true&#x27; is true</span><br><span class="line">        // so true will be returned to caller, and thus tree is mirror of itself.</span><br><span class="line">        // Similarly you can check for any testcase, flow of execution will remain same.</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool isSymmetric(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        // Imagine a tree:    1</span><br><span class="line">        //                 2     2</span><br><span class="line">        //               3   4 4   3</span><br><span class="line">        // We are standing on root that is 1, function begins</span><br><span class="line">        // and now r1 and r2 points to 2 and 2 respectively.                      </span><br><span class="line">        return solve(root-&gt;left, root-&gt;right);     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="Solution1-递归-3"><a href="#Solution1-递归-3" class="headerlink" title="Solution1  递归"></a>Solution1  递归</h2><p><img src="https://files.mdnice.com/user/1489/17bcb971-2dd2-4659-a84f-24493a37c88e.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">		if(root==null) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		//调用递归函数，比较左节点，右节点</span><br><span class="line">		return dfs(root.left,root.right);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	boolean dfs(TreeNode left, TreeNode right) &#123;</span><br><span class="line">		//递归的终止条件是两个节点都为空</span><br><span class="line">		//或者两个节点中有一个为空</span><br><span class="line">		//或者两个节点的值不相等</span><br><span class="line">		if(left==null &amp;&amp; right==null) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		if(left==null || right==null) &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		if(left.val!=right.val) &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		//再递归的比较 左节点的左孩子 和 右节点的右孩子</span><br><span class="line">		//以及比较  左节点的右孩子 和 右节点的左孩子</span><br><span class="line">		return dfs(left.left,right.right) &amp;&amp; dfs(left.right,right.left);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution2-队列"><a href="#Solution2-队列" class="headerlink" title="Solution2 队列"></a>Solution2 队列</h2><p>回想下递归的实现：<br>当两个子树的根节点相等时，就比较:<br>左子树的 left 和 右子树的 right，这个比较是用递归实现的。<br>现在我们改用队列来实现，思路如下：<br>首先从队列中拿出两个节点(left 和 right)比较<br>将 left 的 left 节点和 right 的 right 节点放入队列<br>将 left 的 right 节点和 right 的 left 节点放入队列<br>时间复杂度是 O(n)O(n)，空间复杂度是 O(n)O(n)<br>动画演示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">		if(root==null || (root.left==null &amp;&amp; root.right==null)) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		//用队列保存节点</span><br><span class="line">		LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">		//将根节点的左右孩子放到队列中</span><br><span class="line">		queue.add(root.left);</span><br><span class="line">		queue.add(root.right);</span><br><span class="line">		while(queue.size()&gt;0) &#123;</span><br><span class="line">			//从队列中取出两个节点，再比较这两个节点</span><br><span class="line">			TreeNode left = queue.removeFirst();</span><br><span class="line">			TreeNode right = queue.removeFirst();</span><br><span class="line">			//如果两个节点都为空就继续循环，两者有一个为空就返回false</span><br><span class="line">			if(left==null &amp;&amp; right==null) &#123;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			if(left==null || right==null) &#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">			if(left.val!=right.val) &#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">			//将左节点的左孩子， 右节点的右孩子放入队列</span><br><span class="line">			queue.add(left.left);</span><br><span class="line">			queue.add(right.right);</span><br><span class="line">			//将左节点的右孩子，右节点的左孩子放入队列</span><br><span class="line">			queue.add(left.right);</span><br><span class="line">			queue.add(right.left);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="递归：200-岛屿数量"><a href="#递归：200-岛屿数量" class="headerlink" title="递归：200. 岛屿数量"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/number-of-islands/">递归：200. 岛屿数量</a></h1><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：grid &#x3D; [<br>  [“1”,”1”,”1”,”1”,”0”],<br>  [“1”,”1”,”0”,”1”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”0”,”0”,”0”]<br>]<br>输出：1<br>示例 2：</p>
<p>输入：grid &#x3D; [<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”1”,”0”,”0”],<br>  [“0”,”0”,”0”,”1”,”1”]<br>]<br>输出：3
 </p>
<p>提示：</p>
<p>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 300<br>grid[i][j] 的值为 ‘0’ 或 ‘1’</p>
<p><img src="https://files.mdnice.com/user/1489/6128b483-caa2-4730-a94c-7b53e02cb7b0.png"></p>
<h2 id="Solution1-DFS"><a href="#Solution1-DFS" class="headerlink" title="Solution1  DFS"></a>Solution1  DFS</h2><p>思路：遍历岛这个二维数组，如果当前数为1，则进入感染函数并将岛个数+1<br>感染函数：其实就是一个递归标注的过程，它会将所有相连的1都标注成2。为什么要标注？这样就避免了遍历过程中的重复计数的情况，一个岛所有的1都变成了2后，遍历的时候就不会重复遍历了。建议没想明白的同学画个图看看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numIslands(char[][] grid) &#123;</span><br><span class="line">        int islandNum = 0;</span><br><span class="line">        for(int i = 0; i &lt; grid.length; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; grid[0].length; j++)&#123;</span><br><span class="line">                if(grid[i][j] == &#x27;1&#x27;)&#123;</span><br><span class="line">                    infect(grid, i, j);</span><br><span class="line">                    islandNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return islandNum;</span><br><span class="line">    &#125;</span><br><span class="line">    //感染函数</span><br><span class="line">    public void infect(char[][] grid, int i, int j)&#123;</span><br><span class="line">        if(i &lt; 0 || i &gt;= grid.length ||</span><br><span class="line">           j &lt; 0 || j &gt;= grid[0].length || grid[i][j] != &#x27;1&#x27;)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = &#x27;2&#x27;;</span><br><span class="line">        infect(grid, i + 1, j);</span><br><span class="line">        infect(grid, i - 1, j);</span><br><span class="line">        infect(grid, i, j + 1);</span><br><span class="line">        infect(grid, i, j - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution2-BFS"><a href="#Solution2-BFS" class="headerlink" title="Solution2 BFS"></a>Solution2 BFS</h2><p>主循环和思路一类似，不同点是在于搜索某岛屿边界的方法不同。<br>bfs 方法：<br>借用一个队列 queue，判断队列首部节点 (i, j) 是否未越界且为 1：<br>若是则置零（删除岛屿节点），并将此节点上下左右节点 (i+1,j),(i-1,j),(i,j+1),(i,j-1) 加入队列；<br>若不是则跳过此节点；<br>循环 pop 队列首节点，直到整个队列为空，此时已经遍历完此岛屿。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numIslands(char[][] grid) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for(int i = 0; i &lt; grid.length; i++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; grid[0].length; j++) &#123;</span><br><span class="line">                if(grid[i][j] == &#x27;1&#x27;)&#123;</span><br><span class="line">                    bfs(grid, i, j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">    private void bfs(char[][] grid, int i, int j)&#123;</span><br><span class="line">        Queue&lt;int[]&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line">        list.add(new int[] &#123; i, j &#125;);</span><br><span class="line">        while(!list.isEmpty())&#123;</span><br><span class="line">            int[] cur = list.remove();</span><br><span class="line">            i = cur[0]; j = cur[1];</span><br><span class="line">            if(0 &lt;= i &amp;&amp; i &lt; grid.length &amp;&amp; 0 &lt;= j &amp;&amp; j &lt; grid[0].length &amp;&amp; grid[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                grid[i][j] = &#x27;0&#x27;;</span><br><span class="line">                list.add(new int[] &#123; i + 1, j &#125;);</span><br><span class="line">                list.add(new int[] &#123; i - 1, j &#125;);</span><br><span class="line">                list.add(new int[] &#123; i, j + 1 &#125;);</span><br><span class="line">                list.add(new int[] &#123; i, j - 1 &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="递归：206-反转链表"><a href="#递归：206-反转链表" class="headerlink" title="递归：206. 反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-linked-list/">递归：206. 反转链表</a></h1><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
 </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4,5]<br>输出：[5,4,3,2,1]<br>示例 2：</p>
<p>输入：head &#x3D; [1,2]<br>输出：[2,1]<br>示例 3：</p>
<p>输入：head &#x3D; []<br>输出：[]
 </p>
<p>提示：</p>
<p>链表中节点的数目范围是 [0, 5000]<br>-5000 &lt;&#x3D; Node.val &lt;&#x3D; 5000
 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Well, since the head pointer may also be modified, we create a pre that points to it to facilitate the reverse process.</span><br><span class="line"></span><br><span class="line">For the example list 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 in the problem statement, it will become 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 (we init pre -&gt; val to be 0). We also set a pointer cur to head. Then we keep inserting cur -&gt; next after pre until cur becomes the last node. This idea uses three pointers (pre, cur and temp). You may implement it as follows.</span><br></pre></td></tr></table></figure>
<h2 id="Solution1-迭代"><a href="#Solution1-迭代" class="headerlink" title="Solution1 迭代"></a>Solution1 迭代</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/迭代法</span><br><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">    ListNode pre = null;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    while(cur!=null) &#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-递归"><a href="#Solution2-递归" class="headerlink" title="Solution2 递归"></a>Solution2 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//尾递归</span><br><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">    return reverse(null,head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static ListNode reverse(ListNode pre,ListNode cur)&#123;</span><br><span class="line">    if(cur==null) return pre;</span><br><span class="line">    ListNode next = cur.next;</span><br><span class="line">    cur.next = pre;</span><br><span class="line">    return reverse(cur,next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="树-x2F-递归：235-二叉搜索树的最近公共祖先"><a href="#树-x2F-递归：235-二叉搜索树的最近公共祖先" class="headerlink" title="树&#x2F;递归：235. 二叉搜索树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">树&#x2F;递归：235. 二叉搜索树的最近公共祖先</a></h1><p><img src="https://files.mdnice.com/user/1489/183fb47d-cb82-4909-bfae-8f78c632e7ea.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Well, remember to take advantage of the property of binary search trees, which is, node -&gt; left -&gt; val &lt; node -&gt; val &lt; node -&gt; right -&gt; val. Moreover, both p and q will be the descendants of the root of the subtree that contains both of them. And the root with the largest depth is just the lowest common ancestor. This idea can be turned into the following simple recursive code.</span><br></pre></td></tr></table></figure>
<h2 id="Solution1-非递归"><a href="#Solution1-非递归" class="headerlink" title="Solution1  非递归"></a>Solution1  非递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">      //如果根节点和p,q的差相乘是正数，说明这两个差值要么都是正数要么都是负数，也就是说</span><br><span class="line">      //他们肯定都位于根节点的同一侧，就继续往下找</span><br><span class="line">      while ((root.val - p.val) * (root.val - q.val) &gt; 0)</span><br><span class="line">          root = p.val &lt; root.val ? root.left : root.right;</span><br><span class="line">      //如果相乘的结果是负数，说明p和q位于根节点的两侧，如果等于0，说明至少有一个就是根节点</span><br><span class="line">      return root;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h2 id="Solution2-递归-1"><a href="#Solution2-递归-1" class="headerlink" title="Solution2 递归"></a>Solution2 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">    //如果小于等于0，说明p和q位于root的两侧，直接返回即可</span><br><span class="line">    if ((root.val - p.val) * (root.val - q.val) &lt;= 0)</span><br><span class="line">        return root;</span><br><span class="line">    //否则，p和q位于root的同一侧，就继续往下找</span><br><span class="line">    return lowestCommonAncestor(p.val &lt; root.val ? root.left : root.right, p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="树-x2F-递归：236-二叉树的最近公共祖先"><a href="#树-x2F-递归：236-二叉树的最近公共祖先" class="headerlink" title="树&#x2F;递归：236. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">树&#x2F;递归：236. 二叉树的最近公共祖先</a></h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。<br>示例 2：</p>
<p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4<br>输出：5<br>解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。<br>示例 3：</p>
<p>输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2<br>输出：1
 </p>
<p>提示：</p>
<p>树中节点数目在范围 [2, 105] 内。<br>-109 &lt;&#x3D; Node.val &lt;&#x3D; 109<br>所有 Node.val 互不相同 。<br>p !&#x3D; q<br>p 和 q 均存在于给定的二叉树中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Approach 1: Recursive Approach</span><br><span class="line">Intuition</span><br><span class="line"></span><br><span class="line">The approach is pretty intuitive. Traverse the tree in a depth first manner. The moment you encounter either of the nodes p or q, return some boolean flag. The flag helps to determine if we found the required nodes in any of the paths. The least common ancestor would then be the node for which both the subtree recursions return a True flag. It can also be the node which itself is one of p or q and for which one of the subtree recursions returns a True flag.</span><br><span class="line"></span><br><span class="line">Let us look at the formal algorithm based on this idea.</span><br><span class="line"></span><br><span class="line">Algorithm</span><br><span class="line"></span><br><span class="line">Start traversing the tree from the root node.</span><br><span class="line">If the current node itself is one of p or q, we would mark a variable mid as True and continue the search for the other node in the left and right branches.</span><br><span class="line">If either of the left or the right branch returns True, this means one of the two nodes was found below.</span><br><span class="line">If at any point in the traversal, any two of the three flags left, right or mid become True, this means we have found the lowest common ancestor for the nodes p and q.</span><br><span class="line"></span><br><span class="line">Complexity Analysis</span><br><span class="line"></span><br><span class="line">Time Complexity: O(N)O(N), where NN is the number of nodes in the binary tree. In the worst case we might be visiting all the nodes of the binary tree.</span><br><span class="line"></span><br><span class="line">Space Complexity: O(N)O(N). This is because the maximum amount of space utilized by the recursion stack would be NN since the height of a skewed binary tree could be NN.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Approach 2: Iterative using parent pointers</span><br><span class="line">Intuition</span><br><span class="line"></span><br><span class="line">If we have parent pointers for each node we can traverse back from p and q to get their ancestors. The first common node we get during this traversal would be the LCA node. We can save the parent pointers in a dictionary as we traverse the tree.</span><br><span class="line"></span><br><span class="line">Algorithm</span><br><span class="line"></span><br><span class="line">Start from the root node and traverse the tree.</span><br><span class="line">Until we find p and q both, keep storing the parent pointers in a dictionary.</span><br><span class="line">Once we have found both p and q, we get all the ancestors for p using the parent dictionary and add to a set called ancestors.</span><br><span class="line">Similarly, we traverse through ancestors for node q. If the ancestor is present in the ancestors set for p, this means this is the first ancestor common between p and q (while traversing upwards) and hence this is the LCA node.</span><br><span class="line"></span><br><span class="line">Complexity Analysis</span><br><span class="line"></span><br><span class="line">Time Complexity : O(N)O(N), where NN is the number of nodes in the binary tree. In the worst case we might be visiting all the nodes of the binary tree.</span><br><span class="line"></span><br><span class="line">Space Complexity : O(N)O(N). In the worst case space utilized by the stack, the parent pointer dictionary and the ancestor set, would be NN each, since the height of a skewed binary tree could be NN.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution1-递归-4"><a href="#Solution1-递归-4" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if (root == null) return null;</span><br><span class="line">        // 如果p,q为根节点，则公共祖先为根节点</span><br><span class="line">        if (root.val == p.val || root.val == q.val) return root;</span><br><span class="line">        // 如果p,q在左子树，则公共祖先在左子树查找</span><br><span class="line">        if (find(root.left, p) &amp;&amp; find(root.left, q)) &#123;</span><br><span class="line">            return lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果p,q在右子树，则公共祖先在右子树查找</span><br><span class="line">        if (find(root.right, p) &amp;&amp; find(root.right, q)) &#123;</span><br><span class="line">            return lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果p,q分属两侧，则公共祖先为根节点</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private boolean find(TreeNode root, TreeNode c) &#123;</span><br><span class="line">        if (root == null) return false;</span><br><span class="line">        if (root.val == c.val) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return find(root.left, c) || find(root.right, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="递归：最小的K个数"><a href="#递归：最小的K个数" class="headerlink" title="递归：最小的K个数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof">递归：最小的K个数</a></h1><p><img src="https://files.mdnice.com/user/1489/c9037420-1a61-4305-bad1-b4227ec9707f.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/f5098755-cba5-4145-9804-8e4cbff4dd48.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/e3138c17-60bb-411d-9843-f6639bd0abd7.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/2c2e1f87-d654-46f1-a83f-c36c34189b47.jpg"></p>
<h1 id="树-x2F-递归：二叉搜索树与双向链表"><a href="#树-x2F-递归：二叉搜索树与双向链表" class="headerlink" title="树&#x2F;递归：二叉搜索树与双向链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof">树&#x2F;递归：二叉搜索树与双向链表</a></h1><p><img src="https://files.mdnice.com/user/1489/d51c2fab-43eb-470b-8d20-9408f94774ed.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/c672b522-c4ab-424a-b872-59264a5bd13e.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/77a88286-4f3b-40a2-8aa5-6513bef59e05.jpg"></p>
<h1 id="树-x2F-递归-二叉树的镜像"><a href="#树-x2F-递归-二叉树的镜像" class="headerlink" title="树&#x2F;递归: 二叉树的镜像"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof">树&#x2F;递归: 二叉树的镜像</a></h1><p><img src="https://files.mdnice.com/user/1489/64dedead-67bc-48c3-b39b-b7eefdecdbf3.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/c5329093-56fd-4e91-8ee1-7c045e22310f.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/a89ccc07-d81b-4c4c-9430-b0c3096d59c0.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/f23d7252-0e97-4d3c-890a-434c8b5803d5.jpg"></p>
<h1 id="树-x2F-递归-对称的二叉树"><a href="#树-x2F-递归-对称的二叉树" class="headerlink" title="树&#x2F;递归: 对称的二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof">树&#x2F;递归: 对称的二叉树</a></h1><p><img src="https://files.mdnice.com/user/1489/a2d7a7ea-4135-46f9-9ce9-0601312f2e95.jpg"></p>
<h1 id="树-x2F-递归-树的子结构"><a href="#树-x2F-递归-树的子结构" class="headerlink" title="树&#x2F;递归: 树的子结构"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof">树&#x2F;递归: 树的子结构</a></h1><p><img src="https://files.mdnice.com/user/1489/2c27e439-fff2-4f5e-a3e7-d35da3dd0250.jpg"><br><img src="https://files.mdnice.com/user/1489/ddadda37-15c0-4593-9817-db62669441a3.jpg"></p>
<h1 id="树-x2F-递归-二叉树中和为某一个值的路径"><a href="#树-x2F-递归-二叉树中和为某一个值的路径" class="headerlink" title="树&#x2F;递归: 二叉树中和为某一个值的路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof">树&#x2F;递归: 二叉树中和为某一个值的路径</a></h1><p><img src="https://files.mdnice.com/user/1489/aefe8796-fac3-4849-a19c-fce0f029ba08.jpg"></p>
<h1 id="递归-x2F-树：105-从前序与中序遍历序列构造二叉树"><a href="#递归-x2F-树：105-从前序与中序遍历序列构造二叉树" class="headerlink" title="递归&#x2F;树：105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">递归&#x2F;树：105. 从前序与中序遍历序列构造二叉树</a></h1><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]<br>输出: [3,9,20,null,null,15,7]<br>示例 2:</p>
<p>输入: preorder &#x3D; [-1], inorder &#x3D; [-1]<br>输出: [-1]
 </p>
<p>提示:</p>
<p>1 &lt;&#x3D; preorder.length &lt;&#x3D; 3000<br>inorder.length &#x3D;&#x3D; preorder.length<br>-3000 &lt;&#x3D; preorder[i], inorder[i] &lt;&#x3D; 3000<br>preorder 和 inorder 均 无重复 元素<br>inorder 均出现在 preorder<br>preorder 保证 为二叉树的前序遍历序列<br>inorder 保证 为二叉树的中序遍历序列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Solution</span><br><span class="line">You need to understand preorder and postorder traversal first, and then go ahead.</span><br><span class="line"></span><br><span class="line">Basic idea is:</span><br><span class="line"></span><br><span class="line">preorder[0] is the root node of the tree</span><br><span class="line">preorder[x] is a root node of a sub tree</span><br><span class="line">In in-order traversal</span><br><span class="line">When inorder[index] is an item in the in-order traversal</span><br><span class="line">inorder[0]-inorder[index-1] are on the left branch</span><br><span class="line">inorder[index+1]-inorder[size()-1] are on the right branch</span><br><span class="line">if there is nothing on the left, that means the left child of the node is NULL</span><br><span class="line">if there is nothing on the right, that means the right child of the node is NULL</span><br><span class="line">Algorithm:</span><br><span class="line"></span><br><span class="line">Start from rootIdx 0</span><br><span class="line">Find preorder[rootIdx] from inorder, let&#x27;s call the index pivot</span><br><span class="line">Create a new node with inorder[pivot]</span><br><span class="line">Create its left child recursively</span><br><span class="line">Create its right child recursively</span><br><span class="line">Return the created node.</span><br><span class="line">The implementation is self explanatory. Have a look :)</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-递归-5"><a href="#Solution1-递归-5" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">        // preorder: [root, [left], [right]]</span><br><span class="line">        // inorder:  [[left], root, [right]]</span><br><span class="line">        return buildTree(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, int lo1, int hi1, vector&lt;int&gt;&amp; inorder, int lo2, int hi2) &#123;</span><br><span class="line">        if (lo1 &gt; hi1 || lo2 &gt; hi2) return nullptr;</span><br><span class="line">        int root = preorder[lo1];</span><br><span class="line">        int mid = lo2;</span><br><span class="line">        // 在 inorder 中查找 root 位置</span><br><span class="line">        for (int i = lo2; i &lt;= hi2; ++i) &#123;</span><br><span class="line">            if (inorder[i] == root) &#123;</span><br><span class="line">                mid = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        auto s = new TreeNode(root);</span><br><span class="line">        // 下面的数组表示分割长度</span><br><span class="line">        // inorder: [mid-lo2, mid, hi2-mid]</span><br><span class="line">        // preorder:[root, mid-lo2, hi2-mid]</span><br><span class="line">        s-&gt;left = buildTree(preorder, lo1+1, lo1+mid-lo2, inorder, lo2, mid-1);</span><br><span class="line">        s-&gt;right = buildTree(preorder, lo1+mid-lo2+1, hi1, inorder, mid+1, hi2);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="Solution2-1"><a href="#Solution2-1" class="headerlink" title="Solution2"></a>Solution2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int getLength(ListNode* head) &#123;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (; head != nullptr; ++ret, head = head-&gt;next);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* buildTree(ListNode*&amp; head, int left, int right) &#123;</span><br><span class="line">        if (left &gt; right) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = (left + right + 1) / 2;</span><br><span class="line">        TreeNode* root = new TreeNode();</span><br><span class="line">        root-&gt;left = buildTree(head, left, mid - 1);</span><br><span class="line">        root-&gt;val = head-&gt;val;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        root-&gt;right = buildTree(head, mid + 1, right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* sortedListToBST(ListNode* head) &#123;</span><br><span class="line">        int length = getLength(head);</span><br><span class="line">        return buildTree(head, 0, length - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="递归-x2F-树：109-有序链表转换二叉搜索树"><a href="#递归-x2F-树：109-有序链表转换二叉搜索树" class="headerlink" title="递归&#x2F;树：109. 有序链表转换二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/">递归&#x2F;树：109. 有序链表转换二叉搜索树</a></h1><p>给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: head &#x3D; [-10,-3,0,5,9]<br>输出: [0,-3,9,-10,null,5]<br>解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。<br>示例 2:</p>
<p>输入: head &#x3D; []<br>输出: []
 </p>
<p>提示:</p>
<p>head 中的节点数在[0, 2 * 104] 范围内<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Recursively build tree.</span><br><span class="line"></span><br><span class="line">find midpoint by fast/slow method, use middle node as root.</span><br><span class="line">build left child by first half of the list</span><br><span class="line">build right child by second half of the list (head is midpoint-&gt;next)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution1-先找中点-然后再左右分别构造"><a href="#Solution1-先找中点-然后再左右分别构造" class="headerlink" title="Solution1 先找中点 然后再左右分别构造"></a>Solution1 先找中点 然后再左右分别构造</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode sortedListToBST(ListNode head) &#123;</span><br><span class="line">        if(head == null) return null;</span><br><span class="line">        else if(head.next == null) return new TreeNode(head.val);</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        ListNode p = pre.next;</span><br><span class="line">        ListNode q = p.next;</span><br><span class="line">        //找到链表的中点p</span><br><span class="line">        while(q!=null &amp;&amp; q.next!=null)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            p = pre.next;</span><br><span class="line">            q = q.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //将中点左边的链表分开</span><br><span class="line">        pre.next = null;</span><br><span class="line">        TreeNode root = new TreeNode(p.val);</span><br><span class="line">        root.left = sortedListToBST(head);</span><br><span class="line">        root.right = sortedListToBST(p.next);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="递归-x2F-树：113-路径总和-II"><a href="#递归-x2F-树：113-路径总和-II" class="headerlink" title="递归&#x2F;树：113. 路径总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/path-sum-ii/">递归&#x2F;树：113. 路径总和 II</a></h1><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22<br>输出：[[5,4,11,2],[5,8,4,5]]<br>示例 2：</p>
<p>输入：root &#x3D; [1,2,3], targetSum &#x3D; 5<br>输出：[]<br>示例 3：</p>
<p>输入：root &#x3D; [1,2], targetSum &#x3D; 0<br>输出：[]
 </p>
<p>提示：</p>
<p>树中节点总数在范围 [0, 5000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000<br>-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Idea</span><br><span class="line"></span><br><span class="line">DFS from the root down to it&#x27;s descendants:</span><br><span class="line">We need to keep current path (which stores elements in the path) so far.</span><br><span class="line">We need to keep the remain targetSum so far (after minus value of elements in the path).</span><br><span class="line">If we already reach into leaf node</span><br><span class="line">Check if targetSum == 0 then we found a valid path from root to leaf node which sum equal to targetSum, so add current path to the answer.</span><br><span class="line">Else dfs on left node and on the right node.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Complexity</span><br><span class="line"></span><br><span class="line">Time: O(N^2), where N &lt;= 5000 is the number of elements in the binary tree.</span><br><span class="line"></span><br><span class="line">First, we think the time complexity is O(N) because we only visit each node once.</span><br><span class="line">But we forgot to calculate the cost to copy the current path when we found a valid path, which in the worst case can cost O(N^2), let see the following example for more clear.</span><br><span class="line"></span><br><span class="line">Extra Space (without counting output as space): O(H), where H is height of the binary tree. This is the space for stack recursion or keeping path so far.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Solution1-DFS-1"><a href="#Solution1-DFS-1" class="headerlink" title="Solution1 DFS"></a>Solution1 DFS</h2><p>我们可以采用深度优先搜索的方式，枚举每一条从根节点到叶子节点的路径。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p>
<p>复杂度分析</p>
<p><img src="https://files.mdnice.com/user/1489/070d05a3-3ee3-4b0a-90da-bed5c1c2b9a8.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ret;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line"></span><br><span class="line">    void dfs(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        path.emplace_back(root-&gt;val);</span><br><span class="line">        targetSum -= root-&gt;val;</span><br><span class="line">        if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr &amp;&amp; targetSum == 0) &#123;</span><br><span class="line">            ret.emplace_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left, targetSum);</span><br><span class="line">        dfs(root-&gt;right, targetSum);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        dfs(root, targetSum);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Solution2-BFS-1"><a href="#Solution2-BFS-1" class="headerlink" title="Solution2 BFS"></a>Solution2 BFS</h2><p>方法二：广度优先搜索<br>思路及算法</p>
<p>我们也可以采用广度优先搜索的方式，遍历这棵树。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p>
<p>为了节省空间，我们使用哈希表记录树中的每一个节点的父节点。每次找到一个满足条件的节点，我们就从该节点出发不断向父节点迭代，即可还原出从根节点到当前节点的路径。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ret;</span><br><span class="line">    unordered_map&lt;TreeNode*, TreeNode*&gt; parent;</span><br><span class="line"></span><br><span class="line">    void getPath(TreeNode* node) &#123;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        while (node != nullptr) &#123;</span><br><span class="line">            tmp.emplace_back(node-&gt;val);</span><br><span class="line">            node = parent[node];</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(tmp.begin(), tmp.end());</span><br><span class="line">        ret.emplace_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; que_node;</span><br><span class="line">        queue&lt;int&gt; que_sum;</span><br><span class="line">        que_node.emplace(root);</span><br><span class="line">        que_sum.emplace(0);</span><br><span class="line"></span><br><span class="line">        while (!que_node.empty()) &#123;</span><br><span class="line">            TreeNode* node = que_node.front();</span><br><span class="line">            que_node.pop();</span><br><span class="line">            int rec = que_sum.front() + node-&gt;val;</span><br><span class="line">            que_sum.pop();</span><br><span class="line"></span><br><span class="line">            if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr) &#123;</span><br><span class="line">                if (rec == targetSum) &#123;</span><br><span class="line">                    getPath(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (node-&gt;left != nullptr) &#123;</span><br><span class="line">                    parent[node-&gt;left] = node;</span><br><span class="line">                    que_node.emplace(node-&gt;left);</span><br><span class="line">                    que_sum.emplace(rec);</span><br><span class="line">                &#125;</span><br><span class="line">                if (node-&gt;right != nullptr) &#123;</span><br><span class="line">                    parent[node-&gt;right] = node;</span><br><span class="line">                    que_node.emplace(node-&gt;right);</span><br><span class="line">                    que_sum.emplace(rec);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="树：从上到下打印二叉树"><a href="#树：从上到下打印二叉树" class="headerlink" title="树：从上到下打印二叉树|||"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof">树：从上到下打印二叉树|||</a></h1><p><img src="https://files.mdnice.com/user/1489/a730fbab-4997-4af9-a608-85ffe0bcac07.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/442400a3-6855-4a90-a088-8d14c10099fd.jpg"></p>
<h1 id="树-x2F-分治-重建二叉树"><a href="#树-x2F-分治-重建二叉树" class="headerlink" title="树&#x2F;分治: 重建二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof">树&#x2F;分治: 重建二叉树</a></h1><p><img src="https://files.mdnice.com/user/1489/f3d44400-5e6a-4005-be47-2a20e288383f.jpg"><br><img src="https://files.mdnice.com/user/1489/c1843e98-f7e0-4e0b-b053-3bdb40abb586.jpg"></p>
<h1 id="树：最大二叉树"><a href="#树：最大二叉树" class="headerlink" title="树：最大二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-binary-tree">树：最大二叉树</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Approach 1: Recursive Solution</span><br><span class="line">The current solution is very simple. We make use of a function construct(nums, l, r), which returns the maximum binary tree consisting of numbers within the indices ll and rr in the given numsnums array(excluding the r^&#123;th&#125;r </span><br><span class="line">th</span><br><span class="line">  element).</span><br><span class="line"></span><br><span class="line">The algorithm consists of the following steps:</span><br><span class="line"></span><br><span class="line">Start with the function call construct(nums, 0, n). Here, nn refers to the number of elements in the given numsnums array.</span><br><span class="line"></span><br><span class="line">Find the index, max_imax </span><br><span class="line">i</span><br><span class="line">​</span><br><span class="line"> , of the largest element in the current range of indices (l:r-1)(l:r−1). Make this largest element, nums[max\_i]nums[max_i] as the local root node.</span><br><span class="line"></span><br><span class="line">Determine the left child using construct(nums, l, max_i). Doing this recursively finds the largest element in the subarray left to the current largest element.</span><br><span class="line"></span><br><span class="line">Similarly, determine the right child using construct(nums, max_i + 1, r).</span><br><span class="line"></span><br><span class="line">Return the root node to the calling function.</span><br></pre></td></tr></table></figure>

<p><img src="https://files.mdnice.com/user/1489/7cb88611-e8e0-4de4-a0e0-c34d8a78df3d.jpg"></p>
<h1 id="树-把二叉搜索树转换成为累加树"><a href="#树-把二叉搜索树转换成为累加树" class="headerlink" title="树: 把二叉搜索树转换成为累加树"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/convert-bst-to-greater-tree">树: 把二叉搜索树转换成为累加树</a></h1><p><img src="https://files.mdnice.com/user/1489/f9a6f9ba-1a2e-4ef2-8799-6b93c635519c.jpg"></p>
<h1 id="树-二叉树的直径"><a href="#树-二叉树的直径" class="headerlink" title="树:二叉树的直径"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/diameter-of-binary-tree">树:二叉树的直径</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">int dia=0;</span><br><span class="line"></span><br><span class="line">int diameterOfBinaryTree(TreeNode* root) &#123;</span><br><span class="line">    </span><br><span class="line">    //base case 1:</span><br><span class="line">    if(!root)</span><br><span class="line">        return 0;</span><br><span class="line">    </span><br><span class="line">    //recursively, call the helper function with the root</span><br><span class="line">    helper(root);</span><br><span class="line">    </span><br><span class="line">    //return the diameter value</span><br><span class="line">    return dia;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int helper(TreeNode* node)&#123;</span><br><span class="line">    </span><br><span class="line">    //base case 2</span><br><span class="line">    if(!node)</span><br><span class="line">        return 0;</span><br><span class="line">    </span><br><span class="line">    //initialize two pointers, left &amp; right ones</span><br><span class="line">    int leftNode=helper(node-&gt;left);</span><br><span class="line">    int rightNode=helper(node-&gt;right);</span><br><span class="line">    </span><br><span class="line">    //updated diameter value is the max path between two nodes-&gt; path between two leaves</span><br><span class="line">    dia=max(dia, leftNode+rightNode);</span><br><span class="line">    </span><br><span class="line">    //for each node-&gt; add the diameter by one, as you pass an edge</span><br><span class="line">    return 1+max(leftNode, rightNode);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://files.mdnice.com/user/1489/a8df6972-ea60-4073-a9ed-c607c5017b21.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/ba15565c-2189-4cda-b8eb-92ada72b826f.jpg"></p>
<h1 id="树：94-二叉树的中序遍历"><a href="#树：94-二叉树的中序遍历" class="headerlink" title="树：94. 二叉树的中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-inorder-traversal/">树：94. 二叉树的中序遍历</a></h1><p>给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,null,2,3]<br>输出：[1,3,2]<br>示例 2：</p>
<p>输入：root &#x3D; []<br>输出：[]<br>示例 3：</p>
<p>输入：root &#x3D; [1]<br>输出：[1]
 </p>
<p>提示：</p>
<p>树中节点数目在范围 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100
 </p>
<h2 id="Solution1-递归-6"><a href="#Solution1-递归-6" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><p><img src="https://files.mdnice.com/user/1489/166bca4c-bcc2-4718-b6f4-1576acf3ff36.png"></p>
<h2 id="Solution2-迭代-1"><a href="#Solution2-迭代-1" class="headerlink" title="Solution2 迭代"></a>Solution2 迭代</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        while (root != nullptr || !stk.empty()) &#123;</span><br><span class="line">            while (root != nullptr) &#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<h1 id="树：102-二叉树的层序遍历"><a href="#树：102-二叉树的层序遍历" class="headerlink" title="树：102. 二叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-level-order-traversal/">树：102. 二叉树的层序遍历</a></h1><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]<br>示例 2：</p>
<p>输入：root &#x3D; [1]<br>输出：[[1]]<br>示例 3：</p>
<p>输入：root &#x3D; []<br>输出：[]
 </p>
<p>提示：</p>
<p>树中节点数目在范围 [0, 2000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">What is level in our binary tree? It is set of nodes, for which distance between root and these nodes are constant. And if we talk about distances, it can be a good idea to use bfs.</span><br><span class="line"></span><br><span class="line">We put our root into queue, now we have level 0 in our queue.</span><br><span class="line">On each step extract all nodes from queue and put their children to to opposite end of queue. In this way we will have full level in the end of each step and our queue will be filled with nodes from the next level.</span><br><span class="line">In the end we just return result.</span><br><span class="line">Complexity</span><br><span class="line">Time complexity is O(n): we perform one bfs on our tree. Space complexity is also O(n), because we have answer of this size.</span><br><span class="line"></span><br><span class="line">Code</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-队列实现"><a href="#Solution1-队列实现" class="headerlink" title="Solution1 队列实现"></a>Solution1 队列实现</h2><p><img src="https://files.mdnice.com/user/1489/35a4e4dc-eb76-4d87-ba29-735a5042bfe1.png"></p>
<p><img src="https://files.mdnice.com/user/1489/3f09955d-d39b-41e9-8495-445cf9b35418.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector &lt;vector &lt;int&gt;&gt; ret;</span><br><span class="line">        if (!root) &#123;</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue &lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            int currentLevelSize = q.size();</span><br><span class="line">            ret.push_back(vector &lt;int&gt; ());</span><br><span class="line">            for (int i = 1; i &lt;= currentLevelSize; ++i) &#123;</span><br><span class="line">                auto node = q.front(); q.pop();</span><br><span class="line">                ret.back().push_back(node-&gt;val);</span><br><span class="line">                if (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                if (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="Solution2-递归实现"><a href="#Solution2-递归实现" class="headerlink" title="Solution2 递归实现"></a>Solution2 递归实现</h2><p>层序遍历一般来说确实是用队列实现的，但是这里很明显用递归前序遍历就能实现呀，而且复杂度O(n)。。。</p>
<p>要点有几个：</p>
<p>利用depth变量记录当前在第几层（从0开始），进入下层时depth + 1；<br>如果depth &gt;&#x3D; vector.size()说明这一层还没来过，这是第一次来，所以得扩容咯；<br>因为是前序遍历，中-左-右，对于每一层来说，左边的肯定比右边先被遍历到，实际上后序中序都是一样的。。。<br>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        pre(root, 0, ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void pre(TreeNode *root, int depth, vector&lt;vector&lt;int&gt;&gt; &amp;ans) &#123;</span><br><span class="line">        if (!root) return ;</span><br><span class="line">        if (depth &gt;= ans.size())</span><br><span class="line">            ans.push_back(vector&lt;int&gt; &#123;&#125;);</span><br><span class="line">        ans[depth].push_back(root-&gt;val);</span><br><span class="line">        pre(root-&gt;left, depth + 1, ans);</span><br><span class="line">        pre(root-&gt;right, depth + 1, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="树：103-二叉树的锯齿形层序遍历"><a href="#树：103-二叉树的锯齿形层序遍历" class="headerlink" title="树：103. 二叉树的锯齿形层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">树：103. 二叉树的锯齿形层序遍历</a></h1><p>给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[3],[20,9],[15,7]]<br>示例 2：</p>
<p>输入：root &#x3D; [1]<br>输出：[[1]]<br>示例 3：</p>
<p>输入：root &#x3D; []<br>输出：[]
 </p>
<p>提示：</p>
<p>树中节点数目在范围 [0, 2000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Assuming after traversing the 1st level, nodes in queue are &#123;9, 20, 8&#125;, And we are going to traverse 2nd level, which is even line and should print value from right to left [8, 20, 9].</span><br><span class="line"></span><br><span class="line">We know there are 3 nodes in current queue, so the vector for this level in final result should be of size 3.</span><br><span class="line">Then, queue [i] -&gt; goes to -&gt; vector[queue.size() - 1 - i]</span><br><span class="line">i.e. the ith node in current queue should be placed in (queue.size() - 1 - i) position in vector for that line.</span><br><span class="line"></span><br><span class="line">For example, for node(9), it&#x27;s index in queue is 0, so its index in vector should be (3-1-0) = 2.</span><br></pre></td></tr></table></figure>
<h2 id="Solution1-层序遍历"><a href="#Solution1-层序遍历" class="headerlink" title="Solution1 层序遍历"></a>Solution1 层序遍历</h2><p>层序遍历，然后在奇数时逆序一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">        if(!root) return res;</span><br><span class="line">        </span><br><span class="line">        queue&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        int flag = 0;</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; out;</span><br><span class="line">            int size = q.size(); //取得每一层的长度</span><br><span class="line">            for(int i = 0; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                auto temp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                out.push_back(temp-&gt;val);</span><br><span class="line">                if(temp-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag%2==1)</span><br><span class="line">            &#123;</span><br><span class="line">                reverse(out.begin(),out.end());</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(out);</span><br><span class="line">            flag++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="树：104-二叉树的最大深度"><a href="#树：104-二叉树的最大深度" class="headerlink" title="树：104. 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">树：104. 二叉树的最大深度</a></h1><p><img src="https://files.mdnice.com/user/1489/bdcd019a-a049-4e57-ac75-c491a552e1e0.png"></p>
<p><img src="https://files.mdnice.com/user/1489/6aa612fa-c6de-4c45-bcb7-0ed123b1a063.png"></p>
<h2 id="Solution1-DFS-2"><a href="#Solution1-DFS-2" class="headerlink" title="Solution1 DFS"></a>Solution1 DFS</h2><p><img src="https://files.mdnice.com/user/1489/f28b6ed7-01b5-4a89-952f-d626edf15d9e.png"></p>
<p><img src="https://files.mdnice.com/user/1489/988437b9-f65e-4111-8cde-79a687333027.png"></p>
<h2 id="Slution2-BFS"><a href="#Slution2-BFS" class="headerlink" title="Slution2 BFS"></a>Slution2 BFS</h2><p><img src="https://files.mdnice.com/user/1489/c915e202-251b-48cd-816b-cfcabdbf2214.png"></p>
<h1 id="树：105-从前序与中序遍历序列构造二叉树"><a href="#树：105-从前序与中序遍历序列构造二叉树" class="headerlink" title="树：105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">树：105. 从前序与中序遍历序列构造二叉树</a></h1><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]<br>输出: [3,9,20,null,null,15,7]<br>示例 2:</p>
<p>输入: preorder &#x3D; [-1], inorder &#x3D; [-1]<br>输出: [-1]
 </p>
<p>提示:</p>
<p>1 &lt;&#x3D; preorder.length &lt;&#x3D; 3000<br>inorder.length &#x3D;&#x3D; preorder.length<br>-3000 &lt;&#x3D; preorder[i], inorder[i] &lt;&#x3D; 3000<br>preorder 和 inorder 均 无重复 元素<br>inorder 均出现在 preorder<br>preorder 保证 为二叉树的前序遍历序列<br>inorder 保证 为二叉树的中序遍历序列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">olution</span><br><span class="line">You need to understand preorder and postorder traversal first, and then go ahead.</span><br><span class="line"></span><br><span class="line">Basic idea is:</span><br><span class="line"></span><br><span class="line">preorder[0] is the root node of the tree</span><br><span class="line">preorder[x] is a root node of a sub tree</span><br><span class="line">In in-order traversal</span><br><span class="line">When inorder[index] is an item in the in-order traversal</span><br><span class="line">inorder[0]-inorder[index-1] are on the left branch</span><br><span class="line">inorder[index+1]-inorder[size()-1] are on the right branch</span><br><span class="line">if there is nothing on the left, that means the left child of the node is NULL</span><br><span class="line">if there is nothing on the right, that means the right child of the node is NULL</span><br><span class="line">Algorithm:</span><br><span class="line"></span><br><span class="line">Start from rootIdx 0</span><br><span class="line">Find preorder[rootIdx] from inorder, let&#x27;s call the index pivot</span><br><span class="line">Create a new node with inorder[pivot]</span><br><span class="line">Create its left child recursively</span><br><span class="line">Create its right child recursively</span><br><span class="line">Return the created node.</span><br><span class="line">The implementation is self explanatory. Have a look :)</span><br></pre></td></tr></table></figure>

<h1 id="树：144-二叉树的前序遍历"><a href="#树：144-二叉树的前序遍历" class="headerlink" title="树：144. 二叉树的前序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-preorder-traversal/">树：144. 二叉树的前序遍历</a></h1><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,null,2,3]<br>输出：[1,2,3]<br>示例 2：</p>
<p>输入：root &#x3D; []<br>输出：[]<br>示例 3：</p>
<p>输入：root &#x3D; [1]<br>输出：[1]<br>示例 4：</p>
<p>输入：root &#x3D; [1,2]<br>输出：[1,2]<br>示例 5：</p>
<p>输入：root &#x3D; [1,null,2]<br>输出：[1,2]
 </p>
<p>提示：</p>
<p>树中节点数目在范围 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">There are three solutions to this problem.</span><br><span class="line"></span><br><span class="line">Iterative solution using stack --- O(n) time and O(n) space;</span><br><span class="line">Recursive solution --- O(n) time and O(n) space (function call stack);</span><br><span class="line">Morris traversal --- O(n) time and O(1) space.</span><br></pre></td></tr></table></figure>



<h2 id="Solution1-递归-7"><a href="#Solution1-递归-7" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><p><img src="https://files.mdnice.com/user/1489/04aefe28-f537-4f0f-a96c-e08abbe1030f.png"></p>
<h2 id="Solution2-迭代-2"><a href="#Solution2-迭代-2" class="headerlink" title="Solution2 迭代"></a>Solution2 迭代</h2><p><img src="https://files.mdnice.com/user/1489/de302c02-3172-4795-81bf-b52f9a497fcf.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        while (!stk.empty() || node != nullptr) &#123;</span><br><span class="line">            while (node != nullptr) &#123;</span><br><span class="line">                res.emplace_back(node-&gt;val);</span><br><span class="line">                stk.emplace(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 是二叉树的节点数。每一个节点恰好被遍历一次。</p>
<p>空间复杂度：O(n)O(n)，为迭代过程中显式栈的开销，平均情况下为 O(\log n)O(logn)，最坏情况下树呈现链状，为 O(n)O(n)。</p>
<h1 id="树：199-二叉树的右视图"><a href="#树：199-二叉树的右视图" class="headerlink" title="树：199. 二叉树的右视图"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-right-side-view/">树：199. 二叉树的右视图</a></h1><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: [1,2,3,null,5,null,4]<br>输出: [1,3,4]<br>示例 2:</p>
<p>输入: [1,null,3]<br>输出: [1,3]<br>示例 3:</p>
<p>输入: []<br>输出: []
 </p>
<p>提示:</p>
<p>二叉树的节点个数的范围是 [0,100]<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100 </p>
<p><img src="https://files.mdnice.com/user/1489/48c2dc78-d14d-4a7d-b5fd-0ca2431b377a.png"></p>
<h2 id="Solution1-层序遍历-1"><a href="#Solution1-层序遍历-1" class="headerlink" title="Solution1 层序遍历"></a>Solution1 层序遍历</h2><p>使用层序遍历，并只保留每层最后一个节点的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; rightmostValueAtDepth;</span><br><span class="line">        int max_depth = -1;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; nodeQueue;</span><br><span class="line">        queue&lt;int&gt; depthQueue;</span><br><span class="line">        nodeQueue.push(root);</span><br><span class="line">        depthQueue.push(0);</span><br><span class="line"></span><br><span class="line">        while (!nodeQueue.empty()) &#123;</span><br><span class="line">            TreeNode* node = nodeQueue.front();nodeQueue.pop();</span><br><span class="line">            int depth = depthQueue.front();depthQueue.pop();</span><br><span class="line"></span><br><span class="line">            if (node != NULL) &#123;</span><br><span class="line">            	// 维护二叉树的最大深度</span><br><span class="line">                max_depth = max(max_depth, depth);</span><br><span class="line"></span><br><span class="line">                // 由于每一层最后一个访问到的节点才是我们要的答案，因此不断更新对应深度的信息即可</span><br><span class="line">                rightmostValueAtDepth[depth] =  node -&gt; val;</span><br><span class="line"></span><br><span class="line">                nodeQueue.push(node -&gt; left);</span><br><span class="line">                nodeQueue.push(node -&gt; right);</span><br><span class="line">                depthQueue.push(depth + 1);</span><br><span class="line">                depthQueue.push(depth + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; rightView;</span><br><span class="line">        for (int depth = 0; depth &lt;= max_depth; ++depth) &#123;</span><br><span class="line">            rightView.push_back(rightmostValueAtDepth[depth]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return rightView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="https://files.mdnice.com/user/1489/fb683879-39db-4823-890b-e02d5deeb48c.png"></p>
<p>这里可以通过维护两个node queue来实现</p>
<h1 id="树：226-翻转二叉树"><a href="#树：226-翻转二叉树" class="headerlink" title="树：226. 翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/invert-binary-tree/">树：226. 翻转二叉树</a></h1><p><img src="https://files.mdnice.com/user/1489/69e49a83-545c-483f-8a37-ec3b834d2e93.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">To invert a binary tree, we swap the left and right subtrees and invert them recursively/iteratively.</span><br></pre></td></tr></table></figure>
<h2 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1"></a>Solution1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">利用前序遍历</span><br><span class="line">class Solution &#123;</span><br><span class="line">        // 先序遍历--从顶向下交换</span><br><span class="line">        public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">            if (root == null) return null;</span><br><span class="line">            // 保存右子树</span><br><span class="line">            TreeNode rightTree = root.right;</span><br><span class="line">            // 交换左右子树的位置</span><br><span class="line">            root.right = invertTree(root.left);</span><br><span class="line">            root.left = invertTree(rightTree);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">利用中序遍历</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">            if (root == null) return null;</span><br><span class="line">            invertTree(root.left); // 递归找到左节点</span><br><span class="line">            TreeNode rightNode= root.right; // 保存右节点</span><br><span class="line">            root.right = root.left;</span><br><span class="line">            root.left = rightNode;</span><br><span class="line">            // 递归找到右节点 继续交换 : 因为此时左右节点已经交换了,所以此时的右节点为root.left</span><br><span class="line">            invertTree(root.left); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">利用后序遍历</span><br><span class="line"> class Solution &#123;</span><br><span class="line">        public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">            // 后序遍历-- 从下向上交换</span><br><span class="line">            if (root == null) return null;</span><br><span class="line">            TreeNode leftNode = invertTree(root.left);</span><br><span class="line">            TreeNode rightNode = invertTree(root.right);</span><br><span class="line">            root.right = leftNode;</span><br><span class="line">            root.left = rightNode;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">利用层次遍历</span><br><span class="line">   class Solution &#123;</span><br><span class="line">        public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">            // 层次遍历--直接左右交换即可</span><br><span class="line">            if (root == null) return null;</span><br><span class="line">            Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">            queue.offer(root);</span><br><span class="line">            while (!queue.isEmpty())&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                TreeNode rightTree = node.right;</span><br><span class="line">                node.right = node.left;</span><br><span class="line">                node.left = rightTree;</span><br><span class="line">                if (node.left != null)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (node.right != null)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h1 id="树：230-二叉搜索树中第K小的元素"><a href="#树：230-二叉搜索树中第K小的元素" class="headerlink" title="树：230. 二叉搜索树中第K小的元素"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">树：230. 二叉搜索树中第K小的元素</a></h1><p>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。</p>
<p><img src="https://files.mdnice.com/user/1489/b09171cd-4ad6-4049-bd68-cb3ac6236510.png"></p>
<h2 id="Solution1-非递归-1"><a href="#Solution1-非递归-1" class="headerlink" title="Solution1  非递归"></a>Solution1  非递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int kthSmallest(TreeNode* root, int k) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        int num=0;</span><br><span class="line">        TreeNode *cur=root;</span><br><span class="line">        while(!s.empty() || cur)</span><br><span class="line">        &#123;</span><br><span class="line">            if(cur)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur=cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                cur=s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                num++;</span><br><span class="line">                if(num==k)</span><br><span class="line">                    return cur-&gt;val;</span><br><span class="line">                cur=cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution2-记录子节点数目"><a href="#Solution2-记录子节点数目" class="headerlink" title="Solution2 记录子节点数目"></a>Solution2 记录子节点数目</h2><p><img src="https://files.mdnice.com/user/1489/e65a5f5c-4e4e-4bb7-857a-f5fd4309020f.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class MyBst &#123;</span><br><span class="line">public:</span><br><span class="line">    MyBst(TreeNode *root) &#123;</span><br><span class="line">        this-&gt;root = root;</span><br><span class="line">        countNodeNum(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回二叉搜索树中第k小的元素</span><br><span class="line">    int kthSmallest(int k) &#123;</span><br><span class="line">        TreeNode *node = root;</span><br><span class="line">        while (node != nullptr) &#123;</span><br><span class="line">            int left = getNodeNum(node-&gt;left);</span><br><span class="line">            if (left &lt; k - 1) &#123;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">                k -= left + 1;</span><br><span class="line">            &#125; else if (left == k - 1) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return node-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    TreeNode *root;</span><br><span class="line">    unordered_map&lt;TreeNode *, int&gt; nodeNum;</span><br><span class="line"></span><br><span class="line">    // 统计以node为根结点的子树的结点数</span><br><span class="line">    int countNodeNum(TreeNode * node) &#123;</span><br><span class="line">        if (node == nullptr) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        nodeNum[node] = 1 + countNodeNum(node-&gt;left) + countNodeNum(node-&gt;right);</span><br><span class="line">        return nodeNum[node];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取以node为根结点的子树的结点数</span><br><span class="line">    int getNodeNum(TreeNode * node) &#123;</span><br><span class="line">        if (node != nullptr &amp;&amp; nodeNum.count(node)) &#123;</span><br><span class="line">            return nodeNum[node];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int kthSmallest(TreeNode* root, int k) &#123;</span><br><span class="line">        MyBst bst(root);</span><br><span class="line">        return bst.kthSmallest(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="树：二叉搜索树的第K大节点"><a href="#树：二叉搜索树的第K大节点" class="headerlink" title="树：二叉搜索树的第K大节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof">树：二叉搜索树的第K大节点</a></h1><p><img src="https://files.mdnice.com/user/1489/815f7215-0047-455e-8cc3-fa211fc82157.jpg"></p>
<h1 id="树：114-二叉树展开为链表"><a href="#树：114-二叉树展开为链表" class="headerlink" title="树：114. 二叉树展开为链表"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/">树：114. 二叉树展开为链表</a></h1><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。
 </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,2,5,3,4,null,6]<br>输出：[1,null,2,null,3,null,4,null,5,null,6]<br>示例 2：</p>
<p>输入：root &#x3D; []<br>输出：[]<br>示例 3：</p>
<p>输入：root &#x3D; [0]<br>输出：[0]
 </p>
<p>提示：</p>
<p>树中结点数在范围 [0, 2000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p>
<p><img src="https://files.mdnice.com/user/1489/eb69f29d-548d-4414-bd1f-27b9944ac200.png"></p>
<p> </p>
<h2 id="Solution1-递归-8"><a href="#Solution1-递归-8" class="headerlink" title="Solution1  递归"></a>Solution1  递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* last = nullptr;</span><br><span class="line">void flatten(TreeNode* root) &#123;</span><br><span class="line">    if (root == nullptr) return;</span><br><span class="line">    flatten(root-&gt;right);</span><br><span class="line">    flatten(root-&gt;left);</span><br><span class="line">    root-&gt;right = last;</span><br><span class="line">    root-&gt;left = nullptr;</span><br><span class="line">    last = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Solution2-迭代-3"><a href="#Solution2-迭代-3" class="headerlink" title="Solution2   迭代"></a>Solution2   迭代</h2><p><img src="https://files.mdnice.com/user/1489/5f3de36e-929d-4f22-adcb-a8070f305409.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        while(root)&#123;</span><br><span class="line">            TreeNode* p = root-&gt;left;</span><br><span class="line">            if(p)&#123;</span><br><span class="line">                while(p-&gt;right) p = p-&gt;right; </span><br><span class="line">                p-&gt;right = root-&gt;right;</span><br><span class="line">                root-&gt;right = root-&gt;left;</span><br><span class="line">                root-&gt;left = nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/two-sum/">1. Two Sum</a></h1><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。<br>示例 2：</p>
<p>输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]<br>示例 3：</p>
<p>输入：nums &#x3D; [3,3], target &#x3D; 6<br>输出：[0,1]
 </p>
<p>提示：</p>
<p>2 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>-109 &lt;&#x3D; target &lt;&#x3D; 109<br>只会存在一个有效答案<br>进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？</p>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>双层遍历</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>哈希表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The basic idea is to maintain a hash table for each element num in nums, </span><br><span class="line">using num as key and its index (0-based) as value. For each num,</span><br><span class="line"> search for target - num in the hash table.</span><br><span class="line"> If it is found and is not the same element as num, then we are done.</span><br><span class="line"></span><br><span class="line">The code is as follows. Note that each time before we add num to mp,</span><br><span class="line"> we search for target - num first and so we will not hit the same element.</span><br></pre></td></tr></table></figure>

<h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/4sum/">18. 四数之和</a></h1><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<p>0 &lt;&#x3D; a, b, c, d &lt; n<br>a、b、c 和 d 互不相同<br>nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target<br>你可以按 任意顺序 返回答案 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0<br>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]<br>示例 2：</p>
<p>输入：nums &#x3D; [2,2,2,2,2], target &#x3D; 8<br>输出：[[2,2,2,2]]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>-109 &lt;&#x3D; target &lt;&#x3D; 109</p>
<h2 id="Solution-1-暴力枚举"><a href="#Solution-1-暴力枚举" class="headerlink" title="Solution 1  暴力枚举"></a>Solution 1  暴力枚举</h2><h2 id="Solution-2-双指针法"><a href="#Solution-2-双指针法" class="headerlink" title="Solution 2  双指针法"></a>Solution 2  双指针法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The two pointers pattern requires the array to be sorted, so we do that first. Also, it&#x27;s easier to deal with duplicates if the array is sorted: repeated values are next to each other and easy to skip.</span><br><span class="line"></span><br><span class="line">For 3Sum, we enumerate each value in a single loop, and use the two pointers pattern for the rest of the array. For kSum, we will have k - 2 nested loops to enumerate all combinations of k - 2 values.</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="https://files.mdnice.com/user/1489/1ab57d58-3c53-4974-885c-d0b997487df7.png"></p>
<p><img src="https://files.mdnice.com/user/1489/9abc4082-7aba-4bf2-95ab-8151841c8777.png"></p>
<p><img src="https://files.mdnice.com/user/1489/dbda7684-ec6b-4517-89ef-8415d7f95a32.png"></p>
<p><img src="https://files.mdnice.com/user/1489/5cd09d98-bd6d-413f-a699-5d03755f5802.png"></p>
<h1 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-nth-node-from-end-of-list">19. 删除链表的倒数第 N 个结点</a></h1><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>输出：[1,2,3,5]<br>示例 2：</p>
<p>输入：head &#x3D; [1], n &#x3D; 1<br>输出：[]<br>示例 3：</p>
<p>输入：head &#x3D; [1,2], n &#x3D; 1<br>输出：[1]
 </p>
<p>提示：</p>
<p>链表中结点的数目为 sz<br>1 &lt;&#x3D; sz &lt;&#x3D; 30<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>1 &lt;&#x3D; n &lt;&#x3D; sz</p>
<p><img src="https://files.mdnice.com/user/1489/66e5f430-7a71-4480-8d2b-930a4ea9a2df.png"></p>
<p> </p>
<h2 id="Solution1-计算链表长度"><a href="#Solution1-计算链表长度" class="headerlink" title="Solution1 计算链表长度"></a>Solution1 计算链表长度</h2><p><img src="https://files.mdnice.com/user/1489/5bfffdd4-470d-482c-849d-e4e82e2b40d8.png"></p>
<h2 id="Solution2-栈"><a href="#Solution2-栈" class="headerlink" title="Solution2 栈"></a>Solution2 栈</h2><p><img src="https://files.mdnice.com/user/1489/f6e5ea9e-b6b4-4545-97c5-2ef86e5fbd08.png"></p>
<p><img src="https://files.mdnice.com/user/1489/b3fb36fb-92e9-417d-9c00-60756ed04c17.png"></p>
<h2 id="Solution3-快慢指针-1"><a href="#Solution3-快慢指针-1" class="headerlink" title="Solution3 快慢指针"></a>Solution3 快慢指针</h2><p><img src="https://files.mdnice.com/user/1489/1d658e59-2c76-4ade-a9c5-39a2ff20161f.png"></p>
<p><img src="https://files.mdnice.com/user/1489/7fc31992-dc5b-4e11-bb5e-7c61942e6e57.png"></p>
<h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-parentheses/">20. 有效的括号</a></h1><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。
 </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “()”<br>输出：true<br>示例 2：</p>
<p>输入：s &#x3D; “()[]{}”<br>输出：true<br>示例 3：</p>
<p>输入：s &#x3D; “(]”<br>输出：false<br>示例 4：</p>
<p>输入：s &#x3D; “([)]”<br>输出：false<br>示例 5：</p>
<p>输入：s &#x3D; “{[]}”<br>输出：true</p>
<h2 id="Solution1-栈"><a href="#Solution1-栈" class="headerlink" title="Solution1 栈"></a>Solution1 栈</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValid(string s) &#123;</span><br><span class="line">        stack&lt;char&gt; st;  //taking stack for keep tracking the order of the brackets..</span><br><span class="line">        for(auto i:s)  //iterate over each and every elements</span><br><span class="line">        &#123;</span><br><span class="line">            if(i==&#x27;(&#x27; or i==&#x27;&#123;&#x27; or i==&#x27;[&#x27;) st.push(i);  //if current element of the string will be opening bracket then we will just simply push it into the stack</span><br><span class="line">            else  //if control comes to else part, it means that current element is a closing bracket, so check two conditions  current element matches with top of the stack and the stack must not be empty...</span><br><span class="line">            &#123;</span><br><span class="line">                if(st.empty() or (st.top()==&#x27;(&#x27; and i!=&#x27;)&#x27;) or (st.top()==&#x27;&#123;&#x27; and i!=&#x27;&#125;&#x27;) or (st.top()==&#x27;[&#x27; and i!=&#x27;]&#x27;)) return false;</span><br><span class="line">                st.pop();  //if control reaches to that line, it means we have got the right pair of brackets, so just pop it.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return st.empty();  //at last, it may possible that we left something into the stack unpair so return checking stack is empty or not..</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://files.mdnice.com/user/1489/4097f955-844e-4ceb-a4c1-513342bc6e37.png"></p>
<h1 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h1><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p>
<p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p>
<p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p>
<p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>判题标准:</p>
<p>系统会用下面的代码来测试你的题解:</p>
<p>int[] nums &#x3D; […]; &#x2F;&#x2F; 输入数组<br>int[] expectedNums &#x3D; […]; &#x2F;&#x2F; 长度正确的期望答案</p>
<p>int k &#x3D; removeDuplicates(nums); &#x2F;&#x2F; 调用</p>
<p>assert k &#x3D;&#x3D; expectedNums.length;<br>for (int i &#x3D; 0; i &lt; k; i++) {<br>    assert nums[i] &#x3D;&#x3D; expectedNums[i];<br>}<br>如果所有断言都通过，那么您的题解将被 通过。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,1,2]<br>输出：2, nums &#x3D; [1,2,_]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。<br>示例 2：</p>
<p>输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums &#x3D; [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>nums 已按 升序 排列</p>
<h2 id="Solution1-暴力-9"><a href="#Solution1-暴力-9" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-双指针"><a href="#Solution2-双指针" class="headerlink" title="Solution2 双指针"></a>Solution2 双指针</h2><p><img src="https://files.mdnice.com/user/1489/4bab35d7-99bc-45ab-9bc4-cccdbe223a0c.png"></p>
<p><img src="https://files.mdnice.com/user/1489/731a9af6-7a21-42e7-9a1b-f4b2d9cfddba.png"></p>
<p><img src="https://files.mdnice.com/user/1489/97cb5a3b-6aaa-4be9-9b17-dde9d86f17ab.png"></p>
<h2 id="Solution3-双指针-优化"><a href="#Solution3-双指针-优化" class="headerlink" title="Solution3 双指针 优化"></a>Solution3 双指针 优化</h2><p><img src="https://files.mdnice.com/user/1489/80714af6-4b56-4b6d-965a-6d0e396c1b63.png"></p>
<h1 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/next-permutation/">31. 下一个排列</a></h1><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p>
<p>例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<p>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。</p>
<p>必须 原地 修改，只允许使用额外常数空间。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3]<br>输出：[1,3,2]<br>示例 2：</p>
<p>输入：nums &#x3D; [3,2,1]<br>输出：[1,2,3]<br>示例 3：</p>
<p>输入：nums &#x3D; [1,1,5]<br>输出：[1,5,1]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p>
<h2 id="Solution1-暴力-10"><a href="#Solution1-暴力-10" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><p><img src="https://files.mdnice.com/user/1489/6225fcf0-251b-4649-92fa-65307499a714.png"></p>
<h2 id="Solution2-2"><a href="#Solution2-2" class="headerlink" title="Solution2"></a>Solution2</h2><p><img src="https://files.mdnice.com/user/1489/3b831fba-7be3-423c-87d3-d1f5f499cd9c.png"></p>
<p><img src="https://files.mdnice.com/user/1489/7e984502-8307-4144-85fa-134adc4a304f.png"></p>
<p><img src="https://files.mdnice.com/user/1489/997007a2-0e00-49d3-88fc-6865a7578af8.png"></p>
<h1 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotate-image/">48. 旋转图像</a></h1><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[[7,4,1],[8,5,2],[9,6,3]]<br>示例 2：</p>
<p>输入：matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]<br>输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
 </p>
<p>提示：</p>
<p>n &#x3D;&#x3D; matrix.length &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; n &lt;&#x3D; 20<br>-1000 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 1000
 </p>
<h2 id="Solution1-原地查找"><a href="#Solution1-原地查找" class="headerlink" title="Solution1 原地查找"></a>Solution1 原地查找</h2><p><img src="https://files.mdnice.com/user/1489/21a7a3a3-e652-45a8-99cb-f56b22227301.png"></p>
<h2 id="Solution2-先转置再竖直对称反转"><a href="#Solution2-先转置再竖直对称反转" class="headerlink" title="Solution2 先转置再竖直对称反转"></a>Solution2 先转置再竖直对称反转</h2><p><img src="https://files.mdnice.com/user/1489/bd454bbc-41fb-4383-8f76-57b770d4b60d.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        //先转置</span><br><span class="line">        for(int row=0;row&lt;=matrix.size()-1;row++)&#123;</span><br><span class="line"></span><br><span class="line">            for(int col=row;col&lt;=matrix[0].size()-1;col++)&#123;</span><br><span class="line">                swap(matrix[row][col],matrix[col][row]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //在竖直对称翻转</span><br><span class="line">        for(int row=0;row&lt;=matrix.size()-1;row++)&#123;</span><br><span class="line">            for(int col = 0;col&lt;=(matrix.size()-1)/2;col++)&#123;</span><br><span class="line">                swap(matrix[row][col],matrix[row][matrix.size()-1-col]);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/group-anagrams/">49. 字母异位词分组</a></h1><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p>
<p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: strs &#x3D; [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]<br>示例 2:</p>
<p>输入: strs &#x3D; [“”]<br>输出: [[“”]]<br>示例 3:</p>
<p>输入: strs &#x3D; [“a”]<br>输出: [[“a”]]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; strs.length &lt;&#x3D; 104<br>0 &lt;&#x3D; strs[i].length &lt;&#x3D; 100<br>strs[i] 仅包含小写字母</p>
<h2 id="Solution1-Map"><a href="#Solution1-Map" class="headerlink" title="Solution1 Map"></a>Solution1 Map</h2><p>Use an unordered_map to group the strings by their sorted counterparts. Use the sorted string as the key and all anagram strings as the value.</p>
<p>Moreover, since the string only contains lower-case alphabets, we can sort them using counting sort to improve the time complexity.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        </span><br><span class="line">        map&lt;string,vector&lt;string&gt;&gt;res;</span><br><span class="line">        //遍历 </span><br><span class="line">        for(auto val:strs)&#123;</span><br><span class="line">            string tmp=val;</span><br><span class="line">               //以排序后的str作为key  vector&lt;string&gt;作为value 放进map</span><br><span class="line">            sort(val.begin(),val.end());</span><br><span class="line">            if(res.find(val)==res.end())&#123;</span><br><span class="line">                vector&lt;string&gt; t=&#123;tmp&#125;;</span><br><span class="line">                res.insert(&#123;val,t&#125;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res[val].push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历输出结果</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">        for(auto p:res)&#123;</span><br><span class="line">            result.push_back(p.second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/spiral-matrix/">54. 螺旋矩阵</a></h1><p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br>示例 2：</p>
<p>输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]
 </p>
<p>提示：</p>
<p>m &#x3D;&#x3D; matrix.length<br>n &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 10<br>-100 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 100</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spiral-matrix</span><br><span class="line"></span><br><span class="line">Algorithm:</span><br><span class="line"></span><br><span class="line">First we will iterate in to first row from left to right push back all the elements into a vector. After iterating, we change the top to second row (top++).</span><br><span class="line">Then we will iterate from new top to bottom and push back only right most elements of each row. After iterating, we change the right to second last column (right--).</span><br><span class="line">Then we will iterate in bottom row from right to left and pushback all the elements from new right to left. After iterating, we change the bottom to second last row (bottom--).</span><br><span class="line">Then we will iterate from new bottom to new top and push back only left most element. After iterating, we change the left to second column (left++).</span><br><span class="line">Repeat all these steps until left = right and top = bottom.</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-原地遍历"><a href="#Solution1-原地遍历" class="headerlink" title="Solution1 原地遍历"></a>Solution1 原地遍历</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">          if(matrix.empty())&#123;return res;&#125;</span><br><span class="line">        int s=0,x=matrix.size()-1,z=0,y=matrix[0].size()-1;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">        while(true)&#123;</span><br><span class="line">            //在上边沿</span><br><span class="line">            for(int i=s,j=z;j&lt;=y;j++)&#123;</span><br><span class="line">                res.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(++s&gt;x)   break;</span><br><span class="line">            //在右边沿</span><br><span class="line">            for(int i=s,j=y;i&lt;=x;i++)&#123;</span><br><span class="line">                  res.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(--y&lt;z) break;</span><br><span class="line">            //在下边沿</span><br><span class="line">           for(int i=x,j=y;j&gt;=z;j--)&#123;</span><br><span class="line">                  res.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(--x&lt;s) break;</span><br><span class="line">            //在左边沿</span><br><span class="line">           for(int i=x,j=z;i&gt;=s;i--)&#123;</span><br><span class="line">                  res.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(++z&gt;y) break;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-按层遍历"><a href="#Solution2-按层遍历" class="headerlink" title="Solution2 按层遍历"></a>Solution2 按层遍历</h2><p><img src="https://files.mdnice.com/user/1489/6fc73b94-e500-4182-a9f9-e1d8a4e29a32.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        if (matrix.size() == 0 || matrix[0].size() == 0) &#123;</span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int rows = matrix.size(), columns = matrix[0].size();</span><br><span class="line">        vector&lt;int&gt; order;</span><br><span class="line">        int left = 0, right = columns - 1, top = 0, bottom = rows - 1;</span><br><span class="line">        while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">            for (int column = left; column &lt;= right; column++) &#123;</span><br><span class="line">                order.push_back(matrix[top][column]);</span><br><span class="line">            &#125;</span><br><span class="line">            for (int row = top + 1; row &lt;= bottom; row++) &#123;</span><br><span class="line">                order.push_back(matrix[row][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            if (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">                for (int column = right - 1; column &gt; left; column--) &#123;</span><br><span class="line">                    order.push_back(matrix[bottom][column]);</span><br><span class="line">                &#125;</span><br><span class="line">                for (int row = bottom; row &gt; top; row--) &#123;</span><br><span class="line">                    order.push_back(matrix[row][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        return order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-intervals/">56. 合并区间</a></h1><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<br>示例 2：</p>
<p>输入：intervals &#x3D; [[1,4],[4,5]]<br>输出：[[1,5]]<br>解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; intervals.length &lt;&#x3D; 104<br>intervals[i].length &#x3D;&#x3D; 2<br>0 &lt;&#x3D; starti &lt;&#x3D; endi &lt;&#x3D; 104</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">nitially sort the array and then push the first element into the answer for speculation.</span><br><span class="line">We have two condition if the first elements second part of ans array is greater than or equal to the second element first part of the </span><br><span class="line">interval array.</span><br><span class="line">The other condition we have to tackle is what if its not? then we push the particular element into the ans array which will be then be under speculation.</span><br><span class="line">interval: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">             i</span><br><span class="line">We initally push the 1st element into the ans array:</span><br><span class="line">ans=[[1,3]]</span><br><span class="line">      j        j points to the latest pushed element</span><br><span class="line">Then we i is incremented.</span><br><span class="line">[[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">         i</span><br><span class="line">Now the ans[j][1]&gt;interval[i][0] this means there is a possiblity of merging so we merger them</span><br><span class="line">Remember the way we merge is to take the second element as max(ans[j][1],interval[i][1])</span><br><span class="line">cuz imagine we have this</span><br><span class="line">[1,7][2,4] ---&gt;merge should be ----&gt;[1,7]</span><br><span class="line"></span><br><span class="line">ans=[[1,6]]</span><br><span class="line"></span><br><span class="line">then we move i forward</span><br><span class="line"></span><br><span class="line">[[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">               i</span><br><span class="line">Since ans[j][1]&lt;interval[i][0] thus not contributing to the merge.</span><br><span class="line">Thus we will push this into the ans array and speculate.</span><br><span class="line"></span><br><span class="line">ans=[[1,6][8,10]]</span><br><span class="line">            j   &lt;----j is moved forward</span><br><span class="line">i is moved forward </span><br><span class="line">[[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">                       i</span><br><span class="line">Since ans[j][1]&lt;interval[i][0] thus not contributing to the merge.</span><br><span class="line">ans=[[1,6][8,10][15,18]]</span><br><span class="line">                  j</span><br><span class="line"></span><br><span class="line">Thus yielding our final answer.</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; interval) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        if(interval.size()==0)return ans;</span><br><span class="line">        sort(interval.begin(),interval.end());</span><br><span class="line">        ans.push_back(interval[0]);</span><br><span class="line">        int j=0;</span><br><span class="line">        for(int i=1;i&lt;interval.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(ans[j][1]&gt;=interval[i][0])</span><br><span class="line">                ans[j][1]=max(ans[j][1],interval[i][1]);</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">                ans.push_back(interval[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-排序-1"><a href="#Solution1-排序-1" class="headerlink" title="Solution1 排序"></a>Solution1 排序</h2><p><img src="https://files.mdnice.com/user/1489/e8db6a23-fe74-4f65-b6a6-6cafbddff0bc.png"></p>
<p>复杂度分析</p>
<p>时间复杂度：O(n\log n)O(nlogn)，其中 nn 为区间的数量。除去排序的开销，我们只需要一次线性扫描，所以主要的时间开销是排序的 O(n\log n)O(nlogn)。</p>
<p>空间复杂度：O(\log n)O(logn)，其中 nn 为区间的数量。这里计算的是存储答案之外，使用的额外空间。O(\log n)O(logn) 即为排序所需要的空间复杂度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        if (intervals.size() == 0) &#123;</span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(intervals.begin(), intervals.end());</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; merged;</span><br><span class="line">        for (int i = 0; i &lt; intervals.size(); ++i) &#123;</span><br><span class="line">            int L = intervals[i][0], R = intervals[i][1];</span><br><span class="line">            if (!merged.size() || merged.back()[1] &lt; L) &#123;</span><br><span class="line">                merged.push_back(&#123;L, R&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                merged.back()[1] = max(merged.back()[1], R);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotate-list/">61. 旋转链表</a></h1><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2<br>输出：[4,5,1,2,3]<br>示例 2：</p>
<p>输入：head &#x3D; [0,1,2], k &#x3D; 4<br>输出：[2,0,1]
 </p>
<p>提示：</p>
<p>链表中节点的数目在范围 [0, 500] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>0 &lt;&#x3D; k &lt;&#x3D; 2 * 109</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">There is no trick for this problem. Some people used slow/fast pointers to find the tail node but I don&#x27;t see the benefit (in the sense that it doesn&#x27;t reduce the pointer move op) to do so. So I just used one loop to find the length first.</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* rotateRight(ListNode* head, int k) &#123;</span><br><span class="line">        if(!head) return head;</span><br><span class="line">        </span><br><span class="line">        int len=1; // number of nodes</span><br><span class="line">        ListNode *newH, *tail;</span><br><span class="line">        newH=tail=head;</span><br><span class="line">        </span><br><span class="line">        while(tail-&gt;next)  // get the number of nodes in the list</span><br><span class="line">        &#123;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;next = head; // circle the link</span><br><span class="line"></span><br><span class="line">        if(k %= len) </span><br><span class="line">        &#123;</span><br><span class="line">            for(auto i=0; i&lt;len-k; i++) tail = tail-&gt;next; // the tail node is the (len-k)-th node (1st node is head)</span><br><span class="line">        &#125;</span><br><span class="line">        newH = tail-&gt;next; </span><br><span class="line">        tail-&gt;next = NULL;</span><br><span class="line">        return newH;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-暴力-11"><a href="#Solution1-暴力-11" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Soluion2-闭环"><a href="#Soluion2-闭环" class="headerlink" title="Soluion2  闭环"></a>Soluion2  闭环</h2><p><img src="https://files.mdnice.com/user/1489/319c806f-a568-403a-9a39-c4ac50f30308.png"></p>
<h1 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/plus-one/">66. 加一</a></h1><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：digits &#x3D; [1,2,3]<br>输出：[1,2,4]<br>解释：输入数组表示数字 123。<br>示例 2：</p>
<p>输入：digits &#x3D; [4,3,2,1]<br>输出：[4,3,2,2]<br>解释：输入数组表示数字 4321。<br>示例 3：</p>
<p>输入：digits &#x3D; [0]<br>输出：[1]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; digits.length &lt;&#x3D; 100<br>0 &lt;&#x3D; digits[i] &lt;&#x3D; 9</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">My solution is nothing special and isn&#x27;t clever at all. I decided to post it since I thought the &quot;official&quot; solution article from leetcode was very poorly written and confused me more, even after I solved it on my own.</span><br><span class="line"></span><br><span class="line">So, I believe my comments below should explain the idea, but I want to add that it helps to test the more obscure test cases for this problem to understand the algorithm. For example:</span><br><span class="line"></span><br><span class="line">[9]</span><br><span class="line">[9090]</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123;</span><br><span class="line">      int n = digits.size() - 1;</span><br><span class="line">      </span><br><span class="line">      for (int i = n; i &gt;= 0; --i) &#123; // traverse digits from the last element (least significant)</span><br><span class="line">        // since we begin with the last digit, increasing that digit by one</span><br><span class="line">        // results in overflow.  Therefore, all elements PRIOR to digits[0]</span><br><span class="line">        // need to be considered since there may be additional nines between</span><br><span class="line">        // digits[0], ... , digits[n].</span><br><span class="line">        if (digits[i] == 9) &#123;  </span><br><span class="line">          digits[i] = 0;</span><br><span class="line">        &#125; else &#123;  // current digit is not 9 so we can safely increment by one</span><br><span class="line">          digits[i] += 1;</span><br><span class="line">          return digits;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // if the program runs to this point, each 9 is now a 0.</span><br><span class="line">      // to get a correct solution, we need to add one more element with </span><br><span class="line">      // a value of zero AND set digits[0] to 1 (in the most significant position)</span><br><span class="line">      // to account for the carry digit.</span><br><span class="line">      digits.push_back(0);</span><br><span class="line">      digits[0] = 1;</span><br><span class="line">      return digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-0-暴力"><a href="#Solution-0-暴力" class="headerlink" title="Solution 0  暴力"></a>Solution 0  暴力</h2><h2 id="Solution-1-逆序遍历-找到9"><a href="#Solution-1-逆序遍历-找到9" class="headerlink" title="Solution 1 逆序遍历 找到9"></a>Solution 1 逆序遍历 找到9</h2><p><img src="https://files.mdnice.com/user/1489/846120fb-5574-4fde-bd23-c798e938fa6e.png"></p>
<h1 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sort-colors/">75. 颜色分类</a></h1><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>必须在不使用库的sort函数的情况下解决这个问题。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [2,0,2,1,1,0]<br>输出：[0,0,1,1,2,2]<br>示例 2：</p>
<p>输入：nums &#x3D; [2,0,1]<br>输出：[0,1,2]
 </p>
<p>提示：</p>
<p>n &#x3D;&#x3D; nums.length<br>1 &lt;&#x3D; n &lt;&#x3D; 300<br>nums[i] 为 0、1 或 2
 </p>
<p>进阶：</p>
<p>你可以不使用代码库中的排序函数来解决这道题吗？<br>你能想出一个仅使用常数空间的一趟扫描算法吗？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">The solution requires the use of tracking 3 positions, the Low, Mid and High.</span><br><span class="line"></span><br><span class="line">We assume that the mid is the &quot;Unknown&quot; area that we must evaluate.</span><br><span class="line"></span><br><span class="line">If we encounter a 0, we know that it will be on the low end of the array, and if we encounter a 2, we know it will be on the high end of the array.</span><br><span class="line"></span><br><span class="line">To achieve this in one pass without preprocessing (counting), we simply traverse the unknown will generating the low and high ends.</span><br><span class="line"></span><br><span class="line">Take this example:</span><br><span class="line"></span><br><span class="line">Assume our input is: 1 0 2 2 1 0 (short for simplicity).</span><br><span class="line"></span><br><span class="line">Running the algorithm by hand would look something like:</span><br><span class="line"></span><br><span class="line">    1 0 2 2 1 0</span><br><span class="line">    ^         ^</span><br><span class="line">    L         H</span><br><span class="line">    M</span><br><span class="line"></span><br><span class="line">    Mid != 0 || 2</span><br><span class="line">    Mid++</span><br><span class="line"></span><br><span class="line">    1 0 2 2 1 0</span><br><span class="line">    ^ ^       ^</span><br><span class="line">    L M       H</span><br><span class="line"></span><br><span class="line">    Mid == 0</span><br><span class="line">    Swap Low and Mid</span><br><span class="line">    Mid++</span><br><span class="line">    Low++</span><br><span class="line"></span><br><span class="line">    0 1 2 2 1 0</span><br><span class="line">      ^ ^     ^</span><br><span class="line">      L M     H</span><br><span class="line"></span><br><span class="line">    Mid == 2</span><br><span class="line">    Swap High and Mid</span><br><span class="line">    High--</span><br><span class="line"></span><br><span class="line">    0 1 0 2 1 2</span><br><span class="line">      ^ ^   ^</span><br><span class="line">      L M   H</span><br><span class="line"></span><br><span class="line">    Mid == 0</span><br><span class="line">    Swap Low and Mid</span><br><span class="line">    Mid++</span><br><span class="line">    Low++</span><br><span class="line"></span><br><span class="line">    0 0 1 2 1 2</span><br><span class="line">        ^ ^ ^</span><br><span class="line">        L M H</span><br><span class="line"></span><br><span class="line">    Mid == 2</span><br><span class="line">    Swap High and Mid</span><br><span class="line">    High--</span><br><span class="line"></span><br><span class="line">    0 0 1 1 2 2</span><br><span class="line">        ^ ^</span><br><span class="line">        L M</span><br><span class="line">          H</span><br><span class="line"></span><br><span class="line">    Mid &lt;= High is our exit case</span><br></pre></td></tr></table></figure>
<h2 id="Solution1-暴力-12"><a href="#Solution1-暴力-12" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><p>根据题目中的提示，我们可以统计出数组中 0, 1, 20,1,2 的个数，再根据它们的数量，重写整个数组。这种方法较为简单，也很容易想到，而本题解中会介绍两种基于指针进行交换的方法。</p>
<h2 id="Solution2-单指针"><a href="#Solution2-单指针" class="headerlink" title="Solution2 单指针"></a>Solution2 单指针</h2><p>我们可以考虑对数组进行两次遍历。在第一次遍历中，我们将数组中所有的 00 交换到数组的头部。在第二次遍历中，我们将数组中所有的 11 交换到头部的 00 之后。此时，所有的 22 都出现在数组的尾部，这样我们就完成了排序。</p>
<p>具体地，我们使用一个指针 \textit{ptr}ptr 表示「头部」的范围，\textit{ptr}ptr 中存储了一个整数，表示数组 \textit{nums}nums 从位置 00 到位置 \textit{ptr}-1ptr−1 都属于「头部」。\textit{ptr}ptr 的初始值为 00，表示还没有数处于「头部」。</p>
<p>在第一次遍历中，我们从左向右遍历整个数组，如果找到了 00，那么就需要将 00 与「头部」位置的元素进行交换，并将「头部」向后扩充一个位置。在遍历结束之后，所有的 00 都被交换到「头部」的范围，并且「头部」只包含 00。</p>
<p>在第二次遍历中，我们从「头部」开始，从左向右遍历整个数组，如果找到了 11，那么就需要将 11 与「头部」位置的元素进行交换，并将「头部」向后扩充一个位置。在遍历结束之后，所有的 11 都被交换到「头部」的范围，并且都在 00 之后，此时 22 只出现在「头部」之外的位置，因此排序完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void sortColors(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int ptr = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (nums[i] == 0) &#123;</span><br><span class="line">                swap(nums[i], nums[ptr]);</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = ptr; i &lt; n; ++i) &#123;</span><br><span class="line">            if (nums[i] == 1) &#123;</span><br><span class="line">                swap(nums[i], nums[ptr]);</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution3-双指针"><a href="#Solution3-双指针" class="headerlink" title="Solution3 双指针"></a>Solution3 双指针</h2><p><img src="https://files.mdnice.com/user/1489/d99bbb87-979c-426b-b6e5-647acf2cad20.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void sortColors(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int p0 = 0, p2 = n - 1;</span><br><span class="line">        for (int i = 0; i &lt;= p2; ++i) &#123;</span><br><span class="line">            while (i &lt;= p2 &amp;&amp; nums[i] == 2) &#123;</span><br><span class="line">                swap(nums[i], nums[p2]);</span><br><span class="line">                --p2;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums[i] == 0) &#123;</span><br><span class="line">                swap(nums[i], nums[p0]);</span><br><span class="line">                ++p0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h1><p>给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,1,2]<br>输出：[1,2]<br>示例 2：</p>
<p>输入：head &#x3D; [1,1,2,3,3]<br>输出：[1,2,3]
 </p>
<p>提示：</p>
<p>链表中节点数目在范围 [0, 300] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>题目数据保证链表已经按升序 排列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> noticed that the solutions posted here are too long and complicated. They use unnecessary variables and/or checks etc.</span><br><span class="line">The solution can be much more concise. Here is my solution:</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *deleteDuplicates(ListNode *head) &#123;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        while (cur) &#123;</span><br><span class="line">            while (cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val)</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Note about freeing memory. We need to free memory when we delete a node. But don&#x27;t use delete node; construct on an interview without discussing it with the interviewer. A list node can be allocated in many different ways and we can use delete node; only if we are sure that the nodes were allocated with new TreeNode(...);.</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-一次遍历"><a href="#Solution1-一次遍历" class="headerlink" title="Solution1 一次遍历"></a>Solution1 一次遍历</h2><p>方法一：一次遍历<br>思路与算法</p>
<p>由于给定的链表是排好序的，因此重复的元素在链表中出现的位置是连续的，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。</p>
<p>具体地，我们从指针 \textit{cur}cur 指向链表的头节点，随后开始对链表进行遍历。如果当前 \textit{cur}cur 与 \textit{cur.next}cur.next 对应的元素相同，那么我们就将 \textit{cur.next}cur.next 从链表中移除；否则说明链表中已经不存在其它与 \textit{cur}cur 对应的元素相同的节点，因此可以将 \textit{cur}cur 指向 \textit{cur.next}cur.next。</p>
<p>当遍历完整个链表之后，我们返回链表的头节点即可。</p>
<p>细节</p>
<p>当我们遍历到链表的最后一个节点时，\textit{cur.next}cur.next 为空节点，如果不加以判断，访问 \textit{cur.next}cur.next 对应的元素会产生运行错误。因此我们只需要遍历到链表的最后一个节点，而不需要遍历完整个链表。</p>
<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 是链表的长度。</p>
<p>空间复杂度：O(1)O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">        if (!head) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        while (cur-&gt;next) &#123;</span><br><span class="line">            if (cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/partition-list/">86. 分隔链表</a></h1><p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p>
<p>你应当 保留 两个分区中每个节点的初始相对位置。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,4,3,2,5,2], x &#x3D; 3<br>输出：[1,2,2,4,3,5]<br>示例 2：</p>
<p>输入：head &#x3D; [2,1], x &#x3D; 2<br>输出：[1,2]
 </p>
<p>提示：</p>
<p>链表中节点的数目在范围 [0, 200] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>-200 &lt;&#x3D; x &lt;&#x3D; 200</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Approach 1: Two Pointer Approach</span><br><span class="line">Intuition</span><br><span class="line"></span><br><span class="line">We can take two pointers before and after to keep track of the two linked lists as described above. These two pointers could be used two create two separate lists and then these lists could be combined to form the desired reformed list.</span><br><span class="line"></span><br><span class="line">Algorithm</span><br><span class="line"></span><br><span class="line">Initialize two pointers before and after. In the implementation we have initialized these two with a dummy ListNode. This helps to reduce the number of conditional checks we would need otherwise. You can try an implementation where you don&#x27;t initialize with a dummy node and see it yourself!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dummy Node Initialization</span><br><span class="line"></span><br><span class="line">Iterate the original linked list, using the head pointer.</span><br><span class="line"></span><br><span class="line">If the node&#x27;s value pointed by head is lesser than x, the node should be part of the before list. So we move it to before list.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Else, the node should be part of after list. So we move it to after list.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Once we are done with all the nodes in the original linked list, we would have two list before and after. The original list nodes are either part of before list or after list, depending on its value.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Note: Since we traverse the original linked list from left to right, at no point would the order of nodes change relatively in the two lists. Another important thing to note here is that we show the original linked list intact in the above diagrams. However, in the implementation, we remove the nodes from the original linked list and attach them in the before or after list. We don&#x27;t utilize any additional space. We simply move the nodes from the original list around.</span><br><span class="line"></span><br><span class="line">Now, these two lists before and after can be combined to form the reformed list.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">We did a dummy node initialization at the start to make implementation easier, you don&#x27;t want that to be part of the returned list, hence just move ahead one node in both the lists while combining the two list. Since both before and after have an extra node at the front.</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-双指针"><a href="#Solution1-双指针" class="headerlink" title="Solution1  双指针"></a>Solution1  双指针</h2><p><img src="https://files.mdnice.com/user/1489/1a1aae99-5b02-4641-9e50-5bd0913d1e4d.png"></p>
<h1 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-sorted-array/">88. 合并两个有序数组</a></h1><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>
<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>
<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3<br>输出：[1,2,2,3,5,6]<br>解释：需要合并 [1,2,3] 和 [2,5,6] 。<br>合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。<br>示例 2：</p>
<p>输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0<br>输出：[1]<br>解释：需要合并 [1] 和 [] 。<br>合并结果是 [1] 。<br>示例 3：</p>
<p>输入：nums1 &#x3D; [0], m &#x3D; 0, nums2 &#x3D; [1], n &#x3D; 1<br>输出：[1]<br>解释：需要合并的数组是 [] 和 [1] 。<br>合并结果是 [1] 。<br>注意，因为 m &#x3D; 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。
 </p>
<p>提示：</p>
<p>nums1.length &#x3D;&#x3D; m + n<br>nums2.length &#x3D;&#x3D; n<br>0 &lt;&#x3D; m, n &lt;&#x3D; 200<br>1 &lt;&#x3D; m + n &lt;&#x3D; 200<br>-109 &lt;&#x3D; nums1[i], nums2[j] &lt;&#x3D; 109
 </p>
<p>进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？</p>
<p>This code relies on the simple observation that once all of the numbers from nums2 have been merged into nums1, the rest of the numbers in nums1 that were not moved are already in the correct place.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">The way to think about the solution is that we will have to do a reverse sorting.</span><br><span class="line">We initialize k=m+n-1 as that will be the last location of nums1.</span><br><span class="line">We will keep checking for the greater element of the two arrays(i=m-1,j=n-1) and insert the values.</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">nums1 = [1,2,3,0,0,0]</span><br><span class="line">             |     |</span><br><span class="line">             i     k</span><br><span class="line"></span><br><span class="line">nums2 = [2,5,6]</span><br><span class="line">             |</span><br><span class="line">             j</span><br><span class="line">nums2[j]&gt;nums1[i] thus nums1[k]=6</span><br><span class="line">k and j are decremented.</span><br><span class="line"></span><br><span class="line">nums1 = [1,2,3,0,0,6]</span><br><span class="line">             |     |</span><br><span class="line">             i     k</span><br><span class="line"></span><br><span class="line">nums2 = [2,5,6]</span><br><span class="line">           |</span><br><span class="line">           j</span><br><span class="line">nums2[j]&gt;nums1[i] thus nums1[k]=5</span><br><span class="line">k and j are decremented.</span><br><span class="line"></span><br><span class="line">nums1 = [1,2,3,0,5,6]</span><br><span class="line">             |   |</span><br><span class="line">             i   k</span><br><span class="line"></span><br><span class="line">nums2 = [2,5,6]</span><br><span class="line">         |</span><br><span class="line">         j</span><br><span class="line">We keep following up this procedure and we get the desired reult.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        int i=m-1,j=n-1,k=m+n-1;</span><br><span class="line">        while(i&gt;=0&amp;&amp;j&gt;=0)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums1[i]&gt;nums2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                nums1[k]=nums1[i];</span><br><span class="line">                i--;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                nums1[k]=nums2[j];</span><br><span class="line">                j--;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(i&gt;=0)</span><br><span class="line">            nums1[k--]=nums1[i--];</span><br><span class="line">        while(j&gt;=0)</span><br><span class="line">            nums1[k--]=nums2[j--];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution1-暴力直接合并后排序"><a href="#Solution1-暴力直接合并后排序" class="headerlink" title="Solution1 暴力直接合并后排序"></a>Solution1 暴力直接合并后排序</h2><p><img src="https://files.mdnice.com/user/1489/8aeff7af-53ed-467e-aebc-7835db5b52f5.png"></p>
<h2 id="Solution2-双指针-1"><a href="#Solution2-双指针-1" class="headerlink" title="Solution2 双指针"></a>Solution2 双指针</h2><p><img src="https://files.mdnice.com/user/1489/5be86979-df7c-4994-a29c-088dc60e24e6.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        int p1 = 0, p2 = 0;</span><br><span class="line">        int sorted[m + n];</span><br><span class="line">        int cur;</span><br><span class="line">        while (p1 &lt; m || p2 &lt; n) &#123;</span><br><span class="line">            if (p1 == m) &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125; else if (p2 == n) &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125; else if (nums1[p1] &lt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">            sorted[p1 + p2 - 1] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i != m + n; ++i) &#123;</span><br><span class="line">            nums1[i] = sorted[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(m+n)O(m+n)。<br>指针移动单调递增，最多移动 m+nm+n 次，因此时间复杂度为 O(m+n)O(m+n)。</p>
<p>空间复杂度：O(m+n)O(m+n)。<br>需要建立长度为 m+nm+n 的中间数组 \textit{sorted}sorted。</p>
<h2 id="Solution3-逆向双指针"><a href="#Solution3-逆向双指针" class="headerlink" title="Solution3 逆向双指针"></a>Solution3 逆向双指针</h2><p><img src="https://files.mdnice.com/user/1489/a825eedd-e311-4153-bc5b-ed31be497911.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        int p1 = m - 1, p2 = n - 1;</span><br><span class="line">        int tail = m + n - 1;</span><br><span class="line">        int cur;</span><br><span class="line">        while (p1 &gt;= 0 || p2 &gt;= 0) &#123;</span><br><span class="line">            if (p1 == -1) &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125; else if (p2 == -1) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; else if (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">            nums1[tail--] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h1 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h1><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。
 </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4,5], left &#x3D; 2, right &#x3D; 4<br>输出：[1,4,3,2,5]<br>示例 2：</p>
<p>输入：head &#x3D; [5], left &#x3D; 1, right &#x3D; 1<br>输出：[5]
 </p>
<p>提示：</p>
<p>链表中节点数目为 n<br>1 &lt;&#x3D; n &lt;&#x3D; 500<br>-500 &lt;&#x3D; Node.val &lt;&#x3D; 500<br>1 &lt;&#x3D; left &lt;&#x3D; right &lt;&#x3D; n
 </p>
<p>进阶： 你可以使用一趟扫描完成反转吗？</p>
<h2 id="Solution1-原地反转"><a href="#Solution1-原地反转" class="headerlink" title="Solution1 原地反转"></a>Solution1 原地反转</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Algorithm</span><br><span class="line"></span><br><span class="line">We define a recursion function that will do the job of reversing a portion of the linked list.</span><br><span class="line">Let&#x27;s call this function recurse. The function takes in 3 parameters: m being the starting point of the reversal, n being the ending point for the reversal, and a pointer right which will start at the n^&#123;th&#125;n </span><br><span class="line">th</span><br><span class="line">  node in the linked list and move backwards with the backtracking of the recursion. If this is not clear at the moment, the diagrams that follow will help.</span><br><span class="line">Additionally, we have a pointer called left which starts from the m^&#123;th&#125;m </span><br><span class="line">th</span><br><span class="line">  node in the linked list and moves forward. In Python, we have to take a global variable for this which get&#x27;s changed with recursion. In other languages, where changes made in function calls persist, we can consider this pointer as an additional variable for the function recurse.</span><br><span class="line">In a recursion call, given m, n, and right, we check if n == 1. If this is the case, we don&#x27;t need to go any further.</span><br><span class="line">Until we reach n = 1, we keep moving the right pointer one step forward and after doing that, we make a recursive call with the value of n decreased by 1. At the same time, we keep on moving the left pointer forward until m == 1. When we refer to a pointer being moved forward, it essentially means pointer.next.</span><br><span class="line">So we backtrack as soon as n reaches 1. At that point of time, the right pointer is at the last node of the sublist we want to reverse and the left has already reached the first node of this sublist. So, we swap out the data and move the left pointer one step forward using left = left.next. We need this change to persist across the backtracking process.</span><br><span class="line">From there on, every time we backtrack, the right pointer moves one step backwards. This is the simulation we&#x27;ve been mentioning all along. The backward movement is simulated by backtracking.</span><br><span class="line">We stop the swaps when either right == left, which happens if the sublist size is odd, or, right.next == left which happens when during the backtracking process for an even sized sublist, the right pointer crosses left. We use a global boolean flag for stopping the swaps once these conditions are met.</span><br><span class="line">Let&#x27;s look at a series of diagrams explaining the process on a sample linked list. Hopefully, things would be clearer after this.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">This is the first step in the recursion process. We have a list given to us and the left and the right pointers start off from the head of the linked list. The first step makes a recursive call with updated values of m and n i.e. their values each reduced by 1. Also, the left and the right pointers move one step forward in the linked list.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The next two steps show the movement of the left and the right pointers in the list. Notice that after the second step, the left pointer reaches it&#x27;s designated spot. So, we don&#x27;t move it any further. Only the right pointer progresses from here on out until it reaches node 6.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">As we can see, after the step 5, both the pointers are in their designated spots in the list and we can start the backtracking process. We don&#x27;t recurse further. The operation performed during the backtracking is swapping of data between the left and right nodes.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The right pointer crosses the left pointer after step 3 (backtracking) as can be seen above and by that point, we have already reversed the required portion of the linked list. We needed the output list to be [7 → 9 → 8 → 1 → 10 → 2 → 6] and that&#x27;s what we have. So, we don&#x27;t perform any more swaps and in the code, we can use a global boolean flag to stop the swapping after a point. We can&#x27;t really break out of recursion per say.</span><br></pre></td></tr></table></figure>

<p><img src="https://files.mdnice.com/user/1489/1d9b3377-72f8-4c1b-8451-a2e484bfdc1c.png"></p>
<h1 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/pascals-triangle/">118. 杨辉三角</a></h1><p>给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: numRows &#x3D; 5<br>输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]<br>示例 2:</p>
<p>输入: numRows &#x3D; 1<br>输出: [[1]]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The pascal triangle problem has a very simple and intuitive dynamic programming approach. As the definition states, every element of a row is formed by the sum of the two numbers directly above. So, we can just apply DP and use the previously stored rows of trianlge to calculate the new rows.</span><br><span class="line"></span><br><span class="line">We can just initialize the start and end elements of each row as 1 and update only the elements between them. This will make the code simpler and avoid the need of having extra checks for edge elements of each row.</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-直接求解"><a href="#Solution1-直接求解" class="headerlink" title="Solution1 直接求解"></a>Solution1 直接求解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; yanghui;</span><br><span class="line">        for (int i = 0; i &lt; numRows; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; data(i + 1);</span><br><span class="line">            yanghui.push_back(data);</span><br><span class="line">            for (int j = 0; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                if(j == 0) yanghui[i][j] = 1;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    yanghui[i][j] = yanghui[i - 1][j - 1] + yanghui[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            yanghui[i][yanghui[i].size() - 1] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return yanghui;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-palindrome/">125. 验证回文串</a></h1><p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个回文串。</p>
<p>字母和数字都属于字母数字字符。</p>
<p>给你一个字符串 s，如果它是回文串，返回 true ；否则，返回 false 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入: “A man, a plan, a canal: Panama”<br>输出：true<br>解释：”amanaplanacanalpanama” 是回文串。<br>示例 2：</p>
<p>输入：”race a car”<br>输出：false<br>解释：”raceacar” 不是回文串。<br>示例 3：</p>
<p>输入：s &#x3D; “ “<br>输出：true<br>解释：在移除非字母数字字符之后，s 是一个空字符串 “” 。<br>由于空字符串正着反着读都一样，所以是回文串。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 2 * 105<br>s 仅由可打印的 ASCII 字符组成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool isPalindrome(string s) &#123;</span><br><span class="line">    for (int i = 0, j = s.size() - 1; i &lt; j; i++, j--) &#123; // Move 2 pointers from each end until they collide</span><br><span class="line">        while (isalnum(s[i]) == false &amp;&amp; i &lt; j) i++; // Increment left pointer if not alphanumeric</span><br><span class="line">        while (isalnum(s[j]) == false &amp;&amp; i &lt; j) j--; // Decrement right pointer if no alphanumeric</span><br><span class="line">        if (toupper(s[i]) != toupper(s[j])) return false; // Exit and return error if not match</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-筛选-判断"><a href="#Solution1-筛选-判断" class="headerlink" title="Solution1 筛选 + 判断"></a>Solution1 筛选 + 判断</h2><p><img src="https://files.mdnice.com/user/1489/fb453ee9-27d8-4bad-86ea-346219e70b18.png"></p>
<h2 id="Solution2-筛选-判断-02"><a href="#Solution2-筛选-判断-02" class="headerlink" title="Solution2 筛选 + 判断 02"></a>Solution2 筛选 + 判断 02</h2><p><img src="https://files.mdnice.com/user/1489/bd915655-54ae-4387-8d94-22cabd830f19.png"></p>
<h2 id="Solution03-在原字符串上直接判断"><a href="#Solution03-在原字符串上直接判断" class="headerlink" title="Solution03 在原字符串上直接判断"></a>Solution03 在原字符串上直接判断</h2><p><img src="https://files.mdnice.com/user/1489/4391ada0-91de-488d-a3a9-23fa346ea804.png"></p>
<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/linked-list-cycle/">141. 环形链表</a></h1><p>给你一个链表的头节点 head ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p>
<p>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p>
<p>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：false<br>解释：链表中没有环。
 </p>
<p>提示：</p>
<p>链表中节点的数目范围是 [0, 104]<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>pos 为 -1 或者链表中的一个 有效索引 。
 </p>
<p>进阶：你能用 O(1)（即，常量）内存解决此问题吗？</p>
<h2 id="Solution1-哈希表"><a href="#Solution1-哈希表" class="headerlink" title="Solution1 哈希表"></a>Solution1 哈希表</h2><p><img src="https://files.mdnice.com/user/1489/f65c3a6a-debe-4c68-ac3b-171b07af7262.png"></p>
<h2 id="Solution2-3"><a href="#Solution2-3" class="headerlink" title="Solution2"></a>Solution2</h2><p><img src="https://files.mdnice.com/user/1489/9add3a1c-b13f-4277-a2b6-e511bf914864.png"></p>
<p><img src="https://files.mdnice.com/user/1489/1411c0a9-8a0f-452f-8fc6-ff371d70d1d0.png"></p>
<p><img src="https://files.mdnice.com/user/1489/fc7adb50-508e-4b31-b28e-f3f11eea8217.png"></p>
<h1 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h1><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>不允许修改 链表。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p>
<p>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p>
<p>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：返回 null<br>解释：链表中没有环。
 </p>
<p>提示：</p>
<p>链表中节点的数目范围在范围 [0, 104] 内<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>pos 的值为 -1 或者链表中的一个有效索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Alogrithm Description:</span><br><span class="line">Step 1: Determine whether there is a cycle</span><br><span class="line"></span><br><span class="line">1.1) Using a slow pointer that move forward 1 step each time</span><br><span class="line"></span><br><span class="line">1.2) Using a fast pointer that move forward 2 steps each time</span><br><span class="line"></span><br><span class="line">1.3) If the slow pointer and fast pointer both point to the same location after several moving steps, there is a cycle;</span><br><span class="line"></span><br><span class="line">1.4) Otherwise, if (fast-&gt;next == NULL || fast-&gt;next-&gt;next == NULL), there has no cycle.</span><br><span class="line"></span><br><span class="line">Step 2: If there is a cycle, return the entry location of the cycle</span><br><span class="line"></span><br><span class="line">2.1) L1 is defined as the distance between the head point and entry point</span><br><span class="line"></span><br><span class="line">2.2) L2 is defined as the distance between the entry point and the meeting point</span><br><span class="line"></span><br><span class="line">2.3) C is defined as the length of the cycle</span><br><span class="line"></span><br><span class="line">2.4) n is defined as the travel times of the fast pointer around the cycle When the first encounter of the slow pointer and the fast pointer</span><br><span class="line"></span><br><span class="line">According to the definition of L1, L2 and C, we can obtain:</span><br><span class="line"></span><br><span class="line">the total distance of the slow pointer traveled when encounter is L1 + L2</span><br><span class="line"></span><br><span class="line">the total distance of the fast pointer traveled when encounter is L1 + L2 + n * C</span><br><span class="line"></span><br><span class="line">Because the total distance the fast pointer traveled is twice as the slow pointer, Thus:</span><br><span class="line"></span><br><span class="line">2 * (L1+L2) = L1 + L2 + n * C =&gt; L1 + L2 = n * C =&gt; L1 = (n - 1) C + (C - L2)*</span><br><span class="line"></span><br><span class="line">It can be concluded that the distance between the head location and entry location is equal to the distance between the meeting location and the entry location along the direction of forward movement.</span><br><span class="line"></span><br><span class="line">So, when the slow pointer and the fast pointer encounter in the cycle, we can define a pointer &quot;entry&quot; that point to the head, this &quot;entry&quot; pointer moves one step each time so as the slow pointer. When this &quot;entry&quot; pointer and the slow pointer both point to the same location, this location is the node where the cycle begins.</span><br></pre></td></tr></table></figure>
<h2 id="Solution1-哈希表-1"><a href="#Solution1-哈希表-1" class="headerlink" title="Solution1 哈希表"></a>Solution1 哈希表</h2><p><img src="https://files.mdnice.com/user/1489/335701cf-1815-4ee0-a266-d54c6c35669b.png"></p>
<h2 id="Solution2-双指针-2"><a href="#Solution2-双指针-2" class="headerlink" title="Solution2 双指针"></a>Solution2 双指针</h2><p><img src="https://files.mdnice.com/user/1489/725fc0e8-c8e6-4660-b971-9c47beb3c888.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        while (fast != nullptr) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            if (fast-&gt;next == nullptr) &#123;</span><br><span class="line">                return nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            if (fast == slow) &#123;</span><br><span class="line">                ListNode *ptr = head;</span><br><span class="line">                while (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                return ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://files.mdnice.com/user/1489/7323d75f-2b46-4b8a-9908-4f5c654281f5.png"></p>
<h1 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reorder-list/">143. 重排链表</a></h1><p>给定一个单链表 L 的头节点 head ，单链表 L 表示为：</p>
<p>L0 → L1 → … → Ln - 1 → Ln<br>请将其重新排列后变为：</p>
<p>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …<br>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4]<br>输出：[1,4,2,3]<br>示例 2：</p>
<p>输入：head &#x3D; [1,2,3,4,5]<br>输出：[1,5,2,4,3]
 </p>
<p>提示：</p>
<p>链表的长度范围为 [1, 5 * 104]<br>1 &lt;&#x3D; node.val &lt;&#x3D; 1000</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">If you never solved singly linked lists problems before, or you do not have a lot of experience, this problem can be quite difficult. However if you already know all the tricks, it is not difficult at all. Let us first try to understand what we need to do. For list [1,2,3,4,5,6,7] we need to return [1,7,2,6,3,5,4]. We can note, that it is actually two lists [1,2,3,4] and [7,6,5], where elements are interchange. So, to succeed we need to do the following steps:</span><br><span class="line"></span><br><span class="line">Find the middle of or list - be careful, it needs to work properly both for even and for odd number of nodes. For this we can either just count number of elements and then divide it by to, and do two traversals of list. Or we can use slow/fast iterators trick, where slow moves with speed 1 and fast moves with speed 2. Then when fast reches the end, slow will be in the middle, as we need.</span><br><span class="line">Reverse the second part of linked list. Again, if you never done it before, it can be quite painful, please read oficial solution to problem 206. Reverse Linked List. The idea is to keep three pointers: prev, curr, nextt stand for previous, current and next and change connections in place. Do not forget to use slow.next = None, in opposite case you will have list with loop.</span><br><span class="line">Finally, we need to merge two lists, given its heads. These heads are denoted by head and prev, so for simplisity I created head1 and head2 variables. What we need to do now is to interchange nodes: we put head2 as next element of head1 and then say that head1 is now head2 and head2 is previous head1.next. In this way we do one step for one of the lists and rename lists, so next time we will take element from head2, then rename again and so on.</span><br><span class="line">Complexity: Time complexity is O(n), because we first do O(n) iterations to find middle, then we do O(n) iterations to reverse second half and finally we do O(n) iterations to merge lists. Space complexity is O(1).</span><br></pre></td></tr></table></figure>
<h2 id="Solution0-暴力-2"><a href="#Solution0-暴力-2" class="headerlink" title="Solution0 暴力"></a>Solution0 暴力</h2><h2 id="Solution1-双指针-1"><a href="#Solution1-双指针-1" class="headerlink" title="Solution1 双指针"></a>Solution1 双指针</h2><p>1.快慢指针找到中点 2.拆成两个链表 3.遍历两个链表，后面的塞到前面的“缝隙里”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">void reorderList(ListNode* head) &#123;</span><br><span class="line">    </span><br><span class="line">    if(head==NULL || head-&gt;next == NULL)</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line">    //快慢指针分出两段</span><br><span class="line">    ListNode *slow = head,*fast = head;</span><br><span class="line">    </span><br><span class="line">    while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123;</span><br><span class="line">        </span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //后端反转</span><br><span class="line">    ListNode *needReverser = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = NULL;</span><br><span class="line">    needReverser = reverse(needReverser);</span><br><span class="line">    </span><br><span class="line">    //插入前端缝隙</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    while(cur &amp;&amp; needReverser)&#123;</span><br><span class="line">        ListNode *curSecond = needReverser;</span><br><span class="line">        needReverser = needReverser-&gt;next;</span><br><span class="line">        ListNode *nextCur = cur-&gt;next;</span><br><span class="line">        curSecond-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = curSecond;</span><br><span class="line">        </span><br><span class="line">        cur = nextCur;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode *reverse(ListNode *head)&#123;</span><br><span class="line">    </span><br><span class="line">    ListNode *p1 = NULL;</span><br><span class="line">    ListNode *p2 = head;</span><br><span class="line">    ListNode *p3 = p2;</span><br><span class="line">    </span><br><span class="line">    while(p2)&#123;</span><br><span class="line">        p3 = p2-&gt;next;</span><br><span class="line">        p2-&gt;next = p1;</span><br><span class="line">        p1 = p2;</span><br><span class="line">        p2 = p3;            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return p1;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lru-cache/">146. LRU 缓存</a></h1><p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：<br>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。<br>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p>
<p> </p>
<p>示例：</p>
<p>输入<br>[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”]<br>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]<br>输出<br>[null, null, null, 1, null, -1, null, -1, 3, 4]</p>
<p>解释<br>LRUCache lRUCache &#x3D; new LRUCache(2);<br>lRUCache.put(1, 1); &#x2F;&#x2F; 缓存是 {1&#x3D;1}<br>lRUCache.put(2, 2); &#x2F;&#x2F; 缓存是 {1&#x3D;1, 2&#x3D;2}<br>lRUCache.get(1);    &#x2F;&#x2F; 返回 1<br>lRUCache.put(3, 3); &#x2F;&#x2F; 该操作会使得关键字 2 作废，缓存是 {1&#x3D;1, 3&#x3D;3}<br>lRUCache.get(2);    &#x2F;&#x2F; 返回 -1 (未找到)<br>lRUCache.put(4, 4); &#x2F;&#x2F; 该操作会使得关键字 1 作废，缓存是 {4&#x3D;4, 3&#x3D;3}<br>lRUCache.get(1);    &#x2F;&#x2F; 返回 -1 (未找到)<br>lRUCache.get(3);    &#x2F;&#x2F; 返回 3<br>lRUCache.get(4);    &#x2F;&#x2F; 返回 4
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; capacity &lt;&#x3D; 3000<br>0 &lt;&#x3D; key &lt;&#x3D; 10000<br>0 &lt;&#x3D; value &lt;&#x3D; 105<br>最多调用 2 * 105 次 get 和 put</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n this question we have to keep track of the most least recently used item in the cache. I have designed the cache using list and map in C++.</span><br><span class="line">We do it by following the steps below :-</span><br><span class="line"></span><br><span class="line">When we access an item in the cache it moves to the front of the list as it is the most recently used item.</span><br><span class="line">When we want to remove an item we remove it from the last of the list as it is the least recently used item in the cache.</span><br><span class="line">When we insert an item we insert it into the front of the list as it is the most recently used item.</span><br><span class="line">The idea is to store the keys in the map and its corrosponding values into the list...</span><br><span class="line">Note : splice() function here takes the element at the m[key] and places it at the beginning of the list...</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-哈希表-双向链表"><a href="#Solution1-哈希表-双向链表" class="headerlink" title="Solution1 哈希表 + 双向链表"></a>Solution1 哈希表 + 双向链表</h2><p>方法一：哈希表 + 双向链表<br>算法</p>
<p>LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。</p>
<p>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</p>
<p>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。</p>
<p>这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1)O(1) 的时间内完成 get 或者 put 操作。具体的方法如下：</p>
<p>对于 get 操作，首先判断 key 是否存在：</p>
<p>如果 key 不存在，则返回 -1−1；</p>
<p>如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。</p>
<p>对于 put 操作，首先判断 key 是否存在：</p>
<p>如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；</p>
<p>如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。</p>
<p>上述各项操作中，访问哈希表的时间复杂度为 O(1)O(1)，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 O(1)O(1)。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 O(1)O(1) 时间内完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">struct DLinkedNode &#123;</span><br><span class="line">    int key, value;</span><br><span class="line">    DLinkedNode* prev;</span><br><span class="line">    DLinkedNode* next;</span><br><span class="line">    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) &#123;&#125;</span><br><span class="line">    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LRUCache &#123;</span><br><span class="line">private:</span><br><span class="line">    unordered_map&lt;int, DLinkedNode*&gt; cache;</span><br><span class="line">    DLinkedNode* head;</span><br><span class="line">    DLinkedNode* tail;</span><br><span class="line">    int size;</span><br><span class="line">    int capacity;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    LRUCache(int _capacity): capacity(_capacity), size(0) &#123;</span><br><span class="line">        // 使用伪头部和伪尾部节点</span><br><span class="line">        head = new DLinkedNode();</span><br><span class="line">        tail = new DLinkedNode();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int get(int key) &#123;</span><br><span class="line">        if (!cache.count(key)) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果 key 存在，先通过哈希表定位，再移到头部</span><br><span class="line">        DLinkedNode* node = cache[key];</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        return node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void put(int key, int value) &#123;</span><br><span class="line">        if (!cache.count(key)) &#123;</span><br><span class="line">            // 如果 key 不存在，创建一个新的节点</span><br><span class="line">            DLinkedNode* node = new DLinkedNode(key, value);</span><br><span class="line">            // 添加进哈希表</span><br><span class="line">            cache[key] = node;</span><br><span class="line">            // 添加至双向链表的头部</span><br><span class="line">            addToHead(node);</span><br><span class="line">            ++size;</span><br><span class="line">            if (size &gt; capacity) &#123;</span><br><span class="line">                // 如果超出容量，删除双向链表的尾部节点</span><br><span class="line">                DLinkedNode* removed = removeTail();</span><br><span class="line">                // 删除哈希表中对应的项</span><br><span class="line">                cache.erase(removed-&gt;key);</span><br><span class="line">                // 防止内存泄漏</span><br><span class="line">                delete removed;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span><br><span class="line">            DLinkedNode* node = cache[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void addToHead(DLinkedNode* node) &#123;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void removeNode(DLinkedNode* node) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void moveToHead(DLinkedNode* node) &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DLinkedNode* removeTail() &#123;</span><br><span class="line">        DLinkedNode* node = tail-&gt;prev;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="分治：148-排序链表"><a href="#分治：148-排序链表" class="headerlink" title="分治：148. 排序链表"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sort-list/">分治：148. 排序链表</a></h1><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [4,2,1,3]<br>输出：[1,2,3,4]<br>示例 2：</p>
<p>输入：head &#x3D; [-1,5,3,4,0]<br>输出：[-1,0,3,4,5]<br>示例 3：</p>
<p>输入：head &#x3D; []<br>输出：[]
 </p>
<p>提示：</p>
<p>链表中节点的数目在范围 [0, 5 * 104] 内<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Brief note about Question-</span><br><span class="line"></span><br><span class="line">We have to return the linked list after sorting it in ascending order.</span><br><span class="line">Let&#x27;s take an example not given in question -</span><br><span class="line">Suppose head of linked list given to us is like, head: [3,-9,8,67,9]</span><br><span class="line"></span><br><span class="line">then answer should like [-9,3,8,9,67] after sorting it in ascending order.</span><br><span class="line">Solution - I (Using Merge sort, Accepted)-</span><br><span class="line"></span><br><span class="line">We want to sort a linked list, then we may able to use any of the sorting algorithm and then apply on it.</span><br><span class="line">We will use merge sort here, because I find it easy to implement in linked list.</span><br><span class="line">Whole implementation totally based on the merge sort, so i strongly suggest you to read a article on the merge sort.</span><br><span class="line">Some basic thing that we will do in applying merge sort on our linked list are-</span><br><span class="line">We divide our linked liist into two equal parts until when only one element is left.</span><br><span class="line">After that we start merge them on the basis of value.</span><br><span class="line">Now, if we divide them into two equal parts then then how we will find mid in linked list.</span><br><span class="line">We find mid of linked list using tortise and hare method or say using fast and slow pointer.</span><br><span class="line">See commented code for more explanation.</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-自顶向下归并排序"><a href="#Solution1-自顶向下归并排序" class="headerlink" title="Solution1 自顶向下归并排序"></a>Solution1 自顶向下归并排序</h2><p><img src="https://files.mdnice.com/user/1489/d5233fdc-b942-4252-b385-aeaa32428270.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* sortList(ListNode* head) &#123;</span><br><span class="line">        return sortList(head, nullptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* sortList(ListNode* head, ListNode* tail) &#123;</span><br><span class="line">        if (head == nullptr) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        if (head-&gt;next == tail) &#123;</span><br><span class="line">            head-&gt;next = nullptr;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow = head, *fast = head;</span><br><span class="line">        while (fast != tail) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            if (fast != tail) &#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* mid = slow;</span><br><span class="line">        return merge(sortList(head, mid), sortList(mid, tail));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* merge(ListNode* head1, ListNode* head2) &#123;</span><br><span class="line">        ListNode* dummyHead = new ListNode(0);</span><br><span class="line">        ListNode* temp = dummyHead, *temp1 = head1, *temp2 = head2;</span><br><span class="line">        while (temp1 != nullptr &amp;&amp; temp2 != nullptr) &#123;</span><br><span class="line">            if (temp1-&gt;val &lt;= temp2-&gt;val) &#123;</span><br><span class="line">                temp-&gt;next = temp1;</span><br><span class="line">                temp1 = temp1-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                temp-&gt;next = temp2;</span><br><span class="line">                temp2 = temp2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (temp1 != nullptr) &#123;</span><br><span class="line">            temp-&gt;next = temp1;</span><br><span class="line">        &#125; else if (temp2 != nullptr) &#123;</span><br><span class="line">            temp-&gt;next = temp2;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution2-自底向上归并排序"><a href="#Solution2-自底向上归并排序" class="headerlink" title="Solution2 自底向上归并排序"></a>Solution2 自底向上归并排序</h2><p><img src="https://files.mdnice.com/user/1489/76432652-12d7-4385-8ea8-6dae686cd490.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* sortList(ListNode* head) &#123;</span><br><span class="line">        if (head == nullptr) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        int length = 0;</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        while (node != nullptr) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* dummyHead = new ListNode(0, head);</span><br><span class="line">        for (int subLength = 1; subLength &lt; length; subLength &lt;&lt;= 1) &#123;</span><br><span class="line">            ListNode* prev = dummyHead, *curr = dummyHead-&gt;next;</span><br><span class="line">            while (curr != nullptr) &#123;</span><br><span class="line">                ListNode* head1 = curr;</span><br><span class="line">                for (int i = 1; i &lt; subLength &amp;&amp; curr-&gt;next != nullptr; i++) &#123;</span><br><span class="line">                    curr = curr-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode* head2 = curr-&gt;next;</span><br><span class="line">                curr-&gt;next = nullptr;</span><br><span class="line">                curr = head2;</span><br><span class="line">                for (int i = 1; i &lt; subLength &amp;&amp; curr != nullptr &amp;&amp; curr-&gt;next != nullptr; i++) &#123;</span><br><span class="line">                    curr = curr-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode* next = nullptr;</span><br><span class="line">                if (curr != nullptr) &#123;</span><br><span class="line">                    next = curr-&gt;next;</span><br><span class="line">                    curr-&gt;next = nullptr;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode* merged = merge(head1, head2);</span><br><span class="line">                prev-&gt;next = merged;</span><br><span class="line">                while (prev-&gt;next != nullptr) &#123;</span><br><span class="line">                    prev = prev-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* merge(ListNode* head1, ListNode* head2) &#123;</span><br><span class="line">        ListNode* dummyHead = new ListNode(0);</span><br><span class="line">        ListNode* temp = dummyHead, *temp1 = head1, *temp2 = head2;</span><br><span class="line">        while (temp1 != nullptr &amp;&amp; temp2 != nullptr) &#123;</span><br><span class="line">            if (temp1-&gt;val &lt;= temp2-&gt;val) &#123;</span><br><span class="line">                temp-&gt;next = temp1;</span><br><span class="line">                temp1 = temp1-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                temp-&gt;next = temp2;</span><br><span class="line">                temp2 = temp2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (temp1 != nullptr) &#123;</span><br><span class="line">            temp-&gt;next = temp1;</span><br><span class="line">        &#125; else if (temp2 != nullptr) &#123;</span><br><span class="line">            temp-&gt;next = temp2;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h1><p>根据 逆波兰表示法，求表达式的值。</p>
<p>有效的算符包括 +、-、*、&#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p>注意 两个整数之间的除法只保留整数部分。</p>
<p>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：tokens &#x3D; [“2”,”1”,”+”,”3”,”*”]<br>输出：9<br>解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9<br>示例 2：</p>
<p>输入：tokens &#x3D; [“4”,”13”,”5”,”&#x2F;“,”+”]<br>输出：6<br>解释：该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6<br>示例 3：</p>
<p>输入：tokens &#x3D; [“10”,”6”,”9”,”3”,”+”,”-11”,”<em>“,”&#x2F;“,”</em>“,”17”,”+”,”5”,”+”]<br>输出：22<br>解释：该算式转化为常见的中缀算术表达式为：<br>  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5<br>&#x3D; ((10 * 0) + 17) + 5<br>&#x3D; (0 + 17) + 5<br>&#x3D; 17 + 5<br>&#x3D; 22
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; tokens.length &lt;&#x3D; 104<br>tokens[i] 是一个算符（”+”、”-“、”*” 或 “&#x2F;“），或是在范围 [-200, 200] 内的一个整数
 </p>
<p>逆波兰表达式：</p>
<p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p>
<p>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。<br>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。<br>逆波兰表达式主要有以下两个优点：</p>
<p>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。<br>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Idea:</span><br><span class="line">Reverse Polish Notation was designed specifically to make computing easier with the more efficient use of a stack. So we can use a stack here to store numbers until they&#x27;re used, and then each operand will use the top two values of the stack.</span><br><span class="line"></span><br><span class="line">Since the order of the numbers is still important for subtraction and division, we&#x27;ll have to make sure that the two numbers are processed in their original order, which is the opposite order of the stack.</span><br><span class="line"></span><br><span class="line">After each successful operation, the result should be pushed back onto the stack until it&#x27;s used. After iteration is complete, the remaining value in the stack will be our answer, so we should return stack[0].</span><br><span class="line"></span><br><span class="line">Time Complexity: O(N) where N is the length of tokens</span><br><span class="line">Space Complexity: O(N) for the length of the stack, up to N / 2 + 1 values</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-栈-1"><a href="#Solution1-栈-1" class="headerlink" title="Solution1  栈"></a>Solution1  栈</h2><p><img src="https://files.mdnice.com/user/1489/e7ac0fe5-7797-4094-a619-f13588081fd5.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">        stack&lt;int&gt; stk;</span><br><span class="line">        int n = tokens.size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            string&amp; token = tokens[i];</span><br><span class="line">            if (isNumber(token)) &#123;</span><br><span class="line">                stk.push(atoi(token.c_str()));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int num2 = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                int num1 = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                switch (token[0]) &#123;</span><br><span class="line">                    case &#x27;+&#x27;:</span><br><span class="line">                        stk.push(num1 + num2);</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;-&#x27;:</span><br><span class="line">                        stk.push(num1 - num2);</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;*&#x27;:</span><br><span class="line">                        stk.push(num1 * num2);</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;/&#x27;:</span><br><span class="line">                        stk.push(num1 / num2);</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stk.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isNumber(string&amp; token) &#123;</span><br><span class="line">        return !(token == &quot;+&quot; || token == &quot;-&quot; || token == &quot;*&quot; || token == &quot;/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 是数组 \textit{tokens}tokens 的长度。需要遍历数组 \textit{tokens}tokens 一次，计算逆波兰表达式的值。</p>
<p>空间复杂度：O(n)O(n)，其中 nn 是数组 \textit{tokens}tokens 的长度。使用栈存储计算过程中的数，栈内元素个数不会超过逆波兰表达式的长度。</p>
<h2 id="Solution2-数组模拟栈"><a href="#Solution2-数组模拟栈" class="headerlink" title="Solution2 数组模拟栈"></a>Solution2 数组模拟栈</h2><p><img src="https://files.mdnice.com/user/1489/f40bfb53-0680-426d-b458-8de6820f7bae.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">        int n = tokens.size();</span><br><span class="line">        vector&lt;int&gt; stk((n + 1) / 2);</span><br><span class="line">        int index = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            string&amp; token = tokens[i];</span><br><span class="line">            if (token.length() &gt; 1 || isdigit(token[0])) &#123;</span><br><span class="line">                index++;</span><br><span class="line">                stk[index] = atoi(token.c_str());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                switch (token[0]) &#123;</span><br><span class="line">                    case &#x27;+&#x27;:</span><br><span class="line">                        index--;</span><br><span class="line">                        stk[index] += stk[index + 1];</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;-&#x27;:</span><br><span class="line">                        index--;</span><br><span class="line">                        stk[index] -= stk[index + 1];</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;*&#x27;:</span><br><span class="line">                        index--;</span><br><span class="line">                        stk[index] *= stk[index + 1];</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;/&#x27;:</span><br><span class="line">                        index--;</span><br><span class="line">                        stk[index] /= stk[index + 1];</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stk[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="171-Excel-表列序号"><a href="#171-Excel-表列序号" class="headerlink" title="171. Excel 表列序号"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/excel-sheet-column-number/">171. Excel 表列序号</a></h1><p>给你一个字符串 columnTitle ，表示 Excel 表格中的列名称。返回 该列名称对应的列序号 。</p>
<p>例如：</p>
<p>A -&gt; 1<br>B -&gt; 2<br>C -&gt; 3<br>…<br>Z -&gt; 26<br>AA -&gt; 27<br>AB -&gt; 28<br>…
 </p>
<p>示例 1:</p>
<p>输入: columnTitle &#x3D; “A”<br>输出: 1<br>示例 2:</p>
<p>输入: columnTitle &#x3D; “AB”<br>输出: 28<br>示例 3:</p>
<p>输入: columnTitle &#x3D; “ZY”<br>输出: 701
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; columnTitle.length &lt;&#x3D; 7<br>columnTitle 仅由大写英文组成<br>columnTitle 在范围 [“A”, “FXSHRXW”] 内</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1. There are 26 letters in our alphabet and we start counting from 1, not zero.</span><br><span class="line">   So &#x27;Z&#x27; is 26.</span><br><span class="line">2. The rest of the combinations start from a base 26</span><br><span class="line"></span><br><span class="line">AA --&gt; 26*1+ 1 = 27 (A == 1)</span><br><span class="line">AB --&gt; 26*1+ 2 = 28 (B == 2)</span><br><span class="line">AC --&gt;26*1 + 3 = 29 (C == 3)</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">So we can write like this:</span><br><span class="line"></span><br><span class="line">result = 0</span><br><span class="line">d = s[i](char) - &#x27;A&#x27; + 1 (we used  s[i] -  &#x27;A&#x27; to convert the letter to a number like it&#x27;s going to be C)</span><br><span class="line">result = result* 26 + d</span><br><span class="line"></span><br><span class="line">If the given input is only one letter, it will automatically take the value s[i] - &#x27;A&#x27; + 1 as the first result is 0.</span><br><span class="line">Some More Explanation</span><br><span class="line">1. For every additional digit of the string, we multiply the value of the digit by 26^n</span><br><span class="line">2. here n is the number of digits it is away from the one&#x27;s place.</span><br><span class="line">3. This is similar to how the number 254 could be broken down as this:</span><br><span class="line">	 (2 x 10 x 10) + (5 x 10) + (4).</span><br><span class="line">4. The reason we use 26 instead of 10 is because 26 is our base.</span><br><span class="line"></span><br><span class="line">For s = &quot;BCM&quot; the final solution would be (2 x 26 x 26) + (3 x 26) + (13)</span><br><span class="line"></span><br><span class="line">We could do this process iteratively. Start at looking at the first digit &quot;B&quot;. Add the int equivalent of &quot;B&quot; to the running sum and continue. </span><br><span class="line">Every time we look at the following digit multiply our running sum by 26 before adding the next digit to signify we are changing places. Example below:</span><br><span class="line"></span><br><span class="line">&quot;B&quot; = 2</span><br><span class="line">&quot;BC&quot; = (2)26 + 3</span><br><span class="line">&quot;BCM&quot; = (2(26) + 3)26 + 13</span><br><span class="line">Time Complexity : O(n) one scan of string , n is number of characters in the string</span><br><span class="line"></span><br><span class="line">CODE WITH EXPLANATION</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-26进制"><a href="#Solution1-26进制" class="headerlink" title="Solution1  26进制"></a>Solution1  26进制</h2><p><img src="https://files.mdnice.com/user/1489/ca4fbbe4-2cea-43f3-ac48-3d192c40bacf.png"></p>
<h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/min-stack/comments/">155. 最小栈</a></h1><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>实现 MinStack 类:</p>
<p>MinStack() 初始化堆栈对象。<br>void push(int val) 将元素val推入堆栈。<br>void pop() 删除堆栈顶部的元素。<br>int top() 获取堆栈顶部的元素。<br>int getMin() 获取堆栈中的最小元素。
 </p>
<p>示例 1:</p>
<p>输入：<br>[“MinStack”,”push”,”push”,”push”,”getMin”,”pop”,”top”,”getMin”]<br>[[],[-2],[0],[-3],[],[],[],[]]</p>
<p>输出：<br>[null,null,null,null,-3,null,0,-2]</p>
<p>解释：<br>MinStack minStack &#x3D; new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.
 </p>
<p>提示：</p>
<p>-231 &lt;&#x3D; val &lt;&#x3D; 231 - 1<br>pop、top 和 getMin 操作总是在 非空栈 上调用<br>push, pop, top, and getMin最多被调用 3 * 104 次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">I came up with this simple solution using just a single stack.</span><br><span class="line">Here I am using Stack of Pair of Int. The first value of the pair would store the element of the normal stack and the second value would store the minimum up to that point in the stack.</span><br><span class="line">So even if the minimum element of the stack is removed from the top, we still have a backup of the next minimum element in the pair. So for every element pushed in the stack, it stores its corresponding minimum value.</span><br><span class="line"></span><br><span class="line">For example, let&#x27;s do a Dry Run of an example.</span><br><span class="line"></span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;push&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[5],[-2],[3],[-10],[20],[],[],[],[],[30],[]]</span><br><span class="line">We push 5,-2,3,-10,20 in the stack.</span><br><span class="line">If the stack is empty we push &#123;val,val&#125; in the stack</span><br><span class="line">else we push &#123;val,min(s.top().second,val)&#125; which is basically minimum upto that point.</span><br><span class="line">Hence &#123;5,5&#125;,&#123;-2,-2&#125;,&#123;3,-2&#125;,&#123;-10,-10&#125;,&#123;20,-10&#125; are pushed in the stack.</span><br><span class="line">To pop simply do stack.pop()</span><br><span class="line">To get the top return stack.top().first;</span><br><span class="line">Now we pop 20 and -10 from the stack</span><br><span class="line">The elements in the stack would be &#123;5,5&#125;,&#123;-2,-2&#125;,&#123;3,-2&#125;</span><br><span class="line">On pushing 30 to the stack</span><br><span class="line">The elements in the stack would be &#123;5,5&#125;,&#123;-2,-2&#125;,&#123;3,-2&#125;,&#123;30,-2&#125;.</span><br><span class="line">The Output of the code would be:</span><br><span class="line"></span><br><span class="line">[null,null,null,null,null,null,-10,null,null,3,null,-2]</span><br><span class="line">All the operations are one liners expect the Push operation which is a 2 liner.</span><br><span class="line"></span><br><span class="line">class MinStack &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt; pair&lt;int,int&gt; &gt; s;</span><br><span class="line">	</span><br><span class="line">    MinStack() &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    void push(int val) &#123;</span><br><span class="line">        if(s.empty())</span><br><span class="line">            s.push_back(&#123;val,val&#125;);</span><br><span class="line">        else</span><br><span class="line">            s.push_back(&#123;val,min(s.back().second,val)&#125;);    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void pop() &#123; s.pop_back(); &#125;</span><br><span class="line">    </span><br><span class="line">    int top() &#123; return s.back().first; &#125;</span><br><span class="line">    </span><br><span class="line">    int getMin() &#123; return s.back().second; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">The Time complexity of each operation is O(1)</span><br><span class="line">The Space complexity is O(N)</span><br></pre></td></tr></table></figure>
<h2 id="Solution1-辅助栈"><a href="#Solution1-辅助栈" class="headerlink" title="Solution1 辅助栈"></a>Solution1 辅助栈</h2><p><img src="https://files.mdnice.com/user/1489/0b64394f-ee13-447f-835a-965086697e94.png"></p>
<p><img src="https://files.mdnice.com/user/1489/a01bf43a-aa9c-45e4-8e02-e38f1a09bba3.png"></p>
<h2 id="Solution2-不用辅助栈"><a href="#Solution2-不用辅助栈" class="headerlink" title="Solution2 不用辅助栈"></a>Solution2 不用辅助栈</h2><p><img src="https://files.mdnice.com/user/1489/5f397d41-0fd5-406a-befb-20bb996d6862.png"></p>
<h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h1><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p>
<p>图示两个链表在节点 c1 开始相交：</p>
<p>题目数据 保证 整个链式结构中不存在环。</p>
<p>注意，函数返回结果后，链表必须 保持其原始结构 。</p>
<p>自定义评测：</p>
<p>评测系统 的输入如下（你设计的程序 不适用 此输入）：</p>
<p>intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0<br>listA - 第一个链表<br>listB - 第二个链表<br>skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数<br>skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数<br>评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3<br>输出：Intersected at ‘8’<br>解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。<br>在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。<br>示例 2：</p>
<p>输入：intersectVal &#x3D; 2, listA &#x3D; [1,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1<br>输出：Intersected at ‘2’<br>解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。<br>在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。<br>示例 3：</p>
<p>输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2<br>输出：null<br>解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。<br>由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 null 。
 </p>
<p>提示：</p>
<p>listA 中节点数目为 m<br>listB 中节点数目为 n<br>1 &lt;&#x3D; m, n &lt;&#x3D; 3 * 104<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>0 &lt;&#x3D; skipA &lt;&#x3D; m<br>0 &lt;&#x3D; skipB &lt;&#x3D; n<br>如果 listA 和 listB 没有交点，intersectVal 为 0<br>如果 listA 和 listB 有交点，intersectVal &#x3D;&#x3D; listA[skipA] &#x3D;&#x3D; listB[skipB]
 </p>
<p>进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">O ( 1 ) SPACE SOLUTION</span><br><span class="line"></span><br><span class="line">First using constant space check for last element of both lists.</span><br><span class="line">If tails of both lists are different then return NULL</span><br><span class="line"></span><br><span class="line">Now we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.</span><br><span class="line">Head pointer of the longer list is moved to next till length of both lists become equal</span><br><span class="line"></span><br><span class="line">NOW we will have intersetion point at the same distance from head for both the lists.</span><br><span class="line"></span><br><span class="line">Now keep comparing heads till match found.</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-哈希集合"><a href="#Solution1-哈希集合" class="headerlink" title="Solution1 哈希集合"></a>Solution1 哈希集合</h2><p><img src="https://files.mdnice.com/user/1489/6ed11899-abbb-4316-b5f5-0905cc477414.png"></p>
<h2 id="Solution2-双指针-3"><a href="#Solution2-双指针-3" class="headerlink" title="Solution2 双指针"></a>Solution2 双指针</h2><p><img src="https://files.mdnice.com/user/1489/eef3c25b-9218-4dd9-83d7-392ec8df5f36.png"></p>
<p><img src="https://files.mdnice.com/user/1489/a181f628-892e-4ab3-9509-236d9b01c497.png"></p>
<p><img src="https://files.mdnice.com/user/1489/a1ffabf9-420e-46a6-a2e1-ae5db89d9a6e.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        if (headA == nullptr || headB == nullptr) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *pA = headA, *pB = headB;</span><br><span class="line">        while (pA != pB) &#123;</span><br><span class="line">            pA = pA == nullptr ? headB : pA-&gt;next;</span><br><span class="line">            pB = pB == nullptr ? headA : pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/majority-element/">169. 多数元素</a></h1><p><img src="https://files.mdnice.com/user/1489/edd0b34a-aae0-4667-8e36-645c0c1fbd04.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Approach 1: Brute Force</span><br><span class="line">Intuition</span><br><span class="line">We can exhaust the search space in quadratic time by checking whether each element is the majority element.</span><br><span class="line"></span><br><span class="line">Algorithm</span><br><span class="line">The brute force algorithm iterates over the array, and then iterates again for each number to count its occurrences. As soon as a number is found to have appeared more than any other can possibly have appeared, return it.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Complexity Analysis</span><br><span class="line">Time complexity : O(n^2)</span><br><span class="line"></span><br><span class="line">The brute force algorithm contains two nested for loops that each run for nn iterations, adding up to quadratic time complexity.</span><br><span class="line"></span><br><span class="line">Space complexity : O(1)</span><br><span class="line"></span><br><span class="line">The brute force solution does not allocate additional space proportional to the input size.</span><br></pre></td></tr></table></figure>



<p><img src="https://files.mdnice.com/user/1489/4f33e6e4-017a-4f41-81a0-7f60d1d578f0.png"></p>
<h2 id="Solution-1-哈希表"><a href="#Solution-1-哈希表" class="headerlink" title="Solution 1 哈希表"></a>Solution 1 哈希表</h2><p><img src="https://files.mdnice.com/user/1489/eb446da9-85b1-4898-b238-ee7548e16cc1.png"></p>
<p><img src="https://files.mdnice.com/user/1489/d6347f35-ca4c-425c-b8ca-6b7e2ae2ab07.png"></p>
<h2 id="Solution-2-排序"><a href="#Solution-2-排序" class="headerlink" title="Solution 2  排序"></a>Solution 2  排序</h2><p><img src="https://files.mdnice.com/user/1489/a8de2fa0-7abe-474d-a113-bca524a5c19d.png"></p>
<h2 id="Solution-3-Boyer-Moore-投票法"><a href="#Solution-3-Boyer-Moore-投票法" class="headerlink" title="Solution 3  Boyer-Moore 投票法"></a>Solution 3  Boyer-Moore 投票法</h2><p><img src="https://files.mdnice.com/user/1489/f451fbd9-f97d-4b05-9a25-92f9f405369b.png"></p>
<h1 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172. 阶乘后的零"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/factorial-trailing-zeroes/">172. 阶乘后的零</a></h1><p>给定一个整数 n ，返回 n! 结果中尾随零的数量。</p>
<p>提示 n! &#x3D; n * (n - 1) * (n - 2) * … * 3 * 2 * 1</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 3<br>输出：0<br>解释：3! &#x3D; 6 ，不含尾随 0<br>示例 2：</p>
<p>输入：n &#x3D; 5<br>输出：1<br>解释：5! &#x3D; 120 ，有一个尾随 0<br>示例 3：</p>
<p>输入：n &#x3D; 0<br>输出：0
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; n &lt;&#x3D; 104
 </p>
<p><img src="https://files.mdnice.com/user/1489/90ee8419-0d4e-4f4f-9e93-06007789a613.png"></p>
<h2 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1"></a>Solution1</h2><p>首先题目的意思是末尾有几个0<br> 比如6! &#x3D; 【1* 2* 3* 4* 5* 6】<br>    其中只有2<em>5末尾才有0，所以就可以抛去其他数据 专门看2 5 以及其倍数 毕竟 4 * 25末尾也是0<br>    比如10！ &#x3D; 【2</em>4<em>5</em>6<em>8</em>10】<br>    其中 4能拆成2<em>2  10能拆成2</em>5<br>    所以10！ &#x3D; 【2<em>（2</em>2）<em>5</em>（2<em>3）</em>（2<em>2</em>2）<em>（2</em>5）】<br>    一个2和一个5配对 就产生一个0 所以10！末尾2个0</p>
<pre><code>转头一想 2肯定比5多 所以只数5的个数就行了

假若N=31 31里能凑10的5为[5, 2*5, 3*5, 4*5, 25, 6*5] 
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trailingZeroes(int n) &#123;</span><br><span class="line">        int res=0;</span><br><span class="line">	    for(int i=n;i&gt;0;i/=5)&#123;</span><br><span class="line">		    res+=i/5;</span><br><span class="line">	    &#125;</span><br><span class="line">	    return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179. 最大数"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/largest-number/">179. 最大数</a></h1><p>给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p>
<p>注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [10,2]<br>输出：”210”<br>示例 2：</p>
<p>输入：nums &#x3D; [3,30,34,5,9]<br>输出：”9534330”
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Intuition</span><br><span class="line"></span><br><span class="line">To construct the largest number, we want to ensure that the most significant digits are occupied by the largest digits.</span><br><span class="line"></span><br><span class="line">Algorithm</span><br><span class="line"></span><br><span class="line">First, we convert each integer to a string. Then, we sort the array of strings.</span><br><span class="line"></span><br><span class="line">While it might be tempting to simply sort the numbers in descending order, this causes problems for sets of numbers with the same leading digit. For example, sorting the problem example in descending order would produce the number 95343039534303, while the correct answer can be achieved by transposing the 33 and the 3030. Therefore, for each pairwise comparison during the sort, we compare the numbers achieved by concatenating the pair in both orders. We can prove that this sorts into the proper order as follows:</span><br><span class="line"></span><br><span class="line">Assume that (without loss of generality), for some pair of integers aa and bb, our comparator dictates that aa should precede bb in sorted order. This means that a\frown b &gt; b\frown aa⌢b&gt;b⌢a (where \frown⌢ represents concatenation). For the sort to produce an incorrect ordering, there must be some cc for which bb precedes cc and cc precedes aa. This is a contradiction because a\frown b &gt; b\frown aa⌢b&gt;b⌢a and b\frown c &gt; c\frown bb⌢c&gt;c⌢b implies a\frown c &gt; c\frown aa⌢c&gt;c⌢a. In other words, our custom comparator preserves transitivity, so the sort is correct.</span><br><span class="line"></span><br><span class="line">Once the array is sorted, the most &quot;signficant&quot; number will be at the front. There is a minor edge case that comes up when the array consists of only zeroes, so if the most significant number is 00, we can simply return 00. Otherwise, we build a string out of the sorted array and return it.</span><br></pre></td></tr></table></figure>

<h2 id="Solution0-暴力-3"><a href="#Solution0-暴力-3" class="headerlink" title="Solution0 暴力"></a>Solution0 暴力</h2><h2 id="Solution1-排序-2"><a href="#Solution1-排序-2" class="headerlink" title="Solution1 排序"></a>Solution1 排序</h2><p>自定义一种排序方式 比较 s1 + s2 和 s2 + s1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    static bool cmp(int a,int b)&#123;</span><br><span class="line">        string sa = to_string(a);</span><br><span class="line">        string sb = to_string(b);</span><br><span class="line">        return sa+sb&gt;sb+sa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string largestNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(),nums.end(),cmp);</span><br><span class="line">        string ret;</span><br><span class="line">        for(auto num:nums)&#123;</span><br><span class="line">            if(!(num==0&amp;&amp;ret[0]==&#x27;0&#x27;)) ret+=to_string(num);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><img src="https://files.mdnice.com/user/1489/724583f7-e9bf-46be-a2e9-235ba7e2d358.png"></p>
<h1 id="187-重复的DNA序列"><a href="#187-重复的DNA序列" class="headerlink" title="187. 重复的DNA序列"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></h1><p>DNA序列 由一系列核苷酸组成，缩写为 ‘A’, ‘C’, ‘G’ 和 ‘T’.。</p>
<p>例如，”ACGAATTCCG” 是一个 DNA序列 。<br>在研究 DNA 时，识别 DNA 中的重复序列非常有用。</p>
<p>给定一个表示 DNA序列 的字符串 s ，返回所有在 DNA 分子中出现不止一次的 长度为 10 的序列(子字符串)。你可以按 任意顺序 返回答案。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT”<br>输出：[“AAAAACCCCC”,”CCCCCAAAAA”]<br>示例 2：</p>
<p>输入：s &#x3D; “AAAAAAAAAAAAA”<br>输出：[“AAAAAAAAAA”]
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; s.length &lt;&#x3D; 105<br>s[i]&#x3D;&#x3D;’A’、’C’、’G’ or ‘T’</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Simple sliding window solution.</span><br><span class="line">comments added for better explanation.</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123;</span><br><span class="line">         vector&lt;string&gt; ans;</span><br><span class="line">         map&lt;string,int&gt; mmap;</span><br><span class="line">        //storing the first 10 size substring(dna sequence) </span><br><span class="line">        //in temp</span><br><span class="line">         string temp=s.substr(0,10);</span><br><span class="line">       //adding first dna sequence to map</span><br><span class="line">        mmap[temp]++;</span><br><span class="line">        //now the sliding window.</span><br><span class="line">        for(int i=10;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            //remove first character from exsisting substring</span><br><span class="line">            temp=temp.substr(1);</span><br><span class="line">            </span><br><span class="line">            //add the next character in substring.</span><br><span class="line">            temp=temp+s[i];</span><br><span class="line">            </span><br><span class="line">            //add the new dna sequence to map.</span><br><span class="line">            mmap[temp]++;</span><br><span class="line">            </span><br><span class="line">            //if the count of given sequence is greater than 2</span><br><span class="line">            //and it is not present in out ans vector push it in</span><br><span class="line">            //it</span><br><span class="line">            </span><br><span class="line">            //we have done the find operation to keep the elements in answer vector</span><br><span class="line">            //unique.</span><br><span class="line">            //for example if aa...a sequence is present 4 times, it will adding 4 times</span><br><span class="line">            //in ans according to our sliding window logic. but we want it only one time.</span><br><span class="line">            //therefore we check in our vector if the given dna sequence is already present or not/</span><br><span class="line">            if(mmap[temp]&gt;1 and find(ans.begin(),ans.end(),temp)==ans.end())</span><br><span class="line">            &#123;</span><br><span class="line">                ans.push_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-哈希表-2"><a href="#Solution1-哈希表-2" class="headerlink" title="Solution1 哈希表"></a>Solution1 哈希表</h2><p>我们可以用一个哈希表统计 ss 所有长度为 1010 的子串的出现次数，返回所有出现次数超过 1010 的子串。</p>
<p>代码实现时，可以一边遍历子串一边记录答案，为了不重复记录答案，我们只统计当前出现次数为 22 的子串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    const int L = 10;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        unordered_map&lt;string, int&gt; cnt;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        for (int i = 0; i &lt;= n - L; ++i) &#123;</span><br><span class="line">            string sub = s.substr(i, L);</span><br><span class="line">            if (++cnt[sub] == 2) &#123;</span><br><span class="line">                ans.push_back(sub);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution2-哈希表-滑动窗口-二进制"><a href="#Solution2-哈希表-滑动窗口-二进制" class="headerlink" title="Solution2 哈希表 滑动窗口 二进制"></a>Solution2 哈希表 滑动窗口 二进制</h2><p><img src="https://files.mdnice.com/user/1489/971e09e6-1b22-4c78-a3bc-956a6d4f1827.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    const int L = 10;</span><br><span class="line">    unordered_map&lt;char, int&gt; bin = &#123;&#123;&#x27;A&#x27;, 0&#125;, &#123;&#x27;C&#x27;, 1&#125;, &#123;&#x27;G&#x27;, 2&#125;, &#123;&#x27;T&#x27;, 3&#125;&#125;;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        if (n &lt;= L) &#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int i = 0; i &lt; L - 1; ++i) &#123;</span><br><span class="line">            x = (x &lt;&lt; 2) | bin[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;int, int&gt; cnt;</span><br><span class="line">        for (int i = 0; i &lt;= n - L; ++i) &#123;</span><br><span class="line">            x = ((x &lt;&lt; 2) | bin[s[i + L - 1]]) &amp; ((1 &lt;&lt; (L * 2)) - 1);</span><br><span class="line">            if (++cnt[x] == 2) &#123;</span><br><span class="line">                ans.push_back(s.substr(i, L));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>






<h1 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotate-array/">189. 轮转数组</a></h1><p>给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右轮转 1 步: [7,1,2,3,4,5,6]<br>向右轮转 2 步: [6,7,1,2,3,4,5]<br>向右轮转 3 步: [5,6,7,1,2,3,4]<br>示例 2:</p>
<p>输入：nums &#x3D; [-1,-100,3,99], k &#x3D; 2<br>输出：[3,99,-1,-100]<br>解释:<br>向右轮转 1 步: [99,-1,-100,3]<br>向右轮转 2 步: [3,99,-1,-100]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1<br>0 &lt;&#x3D; k &lt;&#x3D; 105</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// o(n) This solution is simply reversing the array and the reversing array from 0 to k-1 and then from k to n-1. Do a dry run by taking an example on copy and you will usndersand it. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// o(n) Using extra space approach we simply store the last k elemets in same order from n-k to n-1 in a temp vector and we then pushback the reaining elements in the temp vector from index 0 to n-k-1; </span><br><span class="line"></span><br><span class="line">/ o(n*k) we roatate elements of the vector one by one for k times and achieve k roatations.</span><br></pre></td></tr></table></figure>
<h2 id="Solution1-使用额外的数组"><a href="#Solution1-使用额外的数组" class="headerlink" title="Solution1 使用额外的数组"></a>Solution1 使用额外的数组</h2><p><img src="https://files.mdnice.com/user/1489/df37bbbe-bbbb-4e52-b5ae-5ba6fd84cd30.png"></p>
<h2 id="Solution2-数组翻转"><a href="#Solution2-数组翻转" class="headerlink" title="Solution2  数组翻转"></a>Solution2  数组翻转</h2><p><img src="https://files.mdnice.com/user/1489/cd09a3b7-fdbb-469a-8609-f64f592fda01.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reverse(vector&lt;int&gt;&amp; nums, int start, int end) &#123;</span><br><span class="line">        while (start &lt; end) &#123;</span><br><span class="line">            swap(nums[start], nums[end]);</span><br><span class="line">            start += 1;</span><br><span class="line">            end -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        k %= nums.size();</span><br><span class="line">        reverse(nums, 0, nums.size() - 1);</span><br><span class="line">        reverse(nums, 0, k - 1);</span><br><span class="line">        reverse(nums, k, nums.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/happy-number/">202. 快乐数</a></h1><p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」 定义为：</p>
<p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<br>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。<br>如果这个过程 结果为 1，那么这个数就是快乐数。<br>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 19<br>输出：true<br>解释：<br>12 + 92 &#x3D; 82<br>82 + 22 &#x3D; 68<br>62 + 82 &#x3D; 100<br>12 + 02 + 02 &#x3D; 1<br>示例 2：</p>
<p>输入：n &#x3D; 2<br>输出：false
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 231 - 1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1.hash-set</span><br><span class="line"></span><br><span class="line">The hash-set solution is very straightforward. For every new data, we check whether it is already in the set. If no, we insert it into the set. If yes, we detect the loop. Only when the node in the loop is &quot;1&quot;, the number is happy number.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.hash-map</span><br><span class="line"></span><br><span class="line">The idea is similar as hase-set. We check the node value to check whether it is in the loop.</span><br><span class="line"></span><br><span class="line">The code is as follow. The time complexity usually is O(1) (the worst may be O(n) due to conflict)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.Floyd&#x27;s Cycle detection algorithm</span><br><span class="line"></span><br><span class="line">Floyd&#x27;s cycle detection algorithm is a pointer algorithm that uses only two pointers, which move through the sequence at different speeds. Obviously, if there is a loop, they will meet in the loop. It is also called the &quot;tortoise and the hare algorithm&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.Brent&#x27;s Cycle detection algorithm</span><br><span class="line"></span><br><span class="line">Brent&#x27;s algorithm features a moving rabbit and a stationary, then teleporting, turtle. Both turtle and rabbit start at the top of the list. The rabbit takes one step per iteration. Every once in a while, we teleport the turtle to the rabbit&#x27;s position, and let the rabbit continue moving. We start out waiting just 2 steps before teleportation, and we double that each time we move the turtle. If there is a loop, they will meet in the loop.</span><br><span class="line"></span><br><span class="line">The code is as follows. The time complexity is O(λ + μ)*. However you&#x27;re doing less stepping than with Floyd&#x27;s (in fact the upper bound for steps is the number you would do with Floyd&#x27;s algorithm). According to Brent&#x27;s research, his algorithm is 24-36% faster on average for implicit linked list algorithms.(However, it cost same time as the Floyd&#x27;s in the OJ ;) )</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-快慢指针"><a href="#Solution1-快慢指针" class="headerlink" title="Solution1 快慢指针"></a>Solution1 快慢指针</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//参考英文网站热评第一。这题可以用快慢指针的思想去做，有点类似于检测是否为环形链表那道题</span><br><span class="line">//如果给定的数字最后会一直循环重复，那么快的指针（值）一定会追上慢的指针（值），也就是</span><br><span class="line">//两者一定会相等。如果没有循环重复，那么最后快慢指针也会相等，且都等于1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isHappy(int n) &#123;</span><br><span class="line">        int fast=n;</span><br><span class="line">        int slow=n;</span><br><span class="line">        do&#123;</span><br><span class="line">            slow=squareSum(slow);</span><br><span class="line">            fast=squareSum(fast);</span><br><span class="line">            fast=squareSum(fast);</span><br><span class="line">        &#125;while(slow!=fast);</span><br><span class="line">        if(fast==1)</span><br><span class="line">            return true;</span><br><span class="line">        else return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private int squareSum(int m)&#123;</span><br><span class="line">        int squaresum=0;</span><br><span class="line">        while(m!=0)&#123;</span><br><span class="line">           squaresum+=(m%10)*(m%10);</span><br><span class="line">            m/=10;</span><br><span class="line">        &#125;</span><br><span class="line">        return squaresum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution2-暴力"><a href="#Solution2-暴力" class="headerlink" title="Solution2 暴力"></a>Solution2 暴力</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isHappy(int n) &#123;</span><br><span class="line">        int ans=0;</span><br><span class="line">        for(int i = 0 ; i&lt; 100;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            while(n&gt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                ans += (n%10)*(n%10);</span><br><span class="line">                n = n /10;</span><br><span class="line">            &#125;</span><br><span class="line">            n = ans;</span><br><span class="line">            if(n==1)</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-linked-list-elements/">203. 移除链表元素</a></h1><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。
 </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6<br>输出：[1,2,3,4,5]<br>示例 2：</p>
<p>输入：head &#x3D; [], val &#x3D; 1<br>输出：[]<br>示例 3：</p>
<p>输入：head &#x3D; [7,7,7,7], val &#x3D; 7<br>输出：[]
 </p>
<p>提示：</p>
<p>列表中的节点数目在范围 [0, 104] 内<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 50<br>0 &lt;&#x3D; val &lt;&#x3D; 50</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">✔️ Solution - I (Iterative using Dummy node)</span><br><span class="line"></span><br><span class="line">A simple solution to delete the nodes having value T is to traverse over the linked list and just remove the next pointers to the node having value as T. Now, usually in deletion problem of linked list, there can be multiple cases where node to be deleted is either a head node or other node in rest of list. We usually make use of a dummy node at the start or sentinel node to avoid handling multiple edge cases and write a clean uniform solution.</span><br><span class="line"></span><br><span class="line">So, the algorithm we are using can be summarised as -</span><br><span class="line"></span><br><span class="line">Initialize a dummy/sentinel node having its next pointer pointing to the head of linked list and another node pointer prev pointing to this dummy node.</span><br><span class="line">Start iterating over head of linked list</span><br><span class="line">If current node&#x27;s value is not equal to T, we can just move to next node without deleting current node. In this case,</span><br><span class="line">We first update prev pointer and point it to current head</span><br><span class="line">Then move head to next node.</span><br><span class="line">Otherwise, if head -&gt; val == T, we know that this node needs to be deleted. In this case,</span><br><span class="line">We can just update the next pointer of previous node to the next pointer of current node. This will basically remove the current node from list.</span><br><span class="line">Then, we update head to its next node just as in previous case.</span><br><span class="line">Finally, ignore the dummy node created at start and return its next node.</span><br></pre></td></tr></table></figure>
<h2 id="Solution1-迭代-1"><a href="#Solution1-迭代-1" class="headerlink" title="Solution1 迭代"></a>Solution1 迭代</h2><p><img src="https://files.mdnice.com/user/1489/b2e898e8-a1bf-4e57-88b2-00546145e9d0.png"></p>
<h2 id="Solution2-递归-2"><a href="#Solution2-递归-2" class="headerlink" title="Solution2 递归"></a>Solution2 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListNode *removeElements(ListNode *head, int val)</span><br><span class="line">&#123;</span><br><span class="line">    if (!head)</span><br><span class="line">        return head;</span><br><span class="line">    head-&gt;next = removeElements(head-&gt;next, val);</span><br><span class="line">    return head-&gt;val == val ? head-&gt;next : head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析<br>时间复杂度：O(n)O(n)，其中 nn 是链表的长度。需要遍历链表一次。<br>空间复杂度：O(1)O(1)。</p>
<h1 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h1><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: [3,2,1,5,6,4], k &#x3D; 2<br>输出: 5<br>示例 2:</p>
<p>输入: [3,2,3,1,2,4,5,5,6], k &#x3D; 4<br>输出: 4
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; k &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">This problem is well known and quite often can be found in various text books.</span><br><span class="line"></span><br><span class="line">You can take a couple of approaches to actually solve it:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">O(N lg K) running time + O(K) memory</span><br><span class="line">Other possibility is to use a min oriented priority queue that will store the K-th largest values. The algorithm iterates over the whole input and maintains the size of priority queue.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">O(N) best case / O(N^2) worst case running time + O(1) memory</span><br><span class="line">The smart approach for this problem is to use the selection algorithm (based on the partion method - the same one as used in quicksort).</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">O(N) guaranteed running time + O(1) space</span><br><span class="line"></span><br><span class="line">So how can we improve the above solution and make it O(N) guaranteed? The answer is quite simple, we can randomize the input, so that even when the worst case input would be provided the algorithm wouldn&#x27;t be affected. So all what it is needed to be done is to shuffle the input.</span><br></pre></td></tr></table></figure>
<h2 id="Solution1-堆排序"><a href="#Solution1-堆排序" class="headerlink" title="Solution1  堆排序"></a>Solution1  堆排序</h2><p><img src="https://files.mdnice.com/user/1489/bb70337e-337f-4525-9b82-628e0ababa73.png"></p>
<p>复杂度分析</p>
<p>时间复杂度：O(n \log n)O(nlogn)，建堆的时间代价是 O(n)O(n)，删除的总代价是 O(k \log n)O(klogn)，因为 k &lt; nk&lt;n，故渐进时间复杂为 O(n + k \log n) &#x3D; O(n \log n)O(n+klogn)&#x3D;O(nlogn)。<br>空间复杂度：O(\log n)O(logn)，即递归使用栈空间的空间代价。</p>
<p><img src="https://files.mdnice.com/user/1489/6b0ad4c7-d06d-477f-a7be-fc2e043a0db5.png"></p>
<h1 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/contains-duplicate/">217. 存在重复元素</a></h1><p>给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。
 </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3,1]<br>输出：true<br>示例 2：</p>
<p>输入：nums &#x3D; [1,2,3,4]<br>输出：false<br>示例 3：</p>
<p>输入：nums &#x3D; [1,1,1,3,3,4,3,2,4,2]<br>输出：true
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">This problem seems trivial, so lets try different approaches to solve it:</span><br><span class="line"></span><br><span class="line">Starting from worst time complexity to the best one:</span><br><span class="line"></span><br><span class="line">Time complexity: O(N^2), memory: O(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The naive approach would be to run a iteration for each element and see whether a duplicate value can be found: this results in O(N^2) time complexity.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Time complexity: O(N lg N), memory: O(1) - not counting the memory used by sort</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Since it is trivial task to find duplicates in sorted array, we can sort it as the first step of the algorithm and then search for consecutive duplicates.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Time complexity: O(N), memory: O(N)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Finally we can used a well known data structure hash table that will help us to identify whether an element has been previously encountered in the array.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">This is trivial but quite nice example of space-time tradeoff.</span><br></pre></td></tr></table></figure>
<h2 id="Solution1-排序-3"><a href="#Solution1-排序-3" class="headerlink" title="Solution1  排序"></a>Solution1  排序</h2><p><img src="https://files.mdnice.com/user/1489/30ba428f-42b6-472b-8b8b-23aaef1c23b6.png"></p>
<h2 id="Solution2-4"><a href="#Solution2-4" class="headerlink" title="Solution2"></a>Solution2</h2><p><img src="https://files.mdnice.com/user/1489/f14525cf-e0bb-44a5-a385-54ae95316f9b.png"></p>
<h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h1><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p>
<p>实现 MyStack 类：</p>
<p>void push(int x) 将元素 x 压入栈顶。<br>int pop() 移除并返回栈顶元素。<br>int top() 返回栈顶元素。<br>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。
 </p>
<p>注意：</p>
<p>你只能使用队列的基本操作 —— 也就是 push to back、peek&#x2F;pop from front、size 和 is empty 这些操作。<br>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
 </p>
<p>示例：</p>
<p>输入：<br>[“MyStack”, “push”, “push”, “top”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>输出：<br>[null, null, null, 2, 2, false]</p>
<p>解释：<br>MyStack myStack &#x3D; new MyStack();<br>myStack.push(1);<br>myStack.push(2);<br>myStack.top(); &#x2F;&#x2F; 返回 2<br>myStack.pop(); &#x2F;&#x2F; 返回 2<br>myStack.empty(); &#x2F;&#x2F; 返回 False
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; x &lt;&#x3D; 9<br>最多调用100 次 push、pop、top 和 empty<br>每次调用 pop 和 top 都保证栈不为空</p>
<p><img src="https://files.mdnice.com/user/1489/75306b0a-0beb-4576-a53e-49b2835d09c8.png"></p>
<p><img src="https://files.mdnice.com/user/1489/04e73830-74d3-4ebe-9b91-a8058dd5f0d8.png"></p>
<p><img src="https://files.mdnice.com/user/1489/37f7ba54-f044-48a7-a5fc-c2d9a82f7b3c.png"></p>
<h2 id="Solution1-两个队列"><a href="#Solution1-两个队列" class="headerlink" title="Solution1  两个队列"></a>Solution1  两个队列</h2><p><img src="https://files.mdnice.com/user/1489/44e2b2c5-3a86-4e20-97d1-45502d4bfc29.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line">public:</span><br><span class="line">    queue&lt;int&gt; queue1;</span><br><span class="line">    queue&lt;int&gt; queue2;</span><br><span class="line"></span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    MyStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Push element x onto stack. */</span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        queue2.push(x);</span><br><span class="line">        while (!queue1.empty()) &#123;</span><br><span class="line">            queue2.push(queue1.front());</span><br><span class="line">            queue1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        swap(queue1, queue2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Removes the element on top of the stack and returns that element. */</span><br><span class="line">    int pop() &#123;</span><br><span class="line">        int r = queue1.front();</span><br><span class="line">        queue1.pop();</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Get the top element. */</span><br><span class="line">    int top() &#123;</span><br><span class="line">        int r = queue1.front();</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns whether the stack is empty. */</span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return queue1.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution2-单个队列"><a href="#Solution2-单个队列" class="headerlink" title="Solution2 单个队列"></a>Solution2 单个队列</h2><p><img src="https://files.mdnice.com/user/1489/aa634f7b-decf-4a6c-8e21-80efe413f3c1.png"></p>
<h1 id="227-基本计算器-II"><a href="#227-基本计算器-II" class="headerlink" title="227. 基本计算器 II"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/basic-calculator-ii/">227. 基本计算器 II</a></h1><p>给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。</p>
<p>整数除法仅保留整数部分。</p>
<p>你可以假设给定的表达式总是有效的。所有中间结果将在 [-231, 231 - 1] 的范围内。</p>
<p>注意：不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “3+2*2”<br>输出：7<br>示例 2：</p>
<p>输入：s &#x3D; “ 3&#x2F;2 “<br>输出：1<br>示例 3：</p>
<p>输入：s &#x3D; “ 3+5 &#x2F; 2 “<br>输出：5
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 3 * 105<br>s 由整数和算符 (‘+’, ‘-‘, ‘*’, ‘&#x2F;‘) 组成，中间由一些空格隔开<br>s 表示一个 有效表达式<br>表达式中的所有整数都是非负整数，且在范围 [0, 231 - 1] 内<br>题目数据保证答案是一个 32-bit 整数</p>
<p><img src="https://files.mdnice.com/user/1489/9f8c8e11-c866-4407-8346-5dee64d57879.png"></p>
<p><img src="https://files.mdnice.com/user/1489/ad0cf225-2160-4223-8147-528ce599990c.png"></p>
<h2 id="Solution1-栈-2"><a href="#Solution1-栈-2" class="headerlink" title="Solution1 栈"></a>Solution1 栈</h2><p>方法一：栈<br>思路</p>
<p>由于乘除优先于加减计算，因此不妨考虑先进行所有乘除运算，并将这些乘除运算后的整数值放回原表达式的相应位置，则随后整个表达式的值，就等于一系列整数加减后的值。</p>
<p>基于此，我们可以用一个栈，保存这些（进行乘除运算后的）整数的值。对于加减号后的数字，将其直接压入栈中；对于乘除号后的数字，可以直接与栈顶元素计算，并替换栈顶元素为计算后的结果。</p>
<p>具体来说，遍历字符串 ss，并用变量 \textit{preSign}preSign 记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。每次遍历到数字末尾时，根据 \textit{preSign}preSign 来决定计算方式：</p>
<p>加号：将数字压入栈；<br>减号：将数字的相反数压入栈；<br>乘除号：计算数字与栈顶元素，并将栈顶元素替换为计算结果。<br>代码实现中，若读到一个运算符，或者遍历到字符串末尾，即认为是遍历到了数字末尾。处理完该数字后，更新 \textit{preSign}preSign 为当前遍历的字符。</p>
<p>遍历完字符串 ss 后，将栈中元素累加，即为该字符串表达式的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int calculate(string s) &#123;</span><br><span class="line">        vector&lt;int&gt; stk;</span><br><span class="line">        char preSign = &#x27;+&#x27;;</span><br><span class="line">        int num = 0;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (isdigit(s[i])) &#123;</span><br><span class="line">                num = num * 10 + int(s[i] - &#x27;0&#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!isdigit(s[i]) &amp;&amp; s[i] != &#x27; &#x27; || i == n - 1) &#123;</span><br><span class="line">                switch (preSign) &#123;</span><br><span class="line">                    case &#x27;+&#x27;:</span><br><span class="line">                        stk.push_back(num);</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;-&#x27;:</span><br><span class="line">                        stk.push_back(-num);</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;*&#x27;:</span><br><span class="line">                        stk.back() *= num;</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        stk.back() /= num;</span><br><span class="line">                &#125;</span><br><span class="line">                preSign = s[i];</span><br><span class="line">                num = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return accumulate(stk.begin(), stk.end(), 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 为字符串 ss 的长度。需要遍历字符串 ss 一次，计算表达式的值。</p>
<p>空间复杂度：O(n)O(n)，其中 nn 为字符串 ss 的长度。空间复杂度主要取决于栈的空间，栈的元素个数不超过 nn。</p>
<h1 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h1><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p>
<p>实现 MyQueue 类：</p>
<p>void push(int x) 将元素 x 推到队列的末尾<br>int pop() 从队列的开头移除并返回元素<br>int peek() 返回队列开头的元素<br>boolean empty() 如果队列为空，返回 true ；否则，返回 false<br>说明：</p>
<p>你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
 </p>
<p>示例 1：</p>
<p>输入：<br>[“MyQueue”, “push”, “push”, “peek”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>输出：<br>[null, null, null, 1, 1, false]</p>
<p>解释：<br>MyQueue myQueue &#x3D; new MyQueue();<br>myQueue.push(1); &#x2F;&#x2F; queue is: [1]<br>myQueue.push(2); &#x2F;&#x2F; queue is: [1, 2] (leftmost is front of the queue)<br>myQueue.peek(); &#x2F;&#x2F; return 1<br>myQueue.pop(); &#x2F;&#x2F; return 1, queue is [2]<br>myQueue.empty(); &#x2F;&#x2F; return false</p>
<p><img src="https://files.mdnice.com/user/1489/feb1c7fb-24cf-4081-a9db-574dc3b46711.png"></p>
<p><img src="https://files.mdnice.com/user/1489/7a9ccbf5-4ed2-4bdd-aaeb-5b91d2e4c7a1.png"></p>
<h2 id="Solution1-3"><a href="#Solution1-3" class="headerlink" title="Solution1"></a>Solution1</h2><p><img src="https://files.mdnice.com/user/1489/3cd35f16-15b6-4698-8053-935ffdd85349.png"><br>思路</p>
<p>将一个栈当作输入栈，用于压入 \texttt{push}push 传入的数据；另一个栈当作输出栈，用于 \texttt{pop}pop 和 \texttt{peek}peek 操作。</p>
<p>每次 \texttt{pop}pop 或 \texttt{peek}peek 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class MyQueue &#123;</span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; inStack, outStack;</span><br><span class="line"></span><br><span class="line">    void in2out() &#123;</span><br><span class="line">        while (!inStack.empty()) &#123;</span><br><span class="line">            outStack.push(inStack.top());</span><br><span class="line">            inStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    MyQueue() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">        if (outStack.empty()) &#123;</span><br><span class="line">            in2out();</span><br><span class="line">        &#125;</span><br><span class="line">        int x = outStack.top();</span><br><span class="line">        outStack.pop();</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int peek() &#123;</span><br><span class="line">        if (outStack.empty()) &#123;</span><br><span class="line">            in2out();</span><br><span class="line">        &#125;</span><br><span class="line">        return outStack.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return inStack.empty() &amp;&amp; outStack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="https://files.mdnice.com/user/1489/7ee6b978-400a-44f6-8197-a9507c8e058b.png"></p>
<h1 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindrome-linked-list/">234. 回文链表</a></h1><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,2,1]<br>输出：true<br>示例 2：</p>
<p>输入：head &#x3D; [1,2]<br>输出：false
 </p>
<p>提示：</p>
<p>链表中节点数目在范围[1, 105] 内<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 9
 </p>
<p>进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Functions used below are HEART n SOUL of linkedlist questions. Usually, any LinkedList question can be broken down to these functions:-</span><br><span class="line"></span><br><span class="line">Reverse ===&gt; Used for space optimization</span><br><span class="line">Find Mid ===&gt; Slow-Fast Pointer</span><br><span class="line">Iteration : normal iter, recursive iter, adjacent node 2-vars, slow-fast</span><br><span class="line">Insert : start , mid, last</span><br><span class="line">delete : start, mid, last</span><br><span class="line">THIS QUESTION:</span><br><span class="line">find Mid of linkedlist --------&gt; do see cases of even/odd length on paper</span><br><span class="line">reverse second half from mid pointer ----&gt; see how prev gets changed</span><br><span class="line">Now compare first and second half Easy huh! 😜</span><br><span class="line">EdgeCase:</span><br><span class="line">linkedlist size =0,1</span><br></pre></td></tr></table></figure>

<h2 id="Solution0-将链表复制到数组"><a href="#Solution0-将链表复制到数组" class="headerlink" title="Solution0 将链表复制到数组"></a>Solution0 将链表复制到数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        vector&lt;int&gt; vals;</span><br><span class="line">        while (head != nullptr) &#123;</span><br><span class="line">            vals.emplace_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0, j = (int)vals.size() - 1; i &lt; j; ++i, --j) &#123;</span><br><span class="line">            if (vals[i] != vals[j]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="Solution1-中点开始比较"><a href="#Solution1-中点开始比较" class="headerlink" title="Solution1 中点开始比较"></a>Solution1 中点开始比较</h2><p><img src="https://files.mdnice.com/user/1489/86154c4e-b8da-4890-ab23-b2612d4c5777.png"></p>
<h1 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237. 删除链表中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/delete-node-in-a-linked-list/">237. 删除链表中的节点</a></h1><p>有一个单链表的 head，我们想删除它其中的一个节点 node。</p>
<p>给你一个需要删除的节点 node 。你将 无法访问 第一个节点  head。</p>
<p>链表的所有值都是 唯一的，并且保证给定的节点 node 不是链表中的最后一个节点。</p>
<p>删除给定的节点。注意，删除节点并不是指从内存中删除它。这里的意思是：</p>
<p>给定节点的值不应该存在于链表中。<br>链表中的节点数应该减少 1。<br>node 前面的所有值顺序相同。<br>node 后面的所有值顺序相同。<br>自定义测试：</p>
<p>对于输入，你应该提供整个链表 head 和要给出的节点 node。node 不应该是链表的最后一个节点，而应该是链表中的一个实际节点。<br>我们将构建链表，并将节点传递给你的函数。<br>输出将是调用你函数后的整个链表。
 </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [4,5,1,9], node &#x3D; 5<br>输出：[4,1,9]<br>解释：指定链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9<br>示例 2：</p>
<p>输入：head &#x3D; [4,5,1,9], node &#x3D; 1<br>输出：[4,5,9]<br>解释：指定链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9
 </p>
<p>提示：</p>
<p>链表中节点的数目范围是 [2, 1000]<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000<br>链表中每个节点的值都是 唯一 的<br>需要删除的节点 node 是 链表中的节点 ，且 不是末尾节点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void deleteNode(ListNode node) &#123;</span><br><span class="line">        node.val=node.next.val;</span><br><span class="line">        node.next=node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">So, this is our code.</span><br><span class="line">We don&#x27;t have the access to the previous node of the to be deleted node.</span><br><span class="line">But we have the access to the next node, which makes deletion of next node possible.</span><br><span class="line">So, we copy the value of the next node to this node and delete the next node (i.e connecting our current node to the next node&#x27;s next)</span><br><span class="line"></span><br><span class="line">Hopefully you understood, Thank you 😀</span><br></pre></td></tr></table></figure>
<h2 id="Solution1-4"><a href="#Solution1-4" class="headerlink" title="Solution1"></a>Solution1</h2><p><img src="https://files.mdnice.com/user/1489/f6a63c36-aafb-4e9c-a5c7-3eac3a044410.png"></p>
<h1 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h1><p>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。</p>
<p>题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。</p>
<p>请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: nums &#x3D; [1,2,3,4]<br>输出: [24,12,8,6]<br>示例 2:</p>
<p>输入: nums &#x3D; [-1,1,0,-3,3]<br>输出: [0,0,9,0,0]
 </p>
<p>提示：</p>
<p>2 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-30 &lt;&#x3D; nums[i] &lt;&#x3D; 30<br>保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">✔️ Solution - I (Calculate product &amp; divide by self)</span><br><span class="line"></span><br><span class="line">We can simply calculate product of the whole array and for each element in nums, divide the product by nums[i]. This effectively leaves us with product of whole array except self at each index. We need to take care of zeros that may occur in the array -</span><br><span class="line"></span><br><span class="line">1. If there are more than one 0s in nums, the result is an array consisting of all 0.</span><br><span class="line">2. If there is a single 0 in nums, then the result is an array consisting of all 0 except at the index where there was 0 in nums, which will contain product of rest of array.</span><br><span class="line">3. If there&#x27;s no 0 in nums, then the result is an array ans where ans[i] = prod / nums[i] (prod = product of all elements in nums).</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-累乘列表"><a href="#Solution1-累乘列表" class="headerlink" title="Solution1 累乘列表"></a>Solution1 累乘列表</h2><p><img src="https://files.mdnice.com/user/1489/4484458a-b006-4fe8-a7a8-ea586342ca22.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int length = nums.size();</span><br><span class="line"></span><br><span class="line">        // L 和 R 分别表示左右两侧的乘积列表</span><br><span class="line">        vector&lt;int&gt; L(length, 0), R(length, 0);</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; answer(length);</span><br><span class="line"></span><br><span class="line">        // L[i] 为索引 i 左侧所有元素的乘积</span><br><span class="line">        // 对于索引为 &#x27;0&#x27; 的元素，因为左侧没有元素，所以 L[0] = 1</span><br><span class="line">        L[0] = 1;</span><br><span class="line">        for (int i = 1; i &lt; length; i++) &#123;</span><br><span class="line">            L[i] = nums[i - 1] * L[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // R[i] 为索引 i 右侧所有元素的乘积</span><br><span class="line">        // 对于索引为 &#x27;length-1&#x27; 的元素，因为右侧没有元素，所以 R[length-1] = 1</span><br><span class="line">        R[length - 1] = 1;</span><br><span class="line">        for (int i = length - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">            R[i] = nums[i + 1] * R[i + 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积</span><br><span class="line">        for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            answer[i] = L[i] * R[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-空间复杂度为O-1-的方法"><a href="#Solution2-空间复杂度为O-1-的方法" class="headerlink" title="Solution2 空间复杂度为O(1)的方法"></a>Solution2 空间复杂度为O(1)的方法</h2><p><img src="https://files.mdnice.com/user/1489/448bc91c-0af2-4a4b-af89-c01fa606a5b7.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int length = nums.size();</span><br><span class="line">        vector&lt;int&gt; answer(length);</span><br><span class="line"></span><br><span class="line">        // answer[i] 表示索引 i 左侧所有元素的乘积</span><br><span class="line">        // 因为索引为 &#x27;0&#x27; 的元素左侧没有元素， 所以 answer[0] = 1</span><br><span class="line">        answer[0] = 1;</span><br><span class="line">        for (int i = 1; i &lt; length; i++) &#123;</span><br><span class="line">            answer[i] = nums[i - 1] * answer[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // R 为右侧所有元素的乘积</span><br><span class="line">        // 刚开始右边没有元素，所以 R = 1</span><br><span class="line">        int R = 1;</span><br><span class="line">        for (int i = length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            // 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span><br><span class="line">            answer[i] = answer[i] * R;</span><br><span class="line">            // R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span><br><span class="line">            R *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h1><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p>
<p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。
 </p>
<p>示例 1：</p>
<p>输入：matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 5<br>输出：true<br>示例 2：</p>
<p>输入：matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 20<br>输出：false<br> <br><img src="https://files.mdnice.com/user/1489/00e1d4fd-e285-4863-8b0b-3060766bb525.png"></p>
<p>提示：</p>
<p>m &#x3D;&#x3D; matrix.length<br>n &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; n, m &lt;&#x3D; 300<br>-109 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 109<br>每行的所有元素从左到右升序排列<br>每列的所有元素从上到下升序排列<br>-109 &lt;&#x3D; target &lt;&#x3D; 109</p>
<p><img src="https://files.mdnice.com/user/1489/cc8a492c-a4e6-4df7-a90d-320f17769205.png"></p>
<h2 id="Solution0-暴力-4"><a href="#Solution0-暴力-4" class="headerlink" title="Solution0 暴力"></a>Solution0 暴力</h2><h2 id="Solution1-从右上角看是一颗二叉搜索树"><a href="#Solution1-从右上角看是一颗二叉搜索树" class="headerlink" title="Solution1 从右上角看是一颗二叉搜索树"></a>Solution1 从右上角看是一颗二叉搜索树</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;</span><br><span class="line">        if(matrix.size() == 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int i = 0;</span><br><span class="line">        int j = matrix[0].size()-1;</span><br><span class="line">        while(i &lt; matrix.size() &amp;&amp; j &gt;= 0) &#123;</span><br><span class="line">            if(matrix[i][j] == target) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            if(matrix[i][j] &lt; target) &#123;</span><br><span class="line">                ++ i;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                -- j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-anagram/">242. 有效的字母异位词</a></h1><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: s &#x3D; “anagram”, t &#x3D; “nagaram”<br>输出: true<br>示例 2:</p>
<p>输入: s &#x3D; “rat”, t &#x3D; “car”<br>输出: false
 </p>
<p>提示:</p>
<p>1 &lt;&#x3D; s.length, t.length &lt;&#x3D; 5 * 104<br>s 和 t 仅包含小写字母</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Hash Table</span><br><span class="line"></span><br><span class="line">This idea uses a hash table to record the times of appearances of each letter in the two strings s and t. For each letter in s, it increases the counter by 1 while for each letter in t, it decreases the counter by 1. Finally, all the counters will be 0 if they two are anagrams of each other.</span><br><span class="line"></span><br><span class="line">The first implementation uses the built-in unordered_map and takes 36 ms.</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isAnagram(string s, string t) &#123;</span><br><span class="line">        if (s.length() != t.length()) return false;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        unordered_map&lt;char, int&gt; counts;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            counts[s[i]]++;</span><br><span class="line">            counts[t[i]]--;</span><br><span class="line">        &#125;</span><br><span class="line">        for (auto count : counts)</span><br><span class="line">            if (count.second) return false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Since the problem statement says that &quot;the string contains only lowercase alphabets&quot;, we can simply use an array to simulate the unordered_map and speed up the code. The following implementation takes 12 ms.</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isAnagram(string s, string t) &#123;</span><br><span class="line">        if (s.length() != t.length()) return false;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        int counts[26] = &#123;0&#125;;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123; </span><br><span class="line">            counts[s[i] - &#x27;a&#x27;]++;</span><br><span class="line">            counts[t[i] - &#x27;a&#x27;]--;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; 26; i++)</span><br><span class="line">            if (counts[i]) return false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Sorting</span><br><span class="line"></span><br><span class="line">For two anagrams, once they are sorted in a fixed order, they will become the same. This code is much shorter (this idea can be done in just 1 line using Python as here). However, it takes much longer time --- 76 ms in C++.</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isAnagram(string s, string t) &#123; </span><br><span class="line">        sort(s.begin(), s.end());</span><br><span class="line">        sort(t.begin(), t.end());</span><br><span class="line">        return s == t; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>C++ 三种方法：</p>
<h2 id="Solution1-1-直接用sort函数"><a href="#Solution1-1-直接用sort函数" class="headerlink" title="Solution1  1.直接用sort函数"></a>Solution1  1.直接用sort函数</h2><p>class Solution {<br>public:<br>    bool isAnagram(string s, string t) {<br>        sort(s.begin(),s.end());<br>        sort(t.begin(),t.end());<br>        if(s&#x3D;&#x3D;t)<br>            return true;<br>        else<br>            return false;<br>    }<br>};</p>
<h2 id="Solution2-2-map计数"><a href="#Solution2-2-map计数" class="headerlink" title="Solution2  2.map计数"></a>Solution2  2.map计数</h2><p>class Solution {<br>public:<br>    bool isAnagram(string s, string t) {<br>        unordered_map&lt;char,int&gt; map;<br>        if (s.size() !&#x3D; t.size())<br>            return false;<br>        for(int i&#x3D;0;i&lt;s.size();i++){<br>            ++map[s[i]];<br>            –map[t[i]];<br>        }<br>        for(unordered_map&lt;char,int&gt;::iterator it&#x3D;map.begin();it!&#x3D;map.end();it++){<br>            if(it-&gt;second!&#x3D;0)<br>                return false;<br>        }<br>        return true;</p>
<pre><code>&#125;
</code></pre>
<p>};</p>
<h2 id="Solution3-3-效率最高"><a href="#Solution3-3-效率最高" class="headerlink" title="Solution3  3.效率最高"></a>Solution3  3.效率最高</h2><p>class Solution {<br>public:<br>    bool isAnagram(string s, string t) {<br>        int num[26]&#x3D;{0};<br>        if(s.length()!&#x3D;t.length())<br>            return false;<br>        for(int i&#x3D;0;s[i]!&#x3D;’\0’;i++){<br>            num[s[i]-‘a’]++;<br>            num[t[i]-‘a’]–;</p>
<pre><code>    &#125;
    for(int i=0;i&lt;26;i++)
        if(num[i]!=0)
            return false;
    return true;
&#125;
</code></pre>
<p>};</p>
<h1 id="258-各位相加"><a href="#258-各位相加" class="headerlink" title="258. 各位相加"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-digits/">258. 各位相加</a></h1><p>给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: num &#x3D; 38<br>输出: 2<br>解释: 各位相加的过程为：<br>38 –&gt; 3 + 8 –&gt; 11<br>11 –&gt; 1 + 1 –&gt; 2<br>由于 2 是一位数，所以返回 2。<br>示例 1:</p>
<p>输入: num &#x3D; 0<br>输出: 0
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; num &lt;&#x3D; 231 - 1
 </p>
<p>进阶：你可以不使用循环或者递归，在 O(1) 时间复杂度内解决这个问题吗？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Math&#x27;s Explained :-</span><br><span class="line">Any number where it&#x27;s digits add to 9 is always divisible by 9. (18, 27, 36, 45, 54, 63, 72, 81, 90, etc.) Therefore the &#x27;digital root&#x27; for any number divisible by 9 is always 9. You can see this even in larger numbers like 99 because 9 + 9 = 18, and then 1 + 8 = 9 still, so the root always becomes 9 for any numbers divisible by 9.</span><br><span class="line"></span><br><span class="line">Additionally, 0 always has a digital root of 0 obviously.</span><br><span class="line"></span><br><span class="line">The only other cases you need to worry about to find the digital root are when it isn&#x27;t 0 or 9.</span><br><span class="line"></span><br><span class="line">So for any number that isn&#x27;t 0 and isn&#x27;t divisible by 9, the root will always n % 9 for a given number n. (AKA the difference between given number n and the nearest number that is divisible by 9, since numbers divisible by 9 always have a digital root of 9).</span><br><span class="line">For examples: 100 % 9 = 1 (one greater than 99, which is divisible by 9).</span><br><span class="line">101 % 9 = 2</span><br><span class="line">102 % 9 = 3 and so on.</span><br><span class="line"></span><br><span class="line">This explanation/algorithm skips the whole &quot;add digits until there is only 1 remaining&quot;, so the description of this problem seems pretty misleading to me since it makes you think the solution will be something unrelated to the optimal one. I guess the point of Leetcode is to learn all of these tricks though.</span><br></pre></td></tr></table></figure>
<h2 id="Solution1-找规律"><a href="#Solution1-找规律" class="headerlink" title="Solution1 : 找规律"></a>Solution1 : 找规律</h2><p>除了传统的单纯循环，还可以找规律。假如一个三位数’abc’，其值大小为s1 &#x3D; 100 * a + 10 * b + 1 * c，经过一次各位相加后，变为s2 &#x3D; a + b + c，减小的差值为(s1 -s2) &#x3D; 99 * a + 9 * b，差值可以被9整除，每一个循环都这样，缩小了9的倍数。当num小于9，即只有一位时，直接返回num，大于9时，如果能被9整除，则返回9（因为不可能返回0也不可能返回两位数及以上的值），如果不能被整除，就返回被9除的余数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addDigits(self, num: int) -&gt; int:</span><br><span class="line">        if num &gt; 9:</span><br><span class="line">            num = num % 9</span><br><span class="line">            if num == 0:</span><br><span class="line">                return 9</span><br><span class="line">        return num</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-循环"><a href="#Solution2-循环" class="headerlink" title="Solution2 :循环"></a>Solution2 :循环</h2><p><img src="https://files.mdnice.com/user/1489/f5955143-7685-4b34-b5dd-9b24fa5290ce.png"></p>
<h1 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/move-zeroes/">283. 移动零</a></h1><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: nums &#x3D; [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>示例 2:</p>
<p>输入: nums &#x3D; [0]<br>输出: [0]
 </p>
<p>提示:</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">Solution</span><br><span class="line">This question comes under a broad category of &quot;Array Transformation&quot;. This category is the meat of tech interviews. Mostly because arrays are such a simple and easy to use data structure. Traversal or representation doesn&#x27;t require any boilerplate code and most of your code will look like the Pseudocode itself.</span><br><span class="line"></span><br><span class="line">The 2 requirements of the question are:</span><br><span class="line"></span><br><span class="line">Move all the 0&#x27;s to the end of array.</span><br><span class="line"></span><br><span class="line">All the non-zero elements must retain their original order.</span><br><span class="line"></span><br><span class="line">It&#x27;s good to realize here that both the requirements are mutually exclusive, i.e., you can solve the individual sub-problems and then combine them for the final solution.</span><br><span class="line"></span><br><span class="line">Approach #1 (Space Sub-Optimal) [Accepted]</span><br><span class="line">C++</span><br><span class="line"></span><br><span class="line">void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line"></span><br><span class="line">    // Count the zeroes</span><br><span class="line">    int numZeroes = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        numZeroes += (nums[i] == 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Make all the non-zero elements retain their original order.</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (nums[i] != 0) &#123;</span><br><span class="line">            ans.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Move all zeroes to the end</span><br><span class="line">    while (numZeroes--) &#123;</span><br><span class="line">        ans.push_back(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Combine the result</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        nums[i] = ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Complexity Analysis</span><br><span class="line"></span><br><span class="line">Space Complexity : O(n)O(n). Since we are creating the &quot;ans&quot; array to store results.</span><br><span class="line"></span><br><span class="line">Time Complexity: O(n)O(n). However, the total number of operations are sub-optimal. We can achieve the same result in less number of operations.</span><br><span class="line"></span><br><span class="line">If asked in an interview, the above solution would be a good start. You can explain the interviewer(not code) the above and build your base for the next Optimal Solution.</span><br><span class="line"></span><br><span class="line">Approach #2 (Space Optimal, Operation Sub-Optimal) [Accepted]</span><br><span class="line">This approach works the same way as above, i.e. , first fulfills one requirement and then another. The catch? It does it in a clever way. The above problem can also be stated in alternate way, &quot; Bring all the non 0 elements to the front of array keeping their relative order same&quot;.</span><br><span class="line"></span><br><span class="line">This is a 2 pointer approach. The fast pointer which is denoted by variable &quot;cur&quot; does the job of processing new elements. If the newly found element is not a 0, we record it just after the last found non-0 element. The position of last found non-0 element is denoted by the slow pointer &quot;lastNonZeroFoundAt&quot; variable. As we keep finding new non-0 elements, we just overwrite them at the &quot;lastNonZeroFoundAt + 1&quot; &#x27;th index. This overwrite will not result in any loss of data because we already processed what was there(if it were non-0,it already is now written at it&#x27;s corresponding index,or if it were 0 it will be handled later in time).</span><br><span class="line"></span><br><span class="line">After the &quot;cur&quot; index reaches the end of array, we now know that all the non-0 elements have been moved to beginning of array in their original order. Now comes the time to fulfil other requirement, &quot;Move all 0&#x27;s to the end&quot;. We now simply need to fill all the indexes after the &quot;lastNonZeroFoundAt&quot; index with 0.</span><br><span class="line"></span><br><span class="line">C++</span><br><span class="line"></span><br><span class="line">void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int lastNonZeroFoundAt = 0;</span><br><span class="line">    // If the current element is not 0, then we need to</span><br><span class="line">    // append it just in front of last non 0 element we found. </span><br><span class="line">    for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        if (nums[i] != 0) &#123;</span><br><span class="line">            nums[lastNonZeroFoundAt++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> 	// After we have finished processing new elements,</span><br><span class="line"> 	// all the non-zero elements are already at beginning of array.</span><br><span class="line"> 	// We just need to fill remaining array with 0&#x27;s.</span><br><span class="line">    for (int i = lastNonZeroFoundAt; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        nums[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Complexity Analysis</span><br><span class="line"></span><br><span class="line">Space Complexity : O(1)O(1). Only constant space is used.</span><br><span class="line"></span><br><span class="line">Time Complexity: O(n)O(n). However, the total number of operations are still sub-optimal. The total operations (array writes) that code does is nn (Total number of elements).</span><br><span class="line"></span><br><span class="line">Approach #3 (Optimal) [Accepted]</span><br><span class="line">The total number of operations of the previous approach is sub-optimal. For example, the array which has all (except last) leading zeroes: [0, 0, 0, ..., 0, 1].How many write operations to the array? For the previous approach, it writes 0&#x27;s n-1n−1 times, which is not necessary. We could have instead written just once. How? ..... By only fixing the non-0 element,i.e., 1.</span><br><span class="line"></span><br><span class="line">The optimal approach is again a subtle extension of above solution. A simple realization is if the current element is non-0, its&#x27; correct position can at best be it&#x27;s current position or a position earlier. If it&#x27;s the latter one, the current position will be eventually occupied by a non-0 ,or a 0, which lies at a index greater than &#x27;cur&#x27; index. We fill the current position by 0 right away,so that unlike the previous solution, we don&#x27;t need to come back here in next iteration.</span><br><span class="line"></span><br><span class="line">In other words, the code will maintain the following invariant:</span><br><span class="line"></span><br><span class="line">All elements before the slow pointer (lastNonZeroFoundAt) are non-zeroes.</span><br><span class="line"></span><br><span class="line">All elements between the current and slow pointer are zeroes.</span><br><span class="line"></span><br><span class="line">Therefore, when we encounter a non-zero element, we need to swap elements pointed by current and slow pointer, then advance both pointers. If it&#x27;s zero element, we just advance current pointer.</span><br><span class="line"></span><br><span class="line">With this invariant in-place, it&#x27;s easy to see that the algorithm will work.</span><br><span class="line"></span><br><span class="line">C++</span><br><span class="line"></span><br><span class="line">void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    for (int lastNonZeroFoundAt = 0, cur = 0; cur &lt; nums.size(); cur++) &#123;</span><br><span class="line">        if (nums[cur] != 0) &#123;</span><br><span class="line">            swap(nums[lastNonZeroFoundAt++], nums[cur]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Complexity Analysis</span><br><span class="line"></span><br><span class="line">Space Complexity : O(1)O(1). Only constant space is used.</span><br><span class="line"></span><br><span class="line">Time Complexity: O(n)O(n). However, the total number of operations are optimal. The total operations (array writes) that code does is Number of non-0 elements.This gives us a much better best-case (when most of the elements are 0) complexity than last solution. However, the worst-case (when all elements are non-0) complexity for both the algorithms is same.</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-5"><a href="#Solution1-5" class="headerlink" title="Solution1"></a>Solution1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void moveZeroes(int* nums, int numsSize) &#123;</span><br><span class="line">    int i = 0,j = 0;</span><br><span class="line">    for(i = 0 ; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(nums[i] != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[j++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(j &lt; numsSize)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[j++] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="292-Nim-游戏"><a href="#292-Nim-游戏" class="headerlink" title="292. Nim 游戏"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/nim-game/">292. Nim 游戏</a></h1><p><img src="https://files.mdnice.com/user/1489/8faa0b82-6c1d-4433-abc3-8bb1ef5df8b6.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Solution</span><br><span class="line">You can always win a Nim game if the number of stones nn in the pile is not divisible by 44.</span><br><span class="line"></span><br><span class="line">Reasoning</span><br><span class="line"></span><br><span class="line">Let us think of the small cases. It is clear that if there are only one, two, or three stones in the pile, and it is your turn, you can win the game by taking all of them. Like the problem description says, if there are exactly four stones in the pile, you will lose. Because no matter how many you take, you will leave some stones behind for your opponent to take and win the game. So in order to win, you have to ensure that you never reach the situation where there are exactly four stones on the pile on your turn.</span><br><span class="line"></span><br><span class="line">Similarly, if there are five, six, or seven stones you can win by taking just enough to leave four stones for your opponent so that they lose. But if there are eight stones on the pile, you will inevitably lose, because regardless whether you pick one, two or three stones from the pile, your opponent can pick three, two or one stone to ensure that, again, four stones will be left to you on your turn.</span><br><span class="line"></span><br><span class="line">It is obvious that the same pattern repeats itself for n=4,8,12,16,\dotsn=4,8,12,16,…, basically all multiples of 44.</span><br><span class="line"></span><br><span class="line">Complexity Analysis</span><br><span class="line"></span><br><span class="line">Time complexity: O(1)O(1)</span><br><span class="line"></span><br><span class="line">Only one check is performed.</span><br><span class="line">Space complexity: O(1)O(1)</span><br><span class="line"></span><br><span class="line">No additional space is used, so space complexity is also O(1)O(1).</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Solution1-数学推理"><a href="#Solution1-数学推理" class="headerlink" title="Solution1 数学推理"></a>Solution1 数学推理</h2><p><img src="https://files.mdnice.com/user/1489/8c0e907f-f383-48da-98e6-ed531d6bd93a.png"></p>
<h1 id="326-3的幂"><a href="#326-3的幂" class="headerlink" title="326.3的幂"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/power-of-three/">326.3的幂</a></h1><p><img src="https://files.mdnice.com/user/1489/c13f7729-4dce-428f-8f31-b5f9317a5ce2.png"></p>
<p><img src="https://files.mdnice.com/user/1489/a9da96c8-01ef-4845-9aae-aa779466e765.png"></p>
<p><img src="https://files.mdnice.com/user/1489/802538d5-95df-4c84-9c65-31ac4b52eff3.png"></p>
<h2 id="Solution1-试除法"><a href="#Solution1-试除法" class="headerlink" title="Solution1 试除法"></a>Solution1 试除法</h2><p><img src="https://files.mdnice.com/user/1489/bc9e3a37-edc5-498a-b026-882a06a64125.png"></p>
<h2 id="Solution2-约数法"><a href="#Solution2-约数法" class="headerlink" title="Solution2 约数法"></a>Solution2 约数法</h2><p><img src="https://files.mdnice.com/user/1489/654af93a-97e3-4f83-88fb-c27a32ac905a.png"></p>
<h1 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/odd-even-linked-list/">328. 奇偶链表</a></h1><p><img src="https://files.mdnice.com/user/1489/201501bf-a7cf-4604-9d0c-860c89a8eeb9.png"></p>
<p><img src="https://files.mdnice.com/user/1489/9aed981d-b202-4bc8-b0a1-1e9080dc85c1.png"></p>
<h2 id="Solution1-双链法"><a href="#Solution1-双链法" class="headerlink" title="Solution1 双链法"></a>Solution1 双链法</h2><p>结点1作为奇数链的头 结点2作为偶数链的头<br>从第3个点开始遍历，依次轮流附在奇、偶链的后面<br>遍历完后，奇数链的尾连向偶链的头，偶链的尾为空， 返回奇数链的头</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* oddEvenList(ListNode* head) &#123;</span><br><span class="line">        if (head == nullptr) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* evenHead = head-&gt;next;</span><br><span class="line">        ListNode* odd = head;</span><br><span class="line">        ListNode* even = evenHead;</span><br><span class="line">        while (even != nullptr &amp;&amp; even-&gt;next != nullptr) &#123;</span><br><span class="line">            odd-&gt;next = even-&gt;next;</span><br><span class="line">            odd = odd-&gt;next;</span><br><span class="line">            even-&gt;next = odd-&gt;next;</span><br><span class="line">            even = even-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd-&gt;next = evenHead;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 是链表的节点数。需要遍历链表中的每个节点，并更新指针。</p>
<p>空间复杂度：O(1)O(1)。只需要维护有限的指针。</p>
<h1 id="334-递增的三元子序列"><a href="#334-递增的三元子序列" class="headerlink" title="334. 递增的三元子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/increasing-triplet-subsequence/">334. 递增的三元子序列</a></h1><p>给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。</p>
<p>如果存在这样的三元组下标 (i, j, k) 且满足 i &lt; j &lt; k ，使得 nums[i] &lt; nums[j] &lt; nums[k] ，返回 true ；否则，返回 false 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3,4,5]<br>输出：true<br>解释：任何 i &lt; j &lt; k 的三元组都满足题意<br>示例 2：</p>
<p>输入：nums &#x3D; [5,4,3,2,1]<br>输出：false<br>解释：不存在满足题意的三元组<br>示例 3：</p>
<p>输入：nums &#x3D; [2,1,5,0,4,6]<br>输出：true<br>解释：三元组 (3, 4, 5) 满足题意，因为 nums[3] &#x3D;&#x3D; 0 &lt; nums[4] &#x3D;&#x3D; 4 &lt; nums[5] &#x3D;&#x3D; 6
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 5 * 105<br>-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1
 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool increasingTriplet(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int c1 = INT_MAX, c2 = INT_MAX;</span><br><span class="line">    for (int x : nums) &#123;</span><br><span class="line">        if (x &lt;= c1) &#123;</span><br><span class="line">            c1 = x;           // c1 is min seen so far (it&#x27;s a candidate for 1st element)</span><br><span class="line">        &#125; else if (x &lt;= c2) &#123; // here when x &gt; c1, i.e. x might be either c2 or c3</span><br><span class="line">            c2 = x;           // x is better than the current c2, store it</span><br><span class="line">        &#125; else &#123;              // here when we have/had c1 &lt; c2 already and x &gt; c2</span><br><span class="line">            return true;      // the increasing subsequence of 3 elements exists</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-贪心"><a href="#Solution1-贪心" class="headerlink" title="Solution1  贪心"></a>Solution1  贪心</h2><p><img src="https://files.mdnice.com/user/1489/61447011-c76d-459e-be76-ed35d1d0edeb.png"></p>
<h2 id="Solution2-双向遍历"><a href="#Solution2-双向遍历" class="headerlink" title="Solution2 双向遍历"></a>Solution2 双向遍历</h2><p><img src="https://files.mdnice.com/user/1489/32ee1091-199d-4e97-be7e-8c82cd1a5660.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool increasingTriplet(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if (n &lt; 3) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; leftMin(n);</span><br><span class="line">        leftMin[0] = nums[0];</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            leftMin[i] = min(leftMin[i - 1], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; rightMax(n);</span><br><span class="line">        rightMax[n - 1] = nums[n - 1];</span><br><span class="line">        for (int i = n - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">            rightMax[i] = max(rightMax[i + 1], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; n - 1; i++) &#123;</span><br><span class="line">            if (nums[i] &gt; leftMin[i - 1] &amp;&amp; nums[i] &lt; rightMax[i + 1]) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>复杂度分析</p>
<p>时间复杂度：O(n)，其中 nn 是数组 \textit{nums}nums 的长度。需要遍历数组三次。</p>
<p>空间复杂度：O(n)，其中 nn 是数组 \textit{nums}nums 的长度。需要创建两个长度为 nn 的数组 \textit{leftMin}leftMin 和 \textit{rightMax}rightMax。</p>
<h1 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-string/">344. 反转字符串</a></h1><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s &#x3D; [“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]<br>示例 2：</p>
<p>输入：s &#x3D; [“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">We use here two pointers that gives us access to characters for swapping in left and right side of the string. For swapping we use a convinient C++ method swap. We just iterate over characters and swap them.</span><br><span class="line"></span><br><span class="line">Time: O(n)</span><br><span class="line">Space: O(1)</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-双指针交换"><a href="#Solution1-双指针交换" class="headerlink" title="Solution1 双指针交换"></a>Solution1 双指针交换</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reverseString(vector&lt;char&gt;&amp; s) &#123;</span><br><span class="line">        for (int i = 0, j = s.size() - 1; i &lt; s.size()/2; i++, j--) &#123;</span><br><span class="line">            swap(s[i],s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="堆：347-前-K-个高频元素"><a href="#堆：347-前-K-个高频元素" class="headerlink" title="堆：347. 前 K 个高频元素"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/top-k-frequent-elements/">堆：347. 前 K 个高频元素</a></h1><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2<br>输出: [1,2]<br>示例 2:</p>
<p>输入: nums &#x3D; [1], k &#x3D; 1<br>输出: [1]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>k 的取值范围是 [1, 数组中不相同的元素的个数]<br>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的
 </p>
<p>进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">How&#x27;s going Ladies - n - Gentlemen, today we are going to solve another coolest problem i.e. Top K Frequent Elements</span><br><span class="line"></span><br><span class="line">Okay, so in order to solve this problem, first of all let&#x27;s understand what the problem statement is:</span><br><span class="line"></span><br><span class="line">Given an integer array nums, </span><br><span class="line">and an integer k, return the k most frequent elements. You may return the answer in any order.</span><br><span class="line">Okay, so wait wait listen just looking at this if you know the HashMap, you&#x27;ll simply gonna say we can solve this problem easily using HashMap. And I&#x27;ll say yes, exactly we gonna do the exact same thing but we will use Heap as well with HashMap, if you got the idea by listening heap. Then you had just solve the brute force approach</span><br><span class="line"></span><br><span class="line">So, let&#x27;s talk about it&#x27;s</span><br><span class="line"></span><br><span class="line">Brute Force Approach :-</span><br><span class="line">Let&#x27;s take an example,</span><br><span class="line"></span><br><span class="line">Input: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">Output: [1,2]</span><br><span class="line"></span><br><span class="line">So, we have 2 step&#x27;s to perform in this problem:-</span><br><span class="line"></span><br><span class="line">HashMap</span><br><span class="line"></span><br><span class="line">Heap</span><br><span class="line"></span><br><span class="line">Step -1 :- Make an Frequency map &amp; fill it with the given elements</span><br><span class="line"></span><br><span class="line">								[1,1,1,2,2,3]</span><br><span class="line">								</span><br><span class="line">		------------------------------------------------							</span><br><span class="line">			|        1    ---&gt; |       3         |</span><br><span class="line">			|                  |                 |</span><br><span class="line">			|        2    ---&gt; |       2         |                         HashMap of Integer, Integer</span><br><span class="line">			|                  |                 |</span><br><span class="line">			|        3    ---&gt; |       1         |</span><br><span class="line">		------------------------------------------------</span><br><span class="line">Okay, so we just had completed our step no.1 now, it;s time to move to next step</span><br><span class="line"></span><br><span class="line">Step -2 :- Make an MaxHeap &amp; fill it with keys &amp; on the peek of our Heap we will be having most frequent elements</span><br><span class="line"></span><br><span class="line">HashMap :-</span><br><span class="line">		Key     Value</span><br><span class="line">		1 ----&gt; 3</span><br><span class="line">		2 ----&gt; 2</span><br><span class="line">		3 ----&gt; 1</span><br><span class="line">		</span><br><span class="line">Heap :-</span><br><span class="line">		</span><br><span class="line">		|    1   |             from the top of the heap we&#x27;ll pop that no. of element requires in our array of k size</span><br><span class="line">		|    2   |</span><br><span class="line">		|    3   |</span><br><span class="line">	   ------------</span><br><span class="line">Create result array res &amp; store K frequent elements in it.</span><br><span class="line"></span><br><span class="line">Heap :-</span><br><span class="line">		</span><br><span class="line">		|        |             res : [1]</span><br><span class="line">		|    2   |</span><br><span class="line">		|    3   |</span><br><span class="line">	   ------------</span><br><span class="line">Heap :-</span><br><span class="line">		</span><br><span class="line">		|        |             res : [1, 2]</span><br><span class="line">		|        |</span><br><span class="line">		|    3   |</span><br><span class="line">	   ------------</span><br><span class="line">As, our K is 2 we gonna only store Most frequent K elements in our array, therefore in the result we get:- [1, 2]</span><br><span class="line"></span><br><span class="line">I hope so, ladies - n - gentlemen, this approach is absolute clear, Let&#x27;s code it, up</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int[] topKFrequent(int[] nums, int k) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        for(int i : nums)&#123;</span><br><span class="line">            map.put(i, map.getOrDefault(i, 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((a,b) -&gt; map.get(b) - map.get(a));</span><br><span class="line">        </span><br><span class="line">        for(int key : map.keySet())&#123;</span><br><span class="line">            maxHeap.add(key);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int res[] = new int[k];</span><br><span class="line">        for(int i = 0; i &lt; k; i++)&#123;</span><br><span class="line">            res[i] = maxHeap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ANALYSIS :-</span><br><span class="line"></span><br><span class="line">Time Complexity :- BigO(K log D) as we are Poll K distinct elements from the Heap &amp; here D is no. of distinct (unique) elements in the input array</span><br><span class="line"></span><br><span class="line">Space Complexity :- BigO(D), this is the size of the heap.</span><br><span class="line"></span><br><span class="line">Well, this is not a super efficient Approach,</span><br><span class="line">We can solve this more efficiently as well, now some of you&#x27;ll ask but how!!</span><br><span class="line"></span><br><span class="line">Well, for that we have Bucket Sorting</span><br><span class="line"></span><br><span class="line">Optimize Approach :-</span><br><span class="line">Let&#x27;s understand what bucket sort is,</span><br><span class="line"></span><br><span class="line">Bucket sort, or bin sort, is a sorting algorithm that works by distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm, or by recursively applying the bucket sorting algorithm.</span><br><span class="line"></span><br><span class="line">In this process we gonna follow 3 major steps :-</span><br><span class="line"></span><br><span class="line">Step - 1 :</span><br><span class="line">Create Frequency map:</span><br><span class="line">1.1 Iterate thru the given nums[] array</span><br><span class="line">1.2. With each iteration - check if map already contains current key</span><br><span class="line">If current key is already in the map just increase the value for this key</span><br><span class="line">Else add key value pair.</span><br><span class="line">Where key is current int and value is 1 (1 -&gt; we encounter given key for the first time)</span><br><span class="line"></span><br><span class="line">image</span><br><span class="line"></span><br><span class="line">Step - 2 :</span><br><span class="line">Create Bucket List[]:</span><br><span class="line">index of bucket[] arr will represent the value from our map</span><br><span class="line">Why not use int[] arr? Multiple values can have the same frequency that&#x27;s why we use List[] array of lists instead of regular array</span><br><span class="line">Iterate thrue the map and for each value add key at the index of that value</span><br><span class="line"></span><br><span class="line">image</span><br><span class="line"></span><br><span class="line">Step - 3 :</span><br><span class="line">If we look at bucket arr we can see that most frequent elements are located at the end of arr</span><br><span class="line">and leat frequent elemnts at the begining</span><br><span class="line">Last step is to iterate from the end to the begining of the arr and add elements to result List</span><br><span class="line"></span><br><span class="line">image</span><br><span class="line"></span><br><span class="line">I hope so ladies - n - gentlemen Approach is absolute clear, Let&#x27;s code it up</span><br></pre></td></tr></table></figure>
<h2 id="Solution1-排序法"><a href="#Solution1-排序法" class="headerlink" title="Solution1 排序法"></a>Solution1 排序法</h2><p><img src="https://files.mdnice.com/user/1489/9d0654e6-75ac-4ef1-9309-aa410463028e.png"></p>
<h2 id="Solution2-最小堆法"><a href="#Solution2-最小堆法" class="headerlink" title="Solution2 最小堆法"></a>Solution2 最小堆法</h2><p><img src="https://files.mdnice.com/user/1489/8c154642-a002-4b1e-a451-679ecaab6052.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        map&lt;int, int&gt; freq;</span><br><span class="line">        using pii = std::pair&lt;int, int&gt;;</span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;</span><br><span class="line">        </span><br><span class="line">        for (auto e : nums) ++freq[e];</span><br><span class="line">        </span><br><span class="line">        for (auto&amp; pair : freq) &#123;</span><br><span class="line">            pq.emplace(pair.second, pair.first);</span><br><span class="line">            if (pq.size() &gt; k) pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while (!pq.empty()) &#123;</span><br><span class="line">            res.emplace_back(pq.top().second);</span><br><span class="line">            pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h1><p>给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]<br>输出：[2]<br>示例 2：</p>
<p>输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]<br>输出：[9,4]<br>解释：[4,9] 也是可通过的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Approach 1: Two Sets</span><br><span class="line">Intuition</span><br><span class="line"></span><br><span class="line">The naive approach would be to iterate along the first array nums1 and to check for each value if this value in nums2 or not. If yes - add the value to output. Such an approach would result in a pretty bad \mathcal&#123;O&#125;(n \times m)O(n×m) time complexity, where n and m are arrays&#x27; lengths.</span><br><span class="line"></span><br><span class="line">To solve the problem in linear time, let&#x27;s use the structure set, which provides in/contains operation in \mathcal&#123;O&#125;(1)O(1) time in average case.</span><br><span class="line"></span><br><span class="line">The idea is to convert both arrays into sets, and then iterate over the smallest set checking the presence of each element in the larger set. Time complexity of this approach is \mathcal&#123;O&#125;(n + m)O(n+m) in the average case.</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-6"><a href="#Solution1-6" class="headerlink" title="Solution1"></a>Solution1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; result_set; // 存放结果，之所以用set是为了给结果集去重</span><br><span class="line">        int hash[1005] = &#123;0&#125;; // 默认数值为0</span><br><span class="line">        for (int num : nums1) &#123; // nums1中出现的字母在hash数组中做记录</span><br><span class="line">            hash[num] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int num : nums2) &#123; // nums2中出现话，result记录</span><br><span class="line">            if (hash[num] == 1) &#123;</span><br><span class="line">                result_set.insert(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return vector&lt;int&gt;(result_set.begin(), result_set.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Solution2-5"><a href="#Solution2-5" class="headerlink" title="Solution2"></a>Solution2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; result_set; // 存放结果</span><br><span class="line">        unordered_set&lt;int&gt; nums_set(nums1.begin(), nums1.end());</span><br><span class="line">        for (int num : nums2) &#123;</span><br><span class="line">            // 发现nums2的元素 在nums_set里又出现过</span><br><span class="line">            if (nums_set.find(num) != nums_set.end()) &#123;</span><br><span class="line">                result_set.insert(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return vector&lt;int&gt;(result_set.begin(), result_set.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="378-有序矩阵中第-K-小的元素"><a href="#378-有序矩阵中第-K-小的元素" class="headerlink" title="378. 有序矩阵中第 K 小的元素"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/">378. 有序矩阵中第 K 小的元素</a></h1><p>给你一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。<br>请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。</p>
<p>你必须找到一个内存复杂度优于 O(n2) 的解决方案。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：matrix &#x3D; [[1,5,9],[10,11,13],[12,13,15]], k &#x3D; 8<br>输出：13<br>解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13<br>示例 2：</p>
<p>输入：matrix &#x3D; [[-5]], k &#x3D; 1<br>输出：-5
 </p>
<p>提示：</p>
<p>n &#x3D;&#x3D; matrix.length<br>n &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; n &lt;&#x3D; 300<br>-109 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 109<br>题目数据 保证 matrix 中的所有行和列都按 非递减顺序 排列<br>1 &lt;&#x3D; k &lt;&#x3D; n2
 </p>
<p>进阶：</p>
<p>你能否用一个恒定的内存(即 O(1) 内存复杂度)来解决这个问题?<br>你能在 O(n) 的时间复杂度下解决这个问题吗?这个方法对于面试来说可能太超前了，但是你会发现阅读这篇文章（ this paper ）很有趣。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">✔️ Solution 1: Max Heap keeps up to k elements</span><br><span class="line"></span><br><span class="line">The easy approach is that we iterate all elements in the matrix and and add elements into the maxHeap. The maxHeap will keep up to k smallest elements (because when maxHeap is over size of k, we do remove the top of maxHeap which is the largest one). Finally, the top of the maxHeap is the kth smallest element in the matrix.</span><br><span class="line">This approach leads this problem become the same with 215. Kth Largest Element in an Array, which doesn&#x27;t take the advantage that the matrix is already sorted by rows and by columns.</span><br><span class="line"></span><br><span class="line">Complexity:</span><br><span class="line">Time: O(M * N * logK), where M &lt;= 300 is the number of rows, N &lt;= 300 is the number of columns.</span><br><span class="line">Space: O(K), space for heap which stores up to k elements.</span><br><span class="line">✔️ Solution 2: Min Heap to find kth smallest element from amongst N sorted list</span><br><span class="line"></span><br><span class="line">Since each of the rows in matrix are already sorted, we can understand the problem as finding the kth smallest element from amongst M sorted rows.</span><br><span class="line">We start the pointers to point to the beginning of each rows, then we iterate k times, for each time ith, the top of the minHeap is the ith smallest element in the matrix. We pop the top from the minHeap then add the next element which has the same row with that top to the minHeap.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution1-暴力-13"><a href="#Solution1-暴力-13" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><p><img src="https://files.mdnice.com/user/1489/aa8f67bb-f725-4ac9-b288-f00702b84a55.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123;</span><br><span class="line">        struct point &#123;</span><br><span class="line">            int val, x, y;</span><br><span class="line">            point(int val, int x, int y) : val(val), x(x), y(y) &#123;&#125;</span><br><span class="line">            bool operator&gt; (const point&amp; a) const &#123; return this-&gt;val &gt; a.val; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        priority_queue&lt;point, vector&lt;point&gt;, greater&lt;point&gt;&gt; que;</span><br><span class="line">        int n = matrix.size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            que.emplace(matrix[i][0], i, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; k - 1; i++) &#123;</span><br><span class="line">            point now = que.top();</span><br><span class="line">            que.pop();</span><br><span class="line">            if (now.y != n - 1) &#123;</span><br><span class="line">                que.emplace(matrix[now.x][now.y + 1], now.x, now.y + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return que.top().val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Solution2-最小堆"><a href="#Solution2-最小堆" class="headerlink" title="Solution2 最小堆"></a>Solution2 最小堆</h2><p><img src="https://files.mdnice.com/user/1489/ac2814f5-9f64-451b-8a2f-167966444bc9.png"></p>
<p><img src="https://files.mdnice.com/user/1489/89471a17-0dc3-4180-9b34-d9d5c6c4f9da.png"></p>
<p><img src="https://files.mdnice.com/user/1489/bfd3a090-de97-4eff-a66b-be9cddb9bbc8.png"></p>
<h1 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/decode-string/">394. 字符串解码</a></h1><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “3[a]2[bc]”<br>输出：”aaabcbc”<br>示例 2：</p>
<p>输入：s &#x3D; “3[a2[c]]”<br>输出：”accaccacc”<br>示例 3：</p>
<p>输入：s &#x3D; “2[abc]3[cd]ef”<br>输出：”abcabccdcdcdef”<br>示例 4：</p>
<p>输入：s &#x3D; “abc3[cd]xyz”<br>输出：”abccdcdcdxyz”
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 30<br>s 由小写英文字母、数字和方括号 ‘[]’ 组成<br>s 保证是一个 有效 的输入。<br>s 中所有整数的取值范围为 [1, 300] </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This is the standard solution given under the tab &#x27;Solution&#x27; of the same problem: https://leetcode.com/problems/decode-string/solution/</span><br><span class="line">We start with the original string s and index = 0. If the index is not &#x27;]&#x27;, meaning its a digit or alphabet (but not &#x27;[&#x27; -&gt; this is ensured in the later part of the code). Also note that the string won&#x27;t start with &#x27;[&#x27; so there is no chance of having it initially.</span><br><span class="line">First lets take the case when the string isdigit. In that case, count the number of times the inner string need to be repeated. For example 26[X], string X will be repeated 26 times and 26 is stored in k. Now increment the index -&gt; this is done as we know that number will be accompanied by [.</span><br><span class="line">Now recurse on the inner string s and also increment index, this time for ]. While recursing for inner string, if the character is not digit, we store that and return it as a string. Now remember this inner string needs to be repeated &#x27;k&#x27; times so we add that to current return string &#x27;ret&#x27;. Return the ret string.</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-两个栈"><a href="#Solution1-两个栈" class="headerlink" title="Solution1 两个栈"></a>Solution1 两个栈</h2><p><img src="https://files.mdnice.com/user/1489/57e2bfe5-e188-42e3-9460-4fa79082ecd2.png"></p>
<h1 id="402-移掉-K-位数字"><a href="#402-移掉-K-位数字" class="headerlink" title="402. 移掉 K 位数字"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-k-digits/">402. 移掉 K 位数字</a></h1><p>给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p>
<p> <br>示例 1 ：</p>
<p>输入：num &#x3D; “1432219”, k &#x3D; 3<br>输出：”1219”<br>解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。<br>示例 2 ：</p>
<p>输入：num &#x3D; “10200”, k &#x3D; 1<br>输出：”200”<br>解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。<br>示例 3 ：</p>
<p>输入：num &#x3D; “10”, k &#x3D; 2<br>输出：”0”<br>解释：从原数字移除所有的数字，剩余为空就是 0 。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; k &lt;&#x3D; num.length &lt;&#x3D; 105<br>num 仅由若干位数字（0 - 9）组成<br>除了 0 本身之外，num 不含任何前导零</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">KNOCKCAT</span><br><span class="line"></span><br><span class="line">1. Easy C++</span><br><span class="line">2. Line by Line Explanation with Comments.</span><br><span class="line">3. Detailed Explanation ✅</span><br><span class="line">4. Handwritten snap of an TestCase at the end of code given.</span><br><span class="line">5. Please Upvote if it helps⬆️</span><br><span class="line">6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. ⬇️</span><br><span class="line">LeetCode</span><br><span class="line"></span><br><span class="line">EXPLANATION</span><br><span class="line"></span><br><span class="line">1. Deleting k digits means keeping n - k digits, where n is the total number of digits.</span><br><span class="line"></span><br><span class="line">2. Use a stack that you keep sorted ascendingly. You remove elements from it as long as you can still make it to n - k digits,</span><br><span class="line">and your current element is smaller than the top of the stack:</span><br><span class="line"></span><br><span class="line">push(2) =&gt; 2</span><br><span class="line">push(4) because 2 &lt; 4 =&gt; 24</span><br><span class="line">push(6) because 4 &lt; 6 =&gt; 246</span><br><span class="line">pop() because 3 &lt; 6 and we can still end up with 2 digits =&gt; 24</span><br><span class="line">pop() for the same reason =&gt; 2</span><br><span class="line">push(3) =&gt; 23</span><br><span class="line">push(5) =&gt; 235</span><br><span class="line">Then just take the first k digits =&gt; 23. Or you can make sure never to push more than k digits, and then the final stack is your solution.</span><br><span class="line"></span><br><span class="line">3. Note that you cannot pop elements if that means you will not be able to build a solution of k digits.</span><br><span class="line">For this, you need to check the current number of elements in the stack and the number of digits to the right of your current position on the input number.</span><br><span class="line">Some More Points</span><br><span class="line"></span><br><span class="line">1. Approach is simple. We need a number which is minimum, thus we need to remove the most significant digits first.</span><br><span class="line">For eg. if we have a number having digits 1-4 then 1234 would be the minimum and not 2314 or anything else.</span><br><span class="line">So in case of 2314, we remove 3 first, and then we go for 2 (Because they are more significant than 4). Observing this simple idea,</span><br><span class="line">we need to remove any digit which is greater than its following digit. Thats why we deleted 3 as it,</span><br><span class="line">was greater than 1 and similiarly 2 as it was also greater than 1.</span><br><span class="line"></span><br><span class="line">2. In order to accomplish this, we use stack Data Structure where we pop the top if it is greater than current digit.</span><br><span class="line"></span><br><span class="line">3. The conditions mentioned in while loop are important to avoid any Runtime Error. For eg. [&quot;10001&quot; 2] the answer is &quot;0&quot; but if we don&#x27;t</span><br><span class="line">mention the condition !s.empty(), then the while loop will run on empty stack and try to pop the top which doesn&#x27;t exist thus throwing RE.</span><br><span class="line"></span><br><span class="line">Time Complexity :- O(N) // as we only traversing the string for once</span><br><span class="line">Space complexity:- O(N) // as we will store maximum of n digits in our string</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-贪心-单调栈"><a href="#Solution1-贪心-单调栈" class="headerlink" title="Solution1 贪心+单调栈"></a>Solution1 贪心+单调栈</h2><p><img src="https://files.mdnice.com/user/1489/702de056-c52b-45b9-9965-8112d4131454.png"></p>
<p><img src="https://files.mdnice.com/user/1489/48ae75e0-df07-48f0-bfea-017869bac869.png"></p>
<p><img src="https://files.mdnice.com/user/1489/0052ac37-a066-4e57-97fd-4ebe72e6418e.png"></p>
<p><img src="https://files.mdnice.com/user/1489/a4c9016a-3529-492d-a5c4-4172619a5168.png"></p>
<p><img src="https://files.mdnice.com/user/1489/cf2db259-ce16-4284-97f8-6e048c789bd5.png"></p>
<p><img src="https://files.mdnice.com/user/1489/544a41e4-a185-4dff-941f-79e6a60d6e79.png"></p>
<p><img src="https://files.mdnice.com/user/1489/f0bf9bc6-9c7f-434c-b924-cba7405ed0fb.png"></p>
<p><img src="https://files.mdnice.com/user/1489/446462c6-005a-4165-81a4-213042a92492.png"></p>
<p><img src="https://files.mdnice.com/user/1489/207854fc-5451-44e1-84a6-51cde0d77f0f.png"></p>
<h1 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h1><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] &#x3D; [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p>
<p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] &#x3D; [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]<br>输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]<br>解释：<br>编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。<br>编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。<br>编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。<br>编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。<br>编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。<br>示例 2：</p>
<p>输入：people &#x3D; [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]<br>输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; people.length &lt;&#x3D; 2000<br>0 &lt;&#x3D; hi &lt;&#x3D; 106<br>0 &lt;&#x3D; ki &lt; people.length<br>题目数据确保队列可以被重建</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Time Complexity : O(N^2) , Space Complexity : O(N)</span><br><span class="line"></span><br><span class="line">Upvote if Found Helpful</span><br><span class="line"></span><br><span class="line">Intuition :</span><br><span class="line"></span><br><span class="line">So here if we carefully observe we can notice that if we take any person and insert any other shorter person before or after him in queue then the number of people higher or equal to him before him doesn&#x27;t change. So we need to place the taller people first in the queue and we can add the shorter people in between or after them according to reqirement.</span><br><span class="line"></span><br><span class="line">So we need to sort the array according to their height in decreasing order (Heighest at the first).</span><br><span class="line">Now think if 2 person has same height the person with lower (Ki) will be inserted before other. Because The person before will have at least 1 less number of equal or taller people before him than who is after.</span><br><span class="line"></span><br><span class="line">So in case of equal heights (Hi) the person with lesser (Ki) will be placed first during sorting.</span><br><span class="line">Now if we insert the person from the sorted array in the ans array in the position (Ki) then the people greater than or equal to him will be in his left and they total will be (Ki) in number (From 0 to (Ki-1)th position). After that whatever we insert will be shorter (Which doesn&#x27;t matter if inserted after or before the position) or if equal will have greater (Ki) than the present one i.e. will be inserted in the right.</span><br><span class="line"></span><br><span class="line">So for each element in the sorted array we insert it at the (Ki)th position in the ans array.</span><br><span class="line">Example :</span><br><span class="line"></span><br><span class="line"> People = [[7,0], [4,4], [7,2], [5,0], [6,1], [5,4], [8,0]]</span><br><span class="line"> Sorted People accordin to comp function : [[8,0], [7,0], [7,2], [6,1], [5,0], [5,4], [4,4]]]</span><br><span class="line"> </span><br><span class="line"> Now for each iteration in the loop ; (Ki of each man is included in &#x27; &#x27;, and each inserted man in &quot; &quot;)</span><br><span class="line"> </span><br><span class="line"> man = [8,&#x27;0&#x27;] -&gt; ans.insert(ans.begin()+&#x27;0&#x27;, man) -&gt; ans  = [&quot;[8,0]&quot;]</span><br><span class="line"> man = [7,&#x27;0&#x27;] -&gt; ans.insert(ans.begin()+&#x27;0&#x27;, man) -&gt; ans  = [&quot;[7,0]&quot;, [8,0]]</span><br><span class="line"> man = [7,&#x27;2&#x27;] -&gt; ans.insert(ans.begin()+&#x27;2&#x27;, man) -&gt; ans  = [[7,0], [8,0], &quot;[7,2]&quot;]</span><br><span class="line"> man = [6,&#x27;1&#x27;] -&gt; ans.insert(ans.begin()+&#x27;1&#x27;, man) -&gt; ans  = [[7,0], &quot;[6,1]&quot;, [8,0], [7,2]]</span><br><span class="line"> man = [5,&#x27;0&#x27;] -&gt; ans.insert(ans.begin()+&#x27;0&#x27;, man) -&gt; ans  = [&quot;[5,0]&quot;, [7,0], [6,1], [8,0], [7,2]]</span><br><span class="line"> man = [5,&#x27;4&#x27;] -&gt; ans.insert(ans.begin()+&#x27;4&#x27;, man) -&gt; ans  = [[5,0], [7,0], [6,1], [8,0], &quot;[5,4]&quot;, [7,2]]</span><br><span class="line"> man = [4,&#x27;4&#x27;] -&gt; ans.insert(ans.begin()+&#x27;4&#x27;, man) -&gt; ans  = [[5,0], [7,0], [6,1], [8,0], &quot;[4,4]&quot;, [5,4], [7,2]]</span><br><span class="line"> </span><br><span class="line"> See the final ans array fullfills all the conditions.</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-先排序-再插队"><a href="#Solution1-先排序-再插队" class="headerlink" title="Solution1 先排序 再插队"></a>Solution1 先排序 再插队</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(const vector&lt;int&gt; a,const vector&lt;int&gt; b)&#123;</span><br><span class="line">            if (a[0] &gt; b[0]) return true;</span><br><span class="line">            if (a[0] == b[0] &amp;&amp; a[1] &lt; b[1]) return true;</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;</span><br><span class="line">        vector&lt;vector&lt;int &gt;&gt; res;</span><br><span class="line">        sort(people.begin(),people.end(),cmp);</span><br><span class="line">        for(auto val:people)&#123;</span><br><span class="line">            res.insert(res.begin()+val[1],val);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409. 最长回文串"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindrome/">409. 最长回文串</a></h1><p>给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的回文串 。</p>
<p>在构造过程中，请注意 区分大小写 。比如 “Aa” 不能当做一个回文字符串。</p>
<p> </p>
<p>示例 1:</p>
<p>输入:s &#x3D; “abccccdd”<br>输出:7<br>解释:<br>我们可以构造的最长的回文串是”dccaccd”, 它的长度是 7。<br>示例 2:</p>
<p>输入:s &#x3D; “a”<br>输入:1
 </p>
<p>提示:</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 2000<br>s 只由小写 和&#x2F;或 大写英文字母组成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Approach #1: Greedy [Accepted]</span><br><span class="line">Intuition</span><br><span class="line"></span><br><span class="line">A palindrome consists of letters with equal partners, plus possibly a unique center (without a partner). The letter i from the left has its partner i from the right. For example in &#x27;abcba&#x27;, &#x27;aa&#x27; and &#x27;bb&#x27; are partners, and &#x27;c&#x27; is a unique center.</span><br><span class="line"></span><br><span class="line">Imagine we built our palindrome. It consists of as many partnered letters as possible, plus a unique center if possible. This motivates a greedy approach.</span><br><span class="line"></span><br><span class="line">Algorithm</span><br><span class="line"></span><br><span class="line">For each letter, say it occurs v times. We know we have v // 2 * 2 letters that can be partnered for sure. For example, if we have &#x27;aaaaa&#x27;, then we could have &#x27;aaaa&#x27; partnered, which is 5 // 2 * 2 = 4 letters partnered.</span><br><span class="line"></span><br><span class="line">At the end, if there was any v % 2 == 1, then that letter could have been a unique center. Otherwise, every letter was partnered. To perform this check, we will check for v % 2 == 1 and ans % 2 == 0, the latter meaning we haven&#x27;t yet added a unique center to the answer.</span><br><span class="line"></span><br><span class="line">Complexity Analysis</span><br><span class="line"></span><br><span class="line">Time Complexity: O(N)O(N), where NN is the length of s. We need to count each letter.</span><br><span class="line"></span><br><span class="line">Space Complexity: O(1)O(1), the space for our count, as the alphabet size of s is fixed. We should also consider that in a bit complexity model, technically we need O(\log N)O(logN) bits to store the count values.</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-7"><a href="#Solution1-7" class="headerlink" title="Solution1"></a>Solution1</h2><p><img src="https://files.mdnice.com/user/1489/15ea384d-bb95-4dbf-8d73-ba9536ff3f95.png"></p>
<h1 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-strings/">415. 字符串相加</a></h1><p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。</p>
<p>你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：num1 &#x3D; “11”, num2 &#x3D; “123”<br>输出：”134”<br>示例 2：</p>
<p>输入：num1 &#x3D; “456”, num2 &#x3D; “77”<br>输出：”533”<br>示例 3：</p>
<p>输入：num1 &#x3D; “0”, num2 &#x3D; “0”<br>输出：”0”
 </p>
<p> </p>
<p>提示：</p>
<p>1 &lt;&#x3D; num1.length, num2.length &lt;&#x3D; 104<br>num1 和num2 都只包含数字 0-9<br>num1 和num2 都不包含任何前导零</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">26</span><br><span class="line">DBabichev&#x27;s avatar</span><br><span class="line">DBabichev</span><br><span class="line">35937</span><br><span class="line">Last Edit: August 9, 2021 10:37 PM</span><br><span class="line"></span><br><span class="line">1.2K VIEWS</span><br><span class="line"></span><br><span class="line">What we need to do in this problem is to perform usual schoolbook addition. We need to start to add numbers from the last elements and take care of carry and cases when one number has more digits that another. Imagine that we want to add two numbers: 986 and 47. Then we have the followint steps:</span><br><span class="line"></span><br><span class="line">Add 6 and 7, so we have digit 3 and carry equal to 1.</span><br><span class="line">Add 8 and 4 and 1, so we have 3 and carry equal to 1.</span><br><span class="line">Add 9 from first number, and we do not have anything from second, so we choose 0 from second. Also we have curry equal to 1, finally we have digit 0 and carry equal to 1.</span><br><span class="line">We still have carry, but no digits left, so we evaluate 0 + 0 + 1 = 1. And now we can stop, we do not have digits and we do not have carry.</span><br><span class="line">Final number we constructed is 1033.</span><br><span class="line"></span><br><span class="line">Complexity</span><br><span class="line">Time complexity is O(m + n), where m and n are lengths of our linked lists, space complexity is O(max(m, n)) if we count answer as memory or O(1) if we do not.</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-8"><a href="#Solution1-8" class="headerlink" title="Solution1"></a>Solution1</h2><p><img src="https://files.mdnice.com/user/1489/50bd7865-2516-4f4d-bdf7-4de2f00cdf80.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string addStrings(string num1, string num2) &#123;</span><br><span class="line">        int i = num1.length() - 1, j = num2.length() - 1, add = 0;</span><br><span class="line">        string ans = &quot;&quot;;</span><br><span class="line">        while (i &gt;= 0 || j &gt;= 0 || add != 0) &#123;</span><br><span class="line">            int x = i &gt;= 0 ? num1[i] - &#x27;0&#x27; : 0;</span><br><span class="line">            int y = j &gt;= 0 ? num2[j] - &#x27;0&#x27; : 0;</span><br><span class="line">            int result = x + y + add;</span><br><span class="line">            ans.push_back(&#x27;0&#x27; + result % 10);</span><br><span class="line">            add = result / 10;</span><br><span class="line">            i -= 1;</span><br><span class="line">            j -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 计算完以后的答案需要翻转过来</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="https://files.mdnice.com/user/1489/620df582-d9ad-49fd-a069-2b6bb56fa29c.png"></p>
<h1 id="求1-2-…n"><a href="#求1-2-…n" class="headerlink" title="求1+2+…n"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/qiu-12n-lcof">求1+2+…n</a></h1><p><img src="https://files.mdnice.com/user/1489/a39d57a7-49a2-4353-a4a4-68361420e23e.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/19234557-e889-43c9-84a6-e55b36d24aec.jpg"></p>
<h1 id="求滑动窗口的最大值"><a href="#求滑动窗口的最大值" class="headerlink" title="求滑动窗口的最大值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof">求滑动窗口的最大值</a></h1><p><img src="https://files.mdnice.com/user/1489/15a63a92-7b41-4707-a824-964718554f58.jpg"><br><img src="https://files.mdnice.com/user/1489/91669611-5065-4e62-9bcc-ba187bda8268.jpg"></p>
<h1 id="扑克牌中的顺子"><a href="#扑克牌中的顺子" class="headerlink" title="扑克牌中的顺子"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof">扑克牌中的顺子</a></h1><p><img src="https://files.mdnice.com/user/1489/297b7397-78fa-402f-9848-36a3e6baeafc.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/ff5136fb-3f4c-4caa-900f-e4d562a63e80.jpg"></p>
<h1 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof">左旋转字符串</a></h1><p><img src="https://files.mdnice.com/user/1489/e329b323-7662-4aa8-bef3-0ecf293c49de.jpg"></p>
<h1 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof">最长不含重复字符的子字符串</a></h1><p><img src="https://files.mdnice.com/user/1489/f01b0278-174b-461f-8ac7-191f13995a3b.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/bac74319-f5dc-4b47-8f63-1cc381458756.jpg"></p>
<h1 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof">滑动窗口的最大值</a></h1><p><img src="https://files.mdnice.com/user/1489/4a32da04-9232-437a-98df-26863d85179e.jpg"></p>
<h1 id="和为s连续正数序列"><a href="#和为s连续正数序列" class="headerlink" title="和为s连续正数序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof">和为s连续正数序列</a></h1><p><img src="https://files.mdnice.com/user/1489/aee56655-c266-45ae-aeda-2cb3e1573c71.jpg"><br><img src="https://files.mdnice.com/user/1489/6713148f-44c9-472b-9956-90bcad147d34.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/e9aeb4c3-d429-4dbd-ad0a-9d7ae18c6b50.jpg"><br><img src="https://files.mdnice.com/user/1489/9011acac-108a-45de-a940-7dc0cbe33807.jpg"></p>
<h1 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof">翻转单词顺序</a></h1><p><img src="https://files.mdnice.com/user/1489/94ef5c0b-92a5-437e-8920-e808dbf6cc4d.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/433263e7-9556-438c-8f3d-c260225dbf1d.jpg"></p>
<h1 id="左旋转字符串-1"><a href="#左旋转字符串-1" class="headerlink" title="左旋转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof">左旋转字符串</a></h1><p><img src="https://files.mdnice.com/user/1489/4614ddda-961b-4eed-8ee4-cc50ffb25935.jpg"></p>
<h1 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof">和为s的两个数字</a></h1><p><img src="https://files.mdnice.com/user/1489/50faf577-63ab-4b9c-bd6f-59ed0c2ce516.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/c918777d-7c9e-42a2-95fb-576b4618efd1.jpg"></p>
<h1 id="数组中出现次数超过一半的次数"><a href="#数组中出现次数超过一半的次数" class="headerlink" title="数组中出现次数超过一半的次数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof">数组中出现次数超过一半的次数</a></h1><p><img src="https://files.mdnice.com/user/1489/6afab0e0-5928-483e-a44d-bd6fa19e36dd.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/63b82d8b-42d1-4360-b5e7-224ad1ccb987.jpg"></p>
<h1 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof">第一个只出现一次的字符</a></h1><p><img src="https://files.mdnice.com/user/1489/7134c1a6-a705-41e0-b994-d9df133ffd06.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/a5fa6552-4f5e-434b-a31e-38bf09a2cdab.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/8accb7cf-0178-49e7-a907-44da8c41ca8e.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/5e428394-3fd2-480c-9c7e-2bd099118a10.jpg"></p>
<h1 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof">栈的压入、弹出序列</a></h1><p><img src="https://files.mdnice.com/user/1489/56115b51-a2ce-4bca-8a39-7c4ac2e070e6.jpg"></p>
<h1 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof">包含min函数的栈</a></h1><p><img src="https://files.mdnice.com/user/1489/e92fd7e3-d208-4978-bdf6-fd51492fbeb6.jpg"></p>
<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list">反转链表</a></h1><p><img src="https://files.mdnice.com/user/1489/6d46c580-ca37-4f4d-89cb-b250a209b90a.jpg"></p>
<h1 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof">数值的整数次方</a></h1><p><img src="https://files.mdnice.com/user/1489/52bf9fe5-269b-46c3-8f40-dac13d75ecdb.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/4254d052-fced-468a-a06b-80a9c388b798.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/ba0409e5-fa6d-4d7e-9292-f5be87a8fd13.jpg"></p>
<h1 id="删除链表的节点"><a href="#删除链表的节点" class="headerlink" title="删除链表的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof">删除链表的节点</a></h1><p><img src="https://files.mdnice.com/user/1489/f7b719a0-e068-42c3-b6f8-6f20301194df.jpg"></p>
<h1 id="链表的倒数第K个节点"><a href="#链表的倒数第K个节点" class="headerlink" title="链表的倒数第K个节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list">链表的倒数第K个节点</a></h1><p><img src="https://files.mdnice.com/user/1489/4ef04808-5bea-4610-9567-9fe0c028d63c.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/bad95909-e879-4f70-97f2-f9d01d7f5d22.jpg"></p>
<h1 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof">顺时针打印矩阵</a></h1><p><img src="https://files.mdnice.com/user/1489/ec7c4226-3a47-4a54-bfdc-740e523ceaac.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/06c76a5a-8e15-4971-9fa9-4702abdf8348.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/3bbe711c-cbeb-459c-ad4b-e00d7b508cb4.jpg"></p>
<h1 id="调整数组顺序使得奇数位于偶数前"><a href="#调整数组顺序使得奇数位于偶数前" class="headerlink" title="调整数组顺序使得奇数位于偶数前"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof">调整数组顺序使得奇数位于偶数前</a></h1><p><img src="https://files.mdnice.com/user/1489/67ec0ae6-0a3c-4dc0-bc54-2f6bfa7b6d5d.jpg"></p>
<h1 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof">合并两个排序的链表</a></h1><p><img src="https://files.mdnice.com/user/1489/5ad4608e-ae3f-4ea6-abc5-01ccba98b8bd.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/bdc5a0f5-514e-4994-97ae-4aa2b468d4a1.jpg"></p>
<h1 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof">从尾到头打印链表</a></h1><p><img src="https://files.mdnice.com/user/1489/e7287e83-0a0f-4c88-97a9-70c01dd6b61a.jpg"></p>
<h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof">替换空格</a></h1><p><img src="https://files.mdnice.com/user/1489/12f83946-efa1-4c45-aefb-cf2385b1e4e0.jpg"><br><img src="https://files.mdnice.com/user/1489/014f2c8d-e879-4228-a24e-3c902a6366cf.jpg"><br><img src="https://files.mdnice.com/user/1489/aa420d60-feec-41e4-b141-ad2d40924901.jpg"></p>
<h1 id="重构字符串"><a href="#重构字符串" class="headerlink" title="重构字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.cn/problems/reorganize-string/">重构字符串</a></h1><p><img src="https://files.mdnice.com/user/1489/a0be23ac-6081-411c-96cb-9f2c79fcabb1.jpg"><br><img src="https://files.mdnice.com/user/1489/7c65b823-1c0b-4d4f-8a13-554fb12cf314.jpg"></p>
<h1 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof">数组中重复的数字</a></h1><p><img src="https://files.mdnice.com/user/1489/e648c0ad-b283-4b66-90d7-4bc23329dd5a.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/64f8d26f-c230-49c3-b398-df245f234505.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/92daf8e2-3349-475e-af48-4ad83be8a41e.jpg"><br><img src="https://files.mdnice.com/user/1489/174e0c93-01d3-41d0-8a49-c894760318e3.jpg"></p>
<h1 id="自除数"><a href="#自除数" class="headerlink" title="自除数"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/self-dividing-numbers/">自除数</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Approach #1: Brute Force [Accepted]</span><br><span class="line">Intuition and Algorithm</span><br><span class="line"></span><br><span class="line">For each number in the given range, we will directly test if that number is self-dividing.</span><br><span class="line"></span><br><span class="line">By definition, we want to test each whether each digit is non-zero and divides the number. For example, with 128, we want to test d != 0 &amp;&amp; 128 % d == 0 for d = 1, 2, 8. To do that, we need to iterate over each digit of the number.</span><br><span class="line"></span><br><span class="line">A straightforward approach to that problem would be to convert the number into a character array (string in Python), and then convert back to integer to perform the modulo operation when checking n % d == 0.</span><br><span class="line"></span><br><span class="line">We could also continually divide the number by 10 and peek at the last digit. That is shown as a variation in a comment.</span><br><span class="line"></span><br><span class="line">Complexity Analysis</span><br><span class="line"></span><br><span class="line">Time Complexity: O(D)O(D), where DD is the number of integers in the range [L, R][L,R], and assuming \log(R)log(R) is bounded. (In general, the complexity would be O(D\log R)O(DlogR).)</span><br><span class="line"></span><br><span class="line">Space Complexity: O(D)O(D), the length of the answer.</span><br></pre></td></tr></table></figure>


<p><img src="https://files.mdnice.com/user/1489/31bcba36-c886-412a-a41d-069f5cd29713.jpg"></p>
<h1 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/partition-labels/">划分字母区间</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Approach 1: Greedy</span><br><span class="line">Intuition</span><br><span class="line"></span><br><span class="line">Let&#x27;s try to repeatedly choose the smallest left-justified partition. Consider the first label, say it&#x27;s &#x27;a&#x27;. The first partition must include it, and also the last occurrence of &#x27;a&#x27;. However, between those two occurrences of &#x27;a&#x27;, there could be other labels that make the minimum size of this partition bigger. For example, in &quot;abccaddbeffe&quot;, the minimum first partition is &quot;abccaddb&quot;. This gives us the idea for the algorithm: For each letter encountered, process the last occurrence of that letter, extending the current partition [anchor, j] appropriately.</span><br><span class="line"></span><br><span class="line">Algorithm</span><br><span class="line"></span><br><span class="line">We need an array last[char] -&gt; index of S where char occurs last. Then, let anchor and j be the start and end of the current partition. If we are at a label that occurs last at some index after j, we&#x27;ll extend the partition j = last[c]. If we are at the end of the partition (i == j) then we&#x27;ll append a partition size to our answer, and set the start of our new partition to i+1.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Complexity Analysis</span><br><span class="line"></span><br><span class="line">Time Complexity: O(N)O(N), where NN is the length of SS.</span><br><span class="line"></span><br><span class="line">Space Complexity: O(1)O(1) to keep data structure last of not more than 26 characters.</span><br></pre></td></tr></table></figure>
<p><img src="https://files.mdnice.com/user/1489/81edb05f-482a-48d2-a709-9c012a5a148c.jpg"><br><img src="https://files.mdnice.com/user/1489/56fac4ed-d7a0-42b3-b63c-5ae4151b4d95.jpg"></p>
<h1 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/daily-temperatures">每日温度</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">❌ Solution - I (Brute-Force)</span><br><span class="line"></span><br><span class="line">Let&#x27;s see how we can solve this using brute-force approach.</span><br><span class="line"></span><br><span class="line">For each index i, we can just iterate over the array till we either find the the 1st index j such that T[j] &gt; T[i] or reach the end of array.</span><br><span class="line">If we find j such that T[j] &gt; T[i], we have ans[i] = j-i.</span><br><span class="line">Otherwise, ans[i] = 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Time Complexity : O(N2), where N is the number of elements in the input array T. In the worst case, we iterate till the end of array for each index i. So, the total number of iterations required are N-1 + N-2 + N-3 +...+ 1 = N(N-1)/2 which is equivalent to O(N2)</span><br><span class="line">Space Complexity : O(1), ignoring the space required by the output array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">✔️ Solution - II (Decreasing Monotonic Stack)</span><br><span class="line"></span><br><span class="line">In the above solution, we can see that in the worst case, we are repeatedly iterating till the end of array either to find the next greater element at the very end or not finding it at all. This is redundant. We can optimize the above approach by observing that multiple elements can share a common warmer day. For eg. Consider [4,3,2,1,5]. In the brute-force, we would have iterated till 5th element in every case and assigned ans[i] as difference between the indices. However, we see that all elments share 5 as the next warmer day.</span><br><span class="line"></span><br><span class="line">Thus, the pattern we see is that we iterate forward till we find a warmer day and that day will be the answer for all elements before it that are cooler (and not found a warmer day). Thus, we can maintain a stack consisting of indices of days which haven&#x27;t found a warmer day. The temperature at these indices will be in decreasing order since we are only storing days that haven&#x27;t found a warmer next day and hence it is known as decreasing monotonic stack. Whenever we find a current day cur which is warmer, we check elements of stack and assign them the difference of indices for all those elements which have temperature of corresponding day less than T[cur].</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thus, the algorithm can be summarized as -</span><br><span class="line"></span><br><span class="line">Initialize an empty stack s and ans array of size N all initialized to 0s.</span><br><span class="line">Iterate over T from the start</span><br><span class="line">For each current day cur, check if today&#x27;s temperature T[cur] is warmer than values corresponding to previous days&#x27; indices stored in stack (T[s.top()]). Assign answer for all elements of stack for whom current day&#x27;s temperature is warmer (T[cur] &gt; T[s.top()]) and pop them off the stack.</span><br><span class="line">Push cur onto the stack denoting that we need to find warmer next day for cur.</span><br><span class="line">All the elements present in the stack at end don&#x27;t have a next greater element. We don&#x27;t have to worry about them since ans is already initialized to 0. Thus, we can directly return ans.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Time Complexity : O(N), In the worst case, we require O(2*N) ~ O(N) iterations.</span><br><span class="line">Space Complexity : O(N), In the worst case, we may have decreasing elements in T and stack will store all N indices in it</span><br><span class="line"></span><br><span class="line">✔️ Solution - III (Monotonic Stack - 2)</span><br><span class="line"></span><br><span class="line">Another way of modelling the problem in terms of monotonic stack that some may find more intuitive is by starting from the end of the array. We again maintain a monotonic stack in this case as well which is similar to above appraoch, the only change is just that we start from the end.</span><br><span class="line"></span><br><span class="line">This will again allow us to find the next warmer element for each index just by looking through the stack. Since we are maintaining a sorted stack (increasing from top-to-bottom), we know that the first element that we find in stack for curth day such that T[s.top()] &gt; T[cur], will be next warmer day required for that element.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In the above image, we start from the end and each time assign next warmer day to be top of stack element. In the 1st approach, we instead started from beginning and only assigned next warmer day/s at once once we find a warmer day than all preciding elements. Both approach should work just fine.</span><br><span class="line"></span><br><span class="line">The algorithm can be summarized as -</span><br><span class="line"></span><br><span class="line">Initialize an empty stack s and ans array of size N all initialized to 0s.</span><br><span class="line">Iterate over T from the end.</span><br><span class="line">For each current day cur, pop values corresponding from stack that have temperature(T[s.top()]) lower than today&#x27;s temperature T[cur], i.e, T[s.top()] &lt;= T[cur]. This popping is done because these elements are cooler than T[cur] and occur later on than cur. Thus, they will never be a potential answer for elements on the left.</span><br><span class="line">Now that all elements lower than T[cur] have been popped off, stack s is either empty or has some element warmer than cur.</span><br><span class="line">If stack is empty, assign ans[cur] = 0 because no next warmer element exists for cur.</span><br><span class="line">Otherwise, assign ans[cur] = s.top()-cur, the difference between indices of next warmer element and cur.</span><br><span class="line">Then, Push cur onto the stack since it has potential to be next closest warmer day for remaining elements on left of T.</span><br><span class="line">Finally, return ans.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://files.mdnice.com/user/1489/979f2ad7-bb3d-4d06-8f1e-56c11921e810.jpg"><br><img src="https://files.mdnice.com/user/1489/eee786ba-73e5-4de7-9cc8-b82b80c56364.jpg"><br><img src="https://files.mdnice.com/user/1489/f5e179e8-5c9b-40e5-b110-75d3cb245491.jpg"></p>
<h1 id="1比特与2比特字符"><a href="#1比特与2比特字符" class="headerlink" title="1比特与2比特字符"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/1-bit-and-2-bit-characters/">1比特与2比特字符</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Solution Approach:</span><br><span class="line"></span><br><span class="line">Traverse the array from 0 to n-2 (leaving the last character).</span><br><span class="line">Now if current char is 0, increment i by 1.</span><br><span class="line">Else increment by 2 as 1 is always followed by either 1 or 0.</span><br><span class="line">After the loop ends check if i is pointing to last char (i.e. n-1) or before that return true, else false.</span><br></pre></td></tr></table></figure>


<p><img src="https://files.mdnice.com/user/1489/c8d08da7-0629-49fc-b47b-55d8f9ec7c71.jpg"><br><img src="https://files.mdnice.com/user/1489/2d61a58f-d344-424e-8716-5ab9c5653f6e.jpg"></p>
<h1 id="最短无序连续子数组"><a href="#最短无序连续子数组" class="headerlink" title="最短无序连续子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/shortest-unsorted-continuous-subarray/">最短无序连续子数组</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Approach 1: Brute Force</span><br><span class="line">Algorithm</span><br><span class="line"></span><br><span class="line">In the brute force approach, we consider every possible subarray that can be formed from the given array numsnums. For every subarray nums[i:j]nums[i:j] considered, we need to check whether this is the smallest unsorted subarray or not. Thus, for every such subarray considered, we find out the maximum and minimum values lying in that subarray given by maxmax and minmin respectively.</span><br><span class="line"></span><br><span class="line">If the subarrays nums[0:i-1]nums[0:i−1] and nums[j:n-1]nums[j:n−1] are correctly sorted, then only nums[i:j]nums[i:j] could be the required subrray. Further, the elements in nums[0:i-1]nums[0:i−1] all need to be lesser than the minmin for satisfying the required condition. Similarly, all the elements in nums[j:n-1]nums[j:n−1] need to be larger than maxmax. We check for these conditions for every possible ii and jj selected.</span><br><span class="line"></span><br><span class="line">Further, we also need to check if nums[0:i-1]nums[0:i−1] and nums[j:n-1]nums[j:n−1] are sorted correctly. If all the above conditions are satisfied, we determine the length of the unsorted subarray as j-ij−i. We do the same process for every subarray chosen and determine the length of the smallest unsorted subarray found.</span><br></pre></td></tr></table></figure>
<p><img src="https://files.mdnice.com/user/1489/e5f2d5b8-6440-4910-9eb2-20848cebe369.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/08f457d6-d730-4b87-bff8-e9211b8332bd.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/86763d3e-dcd7-46e9-bbe3-d0b14813dc5b.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/11abbaeb-d616-4866-9bd8-029b298f1f97.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/074c12a8-524a-4f31-8abd-878e9aca33be.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/c5bfa348-f61c-44be-b5a6-797e736ece90.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/90f1cfd8-35b9-44aa-8281-b9fc3097c54a.jpg"></p>
<h1 id="找到所有数组中消失的数字"><a href="#找到所有数组中消失的数字" class="headerlink" title="找到所有数组中消失的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array">找到所有数组中消失的数字</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">❌ Solution - I (Brute-Force)</span><br><span class="line"></span><br><span class="line">A brute-force way to solve this question is to take each number in range [1, n] and push it into ans array if it doesn&#x27;t occur in nums.</span><br><span class="line"></span><br><span class="line">C++</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        for(int i = 1; i &lt;= size(nums); i++) </span><br><span class="line">            if(find(begin(nums), end(nums), i) == end(nums))  // linear search in nums for each i</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Python</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def findDisappearedNumbers(self, nums):        </span><br><span class="line">        return [i for i in range(1, len(nums)+1) if i not in nums]</span><br><span class="line">Time Complexity : O(n2), we iterate over the range [1, n] which takes O(n) and for each iteration, we check if that element occurs in nums which takes another O(n) giving total time of O(n2)</span><br><span class="line">Space Complexity : O(1), excluding the space required for the output vector, we only use constant extra space. The output space is generally not included in the space complexity.</span><br><span class="line"></span><br><span class="line">✔️ Solution - II (Sort &amp; Binary-Search)</span><br><span class="line"></span><br><span class="line">Instead of linear-searching if every element in range [1, n] is present in nums or not, we could instead sort nums and then apply binary-search every time. If the element is not found in nums, we include it in ans.</span><br><span class="line"></span><br><span class="line">C++</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sort(begin(nums), end(nums));</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        for(int i = 1; i &lt;= size(nums); i++) </span><br><span class="line">            if(!binary_search(begin(nums), end(nums), i))   // binary search in nums for each i</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Python</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def findDisappearedNumbers(self, nums):</span><br><span class="line">        nums.sort()</span><br><span class="line">        return [i for i in range(1, len(nums)+1) if nums[bisect_left(nums, i)%len(nums)] != i]</span><br><span class="line">Time Complexity : O(nlogn), we iterate over the range [1, n] which takes O(n) and for each iteration, we check if that element occurs in nums using binary search which takes another O(logn) giving a total time of O(nlogn)</span><br><span class="line">Space Complexity : O(sort), the only extra space required is the one used in internal sorting algorithm. Ignoring that space, we can say it to be O(1)</span><br><span class="line"></span><br><span class="line">✔️ Solution - III (HashSet)</span><br><span class="line"></span><br><span class="line">We can do even better if we just insert every element from nums into a hashset and then iterate over the range [1, n] and only add those elements to ans and are not present in hashset.</span><br><span class="line"></span><br><span class="line">C++</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; s(begin(nums), end(nums));   // insert every nums[i] in hashset</span><br><span class="line">        vector&lt;int&gt; ans(size(nums) - size(s));</span><br><span class="line">        for(int i = 1, j = 0; i &lt;= size(nums); i++)  </span><br><span class="line">            if(!s.count(i)) ans[j++] = i;               // add all elements not found in hashset to ans</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Python</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def findDisappearedNumbers(self, nums):</span><br><span class="line">        s = set(nums)</span><br><span class="line">        return [i for i in range(1, len(nums)+1) if i not in s]</span><br><span class="line">Time Complexity : O(n), we require O(n) time to insert all elements into hashset and another O(n) time to iterate over range and insert elements not present in hashset into ans, thus giving a total time of O(n).</span><br><span class="line">Space Complexity : O(n), required to maintain the hashset.</span><br><span class="line"></span><br><span class="line">✔️ Solution - IV (Boolean array)</span><br><span class="line"></span><br><span class="line">We can slightly optimize previous approach by using an boolean array of size n instead of hashset, since the range is known to be [1, n]</span><br><span class="line"></span><br><span class="line">C++</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;bool&gt; seen(size(nums)+1);</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        for(auto c : nums) seen[c] = true;</span><br><span class="line">        for(int i = 1; i &lt;= size(nums); i++)</span><br><span class="line">            if(!seen[i]) ans.push_back(i);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution:</span><br><span class="line">    def findDisappearedNumbers(self, nums):        </span><br><span class="line">        ans, seen = [], [False]*(len(nums)+1)</span><br><span class="line">        for c in nums: seen[c] = True</span><br><span class="line">        for i in range(1, len(nums)+1):</span><br><span class="line">            if not seen[i]:</span><br><span class="line">                ans.append(i)</span><br><span class="line">        return ans</span><br><span class="line">Time Complexity : O(n)</span><br><span class="line">Space Complexity : O(n)</span><br><span class="line"></span><br><span class="line">✔️ Solution - V (Placing Elements at Correct Index - Space Optimized)</span><br><span class="line"></span><br><span class="line">This solution involves placing all possible elements at their right index place. By that, I mean every possible index i should be occupied by correct element i+1, i.e, num[i] = i+1. This allows us to check if a number j from range [1, n] exists in nums or not.</span><br><span class="line"></span><br><span class="line">The numbers j will be present in nums only if the number j itself is present at nums[j-1] which is its correct index place.</span><br><span class="line">The numbers j&#x27; that are not present in nums wont have correct element (which is j&#x27; itself) at its correct index place nums[j&#x27;-1].</span><br><span class="line">The numbers j that are not in nums wont have correct element at their right index place (nums[i-1]) and that index place would be occupied by some other element.</span><br><span class="line"></span><br><span class="line">Now, Can we do this linearly using constant space? Yes!</span><br><span class="line"></span><br><span class="line">We will iterate over each element of nums.</span><br><span class="line">For each element c, if the correct index place of c, i.e, nums[c-1] is not occupied by c, then we place c at its correct index place. But we dont want to lose number which was already present at nums[c-1]. So we swap it instead so the number at nums[c-1] occupies current element c &amp; vice-versa.</span><br><span class="line">We placed original current element c at its correct place but now we have another element as c for which we need to place it at its correct place. So, repeat above step till c is at its correct place in nums.</span><br><span class="line">The steps 2 &amp; 3 are repeated for all elements of nums so that we ensure every possible index is occupied by correct element. At last, the index not occupied by correct element are once which dont occur in nums.</span><br><span class="line">Let nums = [4,3,2,7,8,2,3,1]. The steps take place as -</span><br><span class="line"></span><br><span class="line">[7,3,2,4,8,2,3,1]</span><br><span class="line">[3,3,2,4,8,2,7,1]</span><br><span class="line">[2,3,3,4,8,2,7,1]</span><br><span class="line">[3,2,3,4,8,2,7,1]</span><br><span class="line">[3,2,3,4,1,2,7,8]</span><br><span class="line">[1,2,3,4,3,2,7,8]</span><br><span class="line"></span><br><span class="line">Index 4 &amp; 5 are not occupied by their correct elements meaning the elements corresponding to those indices are missing</span><br></pre></td></tr></table></figure>
<p><img src="https://files.mdnice.com/user/1489/d1fcc62e-aeaa-4ccf-b224-ab724f90ae37.jpg"></p>
<h1 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/assign-cookies">分发饼干</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sort greed array and cookie array. Then simply walk both arrays and match cookie to greed if greed is less than cookie.</span><br></pre></td></tr></table></figure>
<p><img src="https://files.mdnice.com/user/1489/d3a4ed92-b21e-4237-87cd-5bfb2bee545e.jpg"></p>
<h1 id="找到所有数组中消失的数字-1"><a href="#找到所有数组中消失的数字-1" class="headerlink" title="找到所有数组中消失的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array">找到所有数组中消失的数字</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1st for loop: for each value x, negate the element at xth position</span><br><span class="line">2nd for loop: get all the positions that has a positive element. These are the missing values to return.</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">		</span><br><span class="line">        // 1st for loop: nums = [4,3,2,7,8,2,3,1]</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)  // each iteration:</span><br><span class="line">        &#123;                                     // i = 0              i = 1               i = 2                ... i = 7</span><br><span class="line">            int temp = nums[i];               // temp = 4           temp = 3            temp = -2            ... temp = -1</span><br><span class="line">            temp = (temp &gt; 0) ? temp : -temp; // temp = 4           temp = 3            temp = 2             ... temp = 1</span><br><span class="line">            if(nums[temp-1] &gt; 0)              // nums[3] &gt; 0        nums[2] &gt; 0         nums[1] &gt; 0          ... nums[0] &gt; 0</span><br><span class="line">                nums[temp-1] *= -1;           // [4,3,2,-7,8,2,3,1] [4,3,-2,-7,8,2,3,1] [4,-3,-2,-7,8,2,3,1] ... [-4,-3,-2,-7,8,2,-3,-1]</span><br><span class="line">        &#125; </span><br><span class="line">		</span><br><span class="line">		// 2nd for loop: nums = [-4,-3,-2,-7,8,2,-3,-1]</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)</span><br><span class="line">            if(nums[i] &gt; 0)         // the 4th &amp; 5th indexes are positive</span><br><span class="line">                ans.push_back(i+1); // ans = [5,6]</span><br><span class="line">				</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://files.mdnice.com/user/1489/0f99a883-da18-46ca-9985-d7ba4a46092d.jpg"></p>
<h1 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/3sum-closest/">最接近的三数之和</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        //BRUTE FORCE APPROACH...(but a little improved)</span><br><span class="line">        //Applying two pointers on the sorted array for target-currnumber</span><br><span class="line">        //time complexity O(N^2)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        int ans; //...Our Final sum(of all three integers) will be stored here</span><br><span class="line">        int prevDiff = INT_MAX; //...this will be the closest difference between target and the sum we calculated...this will be changed each time it is compared with a sum that is found to be lower than the previous closest sum</span><br><span class="line">        int temp = target;</span><br><span class="line">        sort(nums.begin(),nums.end()); //sorting the array inorder to carry out our two pointer approach</span><br><span class="line">        for(int i =0;i&lt;nums.size()-2;i++)&#123;  //loop till nums.size()-2 because we always play with three pointers two of which we don&#x27;t want to get out of the array</span><br><span class="line">                temp = target-nums[i]; //reducing the target to target-curr value(this curr value is one of the three integers we take into consideration)</span><br><span class="line">                int start = i+1;        // starting from one index ahead of curr index</span><br><span class="line">                int end = nums.size()-1;</span><br><span class="line">                int x;                  // for calculating and comparing with the new target value(temp)...this is similar as two sum problem..</span><br><span class="line">            </span><br><span class="line">        // so the idea here is to get the sum of two integers as closest as (or equal to ) the new target(temp) which is done by </span><br><span class="line">        // keeping two pointers and changing their positions so as to get as close as possible to our new target value.</span><br><span class="line">                while(start&lt;end)&#123;       </span><br><span class="line">                     x = nums[start]+nums[end];</span><br><span class="line">                    if(x==temp) break;      //breaking here ... cuz can&#x27;t get any closer than the TARGET ITSELF!</span><br><span class="line">                    if(x&lt;temp) start++;     //incase the sum is lower we shift start to right side so as to increase sum and get closer to our target value(temp)</span><br><span class="line">                    else end--; </span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            //now here after this traversal we have obtained a value of sum of three integers as close to temp as possible</span><br><span class="line">            //this value is x + nums[i]</span><br><span class="line">            //we take the difference of target value (original) with this sum and compare this difference with previous difference(because we need to be as close to target as possible right!)</span><br><span class="line">            //if difference is less than prev diff we update our ans and prevDifference gets equal to this difference value..</span><br><span class="line">                if(abs(target-(x+nums[i]))&lt;prevDiff)&#123;   </span><br><span class="line">                    ans = x+nums[i];</span><br><span class="line">                    prevDiff = abs(target-(x+nums[i]));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return ans; //hooray!</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://files.mdnice.com/user/1489/d5a6910c-41c0-471f-b8c3-3b79ae583be8.jpg"><br><img src="https://files.mdnice.com/user/1489/252bc915-1dc7-43e6-9498-e75607502c81.jpg"></p>
<h1 id="四数相加"><a href="#四数相加" class="headerlink" title="四数相加||"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/4sum-ii/">四数相加||</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123;</span><br><span class="line">        </span><br><span class="line">        int count=0;</span><br><span class="line">        unordered_map&lt;int,int&gt; mp;</span><br><span class="line">        </span><br><span class="line">        /* Philosophy</span><br><span class="line">        </span><br><span class="line">        1. I know that Addtion have two parts in it  EG (a +b , Part 1 - a, Part 2- b.</span><br><span class="line">        2.So, Lets make and find this dependency factors. How can I do it?</span><br><span class="line">        </span><br><span class="line">        3. If there are 4 Sum. it means 2 sums is going to Part 1 and another 2 gonna be Part 2 which are dependent on Part 1 for 0 resultant.</span><br><span class="line">        </span><br><span class="line">        4. I gonna store summation 2 nums1 in a FREQUENCY Hashmap.</span><br><span class="line">        </span><br><span class="line">        5. Then I traverse 2nd part of the summation (rest to nums) and keep checking that do (0-it1-it2) is exist in map . </span><br><span class="line">       </span><br><span class="line">        6. If yes, the add the frequency of Part1 int COUNT var.</span><br><span class="line">        </span><br><span class="line">        7. return count;</span><br><span class="line">        */</span><br><span class="line">        </span><br><span class="line">        //Traversing Part 1</span><br><span class="line">        for (auto &amp;it1: nums1)</span><br><span class="line">            for (auto &amp;it2:nums2)</span><br><span class="line">                mp[it1+it2]++; </span><br><span class="line">        </span><br><span class="line">        // Traversing Part 2</span><br><span class="line">        for(auto &amp;it3: nums3)</span><br><span class="line">            for(auto &amp;it4:nums4)</span><br><span class="line">               if(mp.count(0-it3-it4)) count+=mp[0-it3-it4];</span><br><span class="line">        </span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://files.mdnice.com/user/1489/81e7a78b-6e9b-4804-b4bc-f32031fdd571.jpg"></p>
<h1 id="分治-最长公共前缀"><a href="#分治-最长公共前缀" class="headerlink" title="分治:最长公共前缀"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-common-prefix/">分治:最长公共前缀</a></h1><p><img src="https://files.mdnice.com/user/1489/30ad2757-a9f8-4d82-8c7f-c651fdf864de.png"></p>
<p><img src="https://files.mdnice.com/user/1489/c3f4eaeb-9f8f-4265-9009-1a4b808cb5e6.png"></p>
<p><img src="https://files.mdnice.com/user/1489/a1c451b7-b2eb-4545-b354-c7c37a1ab8e0.jpg"><br><img src="https://files.mdnice.com/user/1489/d7e4710d-6ea2-41b2-9aba-1dca85dcd9d3.jpg"><br><img src="https://files.mdnice.com/user/1489/6f172e79-74e2-452d-ab77-a7149388bb74.jpg"></p>
<h1 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-integer/">整数反转</a></h1><p><img src="https://files.mdnice.com/user/1489/98e33881-29f0-4462-9991-2012f94ae9f1.png"></p>
<p><img src="https://files.mdnice.com/user/1489/d5945a88-399a-4b88-a5b5-20e6fe7e7e99.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/f8c0d53a-9c66-4d00-857c-cab81d087035.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/0e795a17-567a-42d3-a1bb-677b12f407e8.jpg"></p>
<h1 id="盛水最多的容器"><a href="#盛水最多的容器" class="headerlink" title="盛水最多的容器"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/container-with-most-water/">盛水最多的容器</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Explanation :</span><br><span class="line"></span><br><span class="line">Intuition : Volume/Area depends upon the bar having minimum height</span><br><span class="line"></span><br><span class="line">Now suppose, height[i] &lt; height[j], in this case we can only store water with area height[i]*(j-i), now there is chance there is a greater value of i present in array so increment i</span><br><span class="line">Vice-vera height[i]&gt;height[j], here area would be height[j]*(j-i), in this case there&#x27;s chance a greater value of j is present in array so decrement j</span><br></pre></td></tr></table></figure>
<p><img src="https://files.mdnice.com/user/1489/152a336e-c600-4937-850c-d0f1fd5a4c4f.jpg"></p>
<h1 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-substring-without-repeating-characters">无重复字符的最长子串</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A solution for beginners, which is straightforward, easy to understand, without too many complications and room to optimize once you understand the basic premise of the question. Hope this helps!</span><br><span class="line"></span><br><span class="line">Time Complexity: O(n)</span><br><span class="line">Space Complexity: O(min of a,b) for the unordered set. a, is the upper bound of the space complexity.</span><br><span class="line">Where a: Size of the string</span><br><span class="line">b: Size of the number of characters in the character-set</span><br></pre></td></tr></table></figure>
<p><img src="https://files.mdnice.com/user/1489/f075ebdf-3df9-4229-be81-efdca44423d4.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/55e84e02-f0b6-4e27-ace1-28039e20c7ef.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/7b8def0f-7d26-40fb-8936-24236b14e7af.jpg"></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/19/Linux-Command-Wildcard/" rel="prev" title="Linux Command —— Wildcard">
      <i class="fa fa-chevron-left"></i> Linux Command —— Wildcard
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/05/29/%E3%80%90%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%E3%80%91%E5%85%B3%E4%BA%8E%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AF%AF%E5%B7%AE%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%BB%E7%BB%93/" rel="next" title="【经验总结】关于浮点数double/float精度误差问题的总结">
      【经验总结】关于浮点数double/float精度误差问题的总结 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-number">1.</span> <span class="nav-text">回溯: 字符串的排列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%EF%BC%9A78-%E5%AD%90%E9%9B%86"><span class="nav-number">2.</span> <span class="nav-text">回溯：78. 子集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%9B%9E%E6%BA%AF"><span class="nav-number">2.1.</span> <span class="nav-text">Solution1 回溯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%EF%BC%9A-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="nav-number">3.</span> <span class="nav-text">回溯： 39. 组合总和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B"><span class="nav-number">3.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%9B%9E%E6%BA%AF"><span class="nav-number">3.2.</span> <span class="nav-text">Solution2 回溯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%EF%BC%9A-40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="nav-number">4.</span> <span class="nav-text">回溯： 40. 组合总和 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%9B%9E%E6%BA%AF-1"><span class="nav-number">4.1.</span> <span class="nav-text">Solution1 回溯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%EF%BC%9A-46-%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">5.</span> <span class="nav-text">回溯： 46. 全排列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-1"><span class="nav-number">5.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%9B%9E%E6%BA%AF-1"><span class="nav-number">5.2.</span> <span class="nav-text">Solution2 回溯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%EF%BC%9A22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90"><span class="nav-number">6.</span> <span class="nav-text">回溯：22. 括号生成</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-2"><span class="nav-number">6.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E9%80%92%E5%BD%92-%E5%89%AA%E6%9E%9D"><span class="nav-number">6.2.</span> <span class="nav-text">Solution2 递归 + 剪枝</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="nav-number">7.</span> <span class="nav-text">回溯: 17. 电话号码的字母组合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-1-%E6%9A%B4%E5%8A%9B"><span class="nav-number">7.1.</span> <span class="nav-text">Solution 1  暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Soulution-2-%E5%9B%9E%E6%BA%AF"><span class="nav-number">7.2.</span> <span class="nav-text">Soulution 2  回溯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-3-%E9%98%9F%E5%88%97"><span class="nav-number">7.3.</span> <span class="nav-text">Solution 3  队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%EF%BC%9A0-n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">8.</span> <span class="nav-text">二分：0~n-1中缺失的数字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%EF%BC%9A162-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC"><span class="nav-number">9.</span> <span class="nav-text">二分：162. 寻找峰值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-3"><span class="nav-number">9.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%BA%8C%E5%88%86%E6%B3%95"><span class="nav-number">9.2.</span> <span class="nav-text">Solution2 二分法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%88%86-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="nav-number">10.</span> <span class="nav-text">二分: 旋转数组的最小数字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%EF%BC%9A33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">11.</span> <span class="nav-text">二分：33. 搜索旋转排序数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-4"><span class="nav-number">11.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">11.2.</span> <span class="nav-text">Solution2 二分查找</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%EF%BC%9A34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="nav-number">12.</span> <span class="nav-text">二分：34. 在排序数组中查找元素的第一个和最后一个位置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-5"><span class="nav-number">12.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%BA%8C%E5%88%86"><span class="nav-number">12.2.</span> <span class="nav-text">Solution2 二分</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%EF%BC%9A-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="nav-number">13.</span> <span class="nav-text">二分： 35. 搜索插入位置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-6"><span class="nav-number">13.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%BA%8C%E5%88%86-1"><span class="nav-number">13.2.</span> <span class="nav-text">Solution2 二分</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%EF%BC%9A69-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9"><span class="nav-number">14.</span> <span class="nav-text">二分：69. x 的平方根 </span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-7"><span class="nav-number">14.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="nav-number">14.2.</span> <span class="nav-text">Solution2 二分搜索</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%EF%BC%9A287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0"><span class="nav-number">15.</span> <span class="nav-text">：287. 寻找重复数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E4%BA%8C%E5%88%86%E6%B3%95"><span class="nav-number">15.1.</span> <span class="nav-text">Solution1 二分法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="nav-number">15.2.</span> <span class="nav-text">Solution2 二进制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution3-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="nav-number">15.3.</span> <span class="nav-text">Solution3 快慢指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-number">16.</span> <span class="nav-text">动态规划：53. 最大子数组和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-8"><span class="nav-number">16.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">16.2.</span> <span class="nav-text">Solution2 动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution3-%E5%88%86%E6%B2%BB"><span class="nav-number">16.3.</span> <span class="nav-text">Solution3 分治</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="nav-number">17.</span> <span class="nav-text">动态规划：62. 不同路径</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88"><span class="nav-number">17.1.</span> <span class="nav-text">Solution1 排列组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="nav-number">17.2.</span> <span class="nav-text">Solution2 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">18.</span> <span class="nav-text">动态规划：64. 最小路径和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E6%9A%B4%E5%8A%9B"><span class="nav-number">18.1.</span> <span class="nav-text">Solution0 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">18.2.</span> <span class="nav-text">Solution1 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A70-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="nav-number">19.</span> <span class="nav-text">动态规划：70. 爬楼梯</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92"><span class="nav-number">19.1.</span> <span class="nav-text">Solution1 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95"><span class="nav-number">20.</span> <span class="nav-text">动态规划 91. 解码方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="nav-number">20.1.</span> <span class="nav-text">Solution1 动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BC%98%E5%8C%96%E4%B8%BAO-1"><span class="nav-number">20.2.</span> <span class="nav-text">Solution2 动态规划 空间复杂度优化为O(1)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91-x2F-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A-96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">21.</span> <span class="nav-text">树&#x2F;动态规划： 96. 不同的二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2"><span class="nav-number">21.1.</span> <span class="nav-text">Solution1 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="nav-number">22.</span> <span class="nav-text">动态规划：121. 买卖股票的最佳时机</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95"><span class="nav-number">22.1.</span> <span class="nav-text">Solution0 暴力解法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3"><span class="nav-number">22.2.</span> <span class="nav-text">Solution1 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II"><span class="nav-number">23.</span> <span class="nav-text">动态规划：122. 买卖股票的最佳时机 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-number">23.1.</span> <span class="nav-text">Solution1 贪心算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2"><span class="nav-number">23.2.</span> <span class="nav-text">Solution2 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="nav-number">24.</span> <span class="nav-text">动态规划：139. 单词拆分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-4"><span class="nav-number">24.1.</span> <span class="nav-text">Solution1 动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%BC%98%E5%8C%96%E7%89%88"><span class="nav-number">24.2.</span> <span class="nav-text">Solution2 动态规划 优化版</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">25.</span> <span class="nav-text">动态规划：152. 乘积最大子数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E6%9A%B4%E5%8A%9B-1"><span class="nav-number">25.1.</span> <span class="nav-text">Solution0 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-5"><span class="nav-number">25.2.</span> <span class="nav-text">Solution1 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="nav-number">26.</span> <span class="nav-text">动态规划：198. 打家劫舍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-6"><span class="nav-number">26.1.</span> <span class="nav-text">Solution1  动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3"><span class="nav-number">26.2.</span> <span class="nav-text">Solution2 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="nav-number">27.</span> <span class="nav-text">动态规划：221. 最大正方形</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E6%9A%B4%E5%8A%9B%E6%B3%95"><span class="nav-number">27.1.</span> <span class="nav-text">Solution0 暴力法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-7"><span class="nav-number">27.2.</span> <span class="nav-text">Solution1 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="nav-number">28.</span> <span class="nav-text">动态规划：279. 完全平方数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-8"><span class="nav-number">28.1.</span> <span class="nav-text">Solution1 动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E6%95%B0%E5%AD%A6"><span class="nav-number">28.2.</span> <span class="nav-text">Solution2  数学</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">29.</span> <span class="nav-text">动态规划：300. 最长递增子序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-9"><span class="nav-number">29.1.</span> <span class="nav-text">Solution1 动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%B4%AA%E5%BF%83"><span class="nav-number">29.2.</span> <span class="nav-text">Solution2  贪心</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A313-%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0"><span class="nav-number">30.</span> <span class="nav-text">动态规划：313. 超级丑数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9C%80%E5%B0%8F%E5%A0%86"><span class="nav-number">30.1.</span> <span class="nav-text">Solution1 最小堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-4"><span class="nav-number">30.2.</span> <span class="nav-text">Solution2 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-x2F-%E9%80%92%E5%BD%92%EF%BC%9A322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="nav-number">31.</span> <span class="nav-text">动态规划&#x2F;递归：322. 零钱兑换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-10"><span class="nav-number">31.1.</span> <span class="nav-text">Solution1 动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%B4%AA%E5%BF%83-%E5%9B%9E%E6%BA%AF-%E5%89%AA%E6%9E%9D"><span class="nav-number">31.2.</span> <span class="nav-text">Solution2 贪心+回溯+剪枝</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91-x2F-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-III"><span class="nav-number">32.</span> <span class="nav-text">树&#x2F;动态规划: 337. 打家劫舍 III</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-11"><span class="nav-number">32.1.</span> <span class="nav-text">Solution1 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-x2F-%E8%83%8C%E5%8C%85%EF%BC%9A%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="nav-number">33.</span> <span class="nav-text">动态规划&#x2F;背包：分割等和子集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution"><span class="nav-number">33.1.</span> <span class="nav-text">Solution</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="nav-number">34.</span> <span class="nav-text">动态规划:礼物的最大价值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="nav-number">35.</span> <span class="nav-text">动态规划: 连续子数组的最大和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%89%AA%E7%BB%B3%E5%AD%90"><span class="nav-number">36.</span> <span class="nav-text">动态规划:剪绳子</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="nav-number">37.</span> <span class="nav-text">动态规划: 青蛙跳台阶</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">38.</span> <span class="nav-text">动态规划: 最长重复子数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%9A%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">39.</span> <span class="nav-text">动态规划：和为K的子数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-number">40.</span> <span class="nav-text">动态规划:最长回文子串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97-268-%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">41.</span> <span class="nav-text">位运算:268. 丢失的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%8E%92%E5%BA%8F"><span class="nav-number">41.1.</span> <span class="nav-text">Solution1 排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E6%B1%82%E5%92%8C"><span class="nav-number">41.2.</span> <span class="nav-text">Solution2 求和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution3-%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">41.3.</span> <span class="nav-text">Solution3 位运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution4-%E5%93%88%E5%B8%8C"><span class="nav-number">41.4.</span> <span class="nav-text">Solution4 哈希</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%9A338-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0"><span class="nav-number">42.</span> <span class="nav-text">位运算：338. 比特位计数\</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1"><span class="nav-number">42.1.</span> <span class="nav-text">Solution1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2"><span class="nav-number">42.2.</span> <span class="nav-text">Solution2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution3"><span class="nav-number">42.3.</span> <span class="nav-text">Solution3</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97-371-%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">43.</span> <span class="nav-text">位运算:371. 两整数之和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">43.1.</span> <span class="nav-text">Solution1 位运算</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-number">44.</span> <span class="nav-text">位运算：数组中数字出现的次数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%9A%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95"><span class="nav-number">45.</span> <span class="nav-text">位运算：不用加减乘除做加法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB"><span class="nav-number">46.</span> <span class="nav-text">位运算:汉明距离</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">47.</span> <span class="nav-text">位运算:二进制中1的个数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%EF%BC%9A%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0"><span class="nav-number">48.</span> <span class="nav-text">位运算：数字的补数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%92%E5%BD%92%EF%BC%9A-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">49.</span> <span class="nav-text">递归： 24. 两两交换链表中的节点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-1"><span class="nav-number">49.1.</span> <span class="nav-text">Solution1  递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%BF%AD%E4%BB%A3"><span class="nav-number">49.2.</span> <span class="nav-text">Solution2 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91-x2F-%E9%80%92%E5%BD%92%EF%BC%9A95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-II"><span class="nav-number">50.</span> <span class="nav-text">树&#x2F;递归：95. 不同的二叉搜索树 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%9B%9E%E6%BA%AF-2"><span class="nav-number">50.1.</span> <span class="nav-text">Solution1 回溯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91-x2F-%E9%80%92%E5%BD%92%EF%BC%9A98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">51.</span> <span class="nav-text">树&#x2F;递归：98. 验证二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-2"><span class="nav-number">51.1.</span> <span class="nav-text">Solution1 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%BA%E5%8D%87%E5%BA%8F"><span class="nav-number">51.2.</span> <span class="nav-text">Solution2 中序遍历为升序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91-x2F-%E9%80%92%E5%BD%92%EF%BC%9A101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">52.</span> <span class="nav-text">树&#x2F;递归：101. 对称二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-3"><span class="nav-number">52.1.</span> <span class="nav-text">Solution1  递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E9%98%9F%E5%88%97"><span class="nav-number">52.2.</span> <span class="nav-text">Solution2 队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%92%E5%BD%92%EF%BC%9A200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="nav-number">53.</span> <span class="nav-text">递归：200. 岛屿数量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-DFS"><span class="nav-number">53.1.</span> <span class="nav-text">Solution1  DFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-BFS"><span class="nav-number">53.2.</span> <span class="nav-text">Solution2 BFS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%92%E5%BD%92%EF%BC%9A206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">54.</span> <span class="nav-text">递归：206. 反转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%BF%AD%E4%BB%A3"><span class="nav-number">54.1.</span> <span class="nav-text">Solution1 迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E9%80%92%E5%BD%92"><span class="nav-number">54.2.</span> <span class="nav-text">Solution2 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91-x2F-%E9%80%92%E5%BD%92%EF%BC%9A235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">55.</span> <span class="nav-text">树&#x2F;递归：235. 二叉搜索树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%9D%9E%E9%80%92%E5%BD%92"><span class="nav-number">55.1.</span> <span class="nav-text">Solution1  非递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E9%80%92%E5%BD%92-1"><span class="nav-number">55.2.</span> <span class="nav-text">Solution2 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91-x2F-%E9%80%92%E5%BD%92%EF%BC%9A236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">56.</span> <span class="nav-text">树&#x2F;递归：236. 二叉树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-4"><span class="nav-number">56.1.</span> <span class="nav-text">Solution1 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%92%E5%BD%92%EF%BC%9A%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0"><span class="nav-number">57.</span> <span class="nav-text">递归：最小的K个数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91-x2F-%E9%80%92%E5%BD%92%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">58.</span> <span class="nav-text">树&#x2F;递归：二叉搜索树与双向链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91-x2F-%E9%80%92%E5%BD%92-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="nav-number">59.</span> <span class="nav-text">树&#x2F;递归: 二叉树的镜像</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91-x2F-%E9%80%92%E5%BD%92-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">60.</span> <span class="nav-text">树&#x2F;递归: 对称的二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91-x2F-%E9%80%92%E5%BD%92-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="nav-number">61.</span> <span class="nav-text">树&#x2F;递归: 树的子结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91-x2F-%E9%80%92%E5%BD%92-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E4%B8%AA%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-number">62.</span> <span class="nav-text">树&#x2F;递归: 二叉树中和为某一个值的路径</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%92%E5%BD%92-x2F-%E6%A0%91%EF%BC%9A105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">63.</span> <span class="nav-text">递归&#x2F;树：105. 从前序与中序遍历序列构造二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-5"><span class="nav-number">63.1.</span> <span class="nav-text">Solution1 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-1"><span class="nav-number">63.2.</span> <span class="nav-text">Solution2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%92%E5%BD%92-x2F-%E6%A0%91%EF%BC%9A109-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">64.</span> <span class="nav-text">递归&#x2F;树：109. 有序链表转换二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%85%88%E6%89%BE%E4%B8%AD%E7%82%B9-%E7%84%B6%E5%90%8E%E5%86%8D%E5%B7%A6%E5%8F%B3%E5%88%86%E5%88%AB%E6%9E%84%E9%80%A0"><span class="nav-number">64.1.</span> <span class="nav-text">Solution1 先找中点 然后再左右分别构造</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%92%E5%BD%92-x2F-%E6%A0%91%EF%BC%9A113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II"><span class="nav-number">65.</span> <span class="nav-text">递归&#x2F;树：113. 路径总和 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-DFS-1"><span class="nav-number">65.1.</span> <span class="nav-text">Solution1 DFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-BFS-1"><span class="nav-number">65.2.</span> <span class="nav-text">Solution2 BFS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%EF%BC%9A%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">66.</span> <span class="nav-text">树：从上到下打印二叉树|||</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91-x2F-%E5%88%86%E6%B2%BB-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">67.</span> <span class="nav-text">树&#x2F;分治: 重建二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%EF%BC%9A%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">68.</span> <span class="nav-text">树：最大二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E6%88%90%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91"><span class="nav-number">69.</span> <span class="nav-text">树: 把二叉搜索树转换成为累加树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="nav-number">70.</span> <span class="nav-text">树:二叉树的直径</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%EF%BC%9A94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">71.</span> <span class="nav-text">树：94. 二叉树的中序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-6"><span class="nav-number">71.1.</span> <span class="nav-text">Solution1 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%BF%AD%E4%BB%A3-1"><span class="nav-number">71.2.</span> <span class="nav-text">Solution2 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%EF%BC%9A102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">72.</span> <span class="nav-text">树：102. 二叉树的层序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="nav-number">72.1.</span> <span class="nav-text">Solution1 队列实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0"><span class="nav-number">72.2.</span> <span class="nav-text">Solution2 递归实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%EF%BC%9A103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">73.</span> <span class="nav-text">树：103. 二叉树的锯齿形层序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">73.1.</span> <span class="nav-text">Solution1 层序遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%EF%BC%9A104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">74.</span> <span class="nav-text">树：104. 二叉树的最大深度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-DFS-2"><span class="nav-number">74.1.</span> <span class="nav-text">Solution1 DFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Slution2-BFS"><span class="nav-number">74.2.</span> <span class="nav-text">Slution2 BFS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%EF%BC%9A105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">75.</span> <span class="nav-text">树：105. 从前序与中序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%EF%BC%9A144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">76.</span> <span class="nav-text">树：144. 二叉树的前序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-7"><span class="nav-number">76.1.</span> <span class="nav-text">Solution1 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%BF%AD%E4%BB%A3-2"><span class="nav-number">76.2.</span> <span class="nav-text">Solution2 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%EF%BC%9A199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="nav-number">77.</span> <span class="nav-text">树：199. 二叉树的右视图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-1"><span class="nav-number">77.1.</span> <span class="nav-text">Solution1 层序遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%EF%BC%9A226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">78.</span> <span class="nav-text">树：226. 翻转二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-1"><span class="nav-number">78.1.</span> <span class="nav-text">Solution1</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%EF%BC%9A230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">79.</span> <span class="nav-text">树：230. 二叉搜索树中第K小的元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%9D%9E%E9%80%92%E5%BD%92-1"><span class="nav-number">79.1.</span> <span class="nav-text">Solution1  非递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%AE%B0%E5%BD%95%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE"><span class="nav-number">79.2.</span> <span class="nav-text">Solution2 记录子节点数目</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACK%E5%A4%A7%E8%8A%82%E7%82%B9"><span class="nav-number">80.</span> <span class="nav-text">树：二叉搜索树的第K大节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%EF%BC%9A114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="nav-number">81.</span> <span class="nav-text">树：114. 二叉树展开为链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-8"><span class="nav-number">81.1.</span> <span class="nav-text">Solution1  递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%BF%AD%E4%BB%A3-3"><span class="nav-number">81.2.</span> <span class="nav-text">Solution2   迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Two-Sum"><span class="nav-number">82.</span> <span class="nav-text">1. Two Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-1"><span class="nav-number">82.1.</span> <span class="nav-text">Solution 1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-2"><span class="nav-number">82.2.</span> <span class="nav-text">Solution 2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">83.</span> <span class="nav-text">18. 四数之和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-1-%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE"><span class="nav-number">83.1.</span> <span class="nav-text">Solution 1  暴力枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-2-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95"><span class="nav-number">83.2.</span> <span class="nav-text">Solution 2  双指针法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-number">84.</span> <span class="nav-text">19. 删除链表的倒数第 N 个结点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%AE%A1%E7%AE%97%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6"><span class="nav-number">84.1.</span> <span class="nav-text">Solution1 计算链表长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E6%A0%88"><span class="nav-number">84.2.</span> <span class="nav-text">Solution2 栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution3-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88-1"><span class="nav-number">84.3.</span> <span class="nav-text">Solution3 快慢指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="nav-number">85.</span> <span class="nav-text">20. 有效的括号</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%A0%88"><span class="nav-number">85.1.</span> <span class="nav-text">Solution1 栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="nav-number">86.</span> <span class="nav-text">26. 删除有序数组中的重复项</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-9"><span class="nav-number">86.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">86.2.</span> <span class="nav-text">Solution2 双指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution3-%E5%8F%8C%E6%8C%87%E9%92%88-%E4%BC%98%E5%8C%96"><span class="nav-number">86.3.</span> <span class="nav-text">Solution3 双指针 优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="nav-number">87.</span> <span class="nav-text">31. 下一个排列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-10"><span class="nav-number">87.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-2"><span class="nav-number">87.2.</span> <span class="nav-text">Solution2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="nav-number">88.</span> <span class="nav-text">48. 旋转图像</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8E%9F%E5%9C%B0%E6%9F%A5%E6%89%BE"><span class="nav-number">88.1.</span> <span class="nav-text">Solution1 原地查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%85%88%E8%BD%AC%E7%BD%AE%E5%86%8D%E7%AB%96%E7%9B%B4%E5%AF%B9%E7%A7%B0%E5%8F%8D%E8%BD%AC"><span class="nav-number">88.2.</span> <span class="nav-text">Solution2 先转置再竖直对称反转</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="nav-number">89.</span> <span class="nav-text">49. 字母异位词分组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-Map"><span class="nav-number">89.1.</span> <span class="nav-text">Solution1 Map</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="nav-number">90.</span> <span class="nav-text">54. 螺旋矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8E%9F%E5%9C%B0%E9%81%8D%E5%8E%86"><span class="nav-number">90.1.</span> <span class="nav-text">Solution1 原地遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E6%8C%89%E5%B1%82%E9%81%8D%E5%8E%86"><span class="nav-number">90.2.</span> <span class="nav-text">Solution2 按层遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="nav-number">91.</span> <span class="nav-text">56. 合并区间</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%8E%92%E5%BA%8F-1"><span class="nav-number">91.1.</span> <span class="nav-text">Solution1 排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">92.</span> <span class="nav-text">61. 旋转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-11"><span class="nav-number">92.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Soluion2-%E9%97%AD%E7%8E%AF"><span class="nav-number">92.2.</span> <span class="nav-text">Soluion2  闭环</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#66-%E5%8A%A0%E4%B8%80"><span class="nav-number">93.</span> <span class="nav-text">66. 加一</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-0-%E6%9A%B4%E5%8A%9B"><span class="nav-number">93.1.</span> <span class="nav-text">Solution 0  暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-1-%E9%80%86%E5%BA%8F%E9%81%8D%E5%8E%86-%E6%89%BE%E5%88%B09"><span class="nav-number">93.2.</span> <span class="nav-text">Solution 1 逆序遍历 找到9</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB"><span class="nav-number">94.</span> <span class="nav-text">75. 颜色分类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-12"><span class="nav-number">94.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8D%95%E6%8C%87%E9%92%88"><span class="nav-number">94.2.</span> <span class="nav-text">Solution2 单指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution3-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">94.3.</span> <span class="nav-text">Solution3 双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-number">95.</span> <span class="nav-text">83. 删除排序链表中的重复元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="nav-number">95.1.</span> <span class="nav-text">Solution1 一次遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8"><span class="nav-number">96.</span> <span class="nav-text">86. 分隔链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">96.1.</span> <span class="nav-text">Solution1  双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">97.</span> <span class="nav-text">88. 合并两个有序数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B%E7%9B%B4%E6%8E%A5%E5%90%88%E5%B9%B6%E5%90%8E%E6%8E%92%E5%BA%8F"><span class="nav-number">97.1.</span> <span class="nav-text">Solution1 暴力直接合并后排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8F%8C%E6%8C%87%E9%92%88-1"><span class="nav-number">97.2.</span> <span class="nav-text">Solution2 双指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution3-%E9%80%86%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">97.3.</span> <span class="nav-text">Solution3 逆向双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II"><span class="nav-number">98.</span> <span class="nav-text">92. 反转链表 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8E%9F%E5%9C%B0%E5%8F%8D%E8%BD%AC"><span class="nav-number">98.1.</span> <span class="nav-text">Solution1 原地反转</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="nav-number">99.</span> <span class="nav-text">118. 杨辉三角</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E7%9B%B4%E6%8E%A5%E6%B1%82%E8%A7%A3"><span class="nav-number">99.1.</span> <span class="nav-text">Solution1 直接求解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="nav-number">100.</span> <span class="nav-text">125. 验证回文串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E7%AD%9B%E9%80%89-%E5%88%A4%E6%96%AD"><span class="nav-number">100.1.</span> <span class="nav-text">Solution1 筛选 + 判断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E7%AD%9B%E9%80%89-%E5%88%A4%E6%96%AD-02"><span class="nav-number">100.2.</span> <span class="nav-text">Solution2 筛选 + 判断 02</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution03-%E5%9C%A8%E5%8E%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8A%E7%9B%B4%E6%8E%A5%E5%88%A4%E6%96%AD"><span class="nav-number">100.3.</span> <span class="nav-text">Solution03 在原字符串上直接判断</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="nav-number">101.</span> <span class="nav-text">141. 环形链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">101.1.</span> <span class="nav-text">Solution1 哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-3"><span class="nav-number">101.2.</span> <span class="nav-text">Solution2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II"><span class="nav-number">102.</span> <span class="nav-text">142. 环形链表 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%93%88%E5%B8%8C%E8%A1%A8-1"><span class="nav-number">102.1.</span> <span class="nav-text">Solution1 哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8F%8C%E6%8C%87%E9%92%88-2"><span class="nav-number">102.2.</span> <span class="nav-text">Solution2 双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"><span class="nav-number">103.</span> <span class="nav-text">143. 重排链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E6%9A%B4%E5%8A%9B-2"><span class="nav-number">103.1.</span> <span class="nav-text">Solution0 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8F%8C%E6%8C%87%E9%92%88-1"><span class="nav-number">103.2.</span> <span class="nav-text">Solution1 双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#146-LRU-%E7%BC%93%E5%AD%98"><span class="nav-number">104.</span> <span class="nav-text">146. LRU 缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%93%88%E5%B8%8C%E8%A1%A8-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">104.1.</span> <span class="nav-text">Solution1 哈希表 + 双向链表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E6%B2%BB%EF%BC%9A148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">105.</span> <span class="nav-text">分治：148. 排序链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">105.1.</span> <span class="nav-text">Solution1 自顶向下归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">105.2.</span> <span class="nav-text">Solution2 自底向上归并排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-number">106.</span> <span class="nav-text">150. 逆波兰表达式求值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%A0%88-1"><span class="nav-number">106.1.</span> <span class="nav-text">Solution1  栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E6%A0%88"><span class="nav-number">106.2.</span> <span class="nav-text">Solution2 数组模拟栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#171-Excel-%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7"><span class="nav-number">107.</span> <span class="nav-text">171. Excel 表列序号</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-26%E8%BF%9B%E5%88%B6"><span class="nav-number">107.1.</span> <span class="nav-text">Solution1  26进制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="nav-number">108.</span> <span class="nav-text">155. 最小栈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%BE%85%E5%8A%A9%E6%A0%88"><span class="nav-number">108.1.</span> <span class="nav-text">Solution1 辅助栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%B8%8D%E7%94%A8%E8%BE%85%E5%8A%A9%E6%A0%88"><span class="nav-number">108.2.</span> <span class="nav-text">Solution2 不用辅助栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="nav-number">109.</span> <span class="nav-text">160. 相交链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88"><span class="nav-number">109.1.</span> <span class="nav-text">Solution1 哈希集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8F%8C%E6%8C%87%E9%92%88-3"><span class="nav-number">109.2.</span> <span class="nav-text">Solution2 双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="nav-number">110.</span> <span class="nav-text">169. 多数元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-1-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">110.1.</span> <span class="nav-text">Solution 1 哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-2-%E6%8E%92%E5%BA%8F"><span class="nav-number">110.2.</span> <span class="nav-text">Solution 2  排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-3-Boyer-Moore-%E6%8A%95%E7%A5%A8%E6%B3%95"><span class="nav-number">110.3.</span> <span class="nav-text">Solution 3  Boyer-Moore 投票法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6"><span class="nav-number">111.</span> <span class="nav-text">172. 阶乘后的零</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-2"><span class="nav-number">111.1.</span> <span class="nav-text">Solution1</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#179-%E6%9C%80%E5%A4%A7%E6%95%B0"><span class="nav-number">112.</span> <span class="nav-text">179. 最大数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E6%9A%B4%E5%8A%9B-3"><span class="nav-number">112.1.</span> <span class="nav-text">Solution0 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%8E%92%E5%BA%8F-2"><span class="nav-number">112.2.</span> <span class="nav-text">Solution1 排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#187-%E9%87%8D%E5%A4%8D%E7%9A%84DNA%E5%BA%8F%E5%88%97"><span class="nav-number">113.</span> <span class="nav-text">187. 重复的DNA序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%93%88%E5%B8%8C%E8%A1%A8-2"><span class="nav-number">113.1.</span> <span class="nav-text">Solution1 哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%93%88%E5%B8%8C%E8%A1%A8-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="nav-number">113.2.</span> <span class="nav-text">Solution2 哈希表 滑动窗口 二进制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="nav-number">114.</span> <span class="nav-text">189. 轮转数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E4%BD%BF%E7%94%A8%E9%A2%9D%E5%A4%96%E7%9A%84%E6%95%B0%E7%BB%84"><span class="nav-number">114.1.</span> <span class="nav-text">Solution1 使用额外的数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E6%95%B0%E7%BB%84%E7%BF%BB%E8%BD%AC"><span class="nav-number">114.2.</span> <span class="nav-text">Solution2  数组翻转</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#202-%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="nav-number">115.</span> <span class="nav-text">202. 快乐数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="nav-number">115.1.</span> <span class="nav-text">Solution1 快慢指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E6%9A%B4%E5%8A%9B"><span class="nav-number">115.2.</span> <span class="nav-text">Solution2 暴力</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="nav-number">116.</span> <span class="nav-text">203. 移除链表元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%BF%AD%E4%BB%A3-1"><span class="nav-number">116.1.</span> <span class="nav-text">Solution1 迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E9%80%92%E5%BD%92-2"><span class="nav-number">116.2.</span> <span class="nav-text">Solution2 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="nav-number">117.</span> <span class="nav-text">215. 数组中的第K个最大元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">117.1.</span> <span class="nav-text">Solution1  堆排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-number">118.</span> <span class="nav-text">217. 存在重复元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%8E%92%E5%BA%8F-3"><span class="nav-number">118.1.</span> <span class="nav-text">Solution1  排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-4"><span class="nav-number">118.2.</span> <span class="nav-text">Solution2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="nav-number">119.</span> <span class="nav-text">225. 用队列实现栈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97"><span class="nav-number">119.1.</span> <span class="nav-text">Solution1  两个队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8D%95%E4%B8%AA%E9%98%9F%E5%88%97"><span class="nav-number">119.2.</span> <span class="nav-text">Solution2 单个队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#227-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8-II"><span class="nav-number">120.</span> <span class="nav-text">227. 基本计算器 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%A0%88-2"><span class="nav-number">120.1.</span> <span class="nav-text">Solution1 栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-number">121.</span> <span class="nav-text">232. 用栈实现队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-3"><span class="nav-number">121.1.</span> <span class="nav-text">Solution1</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="nav-number">122.</span> <span class="nav-text">234. 回文链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E5%B0%86%E9%93%BE%E8%A1%A8%E5%A4%8D%E5%88%B6%E5%88%B0%E6%95%B0%E7%BB%84"><span class="nav-number">122.1.</span> <span class="nav-text">Solution0 将链表复制到数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E4%B8%AD%E7%82%B9%E5%BC%80%E5%A7%8B%E6%AF%94%E8%BE%83"><span class="nav-number">122.2.</span> <span class="nav-text">Solution1 中点开始比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">123.</span> <span class="nav-text">237. 删除链表中的节点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-4"><span class="nav-number">123.1.</span> <span class="nav-text">Solution1</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="nav-number">124.</span> <span class="nav-text">238. 除自身以外数组的乘积</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E7%B4%AF%E4%B9%98%E5%88%97%E8%A1%A8"><span class="nav-number">124.1.</span> <span class="nav-text">Solution1 累乘列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO-1-%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">124.2.</span> <span class="nav-text">Solution2 空间复杂度为O(1)的方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II"><span class="nav-number">125.</span> <span class="nav-text">240. 搜索二维矩阵 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E6%9A%B4%E5%8A%9B-4"><span class="nav-number">125.1.</span> <span class="nav-text">Solution0 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E4%BB%8E%E5%8F%B3%E4%B8%8A%E8%A7%92%E7%9C%8B%E6%98%AF%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">125.2.</span> <span class="nav-text">Solution1 从右上角看是一颗二叉搜索树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="nav-number">126.</span> <span class="nav-text">242. 有效的字母异位词</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-1-%E7%9B%B4%E6%8E%A5%E7%94%A8sort%E5%87%BD%E6%95%B0"><span class="nav-number">126.1.</span> <span class="nav-text">Solution1  1.直接用sort函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-2-map%E8%AE%A1%E6%95%B0"><span class="nav-number">126.2.</span> <span class="nav-text">Solution2  2.map计数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution3-3-%E6%95%88%E7%8E%87%E6%9C%80%E9%AB%98"><span class="nav-number">126.3.</span> <span class="nav-text">Solution3  3.效率最高</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#258-%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0"><span class="nav-number">127.</span> <span class="nav-text">258. 各位相加</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%89%BE%E8%A7%84%E5%BE%8B"><span class="nav-number">127.1.</span> <span class="nav-text">Solution1 : 找规律</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%BE%AA%E7%8E%AF"><span class="nav-number">127.2.</span> <span class="nav-text">Solution2 :循环</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#283-%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="nav-number">128.</span> <span class="nav-text">283. 移动零</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-5"><span class="nav-number">128.1.</span> <span class="nav-text">Solution1</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#292-Nim-%E6%B8%B8%E6%88%8F"><span class="nav-number">129.</span> <span class="nav-text">292. Nim 游戏</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%95%B0%E5%AD%A6%E6%8E%A8%E7%90%86"><span class="nav-number">129.1.</span> <span class="nav-text">Solution1 数学推理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#326-3%E7%9A%84%E5%B9%82"><span class="nav-number">130.</span> <span class="nav-text">326.3的幂</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%AF%95%E9%99%A4%E6%B3%95"><span class="nav-number">130.1.</span> <span class="nav-text">Solution1 试除法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E7%BA%A6%E6%95%B0%E6%B3%95"><span class="nav-number">130.2.</span> <span class="nav-text">Solution2 约数法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8"><span class="nav-number">131.</span> <span class="nav-text">328. 奇偶链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8F%8C%E9%93%BE%E6%B3%95"><span class="nav-number">131.1.</span> <span class="nav-text">Solution1 双链法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#334-%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">132.</span> <span class="nav-text">334. 递增的三元子序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%B4%AA%E5%BF%83"><span class="nav-number">132.1.</span> <span class="nav-text">Solution1  贪心</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8F%8C%E5%90%91%E9%81%8D%E5%8E%86"><span class="nav-number">132.2.</span> <span class="nav-text">Solution2 双向遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">133.</span> <span class="nav-text">344. 反转字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8F%8C%E6%8C%87%E9%92%88%E4%BA%A4%E6%8D%A2"><span class="nav-number">133.1.</span> <span class="nav-text">Solution1 双指针交换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A0%86%EF%BC%9A347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="nav-number">134.</span> <span class="nav-text">堆：347. 前 K 个高频元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%8E%92%E5%BA%8F%E6%B3%95"><span class="nav-number">134.1.</span> <span class="nav-text">Solution1 排序法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E6%9C%80%E5%B0%8F%E5%A0%86%E6%B3%95"><span class="nav-number">134.2.</span> <span class="nav-text">Solution2 最小堆法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="nav-number">135.</span> <span class="nav-text">349. 两个数组的交集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-6"><span class="nav-number">135.1.</span> <span class="nav-text">Solution1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-5"><span class="nav-number">135.2.</span> <span class="nav-text">Solution2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#378-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%AC-K-%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">136.</span> <span class="nav-text">378. 有序矩阵中第 K 小的元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-13"><span class="nav-number">136.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E6%9C%80%E5%B0%8F%E5%A0%86"><span class="nav-number">136.2.</span> <span class="nav-text">Solution2 最小堆</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81"><span class="nav-number">137.</span> <span class="nav-text">394. 字符串解码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E4%B8%A4%E4%B8%AA%E6%A0%88"><span class="nav-number">137.1.</span> <span class="nav-text">Solution1 两个栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#402-%E7%A7%BB%E6%8E%89-K-%E4%BD%8D%E6%95%B0%E5%AD%97"><span class="nav-number">138.</span> <span class="nav-text">402. 移掉 K 位数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%B4%AA%E5%BF%83-%E5%8D%95%E8%B0%83%E6%A0%88"><span class="nav-number">138.1.</span> <span class="nav-text">Solution1 贪心+单调栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97"><span class="nav-number">139.</span> <span class="nav-text">406. 根据身高重建队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%85%88%E6%8E%92%E5%BA%8F-%E5%86%8D%E6%8F%92%E9%98%9F"><span class="nav-number">139.1.</span> <span class="nav-text">Solution1 先排序 再插队</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#409-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="nav-number">140.</span> <span class="nav-text">409. 最长回文串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-7"><span class="nav-number">140.1.</span> <span class="nav-text">Solution1</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#415-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0"><span class="nav-number">141.</span> <span class="nav-text">415. 字符串相加</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-8"><span class="nav-number">141.1.</span> <span class="nav-text">Solution1</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B1%821-2-%E2%80%A6n"><span class="nav-number">142.</span> <span class="nav-text">求1+2+…n</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B1%82%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">143.</span> <span class="nav-text">求滑动窗口的最大值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90"><span class="nav-number">144.</span> <span class="nav-text">扑克牌中的顺子</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">145.</span> <span class="nav-text">左旋转字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">146.</span> <span class="nav-text">最长不含重复字符的子字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">147.</span> <span class="nav-text">滑动窗口的最大值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%92%8C%E4%B8%BAs%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97"><span class="nav-number">148.</span> <span class="nav-text">和为s连续正数序列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F"><span class="nav-number">149.</span> <span class="nav-text">翻转单词顺序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-1"><span class="nav-number">150.</span> <span class="nav-text">左旋转字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="nav-number">151.</span> <span class="nav-text">和为s的两个数字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-number">152.</span> <span class="nav-text">数组中出现次数超过一半的次数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="nav-number">153.</span> <span class="nav-text">第一个只出现一次的字符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97"><span class="nav-number">154.</span> <span class="nav-text">栈的压入、弹出序列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><span class="nav-number">155.</span> <span class="nav-text">包含min函数的栈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">156.</span> <span class="nav-text">反转链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9"><span class="nav-number">157.</span> <span class="nav-text">数值的整数次方</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">158.</span> <span class="nav-text">删除链表的节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">159.</span> <span class="nav-text">链表的倒数第K个节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="nav-number">160.</span> <span class="nav-text">顺时针打印矩阵</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%BE%97%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D"><span class="nav-number">161.</span> <span class="nav-text">调整数组顺序使得奇数位于偶数前</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="nav-number">162.</span> <span class="nav-text">合并两个排序的链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"><span class="nav-number">163.</span> <span class="nav-text">从尾到头打印链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="nav-number">164.</span> <span class="nav-text">替换空格</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">165.</span> <span class="nav-text">重构字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">166.</span> <span class="nav-text">数组中重复的数字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%AA%E9%99%A4%E6%95%B0"><span class="nav-number">167.</span> <span class="nav-text">自除数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4"><span class="nav-number">168.</span> <span class="nav-text">划分字母区间</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="nav-number">169.</span> <span class="nav-text">每日温度</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6"><span class="nav-number">170.</span> <span class="nav-text">1比特与2比特字符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">171.</span> <span class="nav-text">最短无序连续子数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">172.</span> <span class="nav-text">找到所有数组中消失的数字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="nav-number">173.</span> <span class="nav-text">分发饼干</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97-1"><span class="nav-number">174.</span> <span class="nav-text">找到所有数组中消失的数字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">175.</span> <span class="nav-text">最接近的三数之和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="nav-number">176.</span> <span class="nav-text">四数相加||</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E6%B2%BB-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="nav-number">177.</span> <span class="nav-text">分治:最长公共前缀</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC"><span class="nav-number">178.</span> <span class="nav-text">整数反转</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-number">179.</span> <span class="nav-text">盛水最多的容器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="nav-number">180.</span> <span class="nav-text">无重复字符的最长子串</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="陈同学"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">陈同学</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kyleandkelly" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kyleandkelly" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/2431173627ccc@gmail.com" title="E-Mail → 2431173627ccc@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/475843583" title="Bilibili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;475843583" rel="noopener" target="_blank"><i class="fab fa-skype fa-fw"></i>Bilibili</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈同学</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
