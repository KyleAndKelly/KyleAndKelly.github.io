<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="Leetcode problems Solutions Note">
<meta property="og:url" content="http://example.com/2022/08/22/Leetcode-problems-Solutions-Note/index.html">
<meta property="og:site_name" content="Blog of Chen">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://files.mdnice.com/user/1489/eb7c965d-59c0-4b08-8d6a-6d3943f10cf5.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7821e311-00aa-40b0-8ab9-57471419d97b.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/cd61b224-e4ae-4271-bef4-076a650f65b3.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e078bf30-d641-4c56-b4c9-8d1da707d807.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e4fa6f50-22c9-41c7-8f6c-e43aab780585.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5cd09d98-bd6d-413f-a699-5d03755f5802.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5bfffdd4-470d-482c-849d-e4e82e2b40d8.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f6e5ea9e-b6b4-4545-97c5-2ef86e5fbd08.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/b3fb36fb-92e9-417d-9c00-60756ed04c17.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/1d658e59-2c76-4ade-a9c5-39a2ff20161f.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7fc31992-dc5b-4e11-bb5e-7c61942e6e57.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4097f955-844e-4ceb-a4c1-513342bc6e37.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/9e16db80-4a17-41b8-9d9d-cdef5be73f58.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/10427a40-975c-4b6b-85ff-d17cc899c623.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/34777dfe-25ba-4a81-883e-b66110b1a8c9.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8b223432-03ba-43a5-8968-584c7c8d8068.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/36ee0f58-1bce-411c-b3fc-308d769ad869.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/97cb5a3b-6aaa-4be9-9b17-dde9d86f17ab.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/80714af6-4b56-4b6d-965a-6d0e396c1b63.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/997007a2-0e00-49d3-88fc-6865a7578af8.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/60ec6cc2-9148-40df-ad8e-2969def89c43.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/56d57700-be9b-4a89-b09c-1d373b1d5318.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8a4705a4-439c-4262-bdce-8186ee916289.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5700074e-68cb-427a-9e58-a1858ab736e1.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/6fc73b94-e500-4182-a9f9-e1d8a4e29a32.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e8db6a23-fe74-4f65-b6a6-6cafbddff0bc.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/319c806f-a568-403a-9a39-c4ac50f30308.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4a4d21b3-ff48-457a-a612-9723074e0647.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5984996e-8148-4ae1-8ed9-8198e3625d2f.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/846120fb-5574-4fde-bd23-c798e938fa6e.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/19d7f700-92c7-4591-bef6-efe163c000f3.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d99bbb87-979c-426b-b6e5-647acf2cad20.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/1a1aae99-5b02-4641-9e50-5bd0913d1e4d.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8aeff7af-53ed-467e-aebc-7835db5b52f5.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5be86979-df7c-4994-a29c-088dc60e24e6.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a825eedd-e311-4153-bc5b-ed31be497911.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/707aac6e-eec8-4f5a-8f0f-b7b45d344451.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ebc2117f-b989-4c3d-b852-4b2b26c77453.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/1d9b3377-72f8-4c1b-8451-a2e484bfdc1c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/166bca4c-bcc2-4718-b6f4-1576acf3ff36.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a150914f-1207-4dc6-8091-639f11405933.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d66220b0-0d89-479e-9313-6adce6816e8c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/17bcb971-2dd2-4659-a84f-24493a37c88e.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/35a4e4dc-eb76-4d87-ba29-735a5042bfe1.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/3f09955d-d39b-41e9-8495-445cf9b35418.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f28b6ed7-01b5-4a89-952f-d626edf15d9e.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/988437b9-f65e-4111-8cde-79a687333027.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c915e202-251b-48cd-816b-cfcabdbf2214.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5f3de36e-929d-4f22-adcb-a8070f305409.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/070d05a3-3ee3-4b0a-90da-bed5c1c2b9a8.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5536a636-d181-42b9-a760-57aff155691a.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/9d910293-a6c0-4c4b-bfd8-c8e32fae01e8.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/fb453ee9-27d8-4bad-86ea-346219e70b18.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/bd915655-54ae-4387-8d94-22cabd830f19.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4391ada0-91de-488d-a3a9-23fa346ea804.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ae0e1058-6b96-43e8-9daa-10bf26ee4ccd.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/779a4035-c7d9-4b9a-b232-3f2cddeaa550.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/12eb162d-772a-41e8-b79b-1e8acfb28d87.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7e979e15-b4a4-41bb-92d8-1cfb54630ee6.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f65c3a6a-debe-4c68-ac3b-171b07af7262.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/9add3a1c-b13f-4277-a2b6-e511bf914864.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/1411c0a9-8a0f-452f-8fc6-ff371d70d1d0.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/fc7adb50-508e-4b31-b28e-f3f11eea8217.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/335701cf-1815-4ee0-a266-d54c6c35669b.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/725fc0e8-c8e6-4660-b971-9c47beb3c888.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7323d75f-2b46-4b8a-9908-4f5c654281f5.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/04aefe28-f537-4f0f-a96c-e08abbe1030f.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/de302c02-3172-4795-81bf-b52f9a497fcf.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d5233fdc-b942-4252-b385-aeaa32428270.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/76432652-12d7-4385-8ea8-6dae686cd490.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e7ac0fe5-7797-4094-a619-f13588081fd5.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f40bfb53-0680-426d-b458-8de6820f7bae.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8079c50a-6dbe-4779-9b7d-ff76f481397d.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ca4fbbe4-2cea-43f3-ac48-3d192c40bacf.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/0b64394f-ee13-447f-835a-965086697e94.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a01bf43a-aa9c-45e4-8e02-e38f1a09bba3.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5f397d41-0fd5-406a-befb-20bb996d6862.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/6ed11899-abbb-4316-b5f5-0905cc477414.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/eef3c25b-9218-4dd9-83d7-392ec8df5f36.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a181f628-892e-4ab3-9509-236d9b01c497.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a1ffabf9-420e-46a6-a2e1-ae5db89d9a6e.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/423b6ac9-a7bd-4bd4-9840-3813d62617b5.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ec008965-da09-4c78-9ad1-83de91a31f4c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/edd0b34a-aae0-4667-8e36-645c0c1fbd04.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/eb446da9-85b1-4898-b238-ee7548e16cc1.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d6347f35-ca4c-425c-b8ca-6b7e2ae2ab07.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a8de2fa0-7abe-474d-a113-bca524a5c19d.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f451fbd9-f97d-4b05-9a25-92f9f405369b.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/724583f7-e9bf-46be-a2e9-235ba7e2d358.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/971e09e6-1b22-4c78-a3bc-956a6d4f1827.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/df37bbbe-bbbb-4e52-b5ae-5ba6fd84cd30.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/cd09a3b7-fdbb-469a-8609-f64f592fda01.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/fb683879-39db-4823-890b-e02d5deeb48c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/b2e898e8-a1bf-4e57-88b2-00546145e9d0.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/bb70337e-337f-4525-9b82-628e0ababa73.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/6b0ad4c7-d06d-477f-a7be-fc2e043a0db5.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/30ba428f-42b6-472b-8b8b-23aaef1c23b6.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f14525cf-e0bb-44a5-a385-54ae95316f9b.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/317b8a93-0319-40c0-9273-c7d6ea72516a.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/19e5cf6f-0c41-4a7c-804d-9d81beac4123.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/44e2b2c5-3a86-4e20-97d1-45502d4bfc29.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/aa634f7b-decf-4a6c-8e21-80efe413f3c1.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/69e49a83-545c-483f-8a37-ec3b834d2e93.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/3cd35f16-15b6-4698-8053-935ffdd85349.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7ee6b978-400a-44f6-8197-a9507c8e058b.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/86154c4e-b8da-4890-ab23-b2612d4c5777.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e65a5f5c-4e4e-4bb7-857a-f5fd4309020f.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/183fb47d-cb82-4909-bfae-8f78c632e7ea.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f6a63c36-aafb-4e9c-a5c7-3eac3a044410.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4484458a-b006-4fe8-a7a8-ea586342ca22.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/448bc91c-0af2-4a4b-af89-c01fa606a5b7.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/00e1d4fd-e285-4863-8b0b-3060766bb525.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f5955143-7685-4b34-b5dd-9b24fa5290ce.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/76ff413d-adba-4dd6-a6f7-14af4914335c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4c7ba032-9897-4231-bb99-98f8ecdcc362.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c5e2d5e5-ba77-4e29-9aa1-9e78c0599f01.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d8bbcdd3-9968-4deb-b8db-b0c7f87e0856.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8ef92a66-0286-4473-88b6-76fd2e9613ed.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/3c123721-1909-4e2c-91e3-c2d357b57458.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/0c2f4579-0b43-40cb-9b3d-8acd25411140.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/6a5118f3-ceff-4fd5-bed5-37e3eb1d1d63.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/403a3990-3546-4736-98f7-813c0e0093b9.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/684b77e1-27e3-43d2-9fd1-52958d131620.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8faa0b82-6c1d-4433-abc3-8bb1ef5df8b6.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8c0e907f-f383-48da-98e6-ed531d6bd93a.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/2f69c7c1-c466-4ba5-aeb7-ee8d57b4bc1c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/1082c59b-c9b3-44b1-a291-78fb192b9ea4.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ce693fb0-6d34-4939-93b2-58af527f3ab4.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/836dc250-a4b3-4acd-80a8-5202dbd8266b.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/144ef974-6b43-473c-9b4e-76efb177144a.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/b2f8f7dd-d476-4624-bed2-09ed94cd6f74.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/bc43d48c-bd11-4ebe-816d-8df25edec96b.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/be81cb56-2d21-4267-81ff-c1fe308261cd.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c13f7729-4dce-428f-8f31-b5f9317a5ce2.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/bc9e3a37-edc5-498a-b026-882a06a64125.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/654af93a-97e3-4f83-88fb-c27a32ac905a.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/201501bf-a7cf-4604-9d0c-860c89a8eeb9.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/61447011-c76d-459e-be76-ed35d1d0edeb.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/32ee1091-199d-4e97-be7e-8c82cd1a5660.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/863165d0-8403-42e8-abcb-4387abc6f8d3.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f05af832-f82d-4a9a-85c8-880b56b213a8.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/9d0654e6-75ac-4ef1-9309-aa410463028e.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8c154642-a002-4b1e-a451-679ecaab6052.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/aa8f67bb-f725-4ac9-b288-f00702b84a55.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ac2814f5-9f64-451b-8a2f-167966444bc9.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/89471a17-0dc3-4180-9b34-d9d5c6c4f9da.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/bfd3a090-de97-4eff-a66b-be9cddb9bbc8.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/57e2bfe5-e188-42e3-9460-4fa79082ecd2.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/702de056-c52b-45b9-9965-8112d4131454.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/48ae75e0-df07-48f0-bfea-017869bac869.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/0052ac37-a066-4e57-97fd-4ebe72e6418e.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a4c9016a-3529-492d-a5c4-4172619a5168.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/cf2db259-ce16-4284-97f8-6e048c789bd5.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/544a41e4-a185-4dff-941f-79e6a60d6e79.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f0bf9bc6-9c7f-434c-b924-cba7405ed0fb.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/446462c6-005a-4165-81a4-213042a92492.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/207854fc-5451-44e1-84a6-51cde0d77f0f.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/15ea384d-bb95-4dbf-8d73-ba9536ff3f95.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/50bd7865-2516-4f4d-bdf7-4de2f00cdf80.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/620df582-d9ad-49fd-a069-2b6bb56fa29c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a39d57a7-49a2-4353-a4a4-68361420e23e.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/19234557-e889-43c9-84a6-e55b36d24aec.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/15a63a92-7b41-4707-a824-964718554f58.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/91669611-5065-4e62-9bcc-ba187bda8268.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/297b7397-78fa-402f-9848-36a3e6baeafc.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ff5136fb-3f4c-4caa-900f-e4d562a63e80.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/815f7215-0047-455e-8cc3-fa211fc82157.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/861c46f5-40c1-4452-bae1-d1fe40b46687.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e329b323-7662-4aa8-bef3-0ecf293c49de.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/beeb899a-9927-4525-b0d1-3d241c00ccb4.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e1be0f97-6680-4f55-a373-3a484128fe6a.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f01b0278-174b-461f-8ac7-191f13995a3b.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/bac74319-f5dc-4b47-8f63-1cc381458756.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4a32da04-9232-437a-98df-26863d85179e.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/aee56655-c266-45ae-aeda-2cb3e1573c71.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/6713148f-44c9-472b-9956-90bcad147d34.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e9aeb4c3-d429-4dbd-ad0a-9d7ae18c6b50.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/9011acac-108a-45de-a940-7dc0cbe33807.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/0db9683d-96ad-462b-9c2f-e80cb835f227.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/94ef5c0b-92a5-437e-8920-e808dbf6cc4d.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/433263e7-9556-438c-8f3d-c260225dbf1d.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4614ddda-961b-4eed-8ee4-cc50ffb25935.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/50faf577-63ab-4b9c-bd6f-59ed0c2ce516.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c918777d-7c9e-42a2-95fb-576b4618efd1.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7d866548-cf10-4e94-b709-7f71ef98a483.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/3b246e5f-80a9-4142-afcc-f87821e72388.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/40509b75-a36f-4c79-88d3-5bfc2084e109.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a871d490-3098-4744-acd1-27faa3facd1e.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/aefe8796-fac3-4849-a19c-fce0f029ba08.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/6afab0e0-5928-483e-a44d-bd6fa19e36dd.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/63b82d8b-42d1-4360-b5e7-224ad1ccb987.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7134c1a6-a705-41e0-b994-d9df133ffd06.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a5fa6552-4f5e-434b-a31e-38bf09a2cdab.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8accb7cf-0178-49e7-a907-44da8c41ca8e.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5e428394-3fd2-480c-9c7e-2bd099118a10.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a730fbab-4997-4af9-a608-85ffe0bcac07.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/442400a3-6855-4a90-a088-8d14c10099fd.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8984e78f-719b-4640-a513-787d3b23d9ce.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a31ff962-6681-4f7c-8888-acccb902ddf6.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f28df7df-9f6a-4428-8716-43437dbb7779.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c9037420-1a61-4305-bad1-b4227ec9707f.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f5098755-cba5-4145-9804-8e4cbff4dd48.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e3138c17-60bb-411d-9843-f6639bd0abd7.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/2c2e1f87-d654-46f1-a83f-c36c34189b47.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d51c2fab-43eb-470b-8d20-9408f94774ed.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c672b522-c4ab-424a-b872-59264a5bd13e.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/828bd8c8-3c46-49e2-8d18-ae06aa6d3582.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/77a88286-4f3b-40a2-8aa5-6513bef59e05.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/56115b51-a2ce-4bca-8a39-7c4ac2e070e6.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e92fd7e3-d208-4978-bdf6-fd51492fbeb6.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/6d46c580-ca37-4f4d-89cb-b250a209b90a.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/52bf9fe5-269b-46c3-8f40-dac13d75ecdb.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4254d052-fced-468a-a06b-80a9c388b798.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ba0409e5-fa6d-4d7e-9292-f5be87a8fd13.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f7b719a0-e068-42c3-b6f8-6f20301194df.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4ef04808-5bea-4610-9567-9fe0c028d63c.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/bad95909-e879-4f70-97f2-f9d01d7f5d22.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/1da2c2bf-57a1-4e47-87f9-613dbee436fb.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7d2f2092-3b35-4543-806a-3426630f698d.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ec7c4226-3a47-4a54-bfdc-740e523ceaac.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/06c76a5a-8e15-4971-9fa9-4702abdf8348.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/3bbe711c-cbeb-459c-ad4b-e00d7b508cb4.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c90e4dd1-4efe-4177-9542-a31c9f7dd10d.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/67ec0ae6-0a3c-4dc0-bc54-2f6bfa7b6d5d.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/64dedead-67bc-48c3-b39b-b7eefdecdbf3.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c5329093-56fd-4e91-8ee1-7c045e22310f.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a89ccc07-d81b-4c4c-9430-b0c3096d59c0.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f23d7252-0e97-4d3c-890a-434c8b5803d5.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a2d7a7ea-4135-46f9-9ce9-0601312f2e95.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/2c27e439-fff2-4f5e-a3e7-d35da3dd0250.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ddadda37-15c0-4593-9817-db62669441a3.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5ad4608e-ae3f-4ea6-abc5-01ccba98b8bd.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/bdc5a0f5-514e-4994-97ae-4aa2b468d4a1.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/03a1de17-c22e-4c59-9494-1f0b2d174b29.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/9522e217-e06b-4346-84a0-eb8263b04f93.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7b12d053-d366-4765-bfe4-75826f938e07.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ca057ccb-65b9-48c8-9fee-a4024d76d47c.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4ac49557-f581-4661-a123-af48b849ece1.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/9056d59a-86ef-4471-b065-a0a89df02627.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/19b73a26-c4e0-4af9-b278-52185b8bc40c.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/aa420d60-feec-41e4-b141-ad2d40924901.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f3d44400-5e6a-4005-be47-2a20e288383f.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c1843e98-f7e0-4e0b-b053-3bdb40abb586.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ae78465c-a8c5-4cb3-9bc4-cc6a7f3f1498.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e7e675f6-8b74-4492-a32d-b6c704015af1.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/014f2c8d-e879-4228-a24e-3c902a6366cf.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e7287e83-0a0f-4c88-97a9-70c01dd6b61a.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/12f83946-efa1-4c45-aefb-cf2385b1e4e0.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e0b97aff-77d6-44a0-905d-ddf01528b962.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/6fb39538-c320-49bd-b472-3e6dc981eb4d.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/2fe78d28-cb51-4119-a5e7-2d289ee647c7.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5587729c-faa6-4969-9c44-33c350aac1a6.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a0be23ac-6081-411c-96cb-9f2c79fcabb1.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7c65b823-1c0b-4d4f-8a13-554fb12cf314.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e648c0ad-b283-4b66-90d7-4bc23329dd5a.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/64f8d26f-c230-49c3-b398-df245f234505.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/92daf8e2-3349-475e-af48-4ad83be8a41e.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/174e0c93-01d3-41d0-8a49-c894760318e3.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/31bcba36-c886-412a-a41d-069f5cd29713.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/81edb05f-482a-48d2-a709-9c012a5a148c.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/56fac4ed-d7a0-42b3-b63c-5ae4151b4d95.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/979f2ad7-bb3d-4d06-8f1e-56c11921e810.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/eee786ba-73e5-4de7-9cc8-b82b80c56364.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f5e179e8-5c9b-40e5-b110-75d3cb245491.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7bc821d7-1447-46ae-899c-cd1196d3e8fe.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c2a7b9ac-91b4-4ecd-ac11-9c6f89d76202.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/83c47edf-7580-482f-9d47-83717761349c.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/623c9607-ca24-41cb-a43c-64e5a071ed00.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/3d092f02-d8a2-49fe-9ae9-a89efccf9907.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/fcfc655c-34c8-49b5-8ab9-09d72d74a3cb.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7cb88611-e8e0-4de4-a0e0-c34d8a78df3d.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c8d08da7-0629-49fc-b47b-55d8f9ec7c71.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/2d61a58f-d344-424e-8716-5ab9c5653f6e.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e5f2d5b8-6440-4910-9eb2-20848cebe369.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/08f457d6-d730-4b87-bff8-e9211b8332bd.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/86763d3e-dcd7-46e9-bbe3-d0b14813dc5b.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/11abbaeb-d616-4866-9bd8-029b298f1f97.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/074c12a8-524a-4f31-8abd-878e9aca33be.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c5bfa348-f61c-44be-b5a6-797e736ece90.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/90f1cfd8-35b9-44aa-8281-b9fc3097c54a.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/05eda67c-4389-4973-9617-02aefee2129f.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f5cbc2d0-8659-47c7-b189-9da1f9840224.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/2345cdfb-b295-4124-83a5-4cf212022be0.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/58a66c05-9434-4a32-89b8-ec1b10ba4c88.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/dbcf5ac5-6466-4d9b-b9cd-d37e6d4d383b.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d1fcc62e-aeaa-4ccf-b224-ab724f90ae37.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f9a6f9ba-1a2e-4ef2-8799-6b93c635519c.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c27eca08-3f9b-4813-b858-da16881adde7.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5d0202cd-9252-47fc-bb24-c44a7962fc24.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a8df6972-ea60-4073-a9ed-c607c5017b21.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ba15565c-2189-4cda-b8eb-92ada72b826f.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d3a4ed92-b21e-4237-87cd-5bfb2bee545e.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/65b0b068-a855-410f-833f-0cd18b42c057.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/127549f9-fa4e-440b-9f58-7e2ec00d19dc.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/0f99a883-da18-46ca-9985-d7ba4a46092d.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d5a6910c-41c0-471f-b8c3-3b79ae583be8.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/81e7a78b-6e9b-4804-b4bc-f32031fdd571.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/252bc915-1dc7-43e6-9498-e75607502c81.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a1c451b7-b2eb-4545-b354-c7c37a1ab8e0.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d7e4710d-6ea2-41b2-9aba-1dca85dcd9d3.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/6f172e79-74e2-452d-ab77-a7149388bb74.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d5945a88-399a-4b88-a5b5-20e6fe7e7e99.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f8c0d53a-9c66-4d00-857c-cab81d087035.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/0e795a17-567a-42d3-a1bb-677b12f407e8.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e7b49339-91b4-4ada-a0b5-14ec5d3cb9d9.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/77577f23-520d-480a-b4d1-94f1e25aeed7.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c6f390b2-c832-408a-ab8e-587085f4faf8.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/bb53951f-2e43-453c-b6f6-0383e670e50f.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/152a336e-c600-4937-850c-d0f1fd5a4c4f.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f075ebdf-3df9-4229-be81-efdca44423d4.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/55e84e02-f0b6-4e27-ace1-28039e20c7ef.jpg">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7b8def0f-7d26-40fb-8936-24236b14e7af.jpg">
<meta property="article:published_time" content="2022-08-22T14:45:47.000Z">
<meta property="article:modified_time" content="2022-09-24T05:49:18.822Z">
<meta property="article:author" content="Chen">
<meta property="article:tag" content="Leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://files.mdnice.com/user/1489/eb7c965d-59c0-4b08-8d6a-6d3943f10cf5.png">

<link rel="canonical" href="http://example.com/2022/08/22/Leetcode-problems-Solutions-Note/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Leetcode problems Solutions Note | Blog of Chen</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Blog of Chen" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog of Chen</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">陈同学的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/22/Leetcode-problems-Solutions-Note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of Chen">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Leetcode problems Solutions Note
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-22 22:45:47" itemprop="dateCreated datePublished" datetime="2022-08-22T22:45:47+08:00">2022-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-24 13:49:18" itemprop="dateModified" datetime="2022-09-24T13:49:18+08:00">2022-09-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
                </span>
            </span>

          
            <div class="post-description"> </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <meta name="referrer" content="no-referrer"/>

<h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">1. Two Sum</a></h1><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。<br>示例 2：</p>
<p>输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]<br>示例 3：</p>
<p>输入：nums &#x3D; [3,3], target &#x3D; 6<br>输出：[0,1]
 </p>
<p>提示：</p>
<p>2 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>-109 &lt;&#x3D; target &lt;&#x3D; 109<br>只会存在一个有效答案<br>进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？</p>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>双层遍历</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>哈希表</p>
<h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h1><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：digits &#x3D; “23”<br>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]<br>示例 2：</p>
<p>输入：digits &#x3D; “”<br>输出：[]<br>示例 3：</p>
<p>输入：digits &#x3D; “2”<br>输出：[“a”,”b”,”c”]
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; digits.length &lt;&#x3D; 4<br>digits[i] 是范围 [‘2’, ‘9’] 的一个数字。</p>
<h2 id="Solution-1-暴力"><a href="#Solution-1-暴力" class="headerlink" title="Solution 1  暴力"></a>Solution 1  暴力</h2><h2 id="Soulution-2-回溯"><a href="#Soulution-2-回溯" class="headerlink" title="Soulution 2  回溯"></a>Soulution 2  回溯</h2><p><img src="https://files.mdnice.com/user/1489/eb7c965d-59c0-4b08-8d6a-6d3943f10cf5.png"><br><img src="https://files.mdnice.com/user/1489/7821e311-00aa-40b0-8ab9-57471419d97b.png"></p>
<h2 id="Solution-3-队列"><a href="#Solution-3-队列" class="headerlink" title="Solution 3  队列"></a>Solution 3  队列</h2><p><img src="https://files.mdnice.com/user/1489/cd61b224-e4ae-4271-bef4-076a650f65b3.png"></p>
<p><img src="https://files.mdnice.com/user/1489/e078bf30-d641-4c56-b4c9-8d1da707d807.png"></p>
<p><img src="https://files.mdnice.com/user/1489/e4fa6f50-22c9-41c7-8f6c-e43aab780585.png"></p>
<h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h1><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<p>0 &lt;&#x3D; a, b, c, d &lt; n<br>a、b、c 和 d 互不相同<br>nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target<br>你可以按 任意顺序 返回答案 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0<br>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]<br>示例 2：</p>
<p>输入：nums &#x3D; [2,2,2,2,2], target &#x3D; 8<br>输出：[[2,2,2,2]]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>-109 &lt;&#x3D; target &lt;&#x3D; 109</p>
<h2 id="Solution-1-暴力枚举"><a href="#Solution-1-暴力枚举" class="headerlink" title="Solution 1  暴力枚举"></a>Solution 1  暴力枚举</h2><h2 id="Solution-2-双指针法"><a href="#Solution-2-双指针法" class="headerlink" title="Solution 2  双指针法"></a>Solution 2  双指针法</h2><p><img src="https://files.mdnice.com/user/1489/5cd09d98-bd6d-413f-a699-5d03755f5802.png"></p>
<h1 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list">19. 删除链表的倒数第 N 个结点</a></h1><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>输出：[1,2,3,5]<br>示例 2：</p>
<p>输入：head &#x3D; [1], n &#x3D; 1<br>输出：[]<br>示例 3：</p>
<p>输入：head &#x3D; [1,2], n &#x3D; 1<br>输出：[1]
 </p>
<p>提示：</p>
<p>链表中结点的数目为 sz<br>1 &lt;&#x3D; sz &lt;&#x3D; 30<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>1 &lt;&#x3D; n &lt;&#x3D; sz
 </p>
<h2 id="Solution1-计算链表长度"><a href="#Solution1-计算链表长度" class="headerlink" title="Solution1 计算链表长度"></a>Solution1 计算链表长度</h2><p><img src="https://files.mdnice.com/user/1489/5bfffdd4-470d-482c-849d-e4e82e2b40d8.png"></p>
<h2 id="Solution2-栈"><a href="#Solution2-栈" class="headerlink" title="Solution2 栈"></a>Solution2 栈</h2><p><img src="https://files.mdnice.com/user/1489/f6e5ea9e-b6b4-4545-97c5-2ef86e5fbd08.png"></p>
<p><img src="https://files.mdnice.com/user/1489/b3fb36fb-92e9-417d-9c00-60756ed04c17.png"></p>
<h2 id="Solution3-快慢指针"><a href="#Solution3-快慢指针" class="headerlink" title="Solution3 快慢指针"></a>Solution3 快慢指针</h2><p><img src="https://files.mdnice.com/user/1489/1d658e59-2c76-4ade-a9c5-39a2ff20161f.png"></p>
<p><img src="https://files.mdnice.com/user/1489/7fc31992-dc5b-4e11-bb5e-7c61942e6e57.png"></p>
<p>#<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></p>
<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。
 </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “()”<br>输出：true<br>示例 2：</p>
<p>输入：s &#x3D; “()[]{}”<br>输出：true<br>示例 3：</p>
<p>输入：s &#x3D; “(]”<br>输出：false<br>示例 4：</p>
<p>输入：s &#x3D; “([)]”<br>输出：false<br>示例 5：</p>
<p>输入：s &#x3D; “{[]}”<br>输出：true</p>
<h2 id="Solution1-栈"><a href="#Solution1-栈" class="headerlink" title="Solution1 栈"></a>Solution1 栈</h2><p><img src="https://files.mdnice.com/user/1489/4097f955-844e-4ceb-a4c1-513342bc6e37.png"></p>
<p>#<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></p>
<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
<p>示例 1：</p>
<p>输入：n &#x3D; 3<br>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]<br>示例 2：</p>
<p>输入：n &#x3D; 1<br>输出：[“()”]</p>
<p>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 8</p>
<h2 id="Solution1-暴力"><a href="#Solution1-暴力" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><p><img src="https://files.mdnice.com/user/1489/9e16db80-4a17-41b8-9d9d-cdef5be73f58.png"></p>
<h2 id="Solution2-递归-剪枝"><a href="#Solution2-递归-剪枝" class="headerlink" title="Solution2 递归 + 剪枝"></a>Solution2 递归 + 剪枝</h2><p><img src="https://files.mdnice.com/user/1489/10427a40-975c-4b6b-85ff-d17cc899c623.png"></p>
<h1 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h1><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4]<br>输出：[2,1,4,3]<br>示例 2：</p>
<p>输入：head &#x3D; []<br>输出：[]<br>示例 3：</p>
<p>输入：head &#x3D; [1]<br>输出：[1]</p>
<h2 id="Solution1-递归"><a href="#Solution1-递归" class="headerlink" title="Solution1  递归"></a>Solution1  递归</h2><p><img src="https://files.mdnice.com/user/1489/34777dfe-25ba-4a81-883e-b66110b1a8c9.png"></p>
<h2 id="Solution2-迭代"><a href="#Solution2-迭代" class="headerlink" title="Solution2 迭代"></a>Solution2 迭代</h2><p><img src="https://files.mdnice.com/user/1489/8b223432-03ba-43a5-8968-584c7c8d8068.png"></p>
<p><img src="https://files.mdnice.com/user/1489/36ee0f58-1bce-411c-b3fc-308d769ad869.png"></p>
<h1 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="[26. 删除有序数组中的重复项]"></a>[26. 删除有序数组中的重复项]</h1><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p>
<p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p>
<p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p>
<p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>判题标准:</p>
<p>系统会用下面的代码来测试你的题解:</p>
<p>int[] nums &#x3D; […]; &#x2F;&#x2F; 输入数组<br>int[] expectedNums &#x3D; […]; &#x2F;&#x2F; 长度正确的期望答案</p>
<p>int k &#x3D; removeDuplicates(nums); &#x2F;&#x2F; 调用</p>
<p>assert k &#x3D;&#x3D; expectedNums.length;<br>for (int i &#x3D; 0; i &lt; k; i++) {<br>    assert nums[i] &#x3D;&#x3D; expectedNums[i];<br>}<br>如果所有断言都通过，那么您的题解将被 通过。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,1,2]<br>输出：2, nums &#x3D; [1,2,_]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。<br>示例 2：</p>
<p>输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums &#x3D; [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>nums 已按 升序 排列</p>
<h2 id="Solution1-暴力-1"><a href="#Solution1-暴力-1" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-双指针"><a href="#Solution2-双指针" class="headerlink" title="Solution2 双指针"></a>Solution2 双指针</h2><p><img src="https://files.mdnice.com/user/1489/97cb5a3b-6aaa-4be9-9b17-dde9d86f17ab.png"></p>
<h2 id="Solution3-双指针-优化"><a href="#Solution3-双指针-优化" class="headerlink" title="Solution3 双指针 优化"></a>Solution3 双指针 优化</h2><p><img src="https://files.mdnice.com/user/1489/80714af6-4b56-4b6d-965a-6d0e396c1b63.png"></p>
<h1 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列</a></h1><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p>
<p>例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<p>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。</p>
<p>必须 原地 修改，只允许使用额外常数空间。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3]<br>输出：[1,3,2]<br>示例 2：</p>
<p>输入：nums &#x3D; [3,2,1]<br>输出：[1,2,3]<br>示例 3：</p>
<p>输入：nums &#x3D; [1,1,5]<br>输出：[1,5,1]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p>
<h2 id="Solution1-暴力-2"><a href="#Solution1-暴力-2" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p><img src="https://files.mdnice.com/user/1489/997007a2-0e00-49d3-88fc-6865a7578af8.png"></p>
<h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h1><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
<p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0<br>输出：4<br>示例 2：</p>
<p>输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3<br>输出：-1<br>示例 3：</p>
<p>输入：nums &#x3D; [1], target &#x3D; 0<br>输出：-1
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 5000<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>nums 中的每个值都 独一无二<br>题目数据保证 nums 在预先未知的某个下标上进行了旋转<br>-104 &lt;&#x3D; target &lt;&#x3D; 104</p>
<h2 id="Solution1-暴力-3"><a href="#Solution1-暴力-3" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-二分查找"><a href="#Solution2-二分查找" class="headerlink" title="Solution2 二分查找"></a>Solution2 二分查找</h2><p><img src="https://files.mdnice.com/user/1489/60ec6cc2-9148-40df-ad8e-2969def89c43.png"></p>
<h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h1><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8<br>输出：[3,4]<br>示例 2：</p>
<p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6<br>输出：[-1,-1]<br>示例 3：</p>
<p>输入：nums &#x3D; [], target &#x3D; 0<br>输出：[-1,-1]
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>nums 是一个非递减数组<br>-109 &lt;&#x3D; target &lt;&#x3D; 109</p>
<h2 id="Solution1-暴力-4"><a href="#Solution1-暴力-4" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-二分"><a href="#Solution2-二分" class="headerlink" title="Solution2 二分"></a>Solution2 二分</h2><p>二分搜索讲解<br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1fA4y1o715?spm_id_from=0.0.header_right.history_list.click">https://www.bilibili.com/video/BV1fA4y1o715?spm_id_from=0.0.header_right.history_list.click</a></p>
<p>寻找target在数组里的左右边界，有如下三种情况：</p>
<ul>
<li>情况一：target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1}</li>
<li>情况二：target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1}</li>
<li>情况三：target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{1, 1}</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int leftBorder = getLeftBorder(nums, target);</span><br><span class="line">        int rightBorder = getRightBorder(nums, target);</span><br><span class="line">        // 情况一</span><br><span class="line">        if (leftBorder == -2 || rightBorder == -2) return &#123;-1, -1&#125;;</span><br><span class="line">        // 情况三</span><br><span class="line">        if (rightBorder - leftBorder &gt; 1) return &#123;leftBorder + 1, rightBorder - 1&#125;;</span><br><span class="line">        // 情况二</span><br><span class="line">        return &#123;-1, -1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">     int getRightBorder(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.size() - 1;</span><br><span class="line">        int rightBorder = -2; // 记录一下rightBorder没有被赋值的情况</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int middle = left + ((right - left) / 2);</span><br><span class="line">            if (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - 1;</span><br><span class="line">            &#125; else &#123; // 寻找右边界，nums[middle] == target的时候更新left</span><br><span class="line">                left = middle + 1;</span><br><span class="line">                rightBorder = left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rightBorder;</span><br><span class="line">    &#125;</span><br><span class="line">    int getLeftBorder(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.size() - 1;</span><br><span class="line">        int leftBorder = -2; // 记录一下leftBorder没有被赋值的情况</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int middle = left + ((right - left) / 2);</span><br><span class="line">            if (nums[middle] &gt;= target) &#123; // 寻找左边界，nums[middle] == target的时候更新right</span><br><span class="line">                right = middle - 1;</span><br><span class="line">                leftBorder = right;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left = middle + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return leftBorder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id=""><a href="#" class="headerlink" title=""></a><a href=""></a></h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 O(log n) 的算法。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 5<br>输出: 2<br>示例 2:</p>
<p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 2<br>输出: 1<br>示例 3:</p>
<p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 7<br>输出: 4</p>
<h2 id="Solution1-暴力-5"><a href="#Solution1-暴力-5" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int searchInsert(int[] nums, int target) &#123;</span><br><span class="line">    for(int i = 0; i &lt; nums.length;i++)&#123;</span><br><span class="line">        if(nums[i] &gt;= target)&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-二分-1"><a href="#Solution2-二分-1" class="headerlink" title="Solution2 二分"></a>Solution2 二分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = n; // 定义target在左闭右开的区间里，[left, right)  target</span><br><span class="line">        while (left &lt; right) &#123; // 因为left == right的时候，在[left, right)是无效的空间</span><br><span class="line">            int middle = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">            if (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle; // target 在左区间，在[left, middle)中</span><br><span class="line">            &#125; else if (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + 1; // target 在右区间，在 [middle+1, right)中</span><br><span class="line">            &#125; else &#123; // nums[middle] == target</span><br><span class="line">                return middle; // 数组中找到目标值的情况，直接返回下标</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 分别处理如下四种情况</span><br><span class="line">        // 目标值在数组所有元素之前 [0,0)</span><br><span class="line">        // 目标值等于数组中某一个元素 return middle</span><br><span class="line">        // 目标值插入数组中的位置 [left, right) ，return right 即可</span><br><span class="line">        // 目标值在数组所有元素之后的情况 [left, right)，这是右开区间，return right 即可</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h1><h2 id="Solution1-暴力-6"><a href="#Solution1-暴力-6" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-回溯"><a href="#Solution2-回溯" class="headerlink" title="Solution2 回溯"></a>Solution2 回溯</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;int&gt;&amp; candidates, int target, vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt;&amp; combine, int idx) &#123;</span><br><span class="line">        if (idx == candidates.size()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (target == 0) &#123;</span><br><span class="line">            ans.emplace_back(combine);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 直接跳过</span><br><span class="line">        dfs(candidates, target, ans, combine, idx + 1);</span><br><span class="line">        // 选择当前数</span><br><span class="line">        if (target - candidates[idx] &gt;= 0) &#123;</span><br><span class="line">            combine.emplace_back(candidates[idx]);</span><br><span class="line">            dfs(candidates, target - candidates[idx], ans, combine, idx);</span><br><span class="line">            combine.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        vector&lt;int&gt; combine;</span><br><span class="line">        dfs(candidates, target, ans, combine, 0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h1><h2 id="Solution1-回溯"><a href="#Solution1-回溯" class="headerlink" title="Solution1 回溯"></a>Solution1 回溯</h2><p>方法一：回溯<br>思路与算法</p>
<p>由于我们需要求出所有和为 \textit{target}target 的组合，并且每个数只能使用一次，因此我们可以使用递归 + 回溯的方法来解决这个问题：</p>
<p>我们用 \textit{dfs}(\textit{pos}, \textit{rest})dfs(pos,rest) 表示递归的函数，其中 \textit{pos}pos 表示我们当前递归到了数组 \textit{candidates}candidates 中的第 \textit{pos}pos 个数，而 \textit{rest}rest 表示我们还需要选择和为 \textit{rest}rest 的数放入列表作为一个组合；</p>
<p>对于当前的第 \textit{pos}pos 个数，我们有两种方法：选或者不选。如果我们选了这个数，那么我们调用 \textit{dfs}(\textit{pos} + 1, \textit{rest} - \textit{candidates}[\textit{pos}])dfs(pos+1,rest−candidates[pos]) 进行递归，注意这里必须满足 \textit{rest} \geq \textit{candidates}[\textit{pos}]rest≥candidates[pos]。如果我们不选这个数，那么我们调用 \textit{dfs}(\textit{pos} + 1, \textit{rest})dfs(pos+1,rest) 进行递归；</p>
<p>在某次递归开始前，如果 \textit{rest}rest 的值为 00，说明我们找到了一个和为 \textit{target}target 的组合，将其放入答案中。每次调用递归函数前，如果我们选了那个数，就需要将其放入列表的末尾，该列表中存储了我们选的所有数。在回溯时，如果我们选了那个数，就要将其从列表的末尾删除。</p>
<p>上述算法就是一个标准的递归 + 回溯算法，但是它并不适用于本题。这是因为题目描述中规定了解集不能包含重复的组合，而上述的算法中并没有去除重复的组合。</p>
<p>例如当 \textit{candidates} &#x3D; [2, 2]candidates&#x3D;[2,2]，\textit{target} &#x3D; 2target&#x3D;2 时，上述算法会将列表 [2][2] 放入答案两次。</p>
<p>因此，我们需要改进上述算法，在求出组合的过程中就进行去重的操作。我们可以考虑将相同的数放在一起进行处理，也就是说，如果数 \textit{x}x 出现了 yy 次，那么在递归时一次性地处理它们，即分别调用选择 0, 1, \cdots, y0,1,⋯,y 次 xx 的递归函数。这样我们就不会得到重复的组合。具体地：</p>
<p>我们使用一个哈希映射（HashMap）统计数组 \textit{candidates}candidates 中每个数出现的次数。在统计完成之后，我们将结果放入一个列表 \textit{freq}freq 中，方便后续的递归使用。</p>
<p>列表 \textit{freq}freq 的长度即为数组 \textit{candidates}candidates 中不同数的个数。其中的每一项对应着哈希映射中的一个键值对，即某个数以及它出现的次数。<br>在递归时，对于当前的第 \textit{pos}pos 个数，它的值为 \textit{freq}[\textit{pos}][0]freq[pos][0]，出现的次数为 \textit{freq}[\textit{pos}][1]freq[pos][1]，那么我们可以调用</p>
<p>\textit{dfs}(\textit{pos} + 1, \textit{rest} - i \times \textit{freq}[\textit{pos}][0])<br>dfs(pos+1,rest−i×freq[pos][0])</p>
<p>即我们选择了这个数 ii 次。这里 ii 不能大于这个数出现的次数，并且 i \times \textit{freq}[\textit{pos}][0]i×freq[pos][0] 也不能大于 \textit{rest}rest。同时，我们需要将 ii 个 \textit{freq}[\textit{pos}][0]freq[pos][0] 放入列表中。</p>
<p>这样一来，我们就可以不重复地枚举所有的组合了。</p>
<p>我们还可以进行什么优化（剪枝）呢？一种比较常用的优化方法是，我们将 \textit{freq}freq 根据数从小到大排序，这样我们在递归时会先选择小的数，再选择大的数。这样做的好处是，当我们递归到 \textit{dfs}(\textit{pos}, \textit{rest})dfs(pos,rest) 时，如果 \textit{freq}[\textit{pos}][0]freq[pos][0] 已经大于 \textit{rest}rest，那么后面还没有递归到的数也都大于 \textit{rest}rest，这就说明不可能再选择若干个和为 \textit{rest}rest 的数放入列表了。此时，我们就可以直接回溯。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; freq;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    vector&lt;int&gt; sequence;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void dfs(int pos, int rest) &#123;</span><br><span class="line">        if (rest == 0) &#123;</span><br><span class="line">            ans.push_back(sequence);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (pos == freq.size() || rest &lt; freq[pos].first) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(pos + 1, rest);</span><br><span class="line"></span><br><span class="line">        int most = min(rest / freq[pos].first, freq[pos].second);</span><br><span class="line">        for (int i = 1; i &lt;= most; ++i) &#123;</span><br><span class="line">            sequence.push_back(freq[pos].first);</span><br><span class="line">            dfs(pos + 1, rest - i * freq[pos].first);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= most; ++i) &#123;</span><br><span class="line">            sequence.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        for (int num: candidates) &#123;</span><br><span class="line">            if (freq.empty() || num != freq.back().first) &#123;</span><br><span class="line">                freq.emplace_back(num, 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ++freq.back().second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(0, target);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h1><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]<br>示例 2：</p>
<p>输入：nums &#x3D; [0,1]<br>输出：[[0,1],[1,0]]<br>示例 3：</p>
<p>输入：nums &#x3D; [1]<br>输出：[[1]]
 </p>
<h2 id="Solution1-暴力-7"><a href="#Solution1-暴力-7" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-回溯-1"><a href="#Solution2-回溯-1" class="headerlink" title="Solution2 回溯"></a>Solution2 回溯</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void backtrack(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; output, int first, int len)&#123;</span><br><span class="line">        // 所有数都填完了</span><br><span class="line">        if (first == len) &#123;</span><br><span class="line">            res.emplace_back(output);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = first; i &lt; len; ++i) &#123;</span><br><span class="line">            // 动态维护数组</span><br><span class="line">            swap(output[i], output[first]);</span><br><span class="line">            // 继续递归填下一个数</span><br><span class="line">            backtrack(res, output, first + 1, len);</span><br><span class="line">            // 撤销操作</span><br><span class="line">            swap(output[i], output[first]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">        backtrack(res, nums, 0, (int)nums.size());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h1><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[[7,4,1],[8,5,2],[9,6,3]]<br>示例 2：</p>
<p>输入：matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]<br>输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
 </p>
<p>提示：</p>
<p>n &#x3D;&#x3D; matrix.length &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; n &lt;&#x3D; 20<br>-1000 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 1000
 </p>
<h2 id="Solution1-原地查找"><a href="#Solution1-原地查找" class="headerlink" title="Solution1 原地查找"></a>Solution1 原地查找</h2><h2 id="Solution2-先转置再竖直对称反转"><a href="#Solution2-先转置再竖直对称反转" class="headerlink" title="Solution2 先转置再竖直对称反转"></a>Solution2 先转置再竖直对称反转</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        //先转置</span><br><span class="line">        for(int row=0;row&lt;=matrix.size()-1;row++)&#123;</span><br><span class="line"></span><br><span class="line">            for(int col=row;col&lt;=matrix[0].size()-1;col++)&#123;</span><br><span class="line">                swap(matrix[row][col],matrix[col][row]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //在竖直对称翻转</span><br><span class="line">        for(int row=0;row&lt;=matrix.size()-1;row++)&#123;</span><br><span class="line">            for(int col = 0;col&lt;=(matrix.size()-1)/2;col++)&#123;</span><br><span class="line">                swap(matrix[row][col],matrix[row][matrix.size()-1-col]);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></h1><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p>
<p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: strs &#x3D; [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]<br>示例 2:</p>
<p>输入: strs &#x3D; [“”]<br>输出: [[“”]]<br>示例 3:</p>
<p>输入: strs &#x3D; [“a”]<br>输出: [[“a”]]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; strs.length &lt;&#x3D; 104<br>0 &lt;&#x3D; strs[i].length &lt;&#x3D; 100<br>strs[i] 仅包含小写字母</p>
<h2 id="Solution1-Map"><a href="#Solution1-Map" class="headerlink" title="Solution1 Map"></a>Solution1 Map</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        </span><br><span class="line">        map&lt;string,vector&lt;string&gt;&gt;res;</span><br><span class="line">        //遍历 </span><br><span class="line">        for(auto val:strs)&#123;</span><br><span class="line">            string tmp=val;</span><br><span class="line">               //以排序后的str作为key  vector&lt;string&gt;作为value 放进map</span><br><span class="line">            sort(val.begin(),val.end());</span><br><span class="line">            if(res.find(val)==res.end())&#123;</span><br><span class="line">                vector&lt;string&gt; t=&#123;tmp&#125;;</span><br><span class="line">                res.insert(&#123;val,t&#125;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res[val].push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历输出结果</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">        for(auto p:res)&#123;</span><br><span class="line">            result.push_back(p.second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/powx-n/">50. Pow(x, n)</a></h1><p>实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，xn ）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：x &#x3D; 2.00000, n &#x3D; 10<br>输出：1024.00000<br>示例 2：</p>
<p>输入：x &#x3D; 2.10000, n &#x3D; 3<br>输出：9.26100<br>示例 3：</p>
<p>输入：x &#x3D; 2.00000, n &#x3D; -2<br>输出：0.25000<br>解释：2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25
 </p>
<p>提示：</p>
<p>-100.0 &lt; x &lt; 100.0<br>-231 &lt;&#x3D; n &lt;&#x3D; 231-1<br>-104 &lt;&#x3D; xn &lt;&#x3D; 104</p>
<h2 id="Solution1-快速幂-递归"><a href="#Solution1-快速幂-递归" class="headerlink" title="Solution1  快速幂+递归"></a>Solution1  快速幂+递归</h2><p><img src="https://files.mdnice.com/user/1489/56d57700-be9b-4a89-b09c-1d373b1d5318.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double quickMul(double x, long long N) &#123;</span><br><span class="line">        if (N == 0) &#123;</span><br><span class="line">            return 1.0;</span><br><span class="line">        &#125;</span><br><span class="line">        double y = quickMul(x, N / 2);</span><br><span class="line">        return N % 2 == 0 ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double myPow(double x, int n) &#123;</span><br><span class="line">        long long N = n;</span><br><span class="line">        return N &gt;= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h1><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>子数组 是数组中的一个连续部分。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。<br>示例 2：</p>
<p>输入：nums &#x3D; [1]<br>输出：1<br>示例 3：</p>
<p>输入：nums &#x3D; [5,4,-1,7,8]<br>输出：23
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104
 </p>
<h2 id="Solution1-暴力-8"><a href="#Solution1-暴力-8" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-动态规划"><a href="#Solution2-动态规划" class="headerlink" title="Solution2 动态规划"></a>Solution2 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/8a4705a4-439c-4262-bdce-8186ee916289.png"></p>
<p><img src="https://files.mdnice.com/user/1489/5700074e-68cb-427a-9e58-a1858ab736e1.png"></p>
<h1 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></h1><p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br>示例 2：</p>
<p>输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]
 </p>
<p>提示：</p>
<p>m &#x3D;&#x3D; matrix.length<br>n &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 10<br>-100 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 100</p>
<h2 id="Solution1-原地遍历"><a href="#Solution1-原地遍历" class="headerlink" title="Solution1 原地遍历"></a>Solution1 原地遍历</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">          if(matrix.empty())&#123;return res;&#125;</span><br><span class="line">        int s=0,x=matrix.size()-1,z=0,y=matrix[0].size()-1;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">        while(true)&#123;</span><br><span class="line">            //在上边沿</span><br><span class="line">            for(int i=s,j=z;j&lt;=y;j++)&#123;</span><br><span class="line">                res.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(++s&gt;x)   break;</span><br><span class="line">            //在右边沿</span><br><span class="line">            for(int i=s,j=y;i&lt;=x;i++)&#123;</span><br><span class="line">                  res.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(--y&lt;z) break;</span><br><span class="line">            //在下边沿</span><br><span class="line">           for(int i=x,j=y;j&gt;=z;j--)&#123;</span><br><span class="line">                  res.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(--x&lt;s) break;</span><br><span class="line">            //在左边沿</span><br><span class="line">           for(int i=x,j=z;i&gt;=s;i--)&#123;</span><br><span class="line">                  res.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(++z&gt;y) break;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-按层遍历"><a href="#Solution2-按层遍历" class="headerlink" title="Solution2 按层遍历"></a>Solution2 按层遍历</h2><p><img src="https://files.mdnice.com/user/1489/6fc73b94-e500-4182-a9f9-e1d8a4e29a32.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        if (matrix.size() == 0 || matrix[0].size() == 0) &#123;</span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int rows = matrix.size(), columns = matrix[0].size();</span><br><span class="line">        vector&lt;int&gt; order;</span><br><span class="line">        int left = 0, right = columns - 1, top = 0, bottom = rows - 1;</span><br><span class="line">        while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">            for (int column = left; column &lt;= right; column++) &#123;</span><br><span class="line">                order.push_back(matrix[top][column]);</span><br><span class="line">            &#125;</span><br><span class="line">            for (int row = top + 1; row &lt;= bottom; row++) &#123;</span><br><span class="line">                order.push_back(matrix[row][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            if (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">                for (int column = right - 1; column &gt; left; column--) &#123;</span><br><span class="line">                    order.push_back(matrix[bottom][column]);</span><br><span class="line">                &#125;</span><br><span class="line">                for (int row = bottom; row &gt; top; row--) &#123;</span><br><span class="line">                    order.push_back(matrix[row][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        return order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h1><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<br>示例 2：</p>
<p>输入：intervals &#x3D; [[1,4],[4,5]]<br>输出：[[1,5]]<br>解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; intervals.length &lt;&#x3D; 104<br>intervals[i].length &#x3D;&#x3D; 2<br>0 &lt;&#x3D; starti &lt;&#x3D; endi &lt;&#x3D; 104</p>
<h2 id="Solution1-排序"><a href="#Solution1-排序" class="headerlink" title="Solution1 排序"></a>Solution1 排序</h2><p><img src="https://files.mdnice.com/user/1489/e8db6a23-fe74-4f65-b6a6-6cafbddff0bc.png"></p>
<p>复杂度分析</p>
<p>时间复杂度：O(n\log n)O(nlogn)，其中 nn 为区间的数量。除去排序的开销，我们只需要一次线性扫描，所以主要的时间开销是排序的 O(n\log n)O(nlogn)。</p>
<p>空间复杂度：O(\log n)O(logn)，其中 nn 为区间的数量。这里计算的是存储答案之外，使用的额外空间。O(\log n)O(logn) 即为排序所需要的空间复杂度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        if (intervals.size() == 0) &#123;</span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(intervals.begin(), intervals.end());</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; merged;</span><br><span class="line">        for (int i = 0; i &lt; intervals.size(); ++i) &#123;</span><br><span class="line">            int L = intervals[i][0], R = intervals[i][1];</span><br><span class="line">            if (!merged.size() || merged.back()[1] &lt; L) &#123;</span><br><span class="line">                merged.push_back(&#123;L, R&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                merged.back()[1] = max(merged.back()[1], R);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-list/">61. 旋转链表</a></h1><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2<br>输出：[4,5,1,2,3]<br>示例 2：</p>
<p>输入：head &#x3D; [0,1,2], k &#x3D; 4<br>输出：[2,0,1]
 </p>
<p>提示：</p>
<p>链表中节点的数目在范围 [0, 500] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>0 &lt;&#x3D; k &lt;&#x3D; 2 * 109</p>
<h2 id="Solution1-暴力-9"><a href="#Solution1-暴力-9" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Soluion2-闭环"><a href="#Soluion2-闭环" class="headerlink" title="Soluion2  闭环"></a>Soluion2  闭环</h2><p><img src="https://files.mdnice.com/user/1489/319c806f-a568-403a-9a39-c4ac50f30308.png"></p>
<h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p> </p>
<p>示例 1：</p>
<p>输入：m &#x3D; 3, n &#x3D; 7<br>输出：28<br>示例 2：</p>
<p>输入：m &#x3D; 3, n &#x3D; 2<br>输出：3<br>解释：<br>从左上角开始，总共有 3 条路径可以到达右下角。</p>
<ol>
<li>向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右</li>
<li>向下 -&gt; 向右 -&gt; 向下<br>示例 3：</li>
</ol>
<p>输入：m &#x3D; 7, n &#x3D; 3<br>输出：28<br>示例 4：</p>
<p>输入：m &#x3D; 3, n &#x3D; 3<br>输出：6
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; m, n &lt;&#x3D; 100<br>题目数据保证答案小于等于 2 * 109</p>
<h2 id="Solution1-排列组合"><a href="#Solution1-排列组合" class="headerlink" title="Solution1 排列组合"></a>Solution1 排列组合</h2><p><img src="https://files.mdnice.com/user/1489/4a4d21b3-ff48-457a-a612-9723074e0647.png"></p>
<h2 id="Solution2-动态规划-1"><a href="#Solution2-动态规划-1" class="headerlink" title="Solution2 动态规划"></a>Solution2 动态规划</h2><p>我们令 dp[i][j] 是到达 i, j 最多路径</p>
<p>动态方程：dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1]</p>
<p>注意，对于第一行 dp[0][j]，或者第一列 dp[i][0]，由于都是在边界，所以只能为 1</p>
<p>时间复杂度：O(m*n)O(m∗n)</p>
<p>空间复杂度：O(m * n)O(m∗n)</p>
<p>优化：因为我们每次只需要 dp[i-1][j],dp[i][j-1]</p>
<p>所以我们只要记录这两个数，直接看代码吧！</p>
<p>思路二：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[][] dp = new int[m][n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) dp[0][i] = 1;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) dp[i][0] = 1;</span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m - 1][n - 1];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>优化1：空间复杂度 O(2n)O(2n)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[] pre = new int[n];</span><br><span class="line">        int[] cur = new int[n];</span><br><span class="line">        Arrays.fill(pre, 1);</span><br><span class="line">        Arrays.fill(cur,1);</span><br><span class="line">        for (int i = 1; i &lt; m;i++)&#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++)&#123;</span><br><span class="line">                cur[j] = cur[j-1] + pre[j];</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        return pre[n-1]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化2：空间复杂度 O(n)O(n)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[] cur = new int[n];</span><br><span class="line">        Arrays.fill(cur,1);</span><br><span class="line">        for (int i = 1; i &lt; m;i++)&#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++)&#123;</span><br><span class="line">                cur[j] += cur[j-1] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur[n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h1><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。<br>示例 2：</p>
<p>输入：grid &#x3D; [[1,2,3],[4,5,6]]<br>输出：12
 </p>
<p>提示：</p>
<p>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 200<br>0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 100</p>
<h2 id="Solution0-暴力"><a href="#Solution0-暴力" class="headerlink" title="Solution0 暴力"></a>Solution0 暴力</h2><h2 id="Solution1-动态规划"><a href="#Solution1-动态规划" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/5984996e-8148-4ae1-8ed9-8198e3625d2f.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minPathSum(int[][] grid) &#123;</span><br><span class="line">        for(int i = 0; i &lt; grid.length; i++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; grid[0].length; j++) &#123;</span><br><span class="line">                if(i == 0 &amp;&amp; j == 0) continue;</span><br><span class="line">                else if(i == 0)  grid[i][j] = grid[i][j - 1] + grid[i][j];</span><br><span class="line">                else if(j == 0)  grid[i][j] = grid[i - 1][j] + grid[i][j];</span><br><span class="line">                else grid[i][j] = Math.min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return grid[grid.length - 1][grid[0].length - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/plus-one/">66. 加一</a></h1><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：digits &#x3D; [1,2,3]<br>输出：[1,2,4]<br>解释：输入数组表示数字 123。<br>示例 2：</p>
<p>输入：digits &#x3D; [4,3,2,1]<br>输出：[4,3,2,2]<br>解释：输入数组表示数字 4321。<br>示例 3：</p>
<p>输入：digits &#x3D; [0]<br>输出：[1]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; digits.length &lt;&#x3D; 100<br>0 &lt;&#x3D; digits[i] &lt;&#x3D; 9</p>
<h2 id="Solution-0-暴力"><a href="#Solution-0-暴力" class="headerlink" title="Solution 0  暴力"></a>Solution 0  暴力</h2><h2 id="Solution-1-逆序遍历-找到9"><a href="#Solution-1-逆序遍历-找到9" class="headerlink" title="Solution 1 逆序遍历 找到9"></a>Solution 1 逆序遍历 找到9</h2><p><img src="https://files.mdnice.com/user/1489/846120fb-5574-4fde-bd23-c798e938fa6e.png"></p>
<h1 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根 "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sqrtx/">69. x 的平方根 </a></h1><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p>
<p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p>
<p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：x &#x3D; 4<br>输出：2<br>示例 2：</p>
<p>输入：x &#x3D; 8<br>输出：2<br>解释：8 的算术平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; x &lt;&#x3D; 231 - 1</p>
<h2 id="Solution1-暴力-10"><a href="#Solution1-暴力-10" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-二分搜索"><a href="#Solution2-二分搜索" class="headerlink" title="Solution2 二分搜索"></a>Solution2 二分搜索</h2><p><img src="https://files.mdnice.com/user/1489/19d7f700-92c7-4591-bef6-efe163c000f3.png"></p>
<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h1><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶<br>示例 2：</li>
</ol>
<p>输入：n &#x3D; 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
<p> </p>
<p>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 45</p>
<h2 id="Solution1-递归-1"><a href="#Solution1-递归-1" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">      int dp0=1;</span><br><span class="line">       int dp1=1;</span><br><span class="line">        for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">            int tmp=dp0;</span><br><span class="line">            dp0=dp1;</span><br><span class="line">            dp1=tmp+dp1;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp1;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>






<h1 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a></h1><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>必须在不使用库的sort函数的情况下解决这个问题。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [2,0,2,1,1,0]<br>输出：[0,0,1,1,2,2]<br>示例 2：</p>
<p>输入：nums &#x3D; [2,0,1]<br>输出：[0,1,2]
 </p>
<p>提示：</p>
<p>n &#x3D;&#x3D; nums.length<br>1 &lt;&#x3D; n &lt;&#x3D; 300<br>nums[i] 为 0、1 或 2
 </p>
<p>进阶：</p>
<p>你可以不使用代码库中的排序函数来解决这道题吗？<br>你能想出一个仅使用常数空间的一趟扫描算法吗？</p>
<h2 id="Solution1-暴力-11"><a href="#Solution1-暴力-11" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><p>根据题目中的提示，我们可以统计出数组中 0, 1, 20,1,2 的个数，再根据它们的数量，重写整个数组。这种方法较为简单，也很容易想到，而本题解中会介绍两种基于指针进行交换的方法。</p>
<h2 id="Solution2-单指针"><a href="#Solution2-单指针" class="headerlink" title="Solution2 单指针"></a>Solution2 单指针</h2><p>我们可以考虑对数组进行两次遍历。在第一次遍历中，我们将数组中所有的 00 交换到数组的头部。在第二次遍历中，我们将数组中所有的 11 交换到头部的 00 之后。此时，所有的 22 都出现在数组的尾部，这样我们就完成了排序。</p>
<p>具体地，我们使用一个指针 \textit{ptr}ptr 表示「头部」的范围，\textit{ptr}ptr 中存储了一个整数，表示数组 \textit{nums}nums 从位置 00 到位置 \textit{ptr}-1ptr−1 都属于「头部」。\textit{ptr}ptr 的初始值为 00，表示还没有数处于「头部」。</p>
<p>在第一次遍历中，我们从左向右遍历整个数组，如果找到了 00，那么就需要将 00 与「头部」位置的元素进行交换，并将「头部」向后扩充一个位置。在遍历结束之后，所有的 00 都被交换到「头部」的范围，并且「头部」只包含 00。</p>
<p>在第二次遍历中，我们从「头部」开始，从左向右遍历整个数组，如果找到了 11，那么就需要将 11 与「头部」位置的元素进行交换，并将「头部」向后扩充一个位置。在遍历结束之后，所有的 11 都被交换到「头部」的范围，并且都在 00 之后，此时 22 只出现在「头部」之外的位置，因此排序完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void sortColors(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int ptr = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (nums[i] == 0) &#123;</span><br><span class="line">                swap(nums[i], nums[ptr]);</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = ptr; i &lt; n; ++i) &#123;</span><br><span class="line">            if (nums[i] == 1) &#123;</span><br><span class="line">                swap(nums[i], nums[ptr]);</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution3-双指针"><a href="#Solution3-双指针" class="headerlink" title="Solution3 双指针"></a>Solution3 双指针</h2><p><img src="https://files.mdnice.com/user/1489/d99bbb87-979c-426b-b6e5-647acf2cad20.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void sortColors(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int p0 = 0, p2 = n - 1;</span><br><span class="line">        for (int i = 0; i &lt;= p2; ++i) &#123;</span><br><span class="line">            while (i &lt;= p2 &amp;&amp; nums[i] == 2) &#123;</span><br><span class="line">                swap(nums[i], nums[p2]);</span><br><span class="line">                --p2;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums[i] == 0) &#123;</span><br><span class="line">                swap(nums[i], nums[p0]);</span><br><span class="line">                ++p0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">78. 子集</a></h1><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3]<br>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]<br>示例 2：</p>
<p>输入：nums &#x3D; [0]<br>输出：[[],[0]]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10<br>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10<br>nums 中的所有元素 互不相同</p>
<h2 id="Solution1-回溯-1"><a href="#Solution1-回溯-1" class="headerlink" title="Solution1 回溯"></a>Solution1 回溯</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/comments/1011321">https://leetcode.cn/problems/subsets/comments/1011321</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/">https://leetcode.cn/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line">    void backtracking(vector&lt;int&gt;&amp; nums, int startIndex) &#123;</span><br><span class="line">        result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉自己</span><br><span class="line">        if (startIndex &gt;= nums.size()) &#123; // 终止条件可以不加</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = startIndex; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            path.push_back(nums[i]);</span><br><span class="line">            backtracking(nums, i + 1);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        backtracking(nums, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="90-子集"><a href="#90-子集" class="headerlink" title="90.子集||"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets-ii/">90.子集||</a></h1><h1 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/">77. 组合</a></h1><h1 id="39-组合总和-1"><a href="#39-组合总和-1" class="headerlink" title="39. 组合总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h1><h1 id="40-组合总和-II-1"><a href="#40-组合总和-II-1" class="headerlink" title="40. 组合总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h1><h1 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h1><h1 id="784-字母大小写全排列"><a href="#784-字母大小写全排列" class="headerlink" title="784. 字母大小写全排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-case-permutation/">784. 字母大小写全排列</a></h1><h1 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search/comments/">79. 单词搜索</a></h1><h1 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h1><p>给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,1,2]<br>输出：[1,2]<br>示例 2：</p>
<p>输入：head &#x3D; [1,1,2,3,3]<br>输出：[1,2,3]
 </p>
<p>提示：</p>
<p>链表中节点数目在范围 [0, 300] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>题目数据保证链表已经按升序 排列</p>
<h2 id="Solution1-一次遍历"><a href="#Solution1-一次遍历" class="headerlink" title="Solution1 一次遍历"></a>Solution1 一次遍历</h2><p>方法一：一次遍历<br>思路与算法</p>
<p>由于给定的链表是排好序的，因此重复的元素在链表中出现的位置是连续的，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。</p>
<p>具体地，我们从指针 \textit{cur}cur 指向链表的头节点，随后开始对链表进行遍历。如果当前 \textit{cur}cur 与 \textit{cur.next}cur.next 对应的元素相同，那么我们就将 \textit{cur.next}cur.next 从链表中移除；否则说明链表中已经不存在其它与 \textit{cur}cur 对应的元素相同的节点，因此可以将 \textit{cur}cur 指向 \textit{cur.next}cur.next。</p>
<p>当遍历完整个链表之后，我们返回链表的头节点即可。</p>
<p>细节</p>
<p>当我们遍历到链表的最后一个节点时，\textit{cur.next}cur.next 为空节点，如果不加以判断，访问 \textit{cur.next}cur.next 对应的元素会产生运行错误。因此我们只需要遍历到链表的最后一个节点，而不需要遍历完整个链表。</p>
<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 是链表的长度。</p>
<p>空间复杂度：O(1)O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">        if (!head) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        while (cur-&gt;next) &#123;</span><br><span class="line">            if (cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-list/">86. 分隔链表</a></h1><p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p>
<p>你应当 保留 两个分区中每个节点的初始相对位置。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,4,3,2,5,2], x &#x3D; 3<br>输出：[1,2,2,4,3,5]<br>示例 2：</p>
<p>输入：head &#x3D; [2,1], x &#x3D; 2<br>输出：[1,2]
 </p>
<p>提示：</p>
<p>链表中节点的数目在范围 [0, 200] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>-200 &lt;&#x3D; x &lt;&#x3D; 200</p>
<h2 id="Solution1-双指针"><a href="#Solution1-双指针" class="headerlink" title="Solution1  双指针"></a>Solution1  双指针</h2><p><img src="https://files.mdnice.com/user/1489/1a1aae99-5b02-4641-9e50-5bd0913d1e4d.png"></p>
<h1 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-sorted-array/">88. 合并两个有序数组</a></h1><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>
<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>
<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3<br>输出：[1,2,2,3,5,6]<br>解释：需要合并 [1,2,3] 和 [2,5,6] 。<br>合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。<br>示例 2：</p>
<p>输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0<br>输出：[1]<br>解释：需要合并 [1] 和 [] 。<br>合并结果是 [1] 。<br>示例 3：</p>
<p>输入：nums1 &#x3D; [0], m &#x3D; 0, nums2 &#x3D; [1], n &#x3D; 1<br>输出：[1]<br>解释：需要合并的数组是 [] 和 [1] 。<br>合并结果是 [1] 。<br>注意，因为 m &#x3D; 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。
 </p>
<p>提示：</p>
<p>nums1.length &#x3D;&#x3D; m + n<br>nums2.length &#x3D;&#x3D; n<br>0 &lt;&#x3D; m, n &lt;&#x3D; 200<br>1 &lt;&#x3D; m + n &lt;&#x3D; 200<br>-109 &lt;&#x3D; nums1[i], nums2[j] &lt;&#x3D; 109
 </p>
<p>进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？</p>
<h2 id="Solution1-暴力直接合并后排序"><a href="#Solution1-暴力直接合并后排序" class="headerlink" title="Solution1 暴力直接合并后排序"></a>Solution1 暴力直接合并后排序</h2><p><img src="https://files.mdnice.com/user/1489/8aeff7af-53ed-467e-aebc-7835db5b52f5.png"></p>
<h2 id="Solution2-双指针-1"><a href="#Solution2-双指针-1" class="headerlink" title="Solution2 双指针"></a>Solution2 双指针</h2><p><img src="https://files.mdnice.com/user/1489/5be86979-df7c-4994-a29c-088dc60e24e6.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        int p1 = 0, p2 = 0;</span><br><span class="line">        int sorted[m + n];</span><br><span class="line">        int cur;</span><br><span class="line">        while (p1 &lt; m || p2 &lt; n) &#123;</span><br><span class="line">            if (p1 == m) &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125; else if (p2 == n) &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125; else if (nums1[p1] &lt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">            sorted[p1 + p2 - 1] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i != m + n; ++i) &#123;</span><br><span class="line">            nums1[i] = sorted[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(m+n)O(m+n)。<br>指针移动单调递增，最多移动 m+nm+n 次，因此时间复杂度为 O(m+n)O(m+n)。</p>
<p>空间复杂度：O(m+n)O(m+n)。<br>需要建立长度为 m+nm+n 的中间数组 \textit{sorted}sorted。</p>
<h2 id="Solution3-逆向双指针"><a href="#Solution3-逆向双指针" class="headerlink" title="Solution3 逆向双指针"></a>Solution3 逆向双指针</h2><p><img src="https://files.mdnice.com/user/1489/a825eedd-e311-4153-bc5b-ed31be497911.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        int p1 = m - 1, p2 = n - 1;</span><br><span class="line">        int tail = m + n - 1;</span><br><span class="line">        int cur;</span><br><span class="line">        while (p1 &gt;= 0 || p2 &gt;= 0) &#123;</span><br><span class="line">            if (p1 == -1) &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125; else if (p2 == -1) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; else if (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">            nums1[tail--] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-ways/">91. 解码方法</a></h1><p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p>
<p>‘A’ -&gt; “1”<br>‘B’ -&gt; “2”<br>…<br>‘Z’ -&gt; “26”<br>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p>
<p>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)<br>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p>
<p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p>
<p>题目数据保证答案肯定是一个 32 位 的整数。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “12”<br>输出：2<br>解释：它可以解码为 “AB”（1 2）或者 “L”（12）。<br>示例 2：</p>
<p>输入：s &#x3D; “226”<br>输出：3<br>解释：它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。<br>示例 3：</p>
<p>输入：s &#x3D; “0”<br>输出：0<br>解释：没有字符映射到以 0 开头的数字。<br>含有 0 的有效映射是 ‘J’ -&gt; “10” 和 ‘T’-&gt; “20” 。<br>由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 100<br>s 只包含数字，并且可能包含前导零。<br>通过次数235,094提交次数721,617</p>
<h2 id="Solution1-动态规划-1"><a href="#Solution1-动态规划-1" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/707aac6e-eec8-4f5a-8f0f-b7b45d344451.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numDecodings(string s) &#123;</span><br><span class="line">        if (s[0] == &#x27;0&#x27;) return 0;</span><br><span class="line">        vector&lt;int&gt; dp(s.size()+1);</span><br><span class="line">        dp[0]=1;dp[1]=1;</span><br><span class="line">        for (int i =1; i &lt; s.size(); i++) &#123;</span><br><span class="line">            if (s[i] == &#x27;0&#x27;)//1.s[i]为0的情况</span><br><span class="line">                if (s[i - 1] == &#x27;1&#x27; || s[i - 1] == &#x27;2&#x27;) //s[i - 1]等于1或2的情况</span><br><span class="line">                    dp[i+1] = dp[i-1];//由于s[1]指第二个下标，对应为dp[2],所以dp的下标要比s大1，故为dp[i+1]</span><br><span class="line">                else </span><br><span class="line">                    return 0;</span><br><span class="line">            else //2.s[i]不为0的情况</span><br><span class="line">                if (s[i - 1] == &#x27;1&#x27; || (s[i - 1] == &#x27;2&#x27; &amp;&amp; s[i] &lt;= &#x27;6&#x27;))//s[i-1]s[i]两位数要小于26的情况</span><br><span class="line">                    dp[i+1] = dp[i]+dp[i-1];</span><br><span class="line">                else//其他情况</span><br><span class="line">                    dp[i+1] = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-动态规划-空间复杂度优化为O-1"><a href="#Solution2-动态规划-空间复杂度优化为O-1" class="headerlink" title="Solution2 动态规划 空间复杂度优化为O(1)"></a>Solution2 动态规划 空间复杂度优化为O(1)</h2><p><img src="https://files.mdnice.com/user/1489/ebc2117f-b989-4c3d-b852-4b2b26c77453.png"></p>
<h1 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h1><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。
 </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4,5], left &#x3D; 2, right &#x3D; 4<br>输出：[1,4,3,2,5]<br>示例 2：</p>
<p>输入：head &#x3D; [5], left &#x3D; 1, right &#x3D; 1<br>输出：[5]
 </p>
<p>提示：</p>
<p>链表中节点数目为 n<br>1 &lt;&#x3D; n &lt;&#x3D; 500<br>-500 &lt;&#x3D; Node.val &lt;&#x3D; 500<br>1 &lt;&#x3D; left &lt;&#x3D; right &lt;&#x3D; n
 </p>
<p>进阶： 你可以使用一趟扫描完成反转吗？</p>
<h2 id="Solution1-原地反转"><a href="#Solution1-原地反转" class="headerlink" title="Solution1 原地反转"></a>Solution1 原地反转</h2><p><img src="https://files.mdnice.com/user/1489/1d9b3377-72f8-4c1b-8451-a2e484bfdc1c.png"></p>
<h1 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h1><p>给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,null,2,3]<br>输出：[1,3,2]<br>示例 2：</p>
<p>输入：root &#x3D; []<br>输出：[]<br>示例 3：</p>
<p>输入：root &#x3D; [1]<br>输出：[1]
 </p>
<p>提示：</p>
<p>树中节点数目在范围 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100
 </p>
<h2 id="Solution1-递归-2"><a href="#Solution1-递归-2" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><p><img src="https://files.mdnice.com/user/1489/166bca4c-bcc2-4718-b6f4-1576acf3ff36.png"></p>
<h2 id="Solution2-迭代-1"><a href="#Solution2-迭代-1" class="headerlink" title="Solution2 迭代"></a>Solution2 迭代</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        while (root != nullptr || !stk.empty()) &#123;</span><br><span class="line">            while (root != nullptr) &#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h1 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h1><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 3<br>输出：5<br>示例 2：</p>
<p>输入：n &#x3D; 1<br>输出：1
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 19</p>
<h2 id="Solution1-动态规划-2"><a href="#Solution1-动态规划-2" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p>结题思路：假设n个节点存在二叉排序树的个数是G(n)，1为根节点，2为根节点，…，n为根节点，<br>当1为根节点时，其左子树节点个数为0，右子树节点个数为n-1，<br>同理当2为根节点时，其左子树节点个数为1，右子树节点为n-2，<br>所以可得G(n) &#x3D; G(0)<em>G(n-1)+G(1)</em>(n-2)+…+G(n-1)*G(0)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numTrees(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n + 1);</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j - 1] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>






<h1 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a></h1><p>给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 3<br>输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]<br>示例 2：</p>
<p>输入：n &#x3D; 1<br>输出：[[1]]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 8</p>
<h2 id="Solution1-回溯-2"><a href="#Solution1-回溯-2" class="headerlink" title="Solution1 回溯"></a>Solution1 回溯</h2><p><img src="https://files.mdnice.com/user/1489/a150914f-1207-4dc6-8091-639f11405933.png"></p>
<p><img src="https://files.mdnice.com/user/1489/d66220b0-0d89-479e-9313-6adce6816e8c.png"></p>
<h1 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h1><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p>有效 二叉搜索树定义如下：</p>
<p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。
 </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [2,1,3]<br>输出：true<br>示例 2：</p>
<p>输入：root &#x3D; [5,1,4,null,null,3,6]<br>输出：false<br>解释：根节点的值是 5 ，但是右子节点的值是 4 。
 </p>
<p>提示：</p>
<p>树中节点数目范围在[1, 104] 内<br>-231 &lt;&#x3D; Node.val &lt;&#x3D; 231 - 1</p>
<h2 id="Solution1-递归-3"><a href="#Solution1-递归-3" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><p>方法一: 递归<br>思路和算法</p>
<p>要解决这道题首先我们要了解二叉搜索树有什么性质可以给我们利用，由题目给出的信息我们可以知道：如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。</p>
<p>这启示我们设计一个递归函数 helper(root, lower, upper) 来递归判断，函数表示考虑以 root 为根的子树，判断子树中所有节点的值是否都在 (l,r)(l,r) 的范围内（注意是开区间）。如果 root 节点的值 val 不在 (l,r)(l,r) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。</p>
<p>那么根据二叉搜索树的性质，在递归调用左子树时，我们需要把上界 upper 改为 root.val，即调用 helper(root.left, lower, root.val)，因为左子树里所有节点的值均小于它的根节点的值。同理递归调用右子树时，我们需要把下界 lower 改为 root.val，即调用 helper(root.right, root.val, upper)。</p>
<p>函数递归调用的入口为 helper(root, -inf, +inf)， inf 表示一个无穷大的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool helper(TreeNode* root, long long lower, long long upper) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root -&gt; val &lt;= lower || root -&gt; val &gt;= upper) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return helper(root -&gt; left, lower, root -&gt; val) &amp;&amp; helper(root -&gt; right, root -&gt; val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        return helper(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 为二叉树的节点个数。在递归调用的时候二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)O(n)。</p>
<p>空间复杂度：O(n)O(n)，其中 nn 为二叉树的节点个数。递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，即二叉树的高度。最坏情况下二叉树为一条链，树的高度为 nn ，递归最深达到 nn 层，故最坏情况下空间复杂度为 O(n)O(n) 。</p>
<h2 id="Solution2-中序遍历为升序"><a href="#Solution2-中序遍历为升序" class="headerlink" title="Solution2 中序遍历为升序"></a>Solution2 中序遍历为升序</h2><p>基于方法一中提及的性质，我们可以进一步知道二叉搜索树「中序遍历」得到的值构成的序列一定是升序的，这启示我们在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。如果均大于说明这个序列是升序的，整棵树是二叉搜索树，否则不是，下面的代码我们使用栈来模拟中序遍历的过程。</p>
<p>可能有读者不知道中序遍历是什么，我们这里简单提及。中序遍历是二叉树的一种遍历方式，它先遍历左子树，再遍历根节点，最后遍历右子树。而我们二叉搜索树保证了左子树的节点的值均小于根节点的值，根节点的值均小于右子树的值，因此中序遍历以后得到的序列一定是升序序列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stack;</span><br><span class="line">        long long inorder = (long long)INT_MIN - 1;</span><br><span class="line"></span><br><span class="line">        while (!stack.empty() || root != nullptr) &#123;</span><br><span class="line">            while (root != nullptr) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root -&gt; left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.top();</span><br><span class="line">            stack.pop();</span><br><span class="line">            // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树</span><br><span class="line">            if (root -&gt; val &lt;= inorder) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            inorder = root -&gt; val;</span><br><span class="line">            root = root -&gt; right;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 为二叉树的节点个数。二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)O(n)。</p>
<p>空间复杂度：O(n)O(n)，其中 nn 为二叉树的节点个数。栈最多存储 nn 个节点，因此需要额外的 O(n)O(n) 的空间。</p>
<h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h1><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,2,2,3,4,4,3]<br>输出：true<br>示例 2：</p>
<p>输入：root &#x3D; [1,2,2,null,3,null,3]<br>输出：false
 </p>
<p>提示：</p>
<p>树中节点数目在范围 [1, 1000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100
 </p>
<p>进阶：你可以运用递归和迭代两种方法解决这个问题吗？</p>
<h2 id="Solution1-递归-4"><a href="#Solution1-递归-4" class="headerlink" title="Solution1  递归"></a>Solution1  递归</h2><p><img src="https://files.mdnice.com/user/1489/17bcb971-2dd2-4659-a84f-24493a37c88e.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">		if(root==null) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		//调用递归函数，比较左节点，右节点</span><br><span class="line">		return dfs(root.left,root.right);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	boolean dfs(TreeNode left, TreeNode right) &#123;</span><br><span class="line">		//递归的终止条件是两个节点都为空</span><br><span class="line">		//或者两个节点中有一个为空</span><br><span class="line">		//或者两个节点的值不相等</span><br><span class="line">		if(left==null &amp;&amp; right==null) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		if(left==null || right==null) &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		if(left.val!=right.val) &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		//再递归的比较 左节点的左孩子 和 右节点的右孩子</span><br><span class="line">		//以及比较  左节点的右孩子 和 右节点的左孩子</span><br><span class="line">		return dfs(left.left,right.right) &amp;&amp; dfs(left.right,right.left);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution2-队列"><a href="#Solution2-队列" class="headerlink" title="Solution2 队列"></a>Solution2 队列</h2><p>回想下递归的实现：<br>当两个子树的根节点相等时，就比较:<br>左子树的 left 和 右子树的 right，这个比较是用递归实现的。<br>现在我们改用队列来实现，思路如下：<br>首先从队列中拿出两个节点(left 和 right)比较<br>将 left 的 left 节点和 right 的 right 节点放入队列<br>将 left 的 right 节点和 right 的 left 节点放入队列<br>时间复杂度是 O(n)O(n)，空间复杂度是 O(n)O(n)<br>动画演示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">		if(root==null || (root.left==null &amp;&amp; root.right==null)) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		//用队列保存节点</span><br><span class="line">		LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">		//将根节点的左右孩子放到队列中</span><br><span class="line">		queue.add(root.left);</span><br><span class="line">		queue.add(root.right);</span><br><span class="line">		while(queue.size()&gt;0) &#123;</span><br><span class="line">			//从队列中取出两个节点，再比较这两个节点</span><br><span class="line">			TreeNode left = queue.removeFirst();</span><br><span class="line">			TreeNode right = queue.removeFirst();</span><br><span class="line">			//如果两个节点都为空就继续循环，两者有一个为空就返回false</span><br><span class="line">			if(left==null &amp;&amp; right==null) &#123;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			if(left==null || right==null) &#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">			if(left.val!=right.val) &#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">			//将左节点的左孩子， 右节点的右孩子放入队列</span><br><span class="line">			queue.add(left.left);</span><br><span class="line">			queue.add(right.right);</span><br><span class="line">			//将左节点的右孩子，右节点的左孩子放入队列</span><br><span class="line">			queue.add(left.right);</span><br><span class="line">			queue.add(right.left);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h1><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]<br>示例 2：</p>
<p>输入：root &#x3D; [1]<br>输出：[[1]]<br>示例 3：</p>
<p>输入：root &#x3D; []<br>输出：[]
 </p>
<p>提示：</p>
<p>树中节点数目在范围 [0, 2000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p>
<h2 id="Solution1-队列实现"><a href="#Solution1-队列实现" class="headerlink" title="Solution1 队列实现"></a>Solution1 队列实现</h2><p><img src="https://files.mdnice.com/user/1489/35a4e4dc-eb76-4d87-ba29-735a5042bfe1.png"></p>
<p><img src="https://files.mdnice.com/user/1489/3f09955d-d39b-41e9-8495-445cf9b35418.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector &lt;vector &lt;int&gt;&gt; ret;</span><br><span class="line">        if (!root) &#123;</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue &lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            int currentLevelSize = q.size();</span><br><span class="line">            ret.push_back(vector &lt;int&gt; ());</span><br><span class="line">            for (int i = 1; i &lt;= currentLevelSize; ++i) &#123;</span><br><span class="line">                auto node = q.front(); q.pop();</span><br><span class="line">                ret.back().push_back(node-&gt;val);</span><br><span class="line">                if (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                if (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="Solution2-递归实现"><a href="#Solution2-递归实现" class="headerlink" title="Solution2 递归实现"></a>Solution2 递归实现</h2><p>层序遍历一般来说确实是用队列实现的，但是这里很明显用递归前序遍历就能实现呀，而且复杂度O(n)。。。</p>
<p>要点有几个：</p>
<p>利用depth变量记录当前在第几层（从0开始），进入下层时depth + 1；<br>如果depth &gt;&#x3D; vector.size()说明这一层还没来过，这是第一次来，所以得扩容咯；<br>因为是前序遍历，中-左-右，对于每一层来说，左边的肯定比右边先被遍历到，实际上后序中序都是一样的。。。<br>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        pre(root, 0, ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void pre(TreeNode *root, int depth, vector&lt;vector&lt;int&gt;&gt; &amp;ans) &#123;</span><br><span class="line">        if (!root) return ;</span><br><span class="line">        if (depth &gt;= ans.size())</span><br><span class="line">            ans.push_back(vector&lt;int&gt; &#123;&#125;);</span><br><span class="line">        ans[depth].push_back(root-&gt;val);</span><br><span class="line">        pre(root-&gt;left, depth + 1, ans);</span><br><span class="line">        pre(root-&gt;right, depth + 1, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h1><p>给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[3],[20,9],[15,7]]<br>示例 2：</p>
<p>输入：root &#x3D; [1]<br>输出：[[1]]<br>示例 3：</p>
<p>输入：root &#x3D; []<br>输出：[]
 </p>
<p>提示：</p>
<p>树中节点数目在范围 [0, 2000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p>
<h2 id="Solution1-层序遍历"><a href="#Solution1-层序遍历" class="headerlink" title="Solution1 层序遍历"></a>Solution1 层序遍历</h2><p>层序遍历，然后在奇数时逆序一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">        if(!root) return res;</span><br><span class="line">        </span><br><span class="line">        queue&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        int flag = 0;</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; out;</span><br><span class="line">            int size = q.size(); //取得每一层的长度</span><br><span class="line">            for(int i = 0; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                auto temp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                out.push_back(temp-&gt;val);</span><br><span class="line">                if(temp-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag%2==1)</span><br><span class="line">            &#123;</span><br><span class="line">                reverse(out.begin(),out.end());</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(out);</span><br><span class="line">            flag++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h1><h2 id="Solution1-DFS"><a href="#Solution1-DFS" class="headerlink" title="Solution1 DFS"></a>Solution1 DFS</h2><p><img src="https://files.mdnice.com/user/1489/f28b6ed7-01b5-4a89-952f-d626edf15d9e.png"></p>
<p><img src="https://files.mdnice.com/user/1489/988437b9-f65e-4111-8cde-79a687333027.png"></p>
<h2 id="Slution2-BFS"><a href="#Slution2-BFS" class="headerlink" title="Slution2 BFS"></a>Slution2 BFS</h2><p><img src="https://files.mdnice.com/user/1489/c915e202-251b-48cd-816b-cfcabdbf2214.png"></p>
<h1 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h1><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]<br>输出: [3,9,20,null,null,15,7]<br>示例 2:</p>
<p>输入: preorder &#x3D; [-1], inorder &#x3D; [-1]<br>输出: [-1]
 </p>
<p>提示:</p>
<p>1 &lt;&#x3D; preorder.length &lt;&#x3D; 3000<br>inorder.length &#x3D;&#x3D; preorder.length<br>-3000 &lt;&#x3D; preorder[i], inorder[i] &lt;&#x3D; 3000<br>preorder 和 inorder 均 无重复 元素<br>inorder 均出现在 preorder<br>preorder 保证 为二叉树的前序遍历序列<br>inorder 保证 为二叉树的中序遍历序列</p>
<h1 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/pascals-triangle/">118. 杨辉三角</a></h1><p>给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: numRows &#x3D; 5<br>输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]<br>示例 2:</p>
<p>输入: numRows &#x3D; 1<br>输出: [[1]]</p>
<h2 id="Solution1-直接求解"><a href="#Solution1-直接求解" class="headerlink" title="Solution1 直接求解"></a>Solution1 直接求解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; yanghui;</span><br><span class="line">        for (int i = 0; i &lt; numRows; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; data(i + 1);</span><br><span class="line">            yanghui.push_back(data);</span><br><span class="line">            for (int j = 0; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                if(j == 0) yanghui[i][j] = 1;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    yanghui[i][j] = yanghui[i - 1][j - 1] + yanghui[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            yanghui[i][yanghui[i].size() - 1] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return yanghui;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h1 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h1><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。
 </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,2,5,3,4,null,6]<br>输出：[1,null,2,null,3,null,4,null,5,null,6]<br>示例 2：</p>
<p>输入：root &#x3D; []<br>输出：[]<br>示例 3：</p>
<p>输入：root &#x3D; [0]<br>输出：[0]
 </p>
<p>提示：</p>
<p>树中结点数在范围 [0, 2000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100
 </p>
<h2 id="Solution1-递归-5"><a href="#Solution1-递归-5" class="headerlink" title="Solution1  递归"></a>Solution1  递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* last = nullptr;</span><br><span class="line">void flatten(TreeNode* root) &#123;</span><br><span class="line">    if (root == nullptr) return;</span><br><span class="line">    flatten(root-&gt;right);</span><br><span class="line">    flatten(root-&gt;left);</span><br><span class="line">    root-&gt;right = last;</span><br><span class="line">    root-&gt;left = nullptr;</span><br><span class="line">    last = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Solution2-迭代-2"><a href="#Solution2-迭代-2" class="headerlink" title="Solution2   迭代"></a>Solution2   迭代</h2><p><img src="https://files.mdnice.com/user/1489/5f3de36e-929d-4f22-adcb-a8070f305409.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        while(root)&#123;</span><br><span class="line">            TreeNode* p = root-&gt;left;</span><br><span class="line">            if(p)&#123;</span><br><span class="line">                while(p-&gt;right) p = p-&gt;right; </span><br><span class="line">                p-&gt;right = root-&gt;right;</span><br><span class="line">                root-&gt;right = root-&gt;left;</span><br><span class="line">                root-&gt;left = nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h1><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22<br>输出：[[5,4,11,2],[5,8,4,5]]<br>示例 2：</p>
<p>输入：root &#x3D; [1,2,3], targetSum &#x3D; 5<br>输出：[]<br>示例 3：</p>
<p>输入：root &#x3D; [1,2], targetSum &#x3D; 0<br>输出：[]
 </p>
<p>提示：</p>
<p>树中节点总数在范围 [0, 5000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000<br>-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000</p>
<h2 id="Solution1-DFS-1"><a href="#Solution1-DFS-1" class="headerlink" title="Solution1 DFS"></a>Solution1 DFS</h2><p>我们可以采用深度优先搜索的方式，枚举每一条从根节点到叶子节点的路径。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p>
<p>复杂度分析</p>
<p><img src="https://files.mdnice.com/user/1489/070d05a3-3ee3-4b0a-90da-bed5c1c2b9a8.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ret;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line"></span><br><span class="line">    void dfs(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        path.emplace_back(root-&gt;val);</span><br><span class="line">        targetSum -= root-&gt;val;</span><br><span class="line">        if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr &amp;&amp; targetSum == 0) &#123;</span><br><span class="line">            ret.emplace_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left, targetSum);</span><br><span class="line">        dfs(root-&gt;right, targetSum);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        dfs(root, targetSum);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Solution2-BFS"><a href="#Solution2-BFS" class="headerlink" title="Solution2 BFS"></a>Solution2 BFS</h2><p>方法二：广度优先搜索<br>思路及算法</p>
<p>我们也可以采用广度优先搜索的方式，遍历这棵树。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p>
<p>为了节省空间，我们使用哈希表记录树中的每一个节点的父节点。每次找到一个满足条件的节点，我们就从该节点出发不断向父节点迭代，即可还原出从根节点到当前节点的路径。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ret;</span><br><span class="line">    unordered_map&lt;TreeNode*, TreeNode*&gt; parent;</span><br><span class="line"></span><br><span class="line">    void getPath(TreeNode* node) &#123;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        while (node != nullptr) &#123;</span><br><span class="line">            tmp.emplace_back(node-&gt;val);</span><br><span class="line">            node = parent[node];</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(tmp.begin(), tmp.end());</span><br><span class="line">        ret.emplace_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; que_node;</span><br><span class="line">        queue&lt;int&gt; que_sum;</span><br><span class="line">        que_node.emplace(root);</span><br><span class="line">        que_sum.emplace(0);</span><br><span class="line"></span><br><span class="line">        while (!que_node.empty()) &#123;</span><br><span class="line">            TreeNode* node = que_node.front();</span><br><span class="line">            que_node.pop();</span><br><span class="line">            int rec = que_sum.front() + node-&gt;val;</span><br><span class="line">            que_sum.pop();</span><br><span class="line"></span><br><span class="line">            if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr) &#123;</span><br><span class="line">                if (rec == targetSum) &#123;</span><br><span class="line">                    getPath(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (node-&gt;left != nullptr) &#123;</span><br><span class="line">                    parent[node-&gt;left] = node;</span><br><span class="line">                    que_node.emplace(node-&gt;left);</span><br><span class="line">                    que_sum.emplace(rec);</span><br><span class="line">                &#125;</span><br><span class="line">                if (node-&gt;right != nullptr) &#123;</span><br><span class="line">                    parent[node-&gt;right] = node;</span><br><span class="line">                    que_node.emplace(node-&gt;right);</span><br><span class="line">                    que_sum.emplace(rec);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></h1><p>给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: head &#x3D; [-10,-3,0,5,9]<br>输出: [0,-3,9,-10,null,5]<br>解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。<br>示例 2:</p>
<p>输入: head &#x3D; []<br>输出: []
 </p>
<p>提示:</p>
<p>head 中的节点数在[0, 2 * 104] 范围内<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105</p>
<h2 id="Solution1-先找中点-然后再左右分别构造"><a href="#Solution1-先找中点-然后再左右分别构造" class="headerlink" title="Solution1 先找中点 然后再左右分别构造"></a>Solution1 先找中点 然后再左右分别构造</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode sortedListToBST(ListNode head) &#123;</span><br><span class="line">        if(head == null) return null;</span><br><span class="line">        else if(head.next == null) return new TreeNode(head.val);</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        ListNode p = pre.next;</span><br><span class="line">        ListNode q = p.next;</span><br><span class="line">        //找到链表的中点p</span><br><span class="line">        while(q!=null &amp;&amp; q.next!=null)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            p = pre.next;</span><br><span class="line">            q = q.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //将中点左边的链表分开</span><br><span class="line">        pre.next = null;</span><br><span class="line">        TreeNode root = new TreeNode(p.val);</span><br><span class="line">        root.left = sortedListToBST(head);</span><br><span class="line">        root.right = sortedListToBST(p.next);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="105-从前序与中序遍历序列构造二叉树-1"><a href="#105-从前序与中序遍历序列构造二叉树-1" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h1><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]<br>输出: [3,9,20,null,null,15,7]<br>示例 2:</p>
<p>输入: preorder &#x3D; [-1], inorder &#x3D; [-1]<br>输出: [-1]
 </p>
<p>提示:</p>
<p>1 &lt;&#x3D; preorder.length &lt;&#x3D; 3000<br>inorder.length &#x3D;&#x3D; preorder.length<br>-3000 &lt;&#x3D; preorder[i], inorder[i] &lt;&#x3D; 3000<br>preorder 和 inorder 均 无重复 元素<br>inorder 均出现在 preorder<br>preorder 保证 为二叉树的前序遍历序列<br>inorder 保证 为二叉树的中序遍历序列</p>
<h2 id="Solution1-递归-6"><a href="#Solution1-递归-6" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">        // preorder: [root, [left], [right]]</span><br><span class="line">        // inorder:  [[left], root, [right]]</span><br><span class="line">        return buildTree(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, int lo1, int hi1, vector&lt;int&gt;&amp; inorder, int lo2, int hi2) &#123;</span><br><span class="line">        if (lo1 &gt; hi1 || lo2 &gt; hi2) return nullptr;</span><br><span class="line">        int root = preorder[lo1];</span><br><span class="line">        int mid = lo2;</span><br><span class="line">        // 在 inorder 中查找 root 位置</span><br><span class="line">        for (int i = lo2; i &lt;= hi2; ++i) &#123;</span><br><span class="line">            if (inorder[i] == root) &#123;</span><br><span class="line">                mid = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        auto s = new TreeNode(root);</span><br><span class="line">        // 下面的数组表示分割长度</span><br><span class="line">        // inorder: [mid-lo2, mid, hi2-mid]</span><br><span class="line">        // preorder:[root, mid-lo2, hi2-mid]</span><br><span class="line">        s-&gt;left = buildTree(preorder, lo1+1, lo1+mid-lo2, inorder, lo2, mid-1);</span><br><span class="line">        s-&gt;right = buildTree(preorder, lo1+mid-lo2+1, hi1, inorder, mid+1, hi2);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="Solution2-1"><a href="#Solution2-1" class="headerlink" title="Solution2"></a>Solution2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int getLength(ListNode* head) &#123;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (; head != nullptr; ++ret, head = head-&gt;next);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* buildTree(ListNode*&amp; head, int left, int right) &#123;</span><br><span class="line">        if (left &gt; right) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = (left + right + 1) / 2;</span><br><span class="line">        TreeNode* root = new TreeNode();</span><br><span class="line">        root-&gt;left = buildTree(head, left, mid - 1);</span><br><span class="line">        root-&gt;val = head-&gt;val;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        root-&gt;right = buildTree(head, mid + 1, right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* sortedListToBST(ListNode* head) &#123;</span><br><span class="line">        int length = getLength(head);</span><br><span class="line">        return buildTree(head, 0, length - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h1><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。<br>     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br>示例 2：</p>
<p>输入：prices &#x3D; [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; prices.length &lt;&#x3D; 105<br>0 &lt;&#x3D; prices[i] &lt;&#x3D; 104</p>
<h2 id="Solution0-暴力解法"><a href="#Solution0-暴力解法" class="headerlink" title="Solution0 暴力解法"></a>Solution0 暴力解法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int n = (int)prices.size(), ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            for (int j = i + 1; j &lt; n; ++j) &#123;</span><br><span class="line">                ans = max(ans, prices[j] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-动态规划-3"><a href="#Solution1-动态规划-3" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p>动态规划 前i天的最大收益 &#x3D; max{前i-1天的最大收益，第i天的价格-前i-1天中的最小价格}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        if(prices.length &lt;= 1)</span><br><span class="line">            return 0;</span><br><span class="line">        int min = prices[0], max = 0;</span><br><span class="line">        for(int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, prices[i] - min);</span><br><span class="line">            min = Math.min(min, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h1><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p>
<p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p>
<p>返回 你能获得的 最大 利润 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：prices &#x3D; [7,1,5,3,6,4]<br>输出：7<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。<br>     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6 - 3 &#x3D; 3 。<br>     总利润为 4 + 3 &#x3D; 7 。<br>示例 2：</p>
<p>输入：prices &#x3D; [1,2,3,4,5]<br>输出：4<br>解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。<br>     总利润为 4 。<br>示例 3：</p>
<p>输入：prices &#x3D; [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; prices.length &lt;&#x3D; 3 * 104<br>0 &lt;&#x3D; prices[i] &lt;&#x3D; 104</p>
<h2 id="Solution1-贪心算法"><a href="#Solution1-贪心算法" class="headerlink" title="Solution1 贪心算法"></a>Solution1 贪心算法</h2><p><img src="https://files.mdnice.com/user/1489/5536a636-d181-42b9-a760-57aff155691a.png"></p>
<h2 id="Solution2-动态规划-2"><a href="#Solution2-动态规划-2" class="headerlink" title="Solution2 动态规划"></a>Solution2 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/9d910293-a6c0-4c4b-bfd8-c8e32fae01e8.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int [] dp = new int [prices.length+1];//这里从第0天开始，到底i天</span><br><span class="line">        dp[0] = 0;//第0天没有股票，最大利润为0</span><br><span class="line">        dp[1] = 0;//第一天只能买，不能买，因此最大利润也是0</span><br><span class="line">        for(int i = 1;i&lt;prices.length;i++)&#123;</span><br><span class="line">            int A =dp[i]+prices[i]-prices[i-1];//第一种选择</span><br><span class="line">            int B = dp[i];//第二种选择</span><br><span class="line">            dp[i+1] = A&gt;B ? A : B;//i从0开始，所以dp[I＋1]是当前天数 </span><br><span class="line">        &#125;</span><br><span class="line">        return dp[prices.length];</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-palindrome/">125. 验证回文串</a></h1><p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个回文串。</p>
<p>字母和数字都属于字母数字字符。</p>
<p>给你一个字符串 s，如果它是回文串，返回 true ；否则，返回 false 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入: “A man, a plan, a canal: Panama”<br>输出：true<br>解释：”amanaplanacanalpanama” 是回文串。<br>示例 2：</p>
<p>输入：”race a car”<br>输出：false<br>解释：”raceacar” 不是回文串。<br>示例 3：</p>
<p>输入：s &#x3D; “ “<br>输出：true<br>解释：在移除非字母数字字符之后，s 是一个空字符串 “” 。<br>由于空字符串正着反着读都一样，所以是回文串。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 2 * 105<br>s 仅由可打印的 ASCII 字符组成</p>
<h2 id="Solution1-筛选-判断"><a href="#Solution1-筛选-判断" class="headerlink" title="Solution1 筛选 + 判断"></a>Solution1 筛选 + 判断</h2><p><img src="https://files.mdnice.com/user/1489/fb453ee9-27d8-4bad-86ea-346219e70b18.png"></p>
<h2 id="Solution2-筛选-判断-02"><a href="#Solution2-筛选-判断-02" class="headerlink" title="Solution2 筛选 + 判断 02"></a>Solution2 筛选 + 判断 02</h2><p><img src="https://files.mdnice.com/user/1489/bd915655-54ae-4387-8d94-22cabd830f19.png"></p>
<h2 id="Solution03-在原字符串上直接判断"><a href="#Solution03-在原字符串上直接判断" class="headerlink" title="Solution03 在原字符串上直接判断"></a>Solution03 在原字符串上直接判断</h2><p><img src="https://files.mdnice.com/user/1489/4391ada0-91de-488d-a3a9-23fa346ea804.png"></p>
<h1 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="">136. 只出现一次的数字</a></h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p>示例 1:</p>
<p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p>
<p>输入: [4,1,2,1,2]<br>输出: 4</p>
<h2 id="Solution1-空间复杂度O-n-方法"><a href="#Solution1-空间复杂度O-n-方法" class="headerlink" title="Solution1  空间复杂度O(n)方法"></a>Solution1  空间复杂度O(n)方法</h2><p>如果不考虑时间复杂度和空间复杂度的限制，这道题有很多种解法，可能的解法有如下几种。</p>
<p>使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。</p>
<p>使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。</p>
<p>使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。</p>
<h2 id="Solution2-空间复杂夫O-1-方法"><a href="#Solution2-空间复杂夫O-1-方法" class="headerlink" title="Solution2 空间复杂夫O(1)方法"></a>Solution2 空间复杂夫O(1)方法</h2><p><img src="https://files.mdnice.com/user/1489/ae0e1058-6b96-43e8-9daa-10bf26ee4ccd.png"></p>
<p><img src="https://files.mdnice.com/user/1489/779a4035-c7d9-4b9a-b232-3f2cddeaa550.png"></p>
<h1 id="137-只出现一次的数字-II"><a href="#137-只出现一次的数字-II" class="headerlink" title="137. 只出现一次的数字 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/single-number-ii/">137. 只出现一次的数字 II</a></h1><p>给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [2,2,3,2]<br>输出：3<br>示例 2：</p>
<p>输入：nums &#x3D; [0,1,0,1,0,1,99]<br>输出：99
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104<br>-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1<br>nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次
 </p>
<p>进阶：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<h2 id="Solution1-哈希表"><a href="#Solution1-哈希表" class="headerlink" title="Solution1 哈希表"></a>Solution1 哈希表</h2><p><img src="https://files.mdnice.com/user/1489/12eb162d-772a-41e8-b79b-1e8acfb28d87.png"></p>
<h2 id="Solution2-二进制"><a href="#Solution2-二进制" class="headerlink" title="Solution2 二进制"></a>Solution2 二进制</h2><p><img src="https://files.mdnice.com/user/1489/7e979e15-b4a4-41bb-92d8-1cfb54630ee6.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; 32; ++i) &#123;</span><br><span class="line">            int total = 0;</span><br><span class="line">            for (int num: nums) &#123;</span><br><span class="line">                total += ((num &gt;&gt; i) &amp; 1);</span><br><span class="line">            &#125;</span><br><span class="line">            if (total % 3) &#123;</span><br><span class="line">                ans |= (1 &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(n \log C)O(nlogC)，其中 nn 是数组的长度，CC 是元素的数据范围，在本题中 \log C&#x3D;\log 2^{32} &#x3D; 32logC&#x3D;log2<br>32<br> &#x3D;32，也就是我们需要遍历第 0\sim310∼31 个二进制位。</p>
<p>空间复杂度：O(1)O(1)。</p>
<h1 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></h1><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</p>
<p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<p> </p>
<p>示例 1：</p>
<p>输入: s &#x3D; “leetcode”, wordDict &#x3D; [“leet”, “code”]<br>输出: true<br>解释: 返回 true 因为 “leetcode” 可以由 “leet” 和 “code” 拼接成。<br>示例 2：</p>
<p>输入: s &#x3D; “applepenapple”, wordDict &#x3D; [“apple”, “pen”]<br>输出: true<br>解释: 返回 true 因为 “applepenapple” 可以由 “apple” “pen” “apple” 拼接成。<br>     注意，你可以重复使用字典中的单词。<br>示例 3：</p>
<p>输入: s &#x3D; “catsandog”, wordDict &#x3D; [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出: false
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 300<br>1 &lt;&#x3D; wordDict.length &lt;&#x3D; 1000<br>1 &lt;&#x3D; wordDict[i].length &lt;&#x3D; 20<br>s 和 wordDict[i] 仅有小写英文字母组成<br>wordDict 中的所有字符串 互不相同</p>
<h2 id="Solution1-动态规划-4"><a href="#Solution1-动态规划-4" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</span><br><span class="line">    vector&lt;bool&gt; dp(s.size()+1, false);</span><br><span class="line">    unordered_set&lt;string&gt; m(wordDict.begin(), wordDict.end());</span><br><span class="line">    dp[0] = true;</span><br><span class="line">    for (int i = 1; i &lt;= s.size(); ++i)&#123;</span><br><span class="line">        for (int j = 0; j &lt; i; ++j)&#123;</span><br><span class="line">            if (dp[j] &amp;&amp; m.find(s.substr(j, i-j)) != m.end())&#123;</span><br><span class="line">                dp[i] = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[s.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-动态规划-优化版"><a href="#Solution2-动态规划-优化版" class="headerlink" title="Solution2 动态规划 优化版"></a>Solution2 动态规划 优化版</h2><p>【优化】对于以上代码可以优化。每次并不需要从s[0]开始搜索。因为wordDict中的字符串长度是有限的。只需要从i-maxWordLength开始搜索就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</span><br><span class="line">    vector&lt;bool&gt; dp(s.size()+1, false);</span><br><span class="line">    unordered_set&lt;string&gt; m(wordDict.begin(), wordDict.end());</span><br><span class="line">    dp[0] = true;</span><br><span class="line">    //获取最长字符串长度</span><br><span class="line">    int maxWordLength = 0;</span><br><span class="line">    for (int i = 0; i &lt; wordDict.size(); ++i)&#123;</span><br><span class="line">        maxWordLength = std::max(maxWordLength, (int)wordDict[i].size());</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= s.size(); ++i)&#123;</span><br><span class="line">        for (int j = std::max(i-maxWordLength, 0); j &lt; i; ++j)&#123;</span><br><span class="line">            if (dp[j] &amp;&amp; m.find(s.substr(j, i-j)) != m.end())&#123;</span><br><span class="line">                dp[i] = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[s.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h1><p>给你一个链表的头节点 head ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p>
<p>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p>
<p>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：false<br>解释：链表中没有环。
 </p>
<p>提示：</p>
<p>链表中节点的数目范围是 [0, 104]<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>pos 为 -1 或者链表中的一个 有效索引 。
 </p>
<p>进阶：你能用 O(1)（即，常量）内存解决此问题吗？</p>
<h2 id="Solution1-哈希表-1"><a href="#Solution1-哈希表-1" class="headerlink" title="Solution1 哈希表"></a>Solution1 哈希表</h2><p><img src="https://files.mdnice.com/user/1489/f65c3a6a-debe-4c68-ac3b-171b07af7262.png"></p>
<h2 id="Solution2-2"><a href="#Solution2-2" class="headerlink" title="Solution2"></a>Solution2</h2><p><img src="https://files.mdnice.com/user/1489/9add3a1c-b13f-4277-a2b6-e511bf914864.png"></p>
<p><img src="https://files.mdnice.com/user/1489/1411c0a9-8a0f-452f-8fc6-ff371d70d1d0.png"></p>
<p><img src="https://files.mdnice.com/user/1489/fc7adb50-508e-4b31-b28e-f3f11eea8217.png"></p>
<h1 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h1><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>不允许修改 链表。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p>
<p>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p>
<p>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：返回 null<br>解释：链表中没有环。
 </p>
<p>提示：</p>
<p>链表中节点的数目范围在范围 [0, 104] 内<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>pos 的值为 -1 或者链表中的一个有效索引</p>
<h2 id="Solution1-哈希表-2"><a href="#Solution1-哈希表-2" class="headerlink" title="Solution1 哈希表"></a>Solution1 哈希表</h2><p><img src="https://files.mdnice.com/user/1489/335701cf-1815-4ee0-a266-d54c6c35669b.png"></p>
<h2 id="Solution2-双指针-2"><a href="#Solution2-双指针-2" class="headerlink" title="Solution2 双指针"></a>Solution2 双指针</h2><p><img src="https://files.mdnice.com/user/1489/725fc0e8-c8e6-4660-b971-9c47beb3c888.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        while (fast != nullptr) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            if (fast-&gt;next == nullptr) &#123;</span><br><span class="line">                return nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            if (fast == slow) &#123;</span><br><span class="line">                ListNode *ptr = head;</span><br><span class="line">                while (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                return ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://files.mdnice.com/user/1489/7323d75f-2b46-4b8a-9908-4f5c654281f5.png"></p>
<h1 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reorder-list/">143. 重排链表</a></h1><p>给定一个单链表 L 的头节点 head ，单链表 L 表示为：</p>
<p>L0 → L1 → … → Ln - 1 → Ln<br>请将其重新排列后变为：</p>
<p>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …<br>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4]<br>输出：[1,4,2,3]<br>示例 2：</p>
<p>输入：head &#x3D; [1,2,3,4,5]<br>输出：[1,5,2,4,3]
 </p>
<p>提示：</p>
<p>链表的长度范围为 [1, 5 * 104]<br>1 &lt;&#x3D; node.val &lt;&#x3D; 1000</p>
<h2 id="Solution0-暴力-1"><a href="#Solution0-暴力-1" class="headerlink" title="Solution0 暴力"></a>Solution0 暴力</h2><h2 id="Solution1-双指针-1"><a href="#Solution1-双指针-1" class="headerlink" title="Solution1 双指针"></a>Solution1 双指针</h2><p>1.快慢指针找到中点 2.拆成两个链表 3.遍历两个链表，后面的塞到前面的“缝隙里”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">void reorderList(ListNode* head) &#123;</span><br><span class="line">    </span><br><span class="line">    if(head==NULL || head-&gt;next == NULL)</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line">    //快慢指针分出两段</span><br><span class="line">    ListNode *slow = head,*fast = head;</span><br><span class="line">    </span><br><span class="line">    while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123;</span><br><span class="line">        </span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //后端反转</span><br><span class="line">    ListNode *needReverser = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = NULL;</span><br><span class="line">    needReverser = reverse(needReverser);</span><br><span class="line">    </span><br><span class="line">    //插入前端缝隙</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    while(cur &amp;&amp; needReverser)&#123;</span><br><span class="line">        ListNode *curSecond = needReverser;</span><br><span class="line">        needReverser = needReverser-&gt;next;</span><br><span class="line">        ListNode *nextCur = cur-&gt;next;</span><br><span class="line">        curSecond-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = curSecond;</span><br><span class="line">        </span><br><span class="line">        cur = nextCur;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode *reverse(ListNode *head)&#123;</span><br><span class="line">    </span><br><span class="line">    ListNode *p1 = NULL;</span><br><span class="line">    ListNode *p2 = head;</span><br><span class="line">    ListNode *p3 = p2;</span><br><span class="line">    </span><br><span class="line">    while(p2)&#123;</span><br><span class="line">        p3 = p2-&gt;next;</span><br><span class="line">        p2-&gt;next = p1;</span><br><span class="line">        p1 = p2;</span><br><span class="line">        p2 = p3;            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return p1;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h1><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,null,2,3]<br>输出：[1,2,3]<br>示例 2：</p>
<p>输入：root &#x3D; []<br>输出：[]<br>示例 3：</p>
<p>输入：root &#x3D; [1]<br>输出：[1]<br>示例 4：</p>
<p>输入：root &#x3D; [1,2]<br>输出：[1,2]<br>示例 5：</p>
<p>输入：root &#x3D; [1,null,2]<br>输出：[1,2]
 </p>
<p>提示：</p>
<p>树中节点数目在范围 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p>
<h2 id="Solution1-递归-7"><a href="#Solution1-递归-7" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><p><img src="https://files.mdnice.com/user/1489/04aefe28-f537-4f0f-a96c-e08abbe1030f.png"></p>
<h2 id="Solution2-迭代-3"><a href="#Solution2-迭代-3" class="headerlink" title="Solution2 迭代"></a>Solution2 迭代</h2><p><img src="https://files.mdnice.com/user/1489/de302c02-3172-4795-81bf-b52f9a497fcf.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        while (!stk.empty() || node != nullptr) &#123;</span><br><span class="line">            while (node != nullptr) &#123;</span><br><span class="line">                res.emplace_back(node-&gt;val);</span><br><span class="line">                stk.emplace(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 是二叉树的节点数。每一个节点恰好被遍历一次。</p>
<p>空间复杂度：O(n)O(n)，为迭代过程中显式栈的开销，平均情况下为 O(\log n)O(logn)，最坏情况下树呈现链状，为 O(n)O(n)。</p>
<h1 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h1><p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：<br>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。<br>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p>
<p> </p>
<p>示例：</p>
<p>输入<br>[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”]<br>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]<br>输出<br>[null, null, null, 1, null, -1, null, -1, 3, 4]</p>
<p>解释<br>LRUCache lRUCache &#x3D; new LRUCache(2);<br>lRUCache.put(1, 1); &#x2F;&#x2F; 缓存是 {1&#x3D;1}<br>lRUCache.put(2, 2); &#x2F;&#x2F; 缓存是 {1&#x3D;1, 2&#x3D;2}<br>lRUCache.get(1);    &#x2F;&#x2F; 返回 1<br>lRUCache.put(3, 3); &#x2F;&#x2F; 该操作会使得关键字 2 作废，缓存是 {1&#x3D;1, 3&#x3D;3}<br>lRUCache.get(2);    &#x2F;&#x2F; 返回 -1 (未找到)<br>lRUCache.put(4, 4); &#x2F;&#x2F; 该操作会使得关键字 1 作废，缓存是 {4&#x3D;4, 3&#x3D;3}<br>lRUCache.get(1);    &#x2F;&#x2F; 返回 -1 (未找到)<br>lRUCache.get(3);    &#x2F;&#x2F; 返回 3<br>lRUCache.get(4);    &#x2F;&#x2F; 返回 4
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; capacity &lt;&#x3D; 3000<br>0 &lt;&#x3D; key &lt;&#x3D; 10000<br>0 &lt;&#x3D; value &lt;&#x3D; 105<br>最多调用 2 * 105 次 get 和 put</p>
<h2 id="Solution1-哈希表-双向链表"><a href="#Solution1-哈希表-双向链表" class="headerlink" title="Solution1 哈希表 + 双向链表"></a>Solution1 哈希表 + 双向链表</h2><p>方法一：哈希表 + 双向链表<br>算法</p>
<p>LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。</p>
<p>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</p>
<p>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。</p>
<p>这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1)O(1) 的时间内完成 get 或者 put 操作。具体的方法如下：</p>
<p>对于 get 操作，首先判断 key 是否存在：</p>
<p>如果 key 不存在，则返回 -1−1；</p>
<p>如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。</p>
<p>对于 put 操作，首先判断 key 是否存在：</p>
<p>如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；</p>
<p>如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。</p>
<p>上述各项操作中，访问哈希表的时间复杂度为 O(1)O(1)，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 O(1)O(1)。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 O(1)O(1) 时间内完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">struct DLinkedNode &#123;</span><br><span class="line">    int key, value;</span><br><span class="line">    DLinkedNode* prev;</span><br><span class="line">    DLinkedNode* next;</span><br><span class="line">    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) &#123;&#125;</span><br><span class="line">    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LRUCache &#123;</span><br><span class="line">private:</span><br><span class="line">    unordered_map&lt;int, DLinkedNode*&gt; cache;</span><br><span class="line">    DLinkedNode* head;</span><br><span class="line">    DLinkedNode* tail;</span><br><span class="line">    int size;</span><br><span class="line">    int capacity;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    LRUCache(int _capacity): capacity(_capacity), size(0) &#123;</span><br><span class="line">        // 使用伪头部和伪尾部节点</span><br><span class="line">        head = new DLinkedNode();</span><br><span class="line">        tail = new DLinkedNode();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int get(int key) &#123;</span><br><span class="line">        if (!cache.count(key)) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果 key 存在，先通过哈希表定位，再移到头部</span><br><span class="line">        DLinkedNode* node = cache[key];</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        return node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void put(int key, int value) &#123;</span><br><span class="line">        if (!cache.count(key)) &#123;</span><br><span class="line">            // 如果 key 不存在，创建一个新的节点</span><br><span class="line">            DLinkedNode* node = new DLinkedNode(key, value);</span><br><span class="line">            // 添加进哈希表</span><br><span class="line">            cache[key] = node;</span><br><span class="line">            // 添加至双向链表的头部</span><br><span class="line">            addToHead(node);</span><br><span class="line">            ++size;</span><br><span class="line">            if (size &gt; capacity) &#123;</span><br><span class="line">                // 如果超出容量，删除双向链表的尾部节点</span><br><span class="line">                DLinkedNode* removed = removeTail();</span><br><span class="line">                // 删除哈希表中对应的项</span><br><span class="line">                cache.erase(removed-&gt;key);</span><br><span class="line">                // 防止内存泄漏</span><br><span class="line">                delete removed;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span><br><span class="line">            DLinkedNode* node = cache[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void addToHead(DLinkedNode* node) &#123;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void removeNode(DLinkedNode* node) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void moveToHead(DLinkedNode* node) &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DLinkedNode* removeTail() &#123;</span><br><span class="line">        DLinkedNode* node = tail-&gt;prev;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></h1><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [4,2,1,3]<br>输出：[1,2,3,4]<br>示例 2：</p>
<p>输入：head &#x3D; [-1,5,3,4,0]<br>输出：[-1,0,3,4,5]<br>示例 3：</p>
<p>输入：head &#x3D; []<br>输出：[]
 </p>
<p>提示：</p>
<p>链表中节点的数目在范围 [0, 5 * 104] 内<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105</p>
<h2 id="Solution1-自顶向下归并排序"><a href="#Solution1-自顶向下归并排序" class="headerlink" title="Solution1 自顶向下归并排序"></a>Solution1 自顶向下归并排序</h2><p><img src="https://files.mdnice.com/user/1489/d5233fdc-b942-4252-b385-aeaa32428270.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* sortList(ListNode* head) &#123;</span><br><span class="line">        return sortList(head, nullptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* sortList(ListNode* head, ListNode* tail) &#123;</span><br><span class="line">        if (head == nullptr) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        if (head-&gt;next == tail) &#123;</span><br><span class="line">            head-&gt;next = nullptr;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow = head, *fast = head;</span><br><span class="line">        while (fast != tail) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            if (fast != tail) &#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* mid = slow;</span><br><span class="line">        return merge(sortList(head, mid), sortList(mid, tail));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* merge(ListNode* head1, ListNode* head2) &#123;</span><br><span class="line">        ListNode* dummyHead = new ListNode(0);</span><br><span class="line">        ListNode* temp = dummyHead, *temp1 = head1, *temp2 = head2;</span><br><span class="line">        while (temp1 != nullptr &amp;&amp; temp2 != nullptr) &#123;</span><br><span class="line">            if (temp1-&gt;val &lt;= temp2-&gt;val) &#123;</span><br><span class="line">                temp-&gt;next = temp1;</span><br><span class="line">                temp1 = temp1-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                temp-&gt;next = temp2;</span><br><span class="line">                temp2 = temp2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (temp1 != nullptr) &#123;</span><br><span class="line">            temp-&gt;next = temp1;</span><br><span class="line">        &#125; else if (temp2 != nullptr) &#123;</span><br><span class="line">            temp-&gt;next = temp2;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution2-自底向上归并排序"><a href="#Solution2-自底向上归并排序" class="headerlink" title="Solution2 自底向上归并排序"></a>Solution2 自底向上归并排序</h2><p><img src="https://files.mdnice.com/user/1489/76432652-12d7-4385-8ea8-6dae686cd490.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* sortList(ListNode* head) &#123;</span><br><span class="line">        if (head == nullptr) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        int length = 0;</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        while (node != nullptr) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* dummyHead = new ListNode(0, head);</span><br><span class="line">        for (int subLength = 1; subLength &lt; length; subLength &lt;&lt;= 1) &#123;</span><br><span class="line">            ListNode* prev = dummyHead, *curr = dummyHead-&gt;next;</span><br><span class="line">            while (curr != nullptr) &#123;</span><br><span class="line">                ListNode* head1 = curr;</span><br><span class="line">                for (int i = 1; i &lt; subLength &amp;&amp; curr-&gt;next != nullptr; i++) &#123;</span><br><span class="line">                    curr = curr-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode* head2 = curr-&gt;next;</span><br><span class="line">                curr-&gt;next = nullptr;</span><br><span class="line">                curr = head2;</span><br><span class="line">                for (int i = 1; i &lt; subLength &amp;&amp; curr != nullptr &amp;&amp; curr-&gt;next != nullptr; i++) &#123;</span><br><span class="line">                    curr = curr-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode* next = nullptr;</span><br><span class="line">                if (curr != nullptr) &#123;</span><br><span class="line">                    next = curr-&gt;next;</span><br><span class="line">                    curr-&gt;next = nullptr;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode* merged = merge(head1, head2);</span><br><span class="line">                prev-&gt;next = merged;</span><br><span class="line">                while (prev-&gt;next != nullptr) &#123;</span><br><span class="line">                    prev = prev-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* merge(ListNode* head1, ListNode* head2) &#123;</span><br><span class="line">        ListNode* dummyHead = new ListNode(0);</span><br><span class="line">        ListNode* temp = dummyHead, *temp1 = head1, *temp2 = head2;</span><br><span class="line">        while (temp1 != nullptr &amp;&amp; temp2 != nullptr) &#123;</span><br><span class="line">            if (temp1-&gt;val &lt;= temp2-&gt;val) &#123;</span><br><span class="line">                temp-&gt;next = temp1;</span><br><span class="line">                temp1 = temp1-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                temp-&gt;next = temp2;</span><br><span class="line">                temp2 = temp2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (temp1 != nullptr) &#123;</span><br><span class="line">            temp-&gt;next = temp1;</span><br><span class="line">        &#125; else if (temp2 != nullptr) &#123;</span><br><span class="line">            temp-&gt;next = temp2;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h1><p>根据 逆波兰表示法，求表达式的值。</p>
<p>有效的算符包括 +、-、*、&#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p>注意 两个整数之间的除法只保留整数部分。</p>
<p>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：tokens &#x3D; [“2”,”1”,”+”,”3”,”*”]<br>输出：9<br>解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9<br>示例 2：</p>
<p>输入：tokens &#x3D; [“4”,”13”,”5”,”&#x2F;“,”+”]<br>输出：6<br>解释：该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6<br>示例 3：</p>
<p>输入：tokens &#x3D; [“10”,”6”,”9”,”3”,”+”,”-11”,”<em>“,”&#x2F;“,”</em>“,”17”,”+”,”5”,”+”]<br>输出：22<br>解释：该算式转化为常见的中缀算术表达式为：<br>  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5<br>&#x3D; ((10 * 0) + 17) + 5<br>&#x3D; (0 + 17) + 5<br>&#x3D; 17 + 5<br>&#x3D; 22
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; tokens.length &lt;&#x3D; 104<br>tokens[i] 是一个算符（”+”、”-“、”*” 或 “&#x2F;“），或是在范围 [-200, 200] 内的一个整数
 </p>
<p>逆波兰表达式：</p>
<p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p>
<p>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。<br>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。<br>逆波兰表达式主要有以下两个优点：</p>
<p>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。<br>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</p>
<h2 id="Solution1-栈-1"><a href="#Solution1-栈-1" class="headerlink" title="Solution1  栈"></a>Solution1  栈</h2><p><img src="https://files.mdnice.com/user/1489/e7ac0fe5-7797-4094-a619-f13588081fd5.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">        stack&lt;int&gt; stk;</span><br><span class="line">        int n = tokens.size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            string&amp; token = tokens[i];</span><br><span class="line">            if (isNumber(token)) &#123;</span><br><span class="line">                stk.push(atoi(token.c_str()));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int num2 = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                int num1 = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                switch (token[0]) &#123;</span><br><span class="line">                    case &#x27;+&#x27;:</span><br><span class="line">                        stk.push(num1 + num2);</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;-&#x27;:</span><br><span class="line">                        stk.push(num1 - num2);</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;*&#x27;:</span><br><span class="line">                        stk.push(num1 * num2);</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;/&#x27;:</span><br><span class="line">                        stk.push(num1 / num2);</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stk.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isNumber(string&amp; token) &#123;</span><br><span class="line">        return !(token == &quot;+&quot; || token == &quot;-&quot; || token == &quot;*&quot; || token == &quot;/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 是数组 \textit{tokens}tokens 的长度。需要遍历数组 \textit{tokens}tokens 一次，计算逆波兰表达式的值。</p>
<p>空间复杂度：O(n)O(n)，其中 nn 是数组 \textit{tokens}tokens 的长度。使用栈存储计算过程中的数，栈内元素个数不会超过逆波兰表达式的长度。</p>
<h2 id="Solution2-数组模拟栈"><a href="#Solution2-数组模拟栈" class="headerlink" title="Solution2 数组模拟栈"></a>Solution2 数组模拟栈</h2><p><img src="https://files.mdnice.com/user/1489/f40bfb53-0680-426d-b458-8de6820f7bae.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">        int n = tokens.size();</span><br><span class="line">        vector&lt;int&gt; stk((n + 1) / 2);</span><br><span class="line">        int index = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            string&amp; token = tokens[i];</span><br><span class="line">            if (token.length() &gt; 1 || isdigit(token[0])) &#123;</span><br><span class="line">                index++;</span><br><span class="line">                stk[index] = atoi(token.c_str());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                switch (token[0]) &#123;</span><br><span class="line">                    case &#x27;+&#x27;:</span><br><span class="line">                        index--;</span><br><span class="line">                        stk[index] += stk[index + 1];</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;-&#x27;:</span><br><span class="line">                        index--;</span><br><span class="line">                        stk[index] -= stk[index + 1];</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;*&#x27;:</span><br><span class="line">                        index--;</span><br><span class="line">                        stk[index] *= stk[index + 1];</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;/&#x27;:</span><br><span class="line">                        index--;</span><br><span class="line">                        stk[index] /= stk[index + 1];</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stk[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-product-subarray/">152. 乘积最大子数组</a></h1><p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>测试用例的答案是一个 32-位 整数。</p>
<p>子数组 是数组的连续子序列。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: nums &#x3D; [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。<br>示例 2:</p>
<p>输入: nums &#x3D; [-2,0,-1]<br>输出: 0<br>解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
 </p>
<p>提示:</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 104<br>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10<br>nums 的任何前缀或后缀的乘积都 保证 是一个 32-位 整数</p>
<h2 id="Solution0-暴力-2"><a href="#Solution0-暴力-2" class="headerlink" title="Solution0 暴力"></a>Solution0 暴力</h2><h2 id="Solution1-动态规划-5"><a href="#Solution1-动态规划-5" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/8079c50a-6dbe-4779-9b7d-ff76f481397d.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if(n == 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else if(n == 1) &#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        int p = nums[0];</span><br><span class="line">        int maxP = nums[0];</span><br><span class="line">        int minP = nums[0];</span><br><span class="line">        for(int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            int t = maxP;</span><br><span class="line">            maxP = max(max(maxP * nums[i], nums[i]), minP *nums[i]);</span><br><span class="line">            minP = min(min(t * nums[i], nums[i]), minP * nums[i]);</span><br><span class="line">            p = max(maxP, p);</span><br><span class="line">        &#125;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="171-Excel-表列序号"><a href="#171-Excel-表列序号" class="headerlink" title="171. Excel 表列序号"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/excel-sheet-column-number/">171. Excel 表列序号</a></h1><p>给你一个字符串 columnTitle ，表示 Excel 表格中的列名称。返回 该列名称对应的列序号 。</p>
<p>例如：</p>
<p>A -&gt; 1<br>B -&gt; 2<br>C -&gt; 3<br>…<br>Z -&gt; 26<br>AA -&gt; 27<br>AB -&gt; 28<br>…
 </p>
<p>示例 1:</p>
<p>输入: columnTitle &#x3D; “A”<br>输出: 1<br>示例 2:</p>
<p>输入: columnTitle &#x3D; “AB”<br>输出: 28<br>示例 3:</p>
<p>输入: columnTitle &#x3D; “ZY”<br>输出: 701
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; columnTitle.length &lt;&#x3D; 7<br>columnTitle 仅由大写英文组成<br>columnTitle 在范围 [“A”, “FXSHRXW”] 内</p>
<h2 id="Solution1-26进制"><a href="#Solution1-26进制" class="headerlink" title="Solution1  26进制"></a>Solution1  26进制</h2><p><img src="https://files.mdnice.com/user/1489/ca4fbbe4-2cea-43f3-ac48-3d192c40bacf.png"></p>
<h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-stack/comments/">155. 最小栈</a></h1><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>实现 MinStack 类:</p>
<p>MinStack() 初始化堆栈对象。<br>void push(int val) 将元素val推入堆栈。<br>void pop() 删除堆栈顶部的元素。<br>int top() 获取堆栈顶部的元素。<br>int getMin() 获取堆栈中的最小元素。
 </p>
<p>示例 1:</p>
<p>输入：<br>[“MinStack”,”push”,”push”,”push”,”getMin”,”pop”,”top”,”getMin”]<br>[[],[-2],[0],[-3],[],[],[],[]]</p>
<p>输出：<br>[null,null,null,null,-3,null,0,-2]</p>
<p>解释：<br>MinStack minStack &#x3D; new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.
 </p>
<p>提示：</p>
<p>-231 &lt;&#x3D; val &lt;&#x3D; 231 - 1<br>pop、top 和 getMin 操作总是在 非空栈 上调用<br>push, pop, top, and getMin最多被调用 3 * 104 次</p>
<h2 id="Solution1-辅助栈"><a href="#Solution1-辅助栈" class="headerlink" title="Solution1 辅助栈"></a>Solution1 辅助栈</h2><p><img src="https://files.mdnice.com/user/1489/0b64394f-ee13-447f-835a-965086697e94.png"></p>
<p><img src="https://files.mdnice.com/user/1489/a01bf43a-aa9c-45e4-8e02-e38f1a09bba3.png"></p>
<h2 id="Solution2-不用辅助栈"><a href="#Solution2-不用辅助栈" class="headerlink" title="Solution2 不用辅助栈"></a>Solution2 不用辅助栈</h2><p><img src="https://files.mdnice.com/user/1489/5f397d41-0fd5-406a-befb-20bb996d6862.png"></p>
<h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h1><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p>
<p>图示两个链表在节点 c1 开始相交：</p>
<p>题目数据 保证 整个链式结构中不存在环。</p>
<p>注意，函数返回结果后，链表必须 保持其原始结构 。</p>
<p>自定义评测：</p>
<p>评测系统 的输入如下（你设计的程序 不适用 此输入）：</p>
<p>intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0<br>listA - 第一个链表<br>listB - 第二个链表<br>skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数<br>skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数<br>评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3<br>输出：Intersected at ‘8’<br>解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。<br>在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。<br>示例 2：</p>
<p>输入：intersectVal &#x3D; 2, listA &#x3D; [1,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1<br>输出：Intersected at ‘2’<br>解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。<br>在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。<br>示例 3：</p>
<p>输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2<br>输出：null<br>解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。<br>由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 null 。
 </p>
<p>提示：</p>
<p>listA 中节点数目为 m<br>listB 中节点数目为 n<br>1 &lt;&#x3D; m, n &lt;&#x3D; 3 * 104<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>0 &lt;&#x3D; skipA &lt;&#x3D; m<br>0 &lt;&#x3D; skipB &lt;&#x3D; n<br>如果 listA 和 listB 没有交点，intersectVal 为 0<br>如果 listA 和 listB 有交点，intersectVal &#x3D;&#x3D; listA[skipA] &#x3D;&#x3D; listB[skipB]
 </p>
<p>进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？</p>
<h2 id="Solution1-哈希集合"><a href="#Solution1-哈希集合" class="headerlink" title="Solution1 哈希集合"></a>Solution1 哈希集合</h2><p><img src="https://files.mdnice.com/user/1489/6ed11899-abbb-4316-b5f5-0905cc477414.png"></p>
<h2 id="Solution2-双指针-3"><a href="#Solution2-双指针-3" class="headerlink" title="Solution2 双指针"></a>Solution2 双指针</h2><p><img src="https://files.mdnice.com/user/1489/eef3c25b-9218-4dd9-83d7-392ec8df5f36.png"></p>
<p><img src="https://files.mdnice.com/user/1489/a181f628-892e-4ab3-9509-236d9b01c497.png"></p>
<p><img src="https://files.mdnice.com/user/1489/a1ffabf9-420e-46a6-a2e1-ae5db89d9a6e.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        if (headA == nullptr || headB == nullptr) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *pA = headA, *pB = headB;</span><br><span class="line">        while (pA != pB) &#123;</span><br><span class="line">            pA = pA == nullptr ? headB : pA-&gt;next;</span><br><span class="line">            pB = pB == nullptr ? headA : pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162. 寻找峰值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值</a></h1><p>峰值元素是指其值严格大于左右相邻值的元素。</p>
<p>给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</p>
<p>你可以假设 nums[-1] &#x3D; nums[n] &#x3D; -∞ 。</p>
<p>你必须实现时间复杂度为 O(log n) 的算法来解决此问题。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3,1]<br>输出：2<br>解释：3 是峰值元素，你的函数应该返回其索引 2。<br>示例 2：</p>
<p>输入：nums &#x3D; [1,2,1,3,5,6,4]<br>输出：1 或 5<br>解释：你的函数可以返回索引 1，其峰值元素为 2；<br>     或者返回索引 5， 其峰值元素为 6。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 1000<br>-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1<br>对于所有有效的 i 都有 nums[i] !&#x3D; nums[i + 1]</p>
<h2 id="Solution1-暴力-12"><a href="#Solution1-暴力-12" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><p><img src="https://files.mdnice.com/user/1489/423b6ac9-a7bd-4bd4-9840-3813d62617b5.png"></p>
<h2 id="Solution2-二分法"><a href="#Solution2-二分法" class="headerlink" title="Solution2 二分法"></a>Solution2 二分法</h2><p><img src="https://files.mdnice.com/user/1489/ec008965-da09-4c78-9ad1-83de91a31f4c.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int findPeakElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int left = 0, right = nums.size() - 1;</span><br><span class="line">    while (left &lt; right ) &#123;</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if (nums[mid] &lt; nums[mid + 1]) &#123;</span><br><span class="line">            left = mid+1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right = mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/majority-element/">169. 多数元素</a></h1><p><img src="https://files.mdnice.com/user/1489/edd0b34a-aae0-4667-8e36-645c0c1fbd04.png"></p>
<h2 id="Solution-1-哈希表"><a href="#Solution-1-哈希表" class="headerlink" title="Solution 1 哈希表"></a>Solution 1 哈希表</h2><p><img src="https://files.mdnice.com/user/1489/eb446da9-85b1-4898-b238-ee7548e16cc1.png"></p>
<p><img src="https://files.mdnice.com/user/1489/d6347f35-ca4c-425c-b8ca-6b7e2ae2ab07.png"></p>
<h2 id="Solution-2-排序"><a href="#Solution-2-排序" class="headerlink" title="Solution 2  排序"></a>Solution 2  排序</h2><p><img src="https://files.mdnice.com/user/1489/a8de2fa0-7abe-474d-a113-bca524a5c19d.png"></p>
<h2 id="Solution-3-Boyer-Moore-投票法"><a href="#Solution-3-Boyer-Moore-投票法" class="headerlink" title="Solution 3  Boyer-Moore 投票法"></a>Solution 3  Boyer-Moore 投票法</h2><p><img src="https://files.mdnice.com/user/1489/f451fbd9-f97d-4b05-9a25-92f9f405369b.png"></p>
<h1 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172. 阶乘后的零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/factorial-trailing-zeroes/">172. 阶乘后的零</a></h1><p>给定一个整数 n ，返回 n! 结果中尾随零的数量。</p>
<p>提示 n! &#x3D; n * (n - 1) * (n - 2) * … * 3 * 2 * 1</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 3<br>输出：0<br>解释：3! &#x3D; 6 ，不含尾随 0<br>示例 2：</p>
<p>输入：n &#x3D; 5<br>输出：1<br>解释：5! &#x3D; 120 ，有一个尾随 0<br>示例 3：</p>
<p>输入：n &#x3D; 0<br>输出：0
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; n &lt;&#x3D; 104
 </p>
<h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p>首先题目的意思是末尾有几个0<br> 比如6! &#x3D; 【1* 2* 3* 4* 5* 6】<br>    其中只有2<em>5末尾才有0，所以就可以抛去其他数据 专门看2 5 以及其倍数 毕竟 4 * 25末尾也是0<br>    比如10！ &#x3D; 【2</em>4<em>5</em>6<em>8</em>10】<br>    其中 4能拆成2<em>2  10能拆成2</em>5<br>    所以10！ &#x3D; 【2<em>（2</em>2）<em>5</em>（2<em>3）</em>（2<em>2</em>2）<em>（2</em>5）】<br>    一个2和一个5配对 就产生一个0 所以10！末尾2个0</p>
<pre><code>转头一想 2肯定比5多 所以只数5的个数就行了

假若N=31 31里能凑10的5为[5, 2*5, 3*5, 4*5, 25, 6*5] 
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trailingZeroes(int n) &#123;</span><br><span class="line">        int res=0;</span><br><span class="line">	    for(int i=n;i&gt;0;i/=5)&#123;</span><br><span class="line">		    res+=i/5;</span><br><span class="line">	    &#125;</span><br><span class="line">	    return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179. 最大数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-number/">179. 最大数</a></h1><p>给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p>
<p>注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [10,2]<br>输出：”210”<br>示例 2：</p>
<p>输入：nums &#x3D; [3,30,34,5,9]<br>输出：”9534330”
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p>
<h2 id="Solution0-暴力-3"><a href="#Solution0-暴力-3" class="headerlink" title="Solution0 暴力"></a>Solution0 暴力</h2><h2 id="Solution1-排序-1"><a href="#Solution1-排序-1" class="headerlink" title="Solution1 排序"></a>Solution1 排序</h2><p>自定义一种排序方式 比较 s1 + s2 和 s2 + s1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    static bool cmp(int a,int b)&#123;</span><br><span class="line">        string sa = to_string(a);</span><br><span class="line">        string sb = to_string(b);</span><br><span class="line">        return sa+sb&gt;sb+sa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string largestNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(),nums.end(),cmp);</span><br><span class="line">        string ret;</span><br><span class="line">        for(auto num:nums)&#123;</span><br><span class="line">            if(!(num==0&amp;&amp;ret[0]==&#x27;0&#x27;)) ret+=to_string(num);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><img src="https://files.mdnice.com/user/1489/724583f7-e9bf-46be-a2e9-235ba7e2d358.png"></p>
<h1 id="187-重复的DNA序列"><a href="#187-重复的DNA序列" class="headerlink" title="187. 重复的DNA序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></h1><p>DNA序列 由一系列核苷酸组成，缩写为 ‘A’, ‘C’, ‘G’ 和 ‘T’.。</p>
<p>例如，”ACGAATTCCG” 是一个 DNA序列 。<br>在研究 DNA 时，识别 DNA 中的重复序列非常有用。</p>
<p>给定一个表示 DNA序列 的字符串 s ，返回所有在 DNA 分子中出现不止一次的 长度为 10 的序列(子字符串)。你可以按 任意顺序 返回答案。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT”<br>输出：[“AAAAACCCCC”,”CCCCCAAAAA”]<br>示例 2：</p>
<p>输入：s &#x3D; “AAAAAAAAAAAAA”<br>输出：[“AAAAAAAAAA”]
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; s.length &lt;&#x3D; 105<br>s[i]&#x3D;&#x3D;’A’、’C’、’G’ or ‘T’</p>
<h2 id="Solution1-哈希表-3"><a href="#Solution1-哈希表-3" class="headerlink" title="Solution1 哈希表"></a>Solution1 哈希表</h2><p>我们可以用一个哈希表统计 ss 所有长度为 1010 的子串的出现次数，返回所有出现次数超过 1010 的子串。</p>
<p>代码实现时，可以一边遍历子串一边记录答案，为了不重复记录答案，我们只统计当前出现次数为 22 的子串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    const int L = 10;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        unordered_map&lt;string, int&gt; cnt;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        for (int i = 0; i &lt;= n - L; ++i) &#123;</span><br><span class="line">            string sub = s.substr(i, L);</span><br><span class="line">            if (++cnt[sub] == 2) &#123;</span><br><span class="line">                ans.push_back(sub);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution2-哈希表-滑动窗口-二进制"><a href="#Solution2-哈希表-滑动窗口-二进制" class="headerlink" title="Solution2 哈希表 滑动窗口 二进制"></a>Solution2 哈希表 滑动窗口 二进制</h2><p><img src="https://files.mdnice.com/user/1489/971e09e6-1b22-4c78-a3bc-956a6d4f1827.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    const int L = 10;</span><br><span class="line">    unordered_map&lt;char, int&gt; bin = &#123;&#123;&#x27;A&#x27;, 0&#125;, &#123;&#x27;C&#x27;, 1&#125;, &#123;&#x27;G&#x27;, 2&#125;, &#123;&#x27;T&#x27;, 3&#125;&#125;;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        if (n &lt;= L) &#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int i = 0; i &lt; L - 1; ++i) &#123;</span><br><span class="line">            x = (x &lt;&lt; 2) | bin[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;int, int&gt; cnt;</span><br><span class="line">        for (int i = 0; i &lt;= n - L; ++i) &#123;</span><br><span class="line">            x = ((x &lt;&lt; 2) | bin[s[i + L - 1]]) &amp; ((1 &lt;&lt; (L * 2)) - 1);</span><br><span class="line">            if (++cnt[x] == 2) &#123;</span><br><span class="line">                ans.push_back(s.substr(i, L));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>






<h1 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></h1><p>给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右轮转 1 步: [7,1,2,3,4,5,6]<br>向右轮转 2 步: [6,7,1,2,3,4,5]<br>向右轮转 3 步: [5,6,7,1,2,3,4]<br>示例 2:</p>
<p>输入：nums &#x3D; [-1,-100,3,99], k &#x3D; 2<br>输出：[3,99,-1,-100]<br>解释:<br>向右轮转 1 步: [99,-1,-100,3]<br>向右轮转 2 步: [3,99,-1,-100]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1<br>0 &lt;&#x3D; k &lt;&#x3D; 105</p>
<h2 id="Solution1-使用额外的数组"><a href="#Solution1-使用额外的数组" class="headerlink" title="Solution1 使用额外的数组"></a>Solution1 使用额外的数组</h2><p><img src="https://files.mdnice.com/user/1489/df37bbbe-bbbb-4e52-b5ae-5ba6fd84cd30.png"></p>
<h2 id="Solution2-数组翻转"><a href="#Solution2-数组翻转" class="headerlink" title="Solution2  数组翻转"></a>Solution2  数组翻转</h2><p><img src="https://files.mdnice.com/user/1489/cd09a3b7-fdbb-469a-8609-f64f592fda01.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reverse(vector&lt;int&gt;&amp; nums, int start, int end) &#123;</span><br><span class="line">        while (start &lt; end) &#123;</span><br><span class="line">            swap(nums[start], nums[end]);</span><br><span class="line">            start += 1;</span><br><span class="line">            end -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        k %= nums.size();</span><br><span class="line">        reverse(nums, 0, nums.size() - 1);</span><br><span class="line">        reverse(nums, 0, k - 1);</span><br><span class="line">        reverse(nums, k, nums.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。<br>示例 2：</p>
<p>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。<br>     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 400</p>
<h2 id="Solution1-动态规划-6"><a href="#Solution1-动态规划-6" class="headerlink" title="Solution1  动态规划"></a>Solution1  动态规划</h2><p>dp 方程 dp[i] &#x3D; max(dp[i-2]+nums[i], dp[i-1])</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.empty()) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        if (size == 1) &#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; dp = vector&lt;int&gt;(size, 0);</span><br><span class="line">        dp[0] = nums[0];</span><br><span class="line">        dp[1] = max(nums[0], nums[1]);</span><br><span class="line">        for (int i = 2; i &lt; size; i++) &#123;</span><br><span class="line">            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[size - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-动态规划-3"><a href="#Solution2-动态规划-3" class="headerlink" title="Solution2 动态规划"></a>Solution2 动态规划</h2><p>上述方法使用了数组存储结果。考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.empty()) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        if (size == 1) &#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        int first = nums[0], second = max(nums[0], nums[1]);</span><br><span class="line">        for (int i = 2; i &lt; size; i++) &#123;</span><br><span class="line">            int temp = second;</span><br><span class="line">            second = max(first + nums[i], second);</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 是数组长度。只需要对数组遍历一次。</p>
<p>空间复杂度：O(1)O(1)。使用滚动数组，可以只存储前两间房屋的最高总金额，而不需要存储整个数组的结果，因此空间复杂度是 O(1)O(1)。</p>
<h1 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h1><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: [1,2,3,null,5,null,4]<br>输出: [1,3,4]<br>示例 2:</p>
<p>输入: [1,null,3]<br>输出: [1,3]<br>示例 3:</p>
<p>输入: []<br>输出: []
 </p>
<p>提示:</p>
<p>二叉树的节点个数的范围是 [0,100]<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100 </p>
<h2 id="Solution1-层序遍历-1"><a href="#Solution1-层序遍历-1" class="headerlink" title="Solution1 层序遍历"></a>Solution1 层序遍历</h2><p>使用层序遍历，并只保留每层最后一个节点的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; rightmostValueAtDepth;</span><br><span class="line">        int max_depth = -1;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; nodeQueue;</span><br><span class="line">        queue&lt;int&gt; depthQueue;</span><br><span class="line">        nodeQueue.push(root);</span><br><span class="line">        depthQueue.push(0);</span><br><span class="line"></span><br><span class="line">        while (!nodeQueue.empty()) &#123;</span><br><span class="line">            TreeNode* node = nodeQueue.front();nodeQueue.pop();</span><br><span class="line">            int depth = depthQueue.front();depthQueue.pop();</span><br><span class="line"></span><br><span class="line">            if (node != NULL) &#123;</span><br><span class="line">            	// 维护二叉树的最大深度</span><br><span class="line">                max_depth = max(max_depth, depth);</span><br><span class="line"></span><br><span class="line">                // 由于每一层最后一个访问到的节点才是我们要的答案，因此不断更新对应深度的信息即可</span><br><span class="line">                rightmostValueAtDepth[depth] =  node -&gt; val;</span><br><span class="line"></span><br><span class="line">                nodeQueue.push(node -&gt; left);</span><br><span class="line">                nodeQueue.push(node -&gt; right);</span><br><span class="line">                depthQueue.push(depth + 1);</span><br><span class="line">                depthQueue.push(depth + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; rightView;</span><br><span class="line">        for (int depth = 0; depth &lt;= max_depth; ++depth) &#123;</span><br><span class="line">            rightView.push_back(rightmostValueAtDepth[depth]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return rightView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="https://files.mdnice.com/user/1489/fb683879-39db-4823-890b-e02d5deeb48c.png"></p>
<p>这里可以通过维护两个node queue来实现</p>
<h1 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h1><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：grid &#x3D; [<br>  [“1”,”1”,”1”,”1”,”0”],<br>  [“1”,”1”,”0”,”1”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”0”,”0”,”0”]<br>]<br>输出：1<br>示例 2：</p>
<p>输入：grid &#x3D; [<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”1”,”0”,”0”],<br>  [“0”,”0”,”0”,”1”,”1”]<br>]<br>输出：3
 </p>
<p>提示：</p>
<p>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 300<br>grid[i][j] 的值为 ‘0’ 或 ‘1’</p>
<h2 id="Solution1-DFS-2"><a href="#Solution1-DFS-2" class="headerlink" title="Solution1  DFS"></a>Solution1  DFS</h2><p>思路：遍历岛这个二维数组，如果当前数为1，则进入感染函数并将岛个数+1<br>感染函数：其实就是一个递归标注的过程，它会将所有相连的1都标注成2。为什么要标注？这样就避免了遍历过程中的重复计数的情况，一个岛所有的1都变成了2后，遍历的时候就不会重复遍历了。建议没想明白的同学画个图看看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numIslands(char[][] grid) &#123;</span><br><span class="line">        int islandNum = 0;</span><br><span class="line">        for(int i = 0; i &lt; grid.length; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; grid[0].length; j++)&#123;</span><br><span class="line">                if(grid[i][j] == &#x27;1&#x27;)&#123;</span><br><span class="line">                    infect(grid, i, j);</span><br><span class="line">                    islandNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return islandNum;</span><br><span class="line">    &#125;</span><br><span class="line">    //感染函数</span><br><span class="line">    public void infect(char[][] grid, int i, int j)&#123;</span><br><span class="line">        if(i &lt; 0 || i &gt;= grid.length ||</span><br><span class="line">           j &lt; 0 || j &gt;= grid[0].length || grid[i][j] != &#x27;1&#x27;)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = &#x27;2&#x27;;</span><br><span class="line">        infect(grid, i + 1, j);</span><br><span class="line">        infect(grid, i - 1, j);</span><br><span class="line">        infect(grid, i, j + 1);</span><br><span class="line">        infect(grid, i, j - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution2-BFS-1"><a href="#Solution2-BFS-1" class="headerlink" title="Solution2 BFS"></a>Solution2 BFS</h2><p>主循环和思路一类似，不同点是在于搜索某岛屿边界的方法不同。<br>bfs 方法：<br>借用一个队列 queue，判断队列首部节点 (i, j) 是否未越界且为 1：<br>若是则置零（删除岛屿节点），并将此节点上下左右节点 (i+1,j),(i-1,j),(i,j+1),(i,j-1) 加入队列；<br>若不是则跳过此节点；<br>循环 pop 队列首节点，直到整个队列为空，此时已经遍历完此岛屿。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numIslands(char[][] grid) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for(int i = 0; i &lt; grid.length; i++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; grid[0].length; j++) &#123;</span><br><span class="line">                if(grid[i][j] == &#x27;1&#x27;)&#123;</span><br><span class="line">                    bfs(grid, i, j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">    private void bfs(char[][] grid, int i, int j)&#123;</span><br><span class="line">        Queue&lt;int[]&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line">        list.add(new int[] &#123; i, j &#125;);</span><br><span class="line">        while(!list.isEmpty())&#123;</span><br><span class="line">            int[] cur = list.remove();</span><br><span class="line">            i = cur[0]; j = cur[1];</span><br><span class="line">            if(0 &lt;= i &amp;&amp; i &lt; grid.length &amp;&amp; 0 &lt;= j &amp;&amp; j &lt; grid[0].length &amp;&amp; grid[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                grid[i][j] = &#x27;0&#x27;;</span><br><span class="line">                list.add(new int[] &#123; i + 1, j &#125;);</span><br><span class="line">                list.add(new int[] &#123; i - 1, j &#125;);</span><br><span class="line">                list.add(new int[] &#123; i, j + 1 &#125;);</span><br><span class="line">                list.add(new int[] &#123; i, j - 1 &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></h1><p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」 定义为：</p>
<p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<br>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。<br>如果这个过程 结果为 1，那么这个数就是快乐数。<br>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 19<br>输出：true<br>解释：<br>12 + 92 &#x3D; 82<br>82 + 22 &#x3D; 68<br>62 + 82 &#x3D; 100<br>12 + 02 + 02 &#x3D; 1<br>示例 2：</p>
<p>输入：n &#x3D; 2<br>输出：false
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 231 - 1</p>
<h2 id="Solution1-快慢指针"><a href="#Solution1-快慢指针" class="headerlink" title="Solution1 快慢指针"></a>Solution1 快慢指针</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//参考英文网站热评第一。这题可以用快慢指针的思想去做，有点类似于检测是否为环形链表那道题</span><br><span class="line">//如果给定的数字最后会一直循环重复，那么快的指针（值）一定会追上慢的指针（值），也就是</span><br><span class="line">//两者一定会相等。如果没有循环重复，那么最后快慢指针也会相等，且都等于1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isHappy(int n) &#123;</span><br><span class="line">        int fast=n;</span><br><span class="line">        int slow=n;</span><br><span class="line">        do&#123;</span><br><span class="line">            slow=squareSum(slow);</span><br><span class="line">            fast=squareSum(fast);</span><br><span class="line">            fast=squareSum(fast);</span><br><span class="line">        &#125;while(slow!=fast);</span><br><span class="line">        if(fast==1)</span><br><span class="line">            return true;</span><br><span class="line">        else return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private int squareSum(int m)&#123;</span><br><span class="line">        int squaresum=0;</span><br><span class="line">        while(m!=0)&#123;</span><br><span class="line">           squaresum+=(m%10)*(m%10);</span><br><span class="line">            m/=10;</span><br><span class="line">        &#125;</span><br><span class="line">        return squaresum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution2-暴力"><a href="#Solution2-暴力" class="headerlink" title="Solution2 暴力"></a>Solution2 暴力</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isHappy(int n) &#123;</span><br><span class="line">        int ans=0;</span><br><span class="line">        for(int i = 0 ; i&lt; 100;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            while(n&gt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                ans += (n%10)*(n%10);</span><br><span class="line">                n = n /10;</span><br><span class="line">            &#125;</span><br><span class="line">            n = ans;</span><br><span class="line">            if(n==1)</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></h1><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。
 </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6<br>输出：[1,2,3,4,5]<br>示例 2：</p>
<p>输入：head &#x3D; [], val &#x3D; 1<br>输出：[]<br>示例 3：</p>
<p>输入：head &#x3D; [7,7,7,7], val &#x3D; 7<br>输出：[]
 </p>
<p>提示：</p>
<p>列表中的节点数目在范围 [0, 104] 内<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 50<br>0 &lt;&#x3D; val &lt;&#x3D; 50</p>
<h2 id="Solution1-迭代"><a href="#Solution1-迭代" class="headerlink" title="Solution1 迭代"></a>Solution1 迭代</h2><p><img src="https://files.mdnice.com/user/1489/b2e898e8-a1bf-4e57-88b2-00546145e9d0.png"></p>
<h2 id="Solution2-递归"><a href="#Solution2-递归" class="headerlink" title="Solution2 递归"></a>Solution2 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListNode *removeElements(ListNode *head, int val)</span><br><span class="line">&#123;</span><br><span class="line">    if (!head)</span><br><span class="line">        return head;</span><br><span class="line">    head-&gt;next = removeElements(head-&gt;next, val);</span><br><span class="line">    return head-&gt;val == val ? head-&gt;next : head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析<br>时间复杂度：O(n)O(n)，其中 nn 是链表的长度。需要遍历链表一次。<br>空间复杂度：O(1)O(1)。</p>
<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h1><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
 </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4,5]<br>输出：[5,4,3,2,1]<br>示例 2：</p>
<p>输入：head &#x3D; [1,2]<br>输出：[2,1]<br>示例 3：</p>
<p>输入：head &#x3D; []<br>输出：[]
 </p>
<p>提示：</p>
<p>链表中节点的数目范围是 [0, 5000]<br>-5000 &lt;&#x3D; Node.val &lt;&#x3D; 5000
 </p>
<h2 id="Solution1-迭代-1"><a href="#Solution1-迭代-1" class="headerlink" title="Solution1 迭代"></a>Solution1 迭代</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/迭代法</span><br><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">    ListNode pre = null;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    while(cur!=null) &#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-递归-1"><a href="#Solution2-递归-1" class="headerlink" title="Solution2 递归"></a>Solution2 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//尾递归</span><br><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">    return reverse(null,head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static ListNode reverse(ListNode pre,ListNode cur)&#123;</span><br><span class="line">    if(cur==null) return pre;</span><br><span class="line">    ListNode next = cur.next;</span><br><span class="line">    cur.next = pre;</span><br><span class="line">    return reverse(cur,next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h1><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: [3,2,1,5,6,4], k &#x3D; 2<br>输出: 5<br>示例 2:</p>
<p>输入: [3,2,3,1,2,4,5,5,6], k &#x3D; 4<br>输出: 4
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; k &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</p>
<h2 id="Solution1-堆排序"><a href="#Solution1-堆排序" class="headerlink" title="Solution1  堆排序"></a>Solution1  堆排序</h2><p><img src="https://files.mdnice.com/user/1489/bb70337e-337f-4525-9b82-628e0ababa73.png"></p>
<p>复杂度分析</p>
<p>时间复杂度：O(n \log n)O(nlogn)，建堆的时间代价是 O(n)O(n)，删除的总代价是 O(k \log n)O(klogn)，因为 k &lt; nk&lt;n，故渐进时间复杂为 O(n + k \log n) &#x3D; O(n \log n)O(n+klogn)&#x3D;O(nlogn)。<br>空间复杂度：O(\log n)O(logn)，即递归使用栈空间的空间代价。</p>
<p><img src="https://files.mdnice.com/user/1489/6b0ad4c7-d06d-477f-a7be-fc2e043a0db5.png"></p>
<h1 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/contains-duplicate/">217. 存在重复元素</a></h1><p>给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。
 </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3,1]<br>输出：true<br>示例 2：</p>
<p>输入：nums &#x3D; [1,2,3,4]<br>输出：false<br>示例 3：</p>
<p>输入：nums &#x3D; [1,1,1,3,3,4,3,2,4,2]<br>输出：true
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p>
<h2 id="Solution1-排序-2"><a href="#Solution1-排序-2" class="headerlink" title="Solution1  排序"></a>Solution1  排序</h2><p><img src="https://files.mdnice.com/user/1489/30ba428f-42b6-472b-8b8b-23aaef1c23b6.png"></p>
<h2 id="Solution2-3"><a href="#Solution2-3" class="headerlink" title="Solution2"></a>Solution2</h2><p><img src="https://files.mdnice.com/user/1489/f14525cf-e0bb-44a5-a385-54ae95316f9b.png"></p>
<h1 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximal-square/">221. 最大正方形</a></h1><p><img src="https://files.mdnice.com/user/1489/317b8a93-0319-40c0-9273-c7d6ea72516a.png"></p>
<h2 id="Solution0-暴力法"><a href="#Solution0-暴力法" class="headerlink" title="Solution0 暴力法"></a>Solution0 暴力法</h2><p><img src="https://files.mdnice.com/user/1489/19e5cf6f-0c41-4a7c-804d-9d81beac4123.png"></p>
<h2 id="Solution1-动态规划-7"><a href="#Solution1-动态规划-7" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p>class Solution {<br>    public int maximalSquare(char[][] matrix) {<br>        &#x2F;**<br>        dp[i][j]表示以第i行第j列为右下角所能构成的最大正方形边长, 则递推式为:<br>        dp[i][j] &#x3D; 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]);<br>        **&#x2F;<br>        int m &#x3D; matrix.length;<br>        if(m &lt; 1) return 0;<br>        int n &#x3D; matrix[0].length;<br>        int max &#x3D; 0;<br>        int[][] dp &#x3D; new int[m+1][n+1];</p>
<pre><code>    for(int i = 1; i &lt;= m; ++i) &#123;
        for(int j = 1; j &lt;= n; ++j) &#123;
            if(matrix[i-1][j-1] == &#39;1&#39;) &#123;
                dp[i][j] = 1 + Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1]));
                max = Math.max(max, dp[i][j]); 
            &#125;
        &#125;
    &#125;
    
    return max*max;
&#125;
</code></pre>
<p>}</p>
<h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h1><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p>
<p>实现 MyStack 类：</p>
<p>void push(int x) 将元素 x 压入栈顶。<br>int pop() 移除并返回栈顶元素。<br>int top() 返回栈顶元素。<br>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。
 </p>
<p>注意：</p>
<p>你只能使用队列的基本操作 —— 也就是 push to back、peek&#x2F;pop from front、size 和 is empty 这些操作。<br>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
 </p>
<p>示例：</p>
<p>输入：<br>[“MyStack”, “push”, “push”, “top”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>输出：<br>[null, null, null, 2, 2, false]</p>
<p>解释：<br>MyStack myStack &#x3D; new MyStack();<br>myStack.push(1);<br>myStack.push(2);<br>myStack.top(); &#x2F;&#x2F; 返回 2<br>myStack.pop(); &#x2F;&#x2F; 返回 2<br>myStack.empty(); &#x2F;&#x2F; 返回 False
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; x &lt;&#x3D; 9<br>最多调用100 次 push、pop、top 和 empty<br>每次调用 pop 和 top 都保证栈不为空</p>
<h2 id="Solution1-两个队列"><a href="#Solution1-两个队列" class="headerlink" title="Solution1  两个队列"></a>Solution1  两个队列</h2><p><img src="https://files.mdnice.com/user/1489/44e2b2c5-3a86-4e20-97d1-45502d4bfc29.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line">public:</span><br><span class="line">    queue&lt;int&gt; queue1;</span><br><span class="line">    queue&lt;int&gt; queue2;</span><br><span class="line"></span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    MyStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Push element x onto stack. */</span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        queue2.push(x);</span><br><span class="line">        while (!queue1.empty()) &#123;</span><br><span class="line">            queue2.push(queue1.front());</span><br><span class="line">            queue1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        swap(queue1, queue2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Removes the element on top of the stack and returns that element. */</span><br><span class="line">    int pop() &#123;</span><br><span class="line">        int r = queue1.front();</span><br><span class="line">        queue1.pop();</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Get the top element. */</span><br><span class="line">    int top() &#123;</span><br><span class="line">        int r = queue1.front();</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns whether the stack is empty. */</span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return queue1.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution2-单个队列"><a href="#Solution2-单个队列" class="headerlink" title="Solution2 单个队列"></a>Solution2 单个队列</h2><p><img src="https://files.mdnice.com/user/1489/aa634f7b-decf-4a6c-8e21-80efe413f3c1.png"></p>
<h1 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h1><p><img src="https://files.mdnice.com/user/1489/69e49a83-545c-483f-8a37-ec3b834d2e93.png"></p>
<h2 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1"></a>Solution1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">利用前序遍历</span><br><span class="line">class Solution &#123;</span><br><span class="line">        // 先序遍历--从顶向下交换</span><br><span class="line">        public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">            if (root == null) return null;</span><br><span class="line">            // 保存右子树</span><br><span class="line">            TreeNode rightTree = root.right;</span><br><span class="line">            // 交换左右子树的位置</span><br><span class="line">            root.right = invertTree(root.left);</span><br><span class="line">            root.left = invertTree(rightTree);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">利用中序遍历</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">            if (root == null) return null;</span><br><span class="line">            invertTree(root.left); // 递归找到左节点</span><br><span class="line">            TreeNode rightNode= root.right; // 保存右节点</span><br><span class="line">            root.right = root.left;</span><br><span class="line">            root.left = rightNode;</span><br><span class="line">            // 递归找到右节点 继续交换 : 因为此时左右节点已经交换了,所以此时的右节点为root.left</span><br><span class="line">            invertTree(root.left); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">利用后序遍历</span><br><span class="line"> class Solution &#123;</span><br><span class="line">        public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">            // 后序遍历-- 从下向上交换</span><br><span class="line">            if (root == null) return null;</span><br><span class="line">            TreeNode leftNode = invertTree(root.left);</span><br><span class="line">            TreeNode rightNode = invertTree(root.right);</span><br><span class="line">            root.right = leftNode;</span><br><span class="line">            root.left = rightNode;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">利用层次遍历</span><br><span class="line">   class Solution &#123;</span><br><span class="line">        public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">            // 层次遍历--直接左右交换即可</span><br><span class="line">            if (root == null) return null;</span><br><span class="line">            Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">            queue.offer(root);</span><br><span class="line">            while (!queue.isEmpty())&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                TreeNode rightTree = node.right;</span><br><span class="line">                node.right = node.left;</span><br><span class="line">                node.left = rightTree;</span><br><span class="line">                if (node.left != null)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (node.right != null)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="227-基本计算器-II"><a href="#227-基本计算器-II" class="headerlink" title="227. 基本计算器 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/basic-calculator-ii/">227. 基本计算器 II</a></h1><p>给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。</p>
<p>整数除法仅保留整数部分。</p>
<p>你可以假设给定的表达式总是有效的。所有中间结果将在 [-231, 231 - 1] 的范围内。</p>
<p>注意：不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “3+2*2”<br>输出：7<br>示例 2：</p>
<p>输入：s &#x3D; “ 3&#x2F;2 “<br>输出：1<br>示例 3：</p>
<p>输入：s &#x3D; “ 3+5 &#x2F; 2 “<br>输出：5
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 3 * 105<br>s 由整数和算符 (‘+’, ‘-‘, ‘*’, ‘&#x2F;‘) 组成，中间由一些空格隔开<br>s 表示一个 有效表达式<br>表达式中的所有整数都是非负整数，且在范围 [0, 231 - 1] 内<br>题目数据保证答案是一个 32-bit 整数</p>
<h2 id="Solution1-栈-2"><a href="#Solution1-栈-2" class="headerlink" title="Solution1 栈"></a>Solution1 栈</h2><p>方法一：栈<br>思路</p>
<p>由于乘除优先于加减计算，因此不妨考虑先进行所有乘除运算，并将这些乘除运算后的整数值放回原表达式的相应位置，则随后整个表达式的值，就等于一系列整数加减后的值。</p>
<p>基于此，我们可以用一个栈，保存这些（进行乘除运算后的）整数的值。对于加减号后的数字，将其直接压入栈中；对于乘除号后的数字，可以直接与栈顶元素计算，并替换栈顶元素为计算后的结果。</p>
<p>具体来说，遍历字符串 ss，并用变量 \textit{preSign}preSign 记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。每次遍历到数字末尾时，根据 \textit{preSign}preSign 来决定计算方式：</p>
<p>加号：将数字压入栈；<br>减号：将数字的相反数压入栈；<br>乘除号：计算数字与栈顶元素，并将栈顶元素替换为计算结果。<br>代码实现中，若读到一个运算符，或者遍历到字符串末尾，即认为是遍历到了数字末尾。处理完该数字后，更新 \textit{preSign}preSign 为当前遍历的字符。</p>
<p>遍历完字符串 ss 后，将栈中元素累加，即为该字符串表达式的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int calculate(string s) &#123;</span><br><span class="line">        vector&lt;int&gt; stk;</span><br><span class="line">        char preSign = &#x27;+&#x27;;</span><br><span class="line">        int num = 0;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (isdigit(s[i])) &#123;</span><br><span class="line">                num = num * 10 + int(s[i] - &#x27;0&#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!isdigit(s[i]) &amp;&amp; s[i] != &#x27; &#x27; || i == n - 1) &#123;</span><br><span class="line">                switch (preSign) &#123;</span><br><span class="line">                    case &#x27;+&#x27;:</span><br><span class="line">                        stk.push_back(num);</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;-&#x27;:</span><br><span class="line">                        stk.push_back(-num);</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;*&#x27;:</span><br><span class="line">                        stk.back() *= num;</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        stk.back() /= num;</span><br><span class="line">                &#125;</span><br><span class="line">                preSign = s[i];</span><br><span class="line">                num = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return accumulate(stk.begin(), stk.end(), 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 为字符串 ss 的长度。需要遍历字符串 ss 一次，计算表达式的值。</p>
<p>空间复杂度：O(n)O(n)，其中 nn 为字符串 ss 的长度。空间复杂度主要取决于栈的空间，栈的元素个数不超过 nn。</p>
<h1 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h1><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p>
<p>实现 MyQueue 类：</p>
<p>void push(int x) 将元素 x 推到队列的末尾<br>int pop() 从队列的开头移除并返回元素<br>int peek() 返回队列开头的元素<br>boolean empty() 如果队列为空，返回 true ；否则，返回 false<br>说明：</p>
<p>你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
 </p>
<p>示例 1：</p>
<p>输入：<br>[“MyQueue”, “push”, “push”, “peek”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>输出：<br>[null, null, null, 1, 1, false]</p>
<p>解释：<br>MyQueue myQueue &#x3D; new MyQueue();<br>myQueue.push(1); &#x2F;&#x2F; queue is: [1]<br>myQueue.push(2); &#x2F;&#x2F; queue is: [1, 2] (leftmost is front of the queue)<br>myQueue.peek(); &#x2F;&#x2F; return 1<br>myQueue.pop(); &#x2F;&#x2F; return 1, queue is [2]<br>myQueue.empty(); &#x2F;&#x2F; return false</p>
<h2 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1"></a>Solution1</h2><p><img src="https://files.mdnice.com/user/1489/3cd35f16-15b6-4698-8053-935ffdd85349.png"><br>思路</p>
<p>将一个栈当作输入栈，用于压入 \texttt{push}push 传入的数据；另一个栈当作输出栈，用于 \texttt{pop}pop 和 \texttt{peek}peek 操作。</p>
<p>每次 \texttt{pop}pop 或 \texttt{peek}peek 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class MyQueue &#123;</span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; inStack, outStack;</span><br><span class="line"></span><br><span class="line">    void in2out() &#123;</span><br><span class="line">        while (!inStack.empty()) &#123;</span><br><span class="line">            outStack.push(inStack.top());</span><br><span class="line">            inStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    MyQueue() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">        if (outStack.empty()) &#123;</span><br><span class="line">            in2out();</span><br><span class="line">        &#125;</span><br><span class="line">        int x = outStack.top();</span><br><span class="line">        outStack.pop();</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int peek() &#123;</span><br><span class="line">        if (outStack.empty()) &#123;</span><br><span class="line">            in2out();</span><br><span class="line">        &#125;</span><br><span class="line">        return outStack.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return inStack.empty() &amp;&amp; outStack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="https://files.mdnice.com/user/1489/7ee6b978-400a-44f6-8197-a9507c8e058b.png"></p>
<h1 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></h1><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,2,1]<br>输出：true<br>示例 2：</p>
<p>输入：head &#x3D; [1,2]<br>输出：false
 </p>
<p>提示：</p>
<p>链表中节点数目在范围[1, 105] 内<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 9
 </p>
<p>进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<h2 id="Solution0-将链表复制到数组"><a href="#Solution0-将链表复制到数组" class="headerlink" title="Solution0 将链表复制到数组"></a>Solution0 将链表复制到数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        vector&lt;int&gt; vals;</span><br><span class="line">        while (head != nullptr) &#123;</span><br><span class="line">            vals.emplace_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0, j = (int)vals.size() - 1; i &lt; j; ++i, --j) &#123;</span><br><span class="line">            if (vals[i] != vals[j]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="Solution1-中点开始比较"><a href="#Solution1-中点开始比较" class="headerlink" title="Solution1 中点开始比较"></a>Solution1 中点开始比较</h2><p><img src="https://files.mdnice.com/user/1489/86154c4e-b8da-4890-ab23-b2612d4c5777.png"></p>
<h1 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h1><p>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。</p>
<h2 id="Solution1-非递归"><a href="#Solution1-非递归" class="headerlink" title="Solution1  非递归"></a>Solution1  非递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int kthSmallest(TreeNode* root, int k) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        int num=0;</span><br><span class="line">        TreeNode *cur=root;</span><br><span class="line">        while(!s.empty() || cur)</span><br><span class="line">        &#123;</span><br><span class="line">            if(cur)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur=cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                cur=s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                num++;</span><br><span class="line">                if(num==k)</span><br><span class="line">                    return cur-&gt;val;</span><br><span class="line">                cur=cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution2-记录子节点数目"><a href="#Solution2-记录子节点数目" class="headerlink" title="Solution2 记录子节点数目"></a>Solution2 记录子节点数目</h2><p><img src="https://files.mdnice.com/user/1489/e65a5f5c-4e4e-4bb7-857a-f5fd4309020f.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class MyBst &#123;</span><br><span class="line">public:</span><br><span class="line">    MyBst(TreeNode *root) &#123;</span><br><span class="line">        this-&gt;root = root;</span><br><span class="line">        countNodeNum(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回二叉搜索树中第k小的元素</span><br><span class="line">    int kthSmallest(int k) &#123;</span><br><span class="line">        TreeNode *node = root;</span><br><span class="line">        while (node != nullptr) &#123;</span><br><span class="line">            int left = getNodeNum(node-&gt;left);</span><br><span class="line">            if (left &lt; k - 1) &#123;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">                k -= left + 1;</span><br><span class="line">            &#125; else if (left == k - 1) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return node-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    TreeNode *root;</span><br><span class="line">    unordered_map&lt;TreeNode *, int&gt; nodeNum;</span><br><span class="line"></span><br><span class="line">    // 统计以node为根结点的子树的结点数</span><br><span class="line">    int countNodeNum(TreeNode * node) &#123;</span><br><span class="line">        if (node == nullptr) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        nodeNum[node] = 1 + countNodeNum(node-&gt;left) + countNodeNum(node-&gt;right);</span><br><span class="line">        return nodeNum[node];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取以node为根结点的子树的结点数</span><br><span class="line">    int getNodeNum(TreeNode * node) &#123;</span><br><span class="line">        if (node != nullptr &amp;&amp; nodeNum.count(node)) &#123;</span><br><span class="line">            return nodeNum[node];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int kthSmallest(TreeNode* root, int k) &#123;</span><br><span class="line">        MyBst bst(root);</span><br><span class="line">        return bst.kthSmallest(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h1><p><img src="https://files.mdnice.com/user/1489/183fb47d-cb82-4909-bfae-8f78c632e7ea.png"></p>
<h2 id="Solution1-非递归-1"><a href="#Solution1-非递归-1" class="headerlink" title="Solution1  非递归"></a>Solution1  非递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">      //如果根节点和p,q的差相乘是正数，说明这两个差值要么都是正数要么都是负数，也就是说</span><br><span class="line">      //他们肯定都位于根节点的同一侧，就继续往下找</span><br><span class="line">      while ((root.val - p.val) * (root.val - q.val) &gt; 0)</span><br><span class="line">          root = p.val &lt; root.val ? root.left : root.right;</span><br><span class="line">      //如果相乘的结果是负数，说明p和q位于根节点的两侧，如果等于0，说明至少有一个就是根节点</span><br><span class="line">      return root;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h2 id="Solution2-递归-2"><a href="#Solution2-递归-2" class="headerlink" title="Solution2 递归"></a>Solution2 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">    //如果小于等于0，说明p和q位于root的两侧，直接返回即可</span><br><span class="line">    if ((root.val - p.val) * (root.val - q.val) &lt;= 0)</span><br><span class="line">        return root;</span><br><span class="line">    //否则，p和q位于root的同一侧，就继续往下找</span><br><span class="line">    return lowestCommonAncestor(p.val &lt; root.val ? root.left : root.right, p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。<br>示例 2：</p>
<p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4<br>输出：5<br>解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。<br>示例 3：</p>
<p>输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2<br>输出：1
 </p>
<p>提示：</p>
<p>树中节点数目在范围 [2, 105] 内。<br>-109 &lt;&#x3D; Node.val &lt;&#x3D; 109<br>所有 Node.val 互不相同 。<br>p !&#x3D; q<br>p 和 q 均存在于给定的二叉树中。</p>
<h2 id="Solution1-递归-8"><a href="#Solution1-递归-8" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if (root == null) return null;</span><br><span class="line">        // 如果p,q为根节点，则公共祖先为根节点</span><br><span class="line">        if (root.val == p.val || root.val == q.val) return root;</span><br><span class="line">        // 如果p,q在左子树，则公共祖先在左子树查找</span><br><span class="line">        if (find(root.left, p) &amp;&amp; find(root.left, q)) &#123;</span><br><span class="line">            return lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果p,q在右子树，则公共祖先在右子树查找</span><br><span class="line">        if (find(root.right, p) &amp;&amp; find(root.right, q)) &#123;</span><br><span class="line">            return lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果p,q分属两侧，则公共祖先为根节点</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private boolean find(TreeNode root, TreeNode c) &#123;</span><br><span class="line">        if (root == null) return false;</span><br><span class="line">        if (root.val == c.val) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return find(root.left, c) || find(root.right, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237. 删除链表中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-linked-list/">237. 删除链表中的节点</a></h1><p>有一个单链表的 head，我们想删除它其中的一个节点 node。</p>
<p>给你一个需要删除的节点 node 。你将 无法访问 第一个节点  head。</p>
<p>链表的所有值都是 唯一的，并且保证给定的节点 node 不是链表中的最后一个节点。</p>
<p>删除给定的节点。注意，删除节点并不是指从内存中删除它。这里的意思是：</p>
<p>给定节点的值不应该存在于链表中。<br>链表中的节点数应该减少 1。<br>node 前面的所有值顺序相同。<br>node 后面的所有值顺序相同。<br>自定义测试：</p>
<p>对于输入，你应该提供整个链表 head 和要给出的节点 node。node 不应该是链表的最后一个节点，而应该是链表中的一个实际节点。<br>我们将构建链表，并将节点传递给你的函数。<br>输出将是调用你函数后的整个链表。
 </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [4,5,1,9], node &#x3D; 5<br>输出：[4,1,9]<br>解释：指定链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9<br>示例 2：</p>
<p>输入：head &#x3D; [4,5,1,9], node &#x3D; 1<br>输出：[4,5,9]<br>解释：指定链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9
 </p>
<p>提示：</p>
<p>链表中节点的数目范围是 [2, 1000]<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000<br>链表中每个节点的值都是 唯一 的<br>需要删除的节点 node 是 链表中的节点 ，且 不是末尾节点</p>
<h2 id="Solution1-3"><a href="#Solution1-3" class="headerlink" title="Solution1"></a>Solution1</h2><p><img src="https://files.mdnice.com/user/1489/f6a63c36-aafb-4e9c-a5c7-3eac3a044410.png"></p>
<h1 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h1><p>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。</p>
<p>题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。</p>
<p>请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: nums &#x3D; [1,2,3,4]<br>输出: [24,12,8,6]<br>示例 2:</p>
<p>输入: nums &#x3D; [-1,1,0,-3,3]<br>输出: [0,0,9,0,0]
 </p>
<p>提示：</p>
<p>2 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-30 &lt;&#x3D; nums[i] &lt;&#x3D; 30<br>保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内</p>
<h2 id="Solution1-累乘列表"><a href="#Solution1-累乘列表" class="headerlink" title="Solution1 累乘列表"></a>Solution1 累乘列表</h2><p><img src="https://files.mdnice.com/user/1489/4484458a-b006-4fe8-a7a8-ea586342ca22.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int length = nums.size();</span><br><span class="line"></span><br><span class="line">        // L 和 R 分别表示左右两侧的乘积列表</span><br><span class="line">        vector&lt;int&gt; L(length, 0), R(length, 0);</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; answer(length);</span><br><span class="line"></span><br><span class="line">        // L[i] 为索引 i 左侧所有元素的乘积</span><br><span class="line">        // 对于索引为 &#x27;0&#x27; 的元素，因为左侧没有元素，所以 L[0] = 1</span><br><span class="line">        L[0] = 1;</span><br><span class="line">        for (int i = 1; i &lt; length; i++) &#123;</span><br><span class="line">            L[i] = nums[i - 1] * L[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // R[i] 为索引 i 右侧所有元素的乘积</span><br><span class="line">        // 对于索引为 &#x27;length-1&#x27; 的元素，因为右侧没有元素，所以 R[length-1] = 1</span><br><span class="line">        R[length - 1] = 1;</span><br><span class="line">        for (int i = length - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">            R[i] = nums[i + 1] * R[i + 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积</span><br><span class="line">        for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            answer[i] = L[i] * R[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-空间复杂度为O-1-的方法"><a href="#Solution2-空间复杂度为O-1-的方法" class="headerlink" title="Solution2 空间复杂度为O(1)的方法"></a>Solution2 空间复杂度为O(1)的方法</h2><p><img src="https://files.mdnice.com/user/1489/448bc91c-0af2-4a4b-af89-c01fa606a5b7.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int length = nums.size();</span><br><span class="line">        vector&lt;int&gt; answer(length);</span><br><span class="line"></span><br><span class="line">        // answer[i] 表示索引 i 左侧所有元素的乘积</span><br><span class="line">        // 因为索引为 &#x27;0&#x27; 的元素左侧没有元素， 所以 answer[0] = 1</span><br><span class="line">        answer[0] = 1;</span><br><span class="line">        for (int i = 1; i &lt; length; i++) &#123;</span><br><span class="line">            answer[i] = nums[i - 1] * answer[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // R 为右侧所有元素的乘积</span><br><span class="line">        // 刚开始右边没有元素，所以 R = 1</span><br><span class="line">        int R = 1;</span><br><span class="line">        for (int i = length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            // 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span><br><span class="line">            answer[i] = answer[i] * R;</span><br><span class="line">            // R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span><br><span class="line">            R *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h1><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p>
<p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。
 </p>
<p>示例 1：</p>
<p>输入：matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 5<br>输出：true<br>示例 2：</p>
<p>输入：matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 20<br>输出：false<br> <br><img src="https://files.mdnice.com/user/1489/00e1d4fd-e285-4863-8b0b-3060766bb525.png"></p>
<p>提示：</p>
<p>m &#x3D;&#x3D; matrix.length<br>n &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; n, m &lt;&#x3D; 300<br>-109 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 109<br>每行的所有元素从左到右升序排列<br>每列的所有元素从上到下升序排列<br>-109 &lt;&#x3D; target &lt;&#x3D; 109</p>
<h2 id="Solution0-暴力-4"><a href="#Solution0-暴力-4" class="headerlink" title="Solution0 暴力"></a>Solution0 暴力</h2><h2 id="Solution1-从右上角看是一颗二叉搜索树"><a href="#Solution1-从右上角看是一颗二叉搜索树" class="headerlink" title="Solution1 从右上角看是一颗二叉搜索树"></a>Solution1 从右上角看是一颗二叉搜索树</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;</span><br><span class="line">        if(matrix.size() == 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int i = 0;</span><br><span class="line">        int j = matrix[0].size()-1;</span><br><span class="line">        while(i &lt; matrix.size() &amp;&amp; j &gt;= 0) &#123;</span><br><span class="line">            if(matrix[i][j] == target) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            if(matrix[i][j] &lt; target) &#123;</span><br><span class="line">                ++ i;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                -- j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a></h1><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: s &#x3D; “anagram”, t &#x3D; “nagaram”<br>输出: true<br>示例 2:</p>
<p>输入: s &#x3D; “rat”, t &#x3D; “car”<br>输出: false
 </p>
<p>提示:</p>
<p>1 &lt;&#x3D; s.length, t.length &lt;&#x3D; 5 * 104<br>s 和 t 仅包含小写字母</p>
<p>C++ 三种方法：</p>
<h2 id="Solution1-1-直接用sort函数"><a href="#Solution1-1-直接用sort函数" class="headerlink" title="Solution1  1.直接用sort函数"></a>Solution1  1.直接用sort函数</h2><p>class Solution {<br>public:<br>    bool isAnagram(string s, string t) {<br>        sort(s.begin(),s.end());<br>        sort(t.begin(),t.end());<br>        if(s&#x3D;&#x3D;t)<br>            return true;<br>        else<br>            return false;<br>    }<br>};</p>
<h2 id="Solution2-2-map计数"><a href="#Solution2-2-map计数" class="headerlink" title="Solution2  2.map计数"></a>Solution2  2.map计数</h2><p>class Solution {<br>public:<br>    bool isAnagram(string s, string t) {<br>        unordered_map&lt;char,int&gt; map;<br>        if (s.size() !&#x3D; t.size())<br>            return false;<br>        for(int i&#x3D;0;i&lt;s.size();i++){<br>            ++map[s[i]];<br>            –map[t[i]];<br>        }<br>        for(unordered_map&lt;char,int&gt;::iterator it&#x3D;map.begin();it!&#x3D;map.end();it++){<br>            if(it-&gt;second!&#x3D;0)<br>                return false;<br>        }<br>        return true;</p>
<pre><code>&#125;
</code></pre>
<p>};</p>
<h2 id="Solution3-3-效率最高"><a href="#Solution3-3-效率最高" class="headerlink" title="Solution3  3.效率最高"></a>Solution3  3.效率最高</h2><p>class Solution {<br>public:<br>    bool isAnagram(string s, string t) {<br>        int num[26]&#x3D;{0};<br>        if(s.length()!&#x3D;t.length())<br>            return false;<br>        for(int i&#x3D;0;s[i]!&#x3D;’\0’;i++){<br>            num[s[i]-‘a’]++;<br>            num[t[i]-‘a’]–;</p>
<pre><code>    &#125;
    for(int i=0;i&lt;26;i++)
        if(num[i]!=0)
            return false;
    return true;
&#125;
</code></pre>
<p>};</p>
<h1 id="258-各位相加"><a href="#258-各位相加" class="headerlink" title="258. 各位相加"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-digits/">258. 各位相加</a></h1><p>给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: num &#x3D; 38<br>输出: 2<br>解释: 各位相加的过程为：<br>38 –&gt; 3 + 8 –&gt; 11<br>11 –&gt; 1 + 1 –&gt; 2<br>由于 2 是一位数，所以返回 2。<br>示例 1:</p>
<p>输入: num &#x3D; 0<br>输出: 0
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; num &lt;&#x3D; 231 - 1
 </p>
<p>进阶：你可以不使用循环或者递归，在 O(1) 时间复杂度内解决这个问题吗？</p>
<h2 id="Solution1-找规律"><a href="#Solution1-找规律" class="headerlink" title="Solution1 : 找规律"></a>Solution1 : 找规律</h2><p>除了传统的单纯循环，还可以找规律。假如一个三位数’abc’，其值大小为s1 &#x3D; 100 * a + 10 * b + 1 * c，经过一次各位相加后，变为s2 &#x3D; a + b + c，减小的差值为(s1 -s2) &#x3D; 99 * a + 9 * b，差值可以被9整除，每一个循环都这样，缩小了9的倍数。当num小于9，即只有一位时，直接返回num，大于9时，如果能被9整除，则返回9（因为不可能返回0也不可能返回两位数及以上的值），如果不能被整除，就返回被9除的余数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addDigits(self, num: int) -&gt; int:</span><br><span class="line">        if num &gt; 9:</span><br><span class="line">            num = num % 9</span><br><span class="line">            if num == 0:</span><br><span class="line">                return 9</span><br><span class="line">        return num</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-循环"><a href="#Solution2-循环" class="headerlink" title="Solution2 :循环"></a>Solution2 :循环</h2><p><img src="https://files.mdnice.com/user/1489/f5955143-7685-4b34-b5dd-9b24fa5290ce.png"></p>
<h1 id="268-丢失的数字"><a href="#268-丢失的数字" class="headerlink" title="268. 丢失的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/missing-number/">268. 丢失的数字</a></h1><p>给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [3,0,1]<br>输出：2<br>解释：n &#x3D; 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。<br>示例 2：</p>
<p>输入：nums &#x3D; [0,1]<br>输出：2<br>解释：n &#x3D; 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。<br>示例 3：</p>
<p>输入：nums &#x3D; [9,6,4,2,3,5,7,0,1]<br>输出：8<br>解释：n &#x3D; 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。<br>示例 4：</p>
<p>输入：nums &#x3D; [0]<br>输出：1<br>解释：n &#x3D; 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。
 </p>
<p>提示：</p>
<p>n &#x3D;&#x3D; nums.length<br>1 &lt;&#x3D; n &lt;&#x3D; 104<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; n<br>nums 中的所有数字都 独一无二</p>
<h2 id="Solution1-排序-3"><a href="#Solution1-排序-3" class="headerlink" title="Solution1 排序"></a>Solution1 排序</h2><p><img src="https://files.mdnice.com/user/1489/76ff413d-adba-4dd6-a6f7-14af4914335c.png"></p>
<h2 id="Solution2-求和"><a href="#Solution2-求和" class="headerlink" title="Solution2 求和"></a>Solution2 求和</h2><p><img src="https://files.mdnice.com/user/1489/4c7ba032-9897-4231-bb99-98f8ecdcc362.png"></p>
<h2 id="Solution3-位运算"><a href="#Solution3-位运算" class="headerlink" title="Solution3 位运算"></a>Solution3 位运算</h2><p><img src="https://files.mdnice.com/user/1489/c5e2d5e5-ba77-4e29-9aa1-9e78c0599f01.png"></p>
<h2 id="Solution4-哈希"><a href="#Solution4-哈希" class="headerlink" title="Solution4 哈希"></a>Solution4 哈希</h2><p><img src="https://files.mdnice.com/user/1489/d8bbcdd3-9968-4deb-b8db-b0c7f87e0856.png"></p>
<h1 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a></h1><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p>
<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 12<br>输出：3<br>解释：12 &#x3D; 4 + 4 + 4<br>示例 2：</p>
<p>输入：n &#x3D; 13<br>输出：2<br>解释：13 &#x3D; 4 + 9</p>
<h2 id="Solution1-动态规划-8"><a href="#Solution1-动态规划-8" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/8ef92a66-0286-4473-88b6-76fd2e9613ed.png"></p>
<h2 id="Solution2-数学"><a href="#Solution2-数学" class="headerlink" title="Solution2  数学"></a>Solution2  数学</h2><p><img src="https://files.mdnice.com/user/1489/3c123721-1909-4e2c-91e3-c2d357b57458.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 判断是否为完全平方数</span><br><span class="line">    bool isPerfectSquare(int x) &#123;</span><br><span class="line">        int y = sqrt(x);</span><br><span class="line">        return y * y == x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断是否能表示为 4^k*(8m+7)</span><br><span class="line">    bool checkAnswer4(int x) &#123;</span><br><span class="line">        while (x % 4 == 0) &#123;</span><br><span class="line">            x /= 4;</span><br><span class="line">        &#125;</span><br><span class="line">        return x % 8 == 7;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int numSquares(int n) &#123;</span><br><span class="line">        if (isPerfectSquare(n)) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (checkAnswer4(n)) &#123;</span><br><span class="line">            return 4;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i * i &lt;= n; i++) &#123;</span><br><span class="line">            int j = n - i * i;</span><br><span class="line">            if (isPerfectSquare(j)) &#123;</span><br><span class="line">                return 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h1><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: nums &#x3D; [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>示例 2:</p>
<p>输入: nums &#x3D; [0]<br>输出: [0]
 </p>
<p>提示:</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1</p>
<h2 id="Solution1-4"><a href="#Solution1-4" class="headerlink" title="Solution1"></a>Solution1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void moveZeroes(int* nums, int numsSize) &#123;</span><br><span class="line">    int i = 0,j = 0;</span><br><span class="line">    for(i = 0 ; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(nums[i] != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[j++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(j &lt; numsSize)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[j++] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-duplicate-number/">287. 寻找重复数</a></h1><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</p>
<p>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</p>
<p>你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,3,4,2,2]<br>输出：2<br>示例 2：</p>
<p>输入：nums &#x3D; [3,1,3,4,2]<br>输出：3
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 105<br>nums.length &#x3D;&#x3D; n + 1<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; n<br>nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次
 </p>
<p>进阶：</p>
<p>如何证明 nums 中至少存在一个重复的数字?<br>你可以设计一个线性级时间复杂度 O(n) 的解决方案吗？</p>
<h2 id="Solution1-二分法"><a href="#Solution1-二分法" class="headerlink" title="Solution1 二分法"></a>Solution1 二分法</h2><p><img src="https://files.mdnice.com/user/1489/0c2f4579-0b43-40cb-9b3d-8acd25411140.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int l = 1, r = n - 1, ans = -1;</span><br><span class="line">        while (l &lt;= r) &#123;</span><br><span class="line">            int mid = (l + r) &gt;&gt; 1;</span><br><span class="line">            int cnt = 0;</span><br><span class="line">            for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">                cnt += nums[i] &lt;= mid;</span><br><span class="line">            &#125;</span><br><span class="line">            if (cnt &lt;= mid) &#123;</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                r = mid - 1;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Solution2-二进制-1"><a href="#Solution2-二进制-1" class="headerlink" title="Solution2 二进制"></a>Solution2 二进制</h2><p><img src="https://files.mdnice.com/user/1489/6a5118f3-ceff-4fd5-bed5-37e3eb1d1d63.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size(), ans = 0;</span><br><span class="line">        // 确定二进制下最高位是多少</span><br><span class="line">        int bit_max = 31;</span><br><span class="line">        while (!((n - 1) &gt;&gt; bit_max)) &#123;</span><br><span class="line">            bit_max -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int bit = 0; bit &lt;= bit_max; ++bit) &#123;</span><br><span class="line">            int x = 0, y = 0;</span><br><span class="line">            for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">                if (nums[i] &amp; (1 &lt;&lt; bit)) &#123;</span><br><span class="line">                    x += 1;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i &gt;= 1 &amp;&amp; (i &amp; (1 &lt;&lt; bit))) &#123;</span><br><span class="line">                    y += 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (x &gt; y) &#123;</span><br><span class="line">                ans |= 1 &lt;&lt; bit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution3-快慢指针-1"><a href="#Solution3-快慢指针-1" class="headerlink" title="Solution3 快慢指针"></a>Solution3 快慢指针</h2><p><img src="https://files.mdnice.com/user/1489/403a3990-3546-4736-98f7-813c0e0093b9.png"></p>
<p><img src="https://files.mdnice.com/user/1489/684b77e1-27e3-43d2-9fd1-52958d131620.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int slow = 0, fast = 0;</span><br><span class="line">        do &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125; while (slow != fast);</span><br><span class="line">        slow = 0;</span><br><span class="line">        while (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="292-Nim-游戏"><a href="#292-Nim-游戏" class="headerlink" title="292. Nim 游戏"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/nim-game/">292. Nim 游戏</a></h1><p><img src="https://files.mdnice.com/user/1489/8faa0b82-6c1d-4433-abc3-8bb1ef5df8b6.png"></p>
<h2 id="Solution1-数学推理"><a href="#Solution1-数学推理" class="headerlink" title="Solution1 数学推理"></a>Solution1 数学推理</h2><p><img src="https://files.mdnice.com/user/1489/8c0e907f-f383-48da-98e6-ed531d6bd93a.png"></p>
<h1 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></h1><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>
<p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p>
<p> <br>示例 1：</p>
<p>输入：nums &#x3D; [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。<br>示例 2：</p>
<p>输入：nums &#x3D; [0,1,0,3,2,3]<br>输出：4<br>示例 3：</p>
<p>输入：nums &#x3D; [7,7,7,7,7,7,7]<br>输出：1
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 2500<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104
 </p>
<p>进阶：</p>
<p>你能将算法的时间复杂度降低到 O(n log(n)) 吗?</p>
<h2 id="Solution1-动态规划-9"><a href="#Solution1-动态规划-9" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/2f69c7c1-c466-4ba5-aeb7-ee8d57b4bc1c.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = (int)nums.size();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; dp(n, 0);</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = 1;</span><br><span class="line">            for (int j = 0; j &lt; i; ++j) &#123;</span><br><span class="line">                if (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return *max_element(dp.begin(), dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="https://files.mdnice.com/user/1489/1082c59b-c9b3-44b1-a291-78fb192b9ea4.png"></p>
<h2 id="Solution2-贪心"><a href="#Solution2-贪心" class="headerlink" title="Solution2  贪心"></a>Solution2  贪心</h2><p><img src="https://files.mdnice.com/user/1489/ce693fb0-6d34-4939-93b2-58af527f3ab4.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len = 1, n = (int)nums.size();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; d(n + 1, 0);</span><br><span class="line">        d[len] = nums[0];</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            if (nums[i] &gt; d[len]) &#123;</span><br><span class="line">                d[++len] = nums[i];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int l = 1, r = len, pos = 0; // 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0</span><br><span class="line">                while (l &lt;= r) &#123;</span><br><span class="line">                    int mid = (l + r) &gt;&gt; 1;</span><br><span class="line">                    if (d[mid] &lt; nums[i]) &#123;</span><br><span class="line">                        pos = mid;</span><br><span class="line">                        l = mid + 1;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        r = mid - 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d[pos + 1] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="313-超级丑数"><a href="#313-超级丑数" class="headerlink" title="313. 超级丑数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/super-ugly-number/">313. 超级丑数</a></h1><p>超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。</p>
<p>给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。</p>
<p>题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 12, primes &#x3D; [2,7,13,19]<br>输出：32<br>解释：给定长度为 4 的质数数组 primes &#x3D; [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。<br>示例 2：</p>
<p>输入：n &#x3D; 1, primes &#x3D; [2,3,5]<br>输出：1<br>解释：1 不含质因数，因此它的所有质因数都在质数数组 primes &#x3D; [2,3,5] 中。<br> <br>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 105<br>1 &lt;&#x3D; primes.length &lt;&#x3D; 100<br>2 &lt;&#x3D; primes[i] &lt;&#x3D; 1000<br>题目数据 保证 primes[i] 是一个质数<br>primes 中的所有值都 互不相同 ，且按 递增顺序 排列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Solution1-最小堆"><a href="#Solution1-最小堆" class="headerlink" title="Solution1 最小堆"></a>Solution1 最小堆</h2><p><img src="https://files.mdnice.com/user/1489/836dc250-a4b3-4acd-80a8-5202dbd8266b.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int nthSuperUglyNumber(int n, int[] primes) &#123;</span><br><span class="line">      PriorityQueue&lt;Long&gt;queue=new PriorityQueue&lt;&gt;();</span><br><span class="line">        long res=1;</span><br><span class="line">        for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">            for(int prime:primes)&#123;</span><br><span class="line">                queue.add(prime*res);</span><br><span class="line">            &#125;</span><br><span class="line">            res=queue.poll();</span><br><span class="line">            while(!queue.isEmpty()&amp;&amp;res==queue.peek()) queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        return (int)res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-动态规划-4"><a href="#Solution2-动态规划-4" class="headerlink" title="Solution2 动态规划"></a>Solution2 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/144ef974-6b43-473c-9b4e-76efb177144a.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int nthSuperUglyNumber(int n, vector&lt;int&gt;&amp; primes) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n + 1);  //用来存储丑数序列</span><br><span class="line">        dp[1] = 1;          //第一个丑数是1</span><br><span class="line">        int m = primes.size();</span><br><span class="line">        vector&lt;int&gt; nums(m);     //记录新丑数序列</span><br><span class="line">        vector&lt;int&gt; pointers(m, 1); //记录质数该与哪一位丑数做乘积</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            int minn = INT_MAX;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                nums[j] = dp[pointers[j]] * primes[j]; //旧丑数 * 质数序列 = 新丑数序列</span><br><span class="line">                minn = min(minn, nums[j]);  //寻找所有新丑数中最小的丑数</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = minn;</span><br><span class="line">            for (int j = 0; j &lt; m; j++)</span><br><span class="line">                if (minn == nums[j])        //如果此位置已经诞生过最小丑数</span><br><span class="line">                    pointers[j]++;          //让此位置所取旧丑数向后推一位</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h1><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11<br>输出：3<br>解释：11 &#x3D; 5 + 5 + 1<br>示例 2：</p>
<p>输入：coins &#x3D; [2], amount &#x3D; 3<br>输出：-1<br>示例 3：</p>
<p>输入：coins &#x3D; [1], amount &#x3D; 0<br>输出：0
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; coins.length &lt;&#x3D; 12<br>1 &lt;&#x3D; coins[i] &lt;&#x3D; 231 - 1<br>0 &lt;&#x3D; amount &lt;&#x3D; 104</p>
<h2 id="Solution1-动态规划-10"><a href="#Solution1-动态规划-10" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/b2f8f7dd-d476-4624-bed2-09ed94cd6f74.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</span><br><span class="line">        int Max = amount + 1;</span><br><span class="line">        vector&lt;int&gt; dp(amount + 1, Max);</span><br><span class="line">        dp[0] = 0;</span><br><span class="line">        for (int i = 1; i &lt;= amount; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; (int)coins.size(); ++j) &#123;</span><br><span class="line">                if (coins[j] &lt;= i) &#123;</span><br><span class="line">                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[amount] &gt; amount ? -1 : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Solution2-贪心-回溯-剪枝"><a href="#Solution2-贪心-回溯-剪枝" class="headerlink" title="Solution2 贪心+回溯+剪枝"></a>Solution2 贪心+回溯+剪枝</h2><p><img src="https://files.mdnice.com/user/1489/bc43d48c-bd11-4ebe-816d-8df25edec96b.png"></p>
<p><img src="https://files.mdnice.com/user/1489/be81cb56-2d21-4267-81ff-c1fe308261cd.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void coinChange(vector&lt;int&gt;&amp; coins, int amount, int c_index, int count, int&amp; ans) &#123;</span><br><span class="line">    if (amount == 0) &#123;</span><br><span class="line">        ans = min(ans, count);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (c_index == coins.size()) return;</span><br><span class="line"></span><br><span class="line">    for (int k = amount / coins[c_index]; k &gt;= 0 &amp;&amp; k + count &lt; ans; k--) &#123;</span><br><span class="line">        coinChange(coins, amount - k * coins[c_index], c_index + 1, count + k, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</span><br><span class="line">    if (amount == 0) return 0;</span><br><span class="line">    sort(coins.rbegin(), coins.rend());</span><br><span class="line">    int ans = INT_MAX;</span><br><span class="line">    coinChange(coins, amount, 0, 0, ans);</span><br><span class="line">    return ans == INT_MAX ? -1 : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="326-3的幂"><a href="#326-3的幂" class="headerlink" title="326.3的幂"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/power-of-three/">326.3的幂</a></h1><p><img src="https://files.mdnice.com/user/1489/c13f7729-4dce-428f-8f31-b5f9317a5ce2.png"></p>
<h2 id="Solution1-试除法"><a href="#Solution1-试除法" class="headerlink" title="Solution1 试除法"></a>Solution1 试除法</h2><p><img src="https://files.mdnice.com/user/1489/bc9e3a37-edc5-498a-b026-882a06a64125.png"></p>
<h2 id="Solution2-约数法"><a href="#Solution2-约数法" class="headerlink" title="Solution2 约数法"></a>Solution2 约数法</h2><p><img src="https://files.mdnice.com/user/1489/654af93a-97e3-4f83-88fb-c27a32ac905a.png"></p>
<h1 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/odd-even-linked-list/">328. 奇偶链表</a></h1><p><img src="https://files.mdnice.com/user/1489/201501bf-a7cf-4604-9d0c-860c89a8eeb9.png"></p>
<h2 id="Solution1-双链法"><a href="#Solution1-双链法" class="headerlink" title="Solution1 双链法"></a>Solution1 双链法</h2><p>结点1作为奇数链的头 结点2作为偶数链的头<br>从第3个点开始遍历，依次轮流附在奇、偶链的后面<br>遍历完后，奇数链的尾连向偶链的头，偶链的尾为空， 返回奇数链的头</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* oddEvenList(ListNode* head) &#123;</span><br><span class="line">        if (head == nullptr) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* evenHead = head-&gt;next;</span><br><span class="line">        ListNode* odd = head;</span><br><span class="line">        ListNode* even = evenHead;</span><br><span class="line">        while (even != nullptr &amp;&amp; even-&gt;next != nullptr) &#123;</span><br><span class="line">            odd-&gt;next = even-&gt;next;</span><br><span class="line">            odd = odd-&gt;next;</span><br><span class="line">            even-&gt;next = odd-&gt;next;</span><br><span class="line">            even = even-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd-&gt;next = evenHead;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 是链表的节点数。需要遍历链表中的每个节点，并更新指针。</p>
<p>空间复杂度：O(1)O(1)。只需要维护有限的指针。</p>
<h1 id="334-递增的三元子序列"><a href="#334-递增的三元子序列" class="headerlink" title="334. 递增的三元子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/increasing-triplet-subsequence/">334. 递增的三元子序列</a></h1><p>给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。</p>
<p>如果存在这样的三元组下标 (i, j, k) 且满足 i &lt; j &lt; k ，使得 nums[i] &lt; nums[j] &lt; nums[k] ，返回 true ；否则，返回 false 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3,4,5]<br>输出：true<br>解释：任何 i &lt; j &lt; k 的三元组都满足题意<br>示例 2：</p>
<p>输入：nums &#x3D; [5,4,3,2,1]<br>输出：false<br>解释：不存在满足题意的三元组<br>示例 3：</p>
<p>输入：nums &#x3D; [2,1,5,0,4,6]<br>输出：true<br>解释：三元组 (3, 4, 5) 满足题意，因为 nums[3] &#x3D;&#x3D; 0 &lt; nums[4] &#x3D;&#x3D; 4 &lt; nums[5] &#x3D;&#x3D; 6
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 5 * 105<br>-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1
 </p>
<h2 id="Solution1-贪心"><a href="#Solution1-贪心" class="headerlink" title="Solution1  贪心"></a>Solution1  贪心</h2><p><img src="https://files.mdnice.com/user/1489/61447011-c76d-459e-be76-ed35d1d0edeb.png"></p>
<h2 id="Solution2-双向遍历"><a href="#Solution2-双向遍历" class="headerlink" title="Solution2 双向遍历"></a>Solution2 双向遍历</h2><p><img src="https://files.mdnice.com/user/1489/32ee1091-199d-4e97-be7e-8c82cd1a5660.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool increasingTriplet(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if (n &lt; 3) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; leftMin(n);</span><br><span class="line">        leftMin[0] = nums[0];</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            leftMin[i] = min(leftMin[i - 1], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; rightMax(n);</span><br><span class="line">        rightMax[n - 1] = nums[n - 1];</span><br><span class="line">        for (int i = n - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">            rightMax[i] = max(rightMax[i + 1], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; n - 1; i++) &#123;</span><br><span class="line">            if (nums[i] &gt; leftMin[i - 1] &amp;&amp; nums[i] &lt; rightMax[i + 1]) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>复杂度分析</p>
<p>时间复杂度：O(n)，其中 nn 是数组 \textit{nums}nums 的长度。需要遍历数组三次。</p>
<p>空间复杂度：O(n)，其中 nn 是数组 \textit{nums}nums 的长度。需要创建两个长度为 nn 的数组 \textit{leftMin}leftMin 和 \textit{rightMax}rightMax。</p>
<h1 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></h1><p><img src="https://files.mdnice.com/user/1489/863165d0-8403-42e8-abcb-4387abc6f8d3.png"></p>
<h2 id="Solution1-动态规划-11"><a href="#Solution1-动态规划-11" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/f05af832-f82d-4a9a-85c8-880b56b213a8.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map &lt;TreeNode*, int&gt; f, g;</span><br><span class="line"></span><br><span class="line">    void dfs(TreeNode* node) &#123;</span><br><span class="line">        if (!node) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node-&gt;left);</span><br><span class="line">        dfs(node-&gt;right);</span><br><span class="line">        f[node] = node-&gt;val + g[node-&gt;left] + g[node-&gt;right];</span><br><span class="line">        g[node] = max(f[node-&gt;left], g[node-&gt;left]) + max(f[node-&gt;right], g[node-&gt;right]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int rob(TreeNode* root) &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        return max(f[root], g[root]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数\"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/counting-bits/">338. 比特位计数</a>\</h1><p>给你一个整数 n ，对于 0 &lt;&#x3D; i &lt;&#x3D; n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 2<br>输出：[0,1,1]<br>解释：<br>0 –&gt; 0<br>1 –&gt; 1<br>2 –&gt; 10<br>示例 2：</p>
<p>输入：n &#x3D; 5<br>输出：[0,1,1,2,1,2]<br>解释：<br>0 –&gt; 0<br>1 –&gt; 1<br>2 –&gt; 10<br>3 –&gt; 11<br>4 –&gt; 100<br>5 –&gt; 101
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; n &lt;&#x3D; 105
 </p>
<p>进阶：</p>
<p>很容易就能实现时间复杂度为 O(n log n) 的解决方案，你可以在线性时间复杂度 O(n) 内用一趟扫描解决此问题吗？<br>你能不使用任何内置函数解决此问题吗？（如，C++ 中的 __builtin_popcount ）</p>
<h2 id="Solution1-5"><a href="#Solution1-5" class="headerlink" title="Solution1"></a>Solution1</h2><p>方法一：i &amp; (i - 1)可以去掉i最右边的一个1（如果有），因此 i &amp; (i - 1）是比 i 小的，而且i &amp; (i - 1)的1的个数已经在前面算过了，所以i的1的个数就是 i &amp; (i - 1)的1的个数加上1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">public int[] countBits(int num) &#123;</span><br><span class="line">    int[] res = new int[num + 1];</span><br><span class="line">    for(int i = 1;i&lt;= num;i++)&#123;  //注意要从1开始，0不满足</span><br><span class="line">        res[i] = res[i &amp; (i - 1)] + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Solution2-4"><a href="#Solution2-4" class="headerlink" title="Solution2"></a>Solution2</h2><p>方法二：i &gt;&gt; 1会把最低位去掉，因此i &gt;&gt; 1 也是比i小的，同样也是在前面的数组里算过。当 i 的最低位是0，则 i 中1的个数和i &gt;&gt; 1中1的个数相同；当i的最低位是1，i 中1的个数是 i &gt;&gt; 1中1的个数再加1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int[] countBits(int num) &#123;</span><br><span class="line">    int[] res = new int[num + 1];</span><br><span class="line">    for(int i = 0;i&lt;= num;i++)&#123;</span><br><span class="line">        res[i] = res[i &gt;&gt; 1] + (i &amp; 1);  //注意i&amp;1需要加括号</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3"></a>Solution3</h2><p>分奇数和偶数：</p>
<p>偶数的二进制1个数超级简单，因为偶数是相当于被某个更小的数乘2，乘2怎么来的？在二进制运算中，就是左移一位，也就是在低位多加1个0，那样就说明dp[i] &#x3D; dp[i &#x2F; 2]<br>奇数稍微难想到一点，奇数由不大于该数的偶数+1得到，偶数+1在二进制位上会发生什么？会在低位多加1个1，那样就说明dp[i] &#x3D; dp[i-1] + 1，当然也可以写成dp[i] &#x3D; dp[i &#x2F; 2] + 1<br>就这么简单！！！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; countBits(int num) &#123;</span><br><span class="line">        int i = 1;</span><br><span class="line">        vector&lt;int&gt; ans(num + 1);</span><br><span class="line">        for (int i = 0; i &lt;= num; i++) &#123;</span><br><span class="line">            if (i % 2 == 0) </span><br><span class="line">                ans[i] = ans[i / 2];</span><br><span class="line">            else </span><br><span class="line">                ans[i] = ans[i / 2] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h1><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s &#x3D; [“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]<br>示例 2：</p>
<p>输入：s &#x3D; [“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]
 </p>
<h2 id="Solution1-双指针交换"><a href="#Solution1-双指针交换" class="headerlink" title="Solution1 双指针交换"></a>Solution1 双指针交换</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reverseString(vector&lt;char&gt;&amp; s) &#123;</span><br><span class="line">        for (int i = 0, j = s.size() - 1; i &lt; s.size()/2; i++, j--) &#123;</span><br><span class="line">            swap(s[i],s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h1><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2<br>输出: [1,2]<br>示例 2:</p>
<p>输入: nums &#x3D; [1], k &#x3D; 1<br>输出: [1]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>k 的取值范围是 [1, 数组中不相同的元素的个数]<br>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的
 </p>
<p>进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。</p>
<h2 id="Solution1-排序法"><a href="#Solution1-排序法" class="headerlink" title="Solution1 排序法"></a>Solution1 排序法</h2><p><img src="https://files.mdnice.com/user/1489/9d0654e6-75ac-4ef1-9309-aa410463028e.png"></p>
<h2 id="Solution2-最小堆法"><a href="#Solution2-最小堆法" class="headerlink" title="Solution2 最小堆法"></a>Solution2 最小堆法</h2><p><img src="https://files.mdnice.com/user/1489/8c154642-a002-4b1e-a451-679ecaab6052.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        map&lt;int, int&gt; freq;</span><br><span class="line">        using pii = std::pair&lt;int, int&gt;;</span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;</span><br><span class="line">        </span><br><span class="line">        for (auto e : nums) ++freq[e];</span><br><span class="line">        </span><br><span class="line">        for (auto&amp; pair : freq) &#123;</span><br><span class="line">            pq.emplace(pair.second, pair.first);</span><br><span class="line">            if (pq.size() &gt; k) pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while (!pq.empty()) &#123;</span><br><span class="line">            res.emplace_back(pq.top().second);</span><br><span class="line">            pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h1><p>给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]<br>输出：[2]<br>示例 2：</p>
<p>输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]<br>输出：[9,4]<br>解释：[4,9] 也是可通过的</p>
<h2 id="Solution1-6"><a href="#Solution1-6" class="headerlink" title="Solution1"></a>Solution1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; result_set; // 存放结果，之所以用set是为了给结果集去重</span><br><span class="line">        int hash[1005] = &#123;0&#125;; // 默认数值为0</span><br><span class="line">        for (int num : nums1) &#123; // nums1中出现的字母在hash数组中做记录</span><br><span class="line">            hash[num] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int num : nums2) &#123; // nums2中出现话，result记录</span><br><span class="line">            if (hash[num] == 1) &#123;</span><br><span class="line">                result_set.insert(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return vector&lt;int&gt;(result_set.begin(), result_set.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Solution2-5"><a href="#Solution2-5" class="headerlink" title="Solution2"></a>Solution2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; result_set; // 存放结果</span><br><span class="line">        unordered_set&lt;int&gt; nums_set(nums1.begin(), nums1.end());</span><br><span class="line">        for (int num : nums2) &#123;</span><br><span class="line">            // 发现nums2的元素 在nums_set里又出现过</span><br><span class="line">            if (nums_set.find(num) != nums_set.end()) &#123;</span><br><span class="line">                result_set.insert(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return vector&lt;int&gt;(result_set.begin(), result_set.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="371-两整数之和"><a href="#371-两整数之和" class="headerlink" title="371. 两整数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-two-integers/">371. 两整数之和</a></h1><p>给你两个整数 a 和 b ，不使用 运算符 + 和 - ​​​​​​​，计算并返回两整数之和。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：a &#x3D; 1, b &#x3D; 2<br>输出：3<br>示例 2：</p>
<p>输入：a &#x3D; 2, b &#x3D; 3<br>输出：5
 </p>
<p>提示：</p>
<p>-1000 &lt;&#x3D; a, b &lt;&#x3D; 1000</p>
<h2 id="Solution1-位运算"><a href="#Solution1-位运算" class="headerlink" title="Solution1 位运算"></a>Solution1 位运算</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int getSum(int a, int b) </span><br><span class="line">&#123;</span><br><span class="line">    int sum, carry; </span><br><span class="line">    sum = a ^ b;  //异或这里可看做是相加但是不显现进位，比如5 ^ 3</span><br><span class="line">                 /*0 1 0 1</span><br><span class="line">                   0 0 1 1</span><br><span class="line">                 ------------</span><br><span class="line">                   0 1 1 0      </span><br><span class="line">              上面的如果看成传统的加法，不就是1+1=2，进1得0，但是这里没有显示进位出来，仅是相加，0+1或者是1+0都不用进位*/</span><br><span class="line">    </span><br><span class="line">    carry = (a &amp; b) &lt;&lt; 1;</span><br><span class="line">    </span><br><span class="line">                //相与为了让进位显现出来，比如5 &amp; 3</span><br><span class="line">                /* 0 1 0 1</span><br><span class="line">                   0 0 1 1</span><br><span class="line">                 ------------</span><br><span class="line">                   0 0 0 1</span><br><span class="line">              上面的最低位1和1相与得1，而在二进制加法中，这里1+1也应该是要进位的，所以刚好吻合，但是这个进位1应该要再往前一位，所以左移一位*/</span><br><span class="line">    </span><br><span class="line">    if(carry != 0)  //经过上面这两步，如果进位不等于0，那么就是说还要把进位给加上去，所以用了尾递归，一直递归到进位是0。</span><br><span class="line">    &#123;</span><br><span class="line">        return getSum(sum, carry);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="378-有序矩阵中第-K-小的元素"><a href="#378-有序矩阵中第-K-小的元素" class="headerlink" title="378. 有序矩阵中第 K 小的元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/">378. 有序矩阵中第 K 小的元素</a></h1><p>给你一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。<br>请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。</p>
<p>你必须找到一个内存复杂度优于 O(n2) 的解决方案。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：matrix &#x3D; [[1,5,9],[10,11,13],[12,13,15]], k &#x3D; 8<br>输出：13<br>解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13<br>示例 2：</p>
<p>输入：matrix &#x3D; [[-5]], k &#x3D; 1<br>输出：-5
 </p>
<p>提示：</p>
<p>n &#x3D;&#x3D; matrix.length<br>n &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; n &lt;&#x3D; 300<br>-109 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 109<br>题目数据 保证 matrix 中的所有行和列都按 非递减顺序 排列<br>1 &lt;&#x3D; k &lt;&#x3D; n2
 </p>
<p>进阶：</p>
<p>你能否用一个恒定的内存(即 O(1) 内存复杂度)来解决这个问题?<br>你能在 O(n) 的时间复杂度下解决这个问题吗?这个方法对于面试来说可能太超前了，但是你会发现阅读这篇文章（ this paper ）很有趣。</p>
<h2 id="Solution1-暴力-13"><a href="#Solution1-暴力-13" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><p><img src="https://files.mdnice.com/user/1489/aa8f67bb-f725-4ac9-b288-f00702b84a55.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123;</span><br><span class="line">        struct point &#123;</span><br><span class="line">            int val, x, y;</span><br><span class="line">            point(int val, int x, int y) : val(val), x(x), y(y) &#123;&#125;</span><br><span class="line">            bool operator&gt; (const point&amp; a) const &#123; return this-&gt;val &gt; a.val; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        priority_queue&lt;point, vector&lt;point&gt;, greater&lt;point&gt;&gt; que;</span><br><span class="line">        int n = matrix.size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            que.emplace(matrix[i][0], i, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; k - 1; i++) &#123;</span><br><span class="line">            point now = que.top();</span><br><span class="line">            que.pop();</span><br><span class="line">            if (now.y != n - 1) &#123;</span><br><span class="line">                que.emplace(matrix[now.x][now.y + 1], now.x, now.y + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return que.top().val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Solution2-最小堆"><a href="#Solution2-最小堆" class="headerlink" title="Solution2 最小堆"></a>Solution2 最小堆</h2><p><img src="https://files.mdnice.com/user/1489/ac2814f5-9f64-451b-8a2f-167966444bc9.png"></p>
<p><img src="https://files.mdnice.com/user/1489/89471a17-0dc3-4180-9b34-d9d5c6c4f9da.png"></p>
<p><img src="https://files.mdnice.com/user/1489/bfd3a090-de97-4eff-a66b-be9cddb9bbc8.png"></p>
<h1 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></h1><p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “3[a]2[bc]”<br>输出：”aaabcbc”<br>示例 2：</p>
<p>输入：s &#x3D; “3[a2[c]]”<br>输出：”accaccacc”<br>示例 3：</p>
<p>输入：s &#x3D; “2[abc]3[cd]ef”<br>输出：”abcabccdcdcdef”<br>示例 4：</p>
<p>输入：s &#x3D; “abc3[cd]xyz”<br>输出：”abccdcdcdxyz”
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 30<br>s 由小写英文字母、数字和方括号 ‘[]’ 组成<br>s 保证是一个 有效 的输入。<br>s 中所有整数的取值范围为 [1, 300] </p>
<h2 id="Solution1-两个栈"><a href="#Solution1-两个栈" class="headerlink" title="Solution1 两个栈"></a>Solution1 两个栈</h2><p><img src="https://files.mdnice.com/user/1489/57e2bfe5-e188-42e3-9460-4fa79082ecd2.png"></p>
<h1 id="402-移掉-K-位数字"><a href="#402-移掉-K-位数字" class="headerlink" title="402. 移掉 K 位数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-k-digits/">402. 移掉 K 位数字</a></h1><p>给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p>
<p> <br>示例 1 ：</p>
<p>输入：num &#x3D; “1432219”, k &#x3D; 3<br>输出：”1219”<br>解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。<br>示例 2 ：</p>
<p>输入：num &#x3D; “10200”, k &#x3D; 1<br>输出：”200”<br>解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。<br>示例 3 ：</p>
<p>输入：num &#x3D; “10”, k &#x3D; 2<br>输出：”0”<br>解释：从原数字移除所有的数字，剩余为空就是 0 。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; k &lt;&#x3D; num.length &lt;&#x3D; 105<br>num 仅由若干位数字（0 - 9）组成<br>除了 0 本身之外，num 不含任何前导零</p>
<h2 id="Solution1-贪心-单调栈"><a href="#Solution1-贪心-单调栈" class="headerlink" title="Solution1 贪心+单调栈"></a>Solution1 贪心+单调栈</h2><p><img src="https://files.mdnice.com/user/1489/702de056-c52b-45b9-9965-8112d4131454.png"></p>
<p><img src="https://files.mdnice.com/user/1489/48ae75e0-df07-48f0-bfea-017869bac869.png"></p>
<p><img src="https://files.mdnice.com/user/1489/0052ac37-a066-4e57-97fd-4ebe72e6418e.png"></p>
<p><img src="https://files.mdnice.com/user/1489/a4c9016a-3529-492d-a5c4-4172619a5168.png"></p>
<p><img src="https://files.mdnice.com/user/1489/cf2db259-ce16-4284-97f8-6e048c789bd5.png"></p>
<p><img src="https://files.mdnice.com/user/1489/544a41e4-a185-4dff-941f-79e6a60d6e79.png"></p>
<p><img src="https://files.mdnice.com/user/1489/f0bf9bc6-9c7f-434c-b924-cba7405ed0fb.png"></p>
<p><img src="https://files.mdnice.com/user/1489/446462c6-005a-4165-81a4-213042a92492.png"></p>
<p><img src="https://files.mdnice.com/user/1489/207854fc-5451-44e1-84a6-51cde0d77f0f.png"></p>
<h1 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h1><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] &#x3D; [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p>
<p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] &#x3D; [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]<br>输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]<br>解释：<br>编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。<br>编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。<br>编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。<br>编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。<br>编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。<br>示例 2：</p>
<p>输入：people &#x3D; [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]<br>输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; people.length &lt;&#x3D; 2000<br>0 &lt;&#x3D; hi &lt;&#x3D; 106<br>0 &lt;&#x3D; ki &lt; people.length<br>题目数据确保队列可以被重建</p>
<h2 id="Solution1-先排序-再插队"><a href="#Solution1-先排序-再插队" class="headerlink" title="Solution1 先排序 再插队"></a>Solution1 先排序 再插队</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(const vector&lt;int&gt; a,const vector&lt;int&gt; b)&#123;</span><br><span class="line">            if (a[0] &gt; b[0]) return true;</span><br><span class="line">            if (a[0] == b[0] &amp;&amp; a[1] &lt; b[1]) return true;</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;</span><br><span class="line">        vector&lt;vector&lt;int &gt;&gt; res;</span><br><span class="line">        sort(people.begin(),people.end(),cmp);</span><br><span class="line">        for(auto val:people)&#123;</span><br><span class="line">            res.insert(res.begin()+val[1],val);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409. 最长回文串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindrome/">409. 最长回文串</a></h1><p>给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的回文串 。</p>
<p>在构造过程中，请注意 区分大小写 。比如 “Aa” 不能当做一个回文字符串。</p>
<p> </p>
<p>示例 1:</p>
<p>输入:s &#x3D; “abccccdd”<br>输出:7<br>解释:<br>我们可以构造的最长的回文串是”dccaccd”, 它的长度是 7。<br>示例 2:</p>
<p>输入:s &#x3D; “a”<br>输入:1
 </p>
<p>提示:</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 2000<br>s 只由小写 和&#x2F;或 大写英文字母组成</p>
<h2 id="Solution1-7"><a href="#Solution1-7" class="headerlink" title="Solution1"></a>Solution1</h2><p><img src="https://files.mdnice.com/user/1489/15ea384d-bb95-4dbf-8d73-ba9536ff3f95.png"></p>
<h1 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-strings/">415. 字符串相加</a></h1><p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。</p>
<p>你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：num1 &#x3D; “11”, num2 &#x3D; “123”<br>输出：”134”<br>示例 2：</p>
<p>输入：num1 &#x3D; “456”, num2 &#x3D; “77”<br>输出：”533”<br>示例 3：</p>
<p>输入：num1 &#x3D; “0”, num2 &#x3D; “0”<br>输出：”0”
 </p>
<p> </p>
<p>提示：</p>
<p>1 &lt;&#x3D; num1.length, num2.length &lt;&#x3D; 104<br>num1 和num2 都只包含数字 0-9<br>num1 和num2 都不包含任何前导零</p>
<h2 id="Solution1-8"><a href="#Solution1-8" class="headerlink" title="Solution1"></a>Solution1</h2><p><img src="https://files.mdnice.com/user/1489/50bd7865-2516-4f4d-bdf7-4de2f00cdf80.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string addStrings(string num1, string num2) &#123;</span><br><span class="line">        int i = num1.length() - 1, j = num2.length() - 1, add = 0;</span><br><span class="line">        string ans = &quot;&quot;;</span><br><span class="line">        while (i &gt;= 0 || j &gt;= 0 || add != 0) &#123;</span><br><span class="line">            int x = i &gt;= 0 ? num1[i] - &#x27;0&#x27; : 0;</span><br><span class="line">            int y = j &gt;= 0 ? num2[j] - &#x27;0&#x27; : 0;</span><br><span class="line">            int result = x + y + add;</span><br><span class="line">            ans.push_back(&#x27;0&#x27; + result % 10);</span><br><span class="line">            add = result / 10;</span><br><span class="line">            i -= 1;</span><br><span class="line">            j -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 计算完以后的答案需要翻转过来</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="https://files.mdnice.com/user/1489/620df582-d9ad-49fd-a069-2b6bb56fa29c.png"></p>
<h1 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h1><p>背包问题 后面和回溯问题一起搞定</p>
<p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,5,11,5]<br>输出：true<br>解释：数组可以分割成 [1, 5, 5] 和 [11] 。<br>示例 2：</p>
<p>输入：nums &#x3D; [1,2,3,5]<br>输出：false<br>解释：数组不能分割成两个元素和相等的子集。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p>
<h1 id="求1-2-…n"><a href="#求1-2-…n" class="headerlink" title="求1+2+…n"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/qiu-12n-lcof">求1+2+…n</a></h1><p><img src="https://files.mdnice.com/user/1489/a39d57a7-49a2-4353-a4a4-68361420e23e.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/19234557-e889-43c9-84a6-e55b36d24aec.jpg"></p>
<h1 id="求滑动窗口的最大值"><a href="#求滑动窗口的最大值" class="headerlink" title="求滑动窗口的最大值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof">求滑动窗口的最大值</a></h1><p><img src="https://files.mdnice.com/user/1489/15a63a92-7b41-4707-a824-964718554f58.jpg"><br><img src="https://files.mdnice.com/user/1489/91669611-5065-4e62-9bcc-ba187bda8268.jpg"></p>
<h1 id="扑克牌中的顺子"><a href="#扑克牌中的顺子" class="headerlink" title="扑克牌中的顺子"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof">扑克牌中的顺子</a></h1><p><img src="https://files.mdnice.com/user/1489/297b7397-78fa-402f-9848-36a3e6baeafc.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/ff5136fb-3f4c-4caa-900f-e4d562a63e80.jpg"></p>
<h1 id="二叉搜索树的第K大节点"><a href="#二叉搜索树的第K大节点" class="headerlink" title="二叉搜索树的第K大节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof">二叉搜索树的第K大节点</a></h1><p><img src="https://files.mdnice.com/user/1489/815f7215-0047-455e-8cc3-fa211fc82157.jpg"></p>
<h1 id="不用加减乘除做加法"><a href="#不用加减乘除做加法" class="headerlink" title="不用加减乘除做加法"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof">不用加减乘除做加法</a></h1><p><img src="https://files.mdnice.com/user/1489/861c46f5-40c1-4452-bae1-d1fe40b46687.jpg"></p>
<h1 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof">左旋转字符串</a></h1><p><img src="https://files.mdnice.com/user/1489/e329b323-7662-4aa8-bef3-0ecf293c49de.jpg"></p>
<h1 id="0-n-1中缺失的数字"><a href="#0-n-1中缺失的数字" class="headerlink" title="0~n-1中缺失的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof">0~n-1中缺失的数字</a></h1><p><img src="https://files.mdnice.com/user/1489/beeb899a-9927-4525-b0d1-3d241c00ccb4.jpg"><br><img src="https://files.mdnice.com/user/1489/e1be0f97-6680-4f55-a373-3a484128fe6a.jpg"></p>
<h1 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof">最长不含重复字符的子字符串</a></h1><p><img src="https://files.mdnice.com/user/1489/f01b0278-174b-461f-8ac7-191f13995a3b.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/bac74319-f5dc-4b47-8f63-1cc381458756.jpg"></p>
<h1 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof">滑动窗口的最大值</a></h1><p><img src="https://files.mdnice.com/user/1489/4a32da04-9232-437a-98df-26863d85179e.jpg"></p>
<h1 id="和为s连续正数序列"><a href="#和为s连续正数序列" class="headerlink" title="和为s连续正数序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof">和为s连续正数序列</a></h1><p><img src="https://files.mdnice.com/user/1489/aee56655-c266-45ae-aeda-2cb3e1573c71.jpg"><br><img src="https://files.mdnice.com/user/1489/6713148f-44c9-472b-9956-90bcad147d34.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/e9aeb4c3-d429-4dbd-ad0a-9d7ae18c6b50.jpg"><br><img src="https://files.mdnice.com/user/1489/9011acac-108a-45de-a940-7dc0cbe33807.jpg"></p>
<h1 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof">礼物的最大价值</a></h1><p><img src="https://files.mdnice.com/user/1489/0db9683d-96ad-462b-9c2f-e80cb835f227.jpg"></p>
<h1 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof">翻转单词顺序</a></h1><p><img src="https://files.mdnice.com/user/1489/94ef5c0b-92a5-437e-8920-e808dbf6cc4d.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/433263e7-9556-438c-8f3d-c260225dbf1d.jpg"></p>
<h1 id="左旋转字符串-1"><a href="#左旋转字符串-1" class="headerlink" title="左旋转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof">左旋转字符串</a></h1><p><img src="https://files.mdnice.com/user/1489/4614ddda-961b-4eed-8ee4-cc50ffb25935.jpg"></p>
<h1 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof">和为s的两个数字</a></h1><p><img src="https://files.mdnice.com/user/1489/50faf577-63ab-4b9c-bd6f-59ed0c2ce516.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/c918777d-7c9e-42a2-95fb-576b4618efd1.jpg"></p>
<h1 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof">数组中数字出现的次数</a></h1><p><img src="https://files.mdnice.com/user/1489/7d866548-cf10-4e94-b709-7f71ef98a483.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/3b246e5f-80a9-4142-afcc-f87821e72388.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/40509b75-a36f-4c79-88d3-5bfc2084e109.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/a871d490-3098-4744-acd1-27faa3facd1e.jpg"></p>
<h1 id="二叉树中和为某一个值的路径"><a href="#二叉树中和为某一个值的路径" class="headerlink" title="二叉树中和为某一个值的路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof">二叉树中和为某一个值的路径</a></h1><p><img src="https://files.mdnice.com/user/1489/aefe8796-fac3-4849-a19c-fce0f029ba08.jpg"></p>
<h1 id="数组中出现次数超过一半的次数"><a href="#数组中出现次数超过一半的次数" class="headerlink" title="数组中出现次数超过一半的次数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof">数组中出现次数超过一半的次数</a></h1><p><img src="https://files.mdnice.com/user/1489/6afab0e0-5928-483e-a44d-bd6fa19e36dd.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/63b82d8b-42d1-4360-b5e7-224ad1ccb987.jpg"></p>
<h1 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof">第一个只出现一次的字符</a></h1><p><img src="https://files.mdnice.com/user/1489/7134c1a6-a705-41e0-b994-d9df133ffd06.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/a5fa6552-4f5e-434b-a31e-38bf09a2cdab.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/8accb7cf-0178-49e7-a907-44da8c41ca8e.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/5e428394-3fd2-480c-9c7e-2bd099118a10.jpg"></p>
<h1 id="从上到下打印二叉树"><a href="#从上到下打印二叉树" class="headerlink" title="从上到下打印二叉树|||"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof">从上到下打印二叉树|||</a></h1><p><img src="https://files.mdnice.com/user/1489/a730fbab-4997-4af9-a608-85ffe0bcac07.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/442400a3-6855-4a90-a088-8d14c10099fd.jpg"></p>
<h1 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof">字符串的排列</a></h1><p><img src="https://files.mdnice.com/user/1489/8984e78f-719b-4640-a513-787d3b23d9ce.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/a31ff962-6681-4f7c-8888-acccb902ddf6.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/f28df7df-9f6a-4428-8716-43437dbb7779.jpg"></p>
<h1 id="最小的K个数"><a href="#最小的K个数" class="headerlink" title="最小的K个数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof">最小的K个数</a></h1><p><img src="https://files.mdnice.com/user/1489/c9037420-1a61-4305-bad1-b4227ec9707f.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/f5098755-cba5-4145-9804-8e4cbff4dd48.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/e3138c17-60bb-411d-9843-f6639bd0abd7.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/2c2e1f87-d654-46f1-a83f-c36c34189b47.jpg"></p>
<h1 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof">二叉搜索树与双向链表</a></h1><p><img src="https://files.mdnice.com/user/1489/d51c2fab-43eb-470b-8d20-9408f94774ed.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/c672b522-c4ab-424a-b872-59264a5bd13e.jpg"></p>
<h1 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof">连续子数组的最大和</a></h1><p><img src="https://files.mdnice.com/user/1489/828bd8c8-3c46-49e2-8d18-ae06aa6d3582.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/77a88286-4f3b-40a2-8aa5-6513bef59e05.jpg"></p>
<h1 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof">栈的压入、弹出序列</a></h1><p><img src="https://files.mdnice.com/user/1489/56115b51-a2ce-4bca-8a39-7c4ac2e070e6.jpg"></p>
<h1 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof">包含min函数的栈</a></h1><p><img src="https://files.mdnice.com/user/1489/e92fd7e3-d208-4978-bdf6-fd51492fbeb6.jpg"></p>
<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list">反转链表</a></h1><p><img src="https://files.mdnice.com/user/1489/6d46c580-ca37-4f4d-89cb-b250a209b90a.jpg"></p>
<h1 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof">数值的整数次方</a></h1><p><img src="https://files.mdnice.com/user/1489/52bf9fe5-269b-46c3-8f40-dac13d75ecdb.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/4254d052-fced-468a-a06b-80a9c388b798.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/ba0409e5-fa6d-4d7e-9292-f5be87a8fd13.jpg"></p>
<h1 id="删除链表的节点"><a href="#删除链表的节点" class="headerlink" title="删除链表的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof">删除链表的节点</a></h1><p><img src="https://files.mdnice.com/user/1489/f7b719a0-e068-42c3-b6f8-6f20301194df.jpg"></p>
<h1 id="链表的倒数第K个节点"><a href="#链表的倒数第K个节点" class="headerlink" title="链表的倒数第K个节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list">链表的倒数第K个节点</a></h1><p><img src="https://files.mdnice.com/user/1489/4ef04808-5bea-4610-9567-9fe0c028d63c.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/bad95909-e879-4f70-97f2-f9d01d7f5d22.jpg"></p>
<h1 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof">二进制中1的个数</a></h1><p><img src="https://files.mdnice.com/user/1489/1da2c2bf-57a1-4e47-87f9-613dbee436fb.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/7d2f2092-3b35-4543-806a-3426630f698d.jpg"></p>
<h1 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof">顺时针打印矩阵</a></h1><p><img src="https://files.mdnice.com/user/1489/ec7c4226-3a47-4a54-bfdc-740e523ceaac.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/06c76a5a-8e15-4971-9fa9-4702abdf8348.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/3bbe711c-cbeb-459c-ad4b-e00d7b508cb4.jpg"></p>
<h1 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof">对称的二叉树</a></h1><p><img src="https://files.mdnice.com/user/1489/c90e4dd1-4efe-4177-9542-a31c9f7dd10d.jpg"></p>
<h1 id="调整数组顺序使得奇数位于偶数前"><a href="#调整数组顺序使得奇数位于偶数前" class="headerlink" title="调整数组顺序使得奇数位于偶数前"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof">调整数组顺序使得奇数位于偶数前</a></h1><p><img src="https://files.mdnice.com/user/1489/67ec0ae6-0a3c-4dc0-bc54-2f6bfa7b6d5d.jpg"></p>
<h1 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof">二叉树的镜像</a></h1><p><img src="https://files.mdnice.com/user/1489/64dedead-67bc-48c3-b39b-b7eefdecdbf3.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/c5329093-56fd-4e91-8ee1-7c045e22310f.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/a89ccc07-d81b-4c4c-9430-b0c3096d59c0.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/f23d7252-0e97-4d3c-890a-434c8b5803d5.jpg"></p>
<h1 id="对称的二叉树-1"><a href="#对称的二叉树-1" class="headerlink" title="对称的二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof">对称的二叉树</a></h1><p><img src="https://files.mdnice.com/user/1489/a2d7a7ea-4135-46f9-9ce9-0601312f2e95.jpg"></p>
<h1 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof">树的子结构</a></h1><p><img src="https://files.mdnice.com/user/1489/2c27e439-fff2-4f5e-a3e7-d35da3dd0250.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/ddadda37-15c0-4593-9817-db62669441a3.jpg"></p>
<h1 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof">合并两个排序的链表</a></h1><p><img src="https://files.mdnice.com/user/1489/5ad4608e-ae3f-4ea6-abc5-01ccba98b8bd.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/bdc5a0f5-514e-4994-97ae-4aa2b468d4a1.jpg"></p>
<h1 id="剪绳子"><a href="#剪绳子" class="headerlink" title="剪绳子"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jian-sheng-zi-ii-lcof">剪绳子</a></h1><p><img src="https://files.mdnice.com/user/1489/03a1de17-c22e-4c59-9494-1f0b2d174b29.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/9522e217-e06b-4346-84a0-eb8263b04f93.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/7b12d053-d366-4765-bfe4-75826f938e07.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/ca057ccb-65b9-48c8-9fee-a4024d76d47c.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/4ac49557-f581-4661-a123-af48b849ece1.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/9056d59a-86ef-4471-b065-a0a89df02627.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/19b73a26-c4e0-4af9-b278-52185b8bc40c.jpg"></p>
<h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof">替换空格</a></h1><p><img src="https://files.mdnice.com/user/1489/aa420d60-feec-41e4-b141-ad2d40924901.jpg"></p>
<h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof">重建二叉树</a></h1><p><img src="https://files.mdnice.com/user/1489/f3d44400-5e6a-4005-be47-2a20e288383f.jpg"><br><img src="https://files.mdnice.com/user/1489/c1843e98-f7e0-4e0b-b053-3bdb40abb586.jpg"></p>
<h1 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof">旋转数组的最小数字</a></h1><p><img src="https://files.mdnice.com/user/1489/ae78465c-a8c5-4cb3-9bc4-cc6a7f3f1498.jpg"><br><img src="https://files.mdnice.com/user/1489/e7e675f6-8b74-4492-a32d-b6c704015af1.jpg"></p>
<h1 id="替换空格-1"><a href="#替换空格-1" class="headerlink" title="替换空格"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof">替换空格</a></h1><p><img src="https://files.mdnice.com/user/1489/014f2c8d-e879-4228-a24e-3c902a6366cf.jpg"></p>
<h1 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof">从尾到头打印链表</a></h1><p><img src="https://files.mdnice.com/user/1489/e7287e83-0a0f-4c88-97a9-70c01dd6b61a.jpg"></p>
<h1 id="替换空格-2"><a href="#替换空格-2" class="headerlink" title="替换空格"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof">替换空格</a></h1><p><img src="https://files.mdnice.com/user/1489/12f83946-efa1-4c45-aefb-cf2385b1e4e0.jpg"></p>
<h1 id="青蛙跳台阶"><a href="#青蛙跳台阶" class="headerlink" title="青蛙跳台阶"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof">青蛙跳台阶</a></h1><p><img src="https://files.mdnice.com/user/1489/e0b97aff-77d6-44a0-905d-ddf01528b962.jpg"><br><img src="https://files.mdnice.com/user/1489/6fb39538-c320-49bd-b472-3e6dc981eb4d.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/2fe78d28-cb51-4119-a5e7-2d289ee647c7.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/5587729c-faa6-4969-9c44-33c350aac1a6.jpg"></p>
<h1 id="重构字符串"><a href="#重构字符串" class="headerlink" title="重构字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reorganize-string/">重构字符串</a></h1><p><img src="https://files.mdnice.com/user/1489/a0be23ac-6081-411c-96cb-9f2c79fcabb1.jpg"><br><img src="https://files.mdnice.com/user/1489/7c65b823-1c0b-4d4f-8a13-554fb12cf314.jpg"></p>
<h1 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof">数组中重复的数字</a></h1><p><img src="https://files.mdnice.com/user/1489/e648c0ad-b283-4b66-90d7-4bc23329dd5a.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/64f8d26f-c230-49c3-b398-df245f234505.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/92daf8e2-3349-475e-af48-4ad83be8a41e.jpg"><br><img src="https://files.mdnice.com/user/1489/174e0c93-01d3-41d0-8a49-c894760318e3.jpg"></p>
<h1 id="自除数"><a href="#自除数" class="headerlink" title="自除数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/self-dividing-numbers/">自除数</a></h1><p><img src="https://files.mdnice.com/user/1489/31bcba36-c886-412a-a41d-069f5cd29713.jpg"></p>
<h1 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-labels/">划分字母区间</a></h1><p><img src="https://files.mdnice.com/user/1489/81edb05f-482a-48d2-a709-9c012a5a148c.jpg"><br><img src="https://files.mdnice.com/user/1489/56fac4ed-d7a0-42b3-b63c-5ae4151b4d95.jpg"></p>
<h1 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures">每日温度</a></h1><p><img src="https://files.mdnice.com/user/1489/979f2ad7-bb3d-4d06-8f1e-56c11921e810.jpg"><br><img src="https://files.mdnice.com/user/1489/eee786ba-73e5-4de7-9cc8-b82b80c56364.jpg"><br><img src="https://files.mdnice.com/user/1489/f5e179e8-5c9b-40e5-b110-75d3cb245491.jpg"></p>
<h1 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray">最长重复子数组</a></h1><p><img src="https://files.mdnice.com/user/1489/7bc821d7-1447-46ae-899c-cd1196d3e8fe.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/c2a7b9ac-91b4-4ecd-ac11-9c6f89d76202.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/83c47edf-7580-482f-9d47-83717761349c.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/623c9607-ca24-41cb-a43c-64e5a071ed00.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/3d092f02-d8a2-49fe-9ae9-a89efccf9907.jpg"><br><img src="https://files.mdnice.com/user/1489/fcfc655c-34c8-49b5-8ab9-09d72d74a3cb.jpg"></p>
<h1 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree">最大二叉树</a></h1><p><img src="https://files.mdnice.com/user/1489/7cb88611-e8e0-4de4-a0e0-c34d8a78df3d.jpg"></p>
<h1 id="1比特与2比特字符"><a href="#1比特与2比特字符" class="headerlink" title="1比特与2比特字符"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/">1比特与2比特字符</a></h1><p><img src="https://files.mdnice.com/user/1489/c8d08da7-0629-49fc-b47b-55d8f9ec7c71.jpg"><br><img src="https://files.mdnice.com/user/1489/2d61a58f-d344-424e-8716-5ab9c5653f6e.jpg"></p>
<h1 id="最短无序连续子数组"><a href="#最短无序连续子数组" class="headerlink" title="最短无序连续子数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/">最短无序连续子数组</a></h1><p><img src="https://files.mdnice.com/user/1489/e5f2d5b8-6440-4910-9eb2-20848cebe369.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/08f457d6-d730-4b87-bff8-e9211b8332bd.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/86763d3e-dcd7-46e9-bbe3-d0b14813dc5b.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/11abbaeb-d616-4866-9bd8-029b298f1f97.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/074c12a8-524a-4f31-8abd-878e9aca33be.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/c5bfa348-f61c-44be-b5a6-797e736ece90.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/90f1cfd8-35b9-44aa-8281-b9fc3097c54a.jpg"></p>
<h1 id="和为K的子数组"><a href="#和为K的子数组" class="headerlink" title="和为K的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/">和为K的子数组</a></h1><p><img src="https://files.mdnice.com/user/1489/05eda67c-4389-4973-9617-02aefee2129f.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/f5cbc2d0-8659-47c7-b189-9da1f9840224.jpg"><br><img src="https://files.mdnice.com/user/1489/2345cdfb-b295-4124-83a5-4cf212022be0.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/58a66c05-9434-4a32-89b8-ec1b10ba4c88.jpg"></p>
<h1 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree">二叉树的直径</a></h1><p><img src="https://files.mdnice.com/user/1489/dbcf5ac5-6466-4d9b-b9cd-d37e6d4d383b.jpg"></p>
<h1 id="找到所有数组中消失的数字"><a href="#找到所有数组中消失的数字" class="headerlink" title="找到所有数组中消失的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array">找到所有数组中消失的数字</a></h1><p><img src="https://files.mdnice.com/user/1489/d1fcc62e-aeaa-4ccf-b224-ab724f90ae37.jpg"></p>
<h1 id="把二叉搜索树转换成为累加树"><a href="#把二叉搜索树转换成为累加树" class="headerlink" title="把二叉搜索树转换成为累加树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree">把二叉搜索树转换成为累加树</a></h1><p><img src="https://files.mdnice.com/user/1489/f9a6f9ba-1a2e-4ef2-8799-6b93c635519c.jpg"></p>
<h1 id="数字的补数"><a href="#数字的补数" class="headerlink" title="数字的补数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-complement/">数字的补数</a></h1><p><img src="https://files.mdnice.com/user/1489/c27eca08-3f9b-4813-b858-da16881adde7.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/5d0202cd-9252-47fc-bb24-c44a7962fc24.jpg"></p>
<h1 id="二叉树的直径-1"><a href="#二叉树的直径-1" class="headerlink" title="二叉树的直径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree">二叉树的直径</a></h1><p><img src="https://files.mdnice.com/user/1489/a8df6972-ea60-4073-a9ed-c607c5017b21.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/ba15565c-2189-4cda-b8eb-92ada72b826f.jpg"></p>
<h1 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/assign-cookies">分发饼干</a></h1><p><img src="https://files.mdnice.com/user/1489/d3a4ed92-b21e-4237-87cd-5bfb2bee545e.jpg"></p>
<h1 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/hamming-distance">汉明距离</a></h1><p><img src="https://files.mdnice.com/user/1489/65b0b068-a855-410f-833f-0cd18b42c057.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/127549f9-fa4e-440b-9f58-7e2ec00d19dc.jpg"></p>
<h1 id="找到所有数组中消失的数字-1"><a href="#找到所有数组中消失的数字-1" class="headerlink" title="找到所有数组中消失的数字"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array">找到所有数组中消失的数字</a></h1><p><img src="https://files.mdnice.com/user/1489/0f99a883-da18-46ca-9985-d7ba4a46092d.jpg"></p>
<h1 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum-closest/">最接近的三数之和</a></h1><p><img src="https://files.mdnice.com/user/1489/d5a6910c-41c0-471f-b8c3-3b79ae583be8.jpg"></p>
<h1 id="四数相加"><a href="#四数相加" class="headerlink" title="四数相加||"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/">四数相加||</a></h1><p><img src="https://files.mdnice.com/user/1489/81e7a78b-6e9b-4804-b4bc-f32031fdd571.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/252bc915-1dc7-43e6-9498-e75607502c81.jpg"></p>
<h1 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-prefix/">最长公共前缀</a></h1><p><img src="https://files.mdnice.com/user/1489/a1c451b7-b2eb-4545-b354-c7c37a1ab8e0.jpg"><br><img src="https://files.mdnice.com/user/1489/d7e4710d-6ea2-41b2-9aba-1dca85dcd9d3.jpg"><br><img src="https://files.mdnice.com/user/1489/6f172e79-74e2-452d-ab77-a7149388bb74.jpg"></p>
<h1 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-integer/">整数反转</a></h1><p><img src="https://files.mdnice.com/user/1489/d5945a88-399a-4b88-a5b5-20e6fe7e7e99.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/f8c0d53a-9c66-4d00-857c-cab81d087035.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/0e795a17-567a-42d3-a1bb-677b12f407e8.jpg"></p>
<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring">最长回文子串</a></h1><p><img src="https://files.mdnice.com/user/1489/e7b49339-91b4-4ada-a0b5-14ec5d3cb9d9.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/77577f23-520d-480a-b4d1-94f1e25aeed7.jpg"><br><img src="https://files.mdnice.com/user/1489/c6f390b2-c832-408a-ab8e-587085f4faf8.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/bb53951f-2e43-453c-b6f6-0383e670e50f.jpg"></p>
<h1 id="盛水最多的容器"><a href="#盛水最多的容器" class="headerlink" title="盛水最多的容器"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/container-with-most-water/">盛水最多的容器</a></h1><p><img src="https://files.mdnice.com/user/1489/152a336e-c600-4937-850c-d0f1fd5a4c4f.jpg"></p>
<h1 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters">无重复字符的最长子串</a></h1><p><img src="https://files.mdnice.com/user/1489/f075ebdf-3df9-4229-be81-efdca44423d4.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/55e84e02-f0b6-4e27-ace1-28039e20c7ef.jpg"></p>
<p><img src="https://files.mdnice.com/user/1489/7b8def0f-7d26-40fb-8936-24236b14e7af.jpg"></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/19/Linux-Command-Wildcard/" rel="prev" title="Linux Command —— Wildcard">
      <i class="fa fa-chevron-left"></i> Linux Command —— Wildcard
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Two-Sum"><span class="nav-number">1.</span> <span class="nav-text">1. Two Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-1"><span class="nav-number">1.1.</span> <span class="nav-text">Solution 1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-2"><span class="nav-number">1.2.</span> <span class="nav-text">Solution 2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="nav-number">2.</span> <span class="nav-text">17. 电话号码的字母组合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-1-%E6%9A%B4%E5%8A%9B"><span class="nav-number">2.1.</span> <span class="nav-text">Solution 1  暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Soulution-2-%E5%9B%9E%E6%BA%AF"><span class="nav-number">2.2.</span> <span class="nav-text">Soulution 2  回溯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-3-%E9%98%9F%E5%88%97"><span class="nav-number">2.3.</span> <span class="nav-text">Solution 3  队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">3.</span> <span class="nav-text">18. 四数之和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-1-%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE"><span class="nav-number">3.1.</span> <span class="nav-text">Solution 1  暴力枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-2-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">Solution 2  双指针法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-number">4.</span> <span class="nav-text">19. 删除链表的倒数第 N 个结点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%AE%A1%E7%AE%97%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6"><span class="nav-number">4.1.</span> <span class="nav-text">Solution1 计算链表长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E6%A0%88"><span class="nav-number">4.2.</span> <span class="nav-text">Solution2 栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution3-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="nav-number">4.3.</span> <span class="nav-text">Solution3 快慢指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%A0%88"><span class="nav-number">4.4.</span> <span class="nav-text">Solution1 栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B"><span class="nav-number">4.5.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E9%80%92%E5%BD%92-%E5%89%AA%E6%9E%9D"><span class="nav-number">4.6.</span> <span class="nav-text">Solution2 递归 + 剪枝</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">5.</span> <span class="nav-text">24. 两两交换链表中的节点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92"><span class="nav-number">5.1.</span> <span class="nav-text">Solution1  递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%BF%AD%E4%BB%A3"><span class="nav-number">5.2.</span> <span class="nav-text">Solution2 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="nav-number">6.</span> <span class="nav-text">[26. 删除有序数组中的重复项]</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-1"><span class="nav-number">6.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">6.2.</span> <span class="nav-text">Solution2 双指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution3-%E5%8F%8C%E6%8C%87%E9%92%88-%E4%BC%98%E5%8C%96"><span class="nav-number">6.3.</span> <span class="nav-text">Solution3 双指针 优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="nav-number">7.</span> <span class="nav-text">31. 下一个排列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-2"><span class="nav-number">7.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2"><span class="nav-number">7.2.</span> <span class="nav-text">Solution2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">8.</span> <span class="nav-text">33. 搜索旋转排序数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-3"><span class="nav-number">8.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">8.2.</span> <span class="nav-text">Solution2 二分查找</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="nav-number">9.</span> <span class="nav-text">34. 在排序数组中查找元素的第一个和最后一个位置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-4"><span class="nav-number">9.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%BA%8C%E5%88%86"><span class="nav-number">9.2.</span> <span class="nav-text">Solution2 二分</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">10.</span> <span class="nav-text"></span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-5"><span class="nav-number">10.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%BA%8C%E5%88%86-1"><span class="nav-number">10.2.</span> <span class="nav-text">Solution2 二分</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="nav-number">11.</span> <span class="nav-text">39. 组合总和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-6"><span class="nav-number">11.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%9B%9E%E6%BA%AF"><span class="nav-number">11.2.</span> <span class="nav-text">Solution2 回溯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="nav-number">12.</span> <span class="nav-text">40. 组合总和 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%9B%9E%E6%BA%AF"><span class="nav-number">12.1.</span> <span class="nav-text">Solution1 回溯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">13.</span> <span class="nav-text">46. 全排列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-7"><span class="nav-number">13.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%9B%9E%E6%BA%AF-1"><span class="nav-number">13.2.</span> <span class="nav-text">Solution2 回溯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="nav-number">14.</span> <span class="nav-text">48. 旋转图像</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8E%9F%E5%9C%B0%E6%9F%A5%E6%89%BE"><span class="nav-number">14.1.</span> <span class="nav-text">Solution1 原地查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%85%88%E8%BD%AC%E7%BD%AE%E5%86%8D%E7%AB%96%E7%9B%B4%E5%AF%B9%E7%A7%B0%E5%8F%8D%E8%BD%AC"><span class="nav-number">14.2.</span> <span class="nav-text">Solution2 先转置再竖直对称反转</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="nav-number">15.</span> <span class="nav-text">49. 字母异位词分组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-Map"><span class="nav-number">15.1.</span> <span class="nav-text">Solution1 Map</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#50-Pow-x-n"><span class="nav-number">16.</span> <span class="nav-text">50. Pow(x, n)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%BF%AB%E9%80%9F%E5%B9%82-%E9%80%92%E5%BD%92"><span class="nav-number">16.1.</span> <span class="nav-text">Solution1  快速幂+递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-number">17.</span> <span class="nav-text">53. 最大子数组和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-8"><span class="nav-number">17.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">17.2.</span> <span class="nav-text">Solution2 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="nav-number">18.</span> <span class="nav-text">54. 螺旋矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8E%9F%E5%9C%B0%E9%81%8D%E5%8E%86"><span class="nav-number">18.1.</span> <span class="nav-text">Solution1 原地遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E6%8C%89%E5%B1%82%E9%81%8D%E5%8E%86"><span class="nav-number">18.2.</span> <span class="nav-text">Solution2 按层遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="nav-number">19.</span> <span class="nav-text">56. 合并区间</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%8E%92%E5%BA%8F"><span class="nav-number">19.1.</span> <span class="nav-text">Solution1 排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">20.</span> <span class="nav-text">61. 旋转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-9"><span class="nav-number">20.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Soluion2-%E9%97%AD%E7%8E%AF"><span class="nav-number">20.2.</span> <span class="nav-text">Soluion2  闭环</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="nav-number">21.</span> <span class="nav-text">62. 不同路径</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88"><span class="nav-number">21.1.</span> <span class="nav-text">Solution1 排列组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="nav-number">21.2.</span> <span class="nav-text">Solution2 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">22.</span> <span class="nav-text">64. 最小路径和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E6%9A%B4%E5%8A%9B"><span class="nav-number">22.1.</span> <span class="nav-text">Solution0 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">22.2.</span> <span class="nav-text">Solution1 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#66-%E5%8A%A0%E4%B8%80"><span class="nav-number">23.</span> <span class="nav-text">66. 加一</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-0-%E6%9A%B4%E5%8A%9B"><span class="nav-number">23.1.</span> <span class="nav-text">Solution 0  暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-1-%E9%80%86%E5%BA%8F%E9%81%8D%E5%8E%86-%E6%89%BE%E5%88%B09"><span class="nav-number">23.2.</span> <span class="nav-text">Solution 1 逆序遍历 找到9</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#69-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9"><span class="nav-number">24.</span> <span class="nav-text">69. x 的平方根 </span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-10"><span class="nav-number">24.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="nav-number">24.2.</span> <span class="nav-text">Solution2 二分搜索</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="nav-number">25.</span> <span class="nav-text">70. 爬楼梯</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-1"><span class="nav-number">25.1.</span> <span class="nav-text">Solution1 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB"><span class="nav-number">26.</span> <span class="nav-text">75. 颜色分类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-11"><span class="nav-number">26.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8D%95%E6%8C%87%E9%92%88"><span class="nav-number">26.2.</span> <span class="nav-text">Solution2 单指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution3-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">26.3.</span> <span class="nav-text">Solution3 双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#78-%E5%AD%90%E9%9B%86"><span class="nav-number">27.</span> <span class="nav-text">78. 子集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%9B%9E%E6%BA%AF-1"><span class="nav-number">27.1.</span> <span class="nav-text">Solution1 回溯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#90-%E5%AD%90%E9%9B%86"><span class="nav-number">28.</span> <span class="nav-text">90.子集||</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#77-%E7%BB%84%E5%90%88"><span class="nav-number">29.</span> <span class="nav-text">77. 组合</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-1"><span class="nav-number">30.</span> <span class="nav-text">39. 组合总和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II-1"><span class="nav-number">31.</span> <span class="nav-text">40. 组合总和 II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-number">32.</span> <span class="nav-text">剑指 Offer 38. 字符串的排列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#784-%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">33.</span> <span class="nav-text">784. 字母大小写全排列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="nav-number">34.</span> <span class="nav-text">79. 单词搜索</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-number">35.</span> <span class="nav-text">83. 删除排序链表中的重复元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="nav-number">35.1.</span> <span class="nav-text">Solution1 一次遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8"><span class="nav-number">36.</span> <span class="nav-text">86. 分隔链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">36.1.</span> <span class="nav-text">Solution1  双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">37.</span> <span class="nav-text">88. 合并两个有序数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B%E7%9B%B4%E6%8E%A5%E5%90%88%E5%B9%B6%E5%90%8E%E6%8E%92%E5%BA%8F"><span class="nav-number">37.1.</span> <span class="nav-text">Solution1 暴力直接合并后排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8F%8C%E6%8C%87%E9%92%88-1"><span class="nav-number">37.2.</span> <span class="nav-text">Solution2 双指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution3-%E9%80%86%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">37.3.</span> <span class="nav-text">Solution3 逆向双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95"><span class="nav-number">38.</span> <span class="nav-text">91. 解码方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="nav-number">38.1.</span> <span class="nav-text">Solution1 动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BC%98%E5%8C%96%E4%B8%BAO-1"><span class="nav-number">38.2.</span> <span class="nav-text">Solution2 动态规划 空间复杂度优化为O(1)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II"><span class="nav-number">39.</span> <span class="nav-text">92. 反转链表 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8E%9F%E5%9C%B0%E5%8F%8D%E8%BD%AC"><span class="nav-number">39.1.</span> <span class="nav-text">Solution1 原地反转</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">40.</span> <span class="nav-text">94. 二叉树的中序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-2"><span class="nav-number">40.1.</span> <span class="nav-text">Solution1 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%BF%AD%E4%BB%A3-1"><span class="nav-number">40.2.</span> <span class="nav-text">Solution2 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">41.</span> <span class="nav-text">96. 不同的二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2"><span class="nav-number">41.1.</span> <span class="nav-text">Solution1 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-II"><span class="nav-number">42.</span> <span class="nav-text">95. 不同的二叉搜索树 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%9B%9E%E6%BA%AF-2"><span class="nav-number">42.1.</span> <span class="nav-text">Solution1 回溯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">43.</span> <span class="nav-text">98. 验证二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-3"><span class="nav-number">43.1.</span> <span class="nav-text">Solution1 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%BA%E5%8D%87%E5%BA%8F"><span class="nav-number">43.2.</span> <span class="nav-text">Solution2 中序遍历为升序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">44.</span> <span class="nav-text">101. 对称二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-4"><span class="nav-number">44.1.</span> <span class="nav-text">Solution1  递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E9%98%9F%E5%88%97"><span class="nav-number">44.2.</span> <span class="nav-text">Solution2 队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">45.</span> <span class="nav-text">102. 二叉树的层序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="nav-number">45.1.</span> <span class="nav-text">Solution1 队列实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0"><span class="nav-number">45.2.</span> <span class="nav-text">Solution2 递归实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">46.</span> <span class="nav-text">103. 二叉树的锯齿形层序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">46.1.</span> <span class="nav-text">Solution1 层序遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">47.</span> <span class="nav-text">104. 二叉树的最大深度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-DFS"><span class="nav-number">47.1.</span> <span class="nav-text">Solution1 DFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Slution2-BFS"><span class="nav-number">47.2.</span> <span class="nav-text">Slution2 BFS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">48.</span> <span class="nav-text">105. 从前序与中序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="nav-number">49.</span> <span class="nav-text">118. 杨辉三角</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E7%9B%B4%E6%8E%A5%E6%B1%82%E8%A7%A3"><span class="nav-number">49.1.</span> <span class="nav-text">Solution1 直接求解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="nav-number">50.</span> <span class="nav-text">114. 二叉树展开为链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-5"><span class="nav-number">50.1.</span> <span class="nav-text">Solution1  递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%BF%AD%E4%BB%A3-2"><span class="nav-number">50.2.</span> <span class="nav-text">Solution2   迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II"><span class="nav-number">51.</span> <span class="nav-text">113. 路径总和 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-DFS-1"><span class="nav-number">51.1.</span> <span class="nav-text">Solution1 DFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-BFS"><span class="nav-number">51.2.</span> <span class="nav-text">Solution2 BFS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#109-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">52.</span> <span class="nav-text">109. 有序链表转换二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%85%88%E6%89%BE%E4%B8%AD%E7%82%B9-%E7%84%B6%E5%90%8E%E5%86%8D%E5%B7%A6%E5%8F%B3%E5%88%86%E5%88%AB%E6%9E%84%E9%80%A0"><span class="nav-number">52.1.</span> <span class="nav-text">Solution1 先找中点 然后再左右分别构造</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-1"><span class="nav-number">53.</span> <span class="nav-text">105. 从前序与中序遍历序列构造二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-6"><span class="nav-number">53.1.</span> <span class="nav-text">Solution1 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-1"><span class="nav-number">53.2.</span> <span class="nav-text">Solution2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="nav-number">54.</span> <span class="nav-text">121. 买卖股票的最佳时机</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95"><span class="nav-number">54.1.</span> <span class="nav-text">Solution0 暴力解法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3"><span class="nav-number">54.2.</span> <span class="nav-text">Solution1 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II"><span class="nav-number">55.</span> <span class="nav-text">122. 买卖股票的最佳时机 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-number">55.1.</span> <span class="nav-text">Solution1 贪心算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2"><span class="nav-number">55.2.</span> <span class="nav-text">Solution2 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="nav-number">56.</span> <span class="nav-text">125. 验证回文串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E7%AD%9B%E9%80%89-%E5%88%A4%E6%96%AD"><span class="nav-number">56.1.</span> <span class="nav-text">Solution1 筛选 + 判断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E7%AD%9B%E9%80%89-%E5%88%A4%E6%96%AD-02"><span class="nav-number">56.2.</span> <span class="nav-text">Solution2 筛选 + 判断 02</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution03-%E5%9C%A8%E5%8E%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8A%E7%9B%B4%E6%8E%A5%E5%88%A4%E6%96%AD"><span class="nav-number">56.3.</span> <span class="nav-text">Solution03 在原字符串上直接判断</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">57.</span> <span class="nav-text">136. 只出现一次的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O-n-%E6%96%B9%E6%B3%95"><span class="nav-number">57.1.</span> <span class="nav-text">Solution1  空间复杂度O(n)方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%A4%ABO-1-%E6%96%B9%E6%B3%95"><span class="nav-number">57.2.</span> <span class="nav-text">Solution2 空间复杂夫O(1)方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#137-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-II"><span class="nav-number">58.</span> <span class="nav-text">137. 只出现一次的数字 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">58.1.</span> <span class="nav-text">Solution1 哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="nav-number">58.2.</span> <span class="nav-text">Solution2 二进制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="nav-number">59.</span> <span class="nav-text">139. 单词拆分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-4"><span class="nav-number">59.1.</span> <span class="nav-text">Solution1 动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%BC%98%E5%8C%96%E7%89%88"><span class="nav-number">59.2.</span> <span class="nav-text">Solution2 动态规划 优化版</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="nav-number">60.</span> <span class="nav-text">141. 环形链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%93%88%E5%B8%8C%E8%A1%A8-1"><span class="nav-number">60.1.</span> <span class="nav-text">Solution1 哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-2"><span class="nav-number">60.2.</span> <span class="nav-text">Solution2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II"><span class="nav-number">61.</span> <span class="nav-text">142. 环形链表 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%93%88%E5%B8%8C%E8%A1%A8-2"><span class="nav-number">61.1.</span> <span class="nav-text">Solution1 哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8F%8C%E6%8C%87%E9%92%88-2"><span class="nav-number">61.2.</span> <span class="nav-text">Solution2 双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"><span class="nav-number">62.</span> <span class="nav-text">143. 重排链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E6%9A%B4%E5%8A%9B-1"><span class="nav-number">62.1.</span> <span class="nav-text">Solution0 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8F%8C%E6%8C%87%E9%92%88-1"><span class="nav-number">62.2.</span> <span class="nav-text">Solution1 双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">63.</span> <span class="nav-text">144. 二叉树的前序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-7"><span class="nav-number">63.1.</span> <span class="nav-text">Solution1 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%BF%AD%E4%BB%A3-3"><span class="nav-number">63.2.</span> <span class="nav-text">Solution2 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#146-LRU-%E7%BC%93%E5%AD%98"><span class="nav-number">64.</span> <span class="nav-text">146. LRU 缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%93%88%E5%B8%8C%E8%A1%A8-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">64.1.</span> <span class="nav-text">Solution1 哈希表 + 双向链表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">65.</span> <span class="nav-text">148. 排序链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">65.1.</span> <span class="nav-text">Solution1 自顶向下归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">65.2.</span> <span class="nav-text">Solution2 自底向上归并排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-number">66.</span> <span class="nav-text">150. 逆波兰表达式求值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%A0%88-1"><span class="nav-number">66.1.</span> <span class="nav-text">Solution1  栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E6%A0%88"><span class="nav-number">66.2.</span> <span class="nav-text">Solution2 数组模拟栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">67.</span> <span class="nav-text">152. 乘积最大子数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E6%9A%B4%E5%8A%9B-2"><span class="nav-number">67.1.</span> <span class="nav-text">Solution0 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-5"><span class="nav-number">67.2.</span> <span class="nav-text">Solution1 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#171-Excel-%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7"><span class="nav-number">68.</span> <span class="nav-text">171. Excel 表列序号</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-26%E8%BF%9B%E5%88%B6"><span class="nav-number">68.1.</span> <span class="nav-text">Solution1  26进制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="nav-number">69.</span> <span class="nav-text">155. 最小栈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%BE%85%E5%8A%A9%E6%A0%88"><span class="nav-number">69.1.</span> <span class="nav-text">Solution1 辅助栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%B8%8D%E7%94%A8%E8%BE%85%E5%8A%A9%E6%A0%88"><span class="nav-number">69.2.</span> <span class="nav-text">Solution2 不用辅助栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="nav-number">70.</span> <span class="nav-text">160. 相交链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88"><span class="nav-number">70.1.</span> <span class="nav-text">Solution1 哈希集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8F%8C%E6%8C%87%E9%92%88-3"><span class="nav-number">70.2.</span> <span class="nav-text">Solution2 双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#162-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC"><span class="nav-number">71.</span> <span class="nav-text">162. 寻找峰值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-12"><span class="nav-number">71.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%BA%8C%E5%88%86%E6%B3%95"><span class="nav-number">71.2.</span> <span class="nav-text">Solution2 二分法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="nav-number">72.</span> <span class="nav-text">169. 多数元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-1-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">72.1.</span> <span class="nav-text">Solution 1 哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-2-%E6%8E%92%E5%BA%8F"><span class="nav-number">72.2.</span> <span class="nav-text">Solution 2  排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-3-Boyer-Moore-%E6%8A%95%E7%A5%A8%E6%B3%95"><span class="nav-number">72.3.</span> <span class="nav-text">Solution 3  Boyer-Moore 投票法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6"><span class="nav-number">73.</span> <span class="nav-text">172. 阶乘后的零</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1"><span class="nav-number">73.1.</span> <span class="nav-text">Solution1</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#179-%E6%9C%80%E5%A4%A7%E6%95%B0"><span class="nav-number">74.</span> <span class="nav-text">179. 最大数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E6%9A%B4%E5%8A%9B-3"><span class="nav-number">74.1.</span> <span class="nav-text">Solution0 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%8E%92%E5%BA%8F-1"><span class="nav-number">74.2.</span> <span class="nav-text">Solution1 排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#187-%E9%87%8D%E5%A4%8D%E7%9A%84DNA%E5%BA%8F%E5%88%97"><span class="nav-number">75.</span> <span class="nav-text">187. 重复的DNA序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%93%88%E5%B8%8C%E8%A1%A8-3"><span class="nav-number">75.1.</span> <span class="nav-text">Solution1 哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%93%88%E5%B8%8C%E8%A1%A8-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="nav-number">75.2.</span> <span class="nav-text">Solution2 哈希表 滑动窗口 二进制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="nav-number">76.</span> <span class="nav-text">189. 轮转数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E4%BD%BF%E7%94%A8%E9%A2%9D%E5%A4%96%E7%9A%84%E6%95%B0%E7%BB%84"><span class="nav-number">76.1.</span> <span class="nav-text">Solution1 使用额外的数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E6%95%B0%E7%BB%84%E7%BF%BB%E8%BD%AC"><span class="nav-number">76.2.</span> <span class="nav-text">Solution2  数组翻转</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="nav-number">77.</span> <span class="nav-text">198. 打家劫舍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-6"><span class="nav-number">77.1.</span> <span class="nav-text">Solution1  动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3"><span class="nav-number">77.2.</span> <span class="nav-text">Solution2 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="nav-number">78.</span> <span class="nav-text">199. 二叉树的右视图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-1"><span class="nav-number">78.1.</span> <span class="nav-text">Solution1 层序遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="nav-number">79.</span> <span class="nav-text">200. 岛屿数量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-DFS-2"><span class="nav-number">79.1.</span> <span class="nav-text">Solution1  DFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-BFS-1"><span class="nav-number">79.2.</span> <span class="nav-text">Solution2 BFS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#202-%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="nav-number">80.</span> <span class="nav-text">202. 快乐数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="nav-number">80.1.</span> <span class="nav-text">Solution1 快慢指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E6%9A%B4%E5%8A%9B"><span class="nav-number">80.2.</span> <span class="nav-text">Solution2 暴力</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="nav-number">81.</span> <span class="nav-text">203. 移除链表元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%BF%AD%E4%BB%A3"><span class="nav-number">81.1.</span> <span class="nav-text">Solution1 迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E9%80%92%E5%BD%92"><span class="nav-number">81.2.</span> <span class="nav-text">Solution2 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">82.</span> <span class="nav-text">206. 反转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%BF%AD%E4%BB%A3-1"><span class="nav-number">82.1.</span> <span class="nav-text">Solution1 迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E9%80%92%E5%BD%92-1"><span class="nav-number">82.2.</span> <span class="nav-text">Solution2 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="nav-number">83.</span> <span class="nav-text">215. 数组中的第K个最大元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">83.1.</span> <span class="nav-text">Solution1  堆排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-number">84.</span> <span class="nav-text">217. 存在重复元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%8E%92%E5%BA%8F-2"><span class="nav-number">84.1.</span> <span class="nav-text">Solution1  排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-3"><span class="nav-number">84.2.</span> <span class="nav-text">Solution2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="nav-number">85.</span> <span class="nav-text">221. 最大正方形</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E6%9A%B4%E5%8A%9B%E6%B3%95"><span class="nav-number">85.1.</span> <span class="nav-text">Solution0 暴力法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-7"><span class="nav-number">85.2.</span> <span class="nav-text">Solution1 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="nav-number">86.</span> <span class="nav-text">225. 用队列实现栈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97"><span class="nav-number">86.1.</span> <span class="nav-text">Solution1  两个队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8D%95%E4%B8%AA%E9%98%9F%E5%88%97"><span class="nav-number">86.2.</span> <span class="nav-text">Solution2 单个队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">87.</span> <span class="nav-text">226. 翻转二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-1"><span class="nav-number">87.1.</span> <span class="nav-text">Solution1</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#227-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8-II"><span class="nav-number">88.</span> <span class="nav-text">227. 基本计算器 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%A0%88-2"><span class="nav-number">88.1.</span> <span class="nav-text">Solution1 栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-number">89.</span> <span class="nav-text">232. 用栈实现队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-2"><span class="nav-number">89.1.</span> <span class="nav-text">Solution1</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="nav-number">90.</span> <span class="nav-text">234. 回文链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E5%B0%86%E9%93%BE%E8%A1%A8%E5%A4%8D%E5%88%B6%E5%88%B0%E6%95%B0%E7%BB%84"><span class="nav-number">90.1.</span> <span class="nav-text">Solution0 将链表复制到数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E4%B8%AD%E7%82%B9%E5%BC%80%E5%A7%8B%E6%AF%94%E8%BE%83"><span class="nav-number">90.2.</span> <span class="nav-text">Solution1 中点开始比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">91.</span> <span class="nav-text">230. 二叉搜索树中第K小的元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%9D%9E%E9%80%92%E5%BD%92"><span class="nav-number">91.1.</span> <span class="nav-text">Solution1  非递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%AE%B0%E5%BD%95%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE"><span class="nav-number">91.2.</span> <span class="nav-text">Solution2 记录子节点数目</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">92.</span> <span class="nav-text">235. 二叉搜索树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%9D%9E%E9%80%92%E5%BD%92-1"><span class="nav-number">92.1.</span> <span class="nav-text">Solution1  非递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E9%80%92%E5%BD%92-2"><span class="nav-number">92.2.</span> <span class="nav-text">Solution2 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">93.</span> <span class="nav-text">236. 二叉树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-8"><span class="nav-number">93.1.</span> <span class="nav-text">Solution1 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">94.</span> <span class="nav-text">237. 删除链表中的节点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-3"><span class="nav-number">94.1.</span> <span class="nav-text">Solution1</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="nav-number">95.</span> <span class="nav-text">238. 除自身以外数组的乘积</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E7%B4%AF%E4%B9%98%E5%88%97%E8%A1%A8"><span class="nav-number">95.1.</span> <span class="nav-text">Solution1 累乘列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAO-1-%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">95.2.</span> <span class="nav-text">Solution2 空间复杂度为O(1)的方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-II"><span class="nav-number">96.</span> <span class="nav-text">240. 搜索二维矩阵 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E6%9A%B4%E5%8A%9B-4"><span class="nav-number">96.1.</span> <span class="nav-text">Solution0 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E4%BB%8E%E5%8F%B3%E4%B8%8A%E8%A7%92%E7%9C%8B%E6%98%AF%E4%B8%80%E9%A2%97%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">96.2.</span> <span class="nav-text">Solution1 从右上角看是一颗二叉搜索树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="nav-number">97.</span> <span class="nav-text">242. 有效的字母异位词</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-1-%E7%9B%B4%E6%8E%A5%E7%94%A8sort%E5%87%BD%E6%95%B0"><span class="nav-number">97.1.</span> <span class="nav-text">Solution1  1.直接用sort函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-2-map%E8%AE%A1%E6%95%B0"><span class="nav-number">97.2.</span> <span class="nav-text">Solution2  2.map计数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution3-3-%E6%95%88%E7%8E%87%E6%9C%80%E9%AB%98"><span class="nav-number">97.3.</span> <span class="nav-text">Solution3  3.效率最高</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#258-%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0"><span class="nav-number">98.</span> <span class="nav-text">258. 各位相加</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%89%BE%E8%A7%84%E5%BE%8B"><span class="nav-number">98.1.</span> <span class="nav-text">Solution1 : 找规律</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%BE%AA%E7%8E%AF"><span class="nav-number">98.2.</span> <span class="nav-text">Solution2 :循环</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#268-%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">99.</span> <span class="nav-text">268. 丢失的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%8E%92%E5%BA%8F-3"><span class="nav-number">99.1.</span> <span class="nav-text">Solution1 排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E6%B1%82%E5%92%8C"><span class="nav-number">99.2.</span> <span class="nav-text">Solution2 求和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution3-%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">99.3.</span> <span class="nav-text">Solution3 位运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution4-%E5%93%88%E5%B8%8C"><span class="nav-number">99.4.</span> <span class="nav-text">Solution4 哈希</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="nav-number">100.</span> <span class="nav-text">279. 完全平方数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-8"><span class="nav-number">100.1.</span> <span class="nav-text">Solution1 动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E6%95%B0%E5%AD%A6"><span class="nav-number">100.2.</span> <span class="nav-text">Solution2  数学</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#283-%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="nav-number">101.</span> <span class="nav-text">283. 移动零</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-4"><span class="nav-number">101.1.</span> <span class="nav-text">Solution1</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0"><span class="nav-number">102.</span> <span class="nav-text">287. 寻找重复数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E4%BA%8C%E5%88%86%E6%B3%95"><span class="nav-number">102.1.</span> <span class="nav-text">Solution1 二分法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%BA%8C%E8%BF%9B%E5%88%B6-1"><span class="nav-number">102.2.</span> <span class="nav-text">Solution2 二进制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution3-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88-1"><span class="nav-number">102.3.</span> <span class="nav-text">Solution3 快慢指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#292-Nim-%E6%B8%B8%E6%88%8F"><span class="nav-number">103.</span> <span class="nav-text">292. Nim 游戏</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%95%B0%E5%AD%A6%E6%8E%A8%E7%90%86"><span class="nav-number">103.1.</span> <span class="nav-text">Solution1 数学推理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">104.</span> <span class="nav-text">300. 最长递增子序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-9"><span class="nav-number">104.1.</span> <span class="nav-text">Solution1 动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%B4%AA%E5%BF%83"><span class="nav-number">104.2.</span> <span class="nav-text">Solution2  贪心</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#313-%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0"><span class="nav-number">105.</span> <span class="nav-text">313. 超级丑数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9C%80%E5%B0%8F%E5%A0%86"><span class="nav-number">105.1.</span> <span class="nav-text">Solution1 最小堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-4"><span class="nav-number">105.2.</span> <span class="nav-text">Solution2 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2"><span class="nav-number">106.</span> <span class="nav-text">322. 零钱兑换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-10"><span class="nav-number">106.1.</span> <span class="nav-text">Solution1 动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%B4%AA%E5%BF%83-%E5%9B%9E%E6%BA%AF-%E5%89%AA%E6%9E%9D"><span class="nav-number">106.2.</span> <span class="nav-text">Solution2 贪心+回溯+剪枝</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#326-3%E7%9A%84%E5%B9%82"><span class="nav-number">107.</span> <span class="nav-text">326.3的幂</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%AF%95%E9%99%A4%E6%B3%95"><span class="nav-number">107.1.</span> <span class="nav-text">Solution1 试除法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E7%BA%A6%E6%95%B0%E6%B3%95"><span class="nav-number">107.2.</span> <span class="nav-text">Solution2 约数法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8"><span class="nav-number">108.</span> <span class="nav-text">328. 奇偶链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8F%8C%E9%93%BE%E6%B3%95"><span class="nav-number">108.1.</span> <span class="nav-text">Solution1 双链法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#334-%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">109.</span> <span class="nav-text">334. 递增的三元子序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%B4%AA%E5%BF%83"><span class="nav-number">109.1.</span> <span class="nav-text">Solution1  贪心</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8F%8C%E5%90%91%E9%81%8D%E5%8E%86"><span class="nav-number">109.2.</span> <span class="nav-text">Solution2 双向遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-III"><span class="nav-number">110.</span> <span class="nav-text">337. 打家劫舍 III</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-11"><span class="nav-number">110.1.</span> <span class="nav-text">Solution1 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#338-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0"><span class="nav-number">111.</span> <span class="nav-text">338. 比特位计数\</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-5"><span class="nav-number">111.1.</span> <span class="nav-text">Solution1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-4"><span class="nav-number">111.2.</span> <span class="nav-text">Solution2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution3"><span class="nav-number">111.3.</span> <span class="nav-text">Solution3</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">112.</span> <span class="nav-text">344. 反转字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8F%8C%E6%8C%87%E9%92%88%E4%BA%A4%E6%8D%A2"><span class="nav-number">112.1.</span> <span class="nav-text">Solution1 双指针交换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="nav-number">113.</span> <span class="nav-text">347. 前 K 个高频元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%8E%92%E5%BA%8F%E6%B3%95"><span class="nav-number">113.1.</span> <span class="nav-text">Solution1 排序法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E6%9C%80%E5%B0%8F%E5%A0%86%E6%B3%95"><span class="nav-number">113.2.</span> <span class="nav-text">Solution2 最小堆法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="nav-number">114.</span> <span class="nav-text">349. 两个数组的交集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-6"><span class="nav-number">114.1.</span> <span class="nav-text">Solution1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-5"><span class="nav-number">114.2.</span> <span class="nav-text">Solution2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#371-%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">115.</span> <span class="nav-text">371. 两整数之和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">115.1.</span> <span class="nav-text">Solution1 位运算</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#378-%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%AC%AC-K-%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">116.</span> <span class="nav-text">378. 有序矩阵中第 K 小的元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-13"><span class="nav-number">116.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E6%9C%80%E5%B0%8F%E5%A0%86"><span class="nav-number">116.2.</span> <span class="nav-text">Solution2 最小堆</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81"><span class="nav-number">117.</span> <span class="nav-text">394. 字符串解码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E4%B8%A4%E4%B8%AA%E6%A0%88"><span class="nav-number">117.1.</span> <span class="nav-text">Solution1 两个栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#402-%E7%A7%BB%E6%8E%89-K-%E4%BD%8D%E6%95%B0%E5%AD%97"><span class="nav-number">118.</span> <span class="nav-text">402. 移掉 K 位数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%B4%AA%E5%BF%83-%E5%8D%95%E8%B0%83%E6%A0%88"><span class="nav-number">118.1.</span> <span class="nav-text">Solution1 贪心+单调栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97"><span class="nav-number">119.</span> <span class="nav-text">406. 根据身高重建队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%85%88%E6%8E%92%E5%BA%8F-%E5%86%8D%E6%8F%92%E9%98%9F"><span class="nav-number">119.1.</span> <span class="nav-text">Solution1 先排序 再插队</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#409-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="nav-number">120.</span> <span class="nav-text">409. 最长回文串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-7"><span class="nav-number">120.1.</span> <span class="nav-text">Solution1</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#415-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0"><span class="nav-number">121.</span> <span class="nav-text">415. 字符串相加</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-8"><span class="nav-number">121.1.</span> <span class="nav-text">Solution1</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="nav-number">122.</span> <span class="nav-text">416. 分割等和子集</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B1%821-2-%E2%80%A6n"><span class="nav-number">123.</span> <span class="nav-text">求1+2+…n</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B1%82%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">124.</span> <span class="nav-text">求滑动窗口的最大值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90"><span class="nav-number">125.</span> <span class="nav-text">扑克牌中的顺子</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACK%E5%A4%A7%E8%8A%82%E7%82%B9"><span class="nav-number">126.</span> <span class="nav-text">二叉搜索树的第K大节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95"><span class="nav-number">127.</span> <span class="nav-text">不用加减乘除做加法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">128.</span> <span class="nav-text">左旋转字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0-n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">129.</span> <span class="nav-text">0~n-1中缺失的数字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">130.</span> <span class="nav-text">最长不含重复字符的子字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">131.</span> <span class="nav-text">滑动窗口的最大值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%92%8C%E4%B8%BAs%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97"><span class="nav-number">132.</span> <span class="nav-text">和为s连续正数序列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="nav-number">133.</span> <span class="nav-text">礼物的最大价值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F"><span class="nav-number">134.</span> <span class="nav-text">翻转单词顺序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-1"><span class="nav-number">135.</span> <span class="nav-text">左旋转字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="nav-number">136.</span> <span class="nav-text">和为s的两个数字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-number">137.</span> <span class="nav-text">数组中数字出现的次数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E4%B8%AA%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-number">138.</span> <span class="nav-text">二叉树中和为某一个值的路径</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-number">139.</span> <span class="nav-text">数组中出现次数超过一半的次数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="nav-number">140.</span> <span class="nav-text">第一个只出现一次的字符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">141.</span> <span class="nav-text">从上到下打印二叉树|||</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-number">142.</span> <span class="nav-text">字符串的排列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0"><span class="nav-number">143.</span> <span class="nav-text">最小的K个数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">144.</span> <span class="nav-text">二叉搜索树与双向链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="nav-number">145.</span> <span class="nav-text">连续子数组的最大和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97"><span class="nav-number">146.</span> <span class="nav-text">栈的压入、弹出序列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><span class="nav-number">147.</span> <span class="nav-text">包含min函数的栈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">148.</span> <span class="nav-text">反转链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9"><span class="nav-number">149.</span> <span class="nav-text">数值的整数次方</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">150.</span> <span class="nav-text">删除链表的节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">151.</span> <span class="nav-text">链表的倒数第K个节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">152.</span> <span class="nav-text">二进制中1的个数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="nav-number">153.</span> <span class="nav-text">顺时针打印矩阵</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">154.</span> <span class="nav-text">对称的二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%BE%97%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D"><span class="nav-number">155.</span> <span class="nav-text">调整数组顺序使得奇数位于偶数前</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="nav-number">156.</span> <span class="nav-text">二叉树的镜像</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91-1"><span class="nav-number">157.</span> <span class="nav-text">对称的二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="nav-number">158.</span> <span class="nav-text">树的子结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="nav-number">159.</span> <span class="nav-text">合并两个排序的链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%AA%E7%BB%B3%E5%AD%90"><span class="nav-number">160.</span> <span class="nav-text">剪绳子</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="nav-number">161.</span> <span class="nav-text">替换空格</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">162.</span> <span class="nav-text">重建二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="nav-number">163.</span> <span class="nav-text">旋转数组的最小数字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC-1"><span class="nav-number">164.</span> <span class="nav-text">替换空格</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"><span class="nav-number">165.</span> <span class="nav-text">从尾到头打印链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC-2"><span class="nav-number">166.</span> <span class="nav-text">替换空格</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="nav-number">167.</span> <span class="nav-text">青蛙跳台阶</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">168.</span> <span class="nav-text">重构字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">169.</span> <span class="nav-text">数组中重复的数字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%AA%E9%99%A4%E6%95%B0"><span class="nav-number">170.</span> <span class="nav-text">自除数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4"><span class="nav-number">171.</span> <span class="nav-text">划分字母区间</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="nav-number">172.</span> <span class="nav-text">每日温度</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">173.</span> <span class="nav-text">最长重复子数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">174.</span> <span class="nav-text">最大二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6"><span class="nav-number">175.</span> <span class="nav-text">1比特与2比特字符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">176.</span> <span class="nav-text">最短无序连续子数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">177.</span> <span class="nav-text">和为K的子数组</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="nav-number">178.</span> <span class="nav-text">二叉树的直径</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">179.</span> <span class="nav-text">找到所有数组中消失的数字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E6%88%90%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91"><span class="nav-number">180.</span> <span class="nav-text">把二叉搜索树转换成为累加树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0"><span class="nav-number">181.</span> <span class="nav-text">数字的补数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84-1"><span class="nav-number">182.</span> <span class="nav-text">二叉树的直径</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="nav-number">183.</span> <span class="nav-text">分发饼干</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB"><span class="nav-number">184.</span> <span class="nav-text">汉明距离</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97-1"><span class="nav-number">185.</span> <span class="nav-text">找到所有数组中消失的数字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">186.</span> <span class="nav-text">最接近的三数之和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="nav-number">187.</span> <span class="nav-text">四数相加||</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80"><span class="nav-number">188.</span> <span class="nav-text">最长公共前缀</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC"><span class="nav-number">189.</span> <span class="nav-text">整数反转</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-number">190.</span> <span class="nav-text">最长回文子串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-number">191.</span> <span class="nav-text">盛水最多的容器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="nav-number">192.</span> <span class="nav-text">无重复字符的最长子串</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
