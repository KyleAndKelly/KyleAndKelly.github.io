<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="Leetcode problems Solutions Note">
<meta property="og:url" content="http://example.com/2022/08/22/Leetcode-problems-Solutions-Note/index.html">
<meta property="og:site_name" content="Blog of Chen">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://files.mdnice.com/user/1489/eb7c965d-59c0-4b08-8d6a-6d3943f10cf5.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7821e311-00aa-40b0-8ab9-57471419d97b.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/cd61b224-e4ae-4271-bef4-076a650f65b3.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e078bf30-d641-4c56-b4c9-8d1da707d807.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e4fa6f50-22c9-41c7-8f6c-e43aab780585.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5cd09d98-bd6d-413f-a699-5d03755f5802.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5bfffdd4-470d-482c-849d-e4e82e2b40d8.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f6e5ea9e-b6b4-4545-97c5-2ef86e5fbd08.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/b3fb36fb-92e9-417d-9c00-60756ed04c17.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/1d658e59-2c76-4ade-a9c5-39a2ff20161f.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7fc31992-dc5b-4e11-bb5e-7c61942e6e57.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4097f955-844e-4ceb-a4c1-513342bc6e37.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/9e16db80-4a17-41b8-9d9d-cdef5be73f58.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/10427a40-975c-4b6b-85ff-d17cc899c623.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/34777dfe-25ba-4a81-883e-b66110b1a8c9.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8b223432-03ba-43a5-8968-584c7c8d8068.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/36ee0f58-1bce-411c-b3fc-308d769ad869.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/97cb5a3b-6aaa-4be9-9b17-dde9d86f17ab.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/80714af6-4b56-4b6d-965a-6d0e396c1b63.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/997007a2-0e00-49d3-88fc-6865a7578af8.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/60ec6cc2-9148-40df-ad8e-2969def89c43.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/56d57700-be9b-4a89-b09c-1d373b1d5318.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8a4705a4-439c-4262-bdce-8186ee916289.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5700074e-68cb-427a-9e58-a1858ab736e1.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/6fc73b94-e500-4182-a9f9-e1d8a4e29a32.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e8db6a23-fe74-4f65-b6a6-6cafbddff0bc.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/319c806f-a568-403a-9a39-c4ac50f30308.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4a4d21b3-ff48-457a-a612-9723074e0647.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5984996e-8148-4ae1-8ed9-8198e3625d2f.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/846120fb-5574-4fde-bd23-c798e938fa6e.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/19d7f700-92c7-4591-bef6-efe163c000f3.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d99bbb87-979c-426b-b6e5-647acf2cad20.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/1a1aae99-5b02-4641-9e50-5bd0913d1e4d.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8aeff7af-53ed-467e-aebc-7835db5b52f5.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5be86979-df7c-4994-a29c-088dc60e24e6.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a825eedd-e311-4153-bc5b-ed31be497911.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/707aac6e-eec8-4f5a-8f0f-b7b45d344451.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ebc2117f-b989-4c3d-b852-4b2b26c77453.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/1d9b3377-72f8-4c1b-8451-a2e484bfdc1c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/166bca4c-bcc2-4718-b6f4-1576acf3ff36.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a150914f-1207-4dc6-8091-639f11405933.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d66220b0-0d89-479e-9313-6adce6816e8c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/17bcb971-2dd2-4659-a84f-24493a37c88e.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/35a4e4dc-eb76-4d87-ba29-735a5042bfe1.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/3f09955d-d39b-41e9-8495-445cf9b35418.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f28b6ed7-01b5-4a89-952f-d626edf15d9e.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/988437b9-f65e-4111-8cde-79a687333027.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c915e202-251b-48cd-816b-cfcabdbf2214.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5f3de36e-929d-4f22-adcb-a8070f305409.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/070d05a3-3ee3-4b0a-90da-bed5c1c2b9a8.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5536a636-d181-42b9-a760-57aff155691a.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/9d910293-a6c0-4c4b-bfd8-c8e32fae01e8.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/fb453ee9-27d8-4bad-86ea-346219e70b18.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/bd915655-54ae-4387-8d94-22cabd830f19.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4391ada0-91de-488d-a3a9-23fa346ea804.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ae0e1058-6b96-43e8-9daa-10bf26ee4ccd.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/779a4035-c7d9-4b9a-b232-3f2cddeaa550.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/12eb162d-772a-41e8-b79b-1e8acfb28d87.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7e979e15-b4a4-41bb-92d8-1cfb54630ee6.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f65c3a6a-debe-4c68-ac3b-171b07af7262.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/9add3a1c-b13f-4277-a2b6-e511bf914864.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/1411c0a9-8a0f-452f-8fc6-ff371d70d1d0.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/fc7adb50-508e-4b31-b28e-f3f11eea8217.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/335701cf-1815-4ee0-a266-d54c6c35669b.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/725fc0e8-c8e6-4660-b971-9c47beb3c888.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7323d75f-2b46-4b8a-9908-4f5c654281f5.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/04aefe28-f537-4f0f-a96c-e08abbe1030f.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/de302c02-3172-4795-81bf-b52f9a497fcf.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d5233fdc-b942-4252-b385-aeaa32428270.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/76432652-12d7-4385-8ea8-6dae686cd490.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e7ac0fe5-7797-4094-a619-f13588081fd5.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f40bfb53-0680-426d-b458-8de6820f7bae.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8079c50a-6dbe-4779-9b7d-ff76f481397d.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ca4fbbe4-2cea-43f3-ac48-3d192c40bacf.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/0b64394f-ee13-447f-835a-965086697e94.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a01bf43a-aa9c-45e4-8e02-e38f1a09bba3.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5f397d41-0fd5-406a-befb-20bb996d6862.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/6ed11899-abbb-4316-b5f5-0905cc477414.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/eef3c25b-9218-4dd9-83d7-392ec8df5f36.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a181f628-892e-4ab3-9509-236d9b01c497.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a1ffabf9-420e-46a6-a2e1-ae5db89d9a6e.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/423b6ac9-a7bd-4bd4-9840-3813d62617b5.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ec008965-da09-4c78-9ad1-83de91a31f4c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/edd0b34a-aae0-4667-8e36-645c0c1fbd04.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/eb446da9-85b1-4898-b238-ee7548e16cc1.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d6347f35-ca4c-425c-b8ca-6b7e2ae2ab07.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a8de2fa0-7abe-474d-a113-bca524a5c19d.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f451fbd9-f97d-4b05-9a25-92f9f405369b.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/724583f7-e9bf-46be-a2e9-235ba7e2d358.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/971e09e6-1b22-4c78-a3bc-956a6d4f1827.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/df37bbbe-bbbb-4e52-b5ae-5ba6fd84cd30.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/cd09a3b7-fdbb-469a-8609-f64f592fda01.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/fb683879-39db-4823-890b-e02d5deeb48c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/b2e898e8-a1bf-4e57-88b2-00546145e9d0.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/bb70337e-337f-4525-9b82-628e0ababa73.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/6b0ad4c7-d06d-477f-a7be-fc2e043a0db5.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/30ba428f-42b6-472b-8b8b-23aaef1c23b6.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f14525cf-e0bb-44a5-a385-54ae95316f9b.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/317b8a93-0319-40c0-9273-c7d6ea72516a.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/19e5cf6f-0c41-4a7c-804d-9d81beac4123.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/44e2b2c5-3a86-4e20-97d1-45502d4bfc29.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/aa634f7b-decf-4a6c-8e21-80efe413f3c1.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/69e49a83-545c-483f-8a37-ec3b834d2e93.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/3cd35f16-15b6-4698-8053-935ffdd85349.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7ee6b978-400a-44f6-8197-a9507c8e058b.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/86154c4e-b8da-4890-ab23-b2612d4c5777.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e65a5f5c-4e4e-4bb7-857a-f5fd4309020f.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/183fb47d-cb82-4909-bfae-8f78c632e7ea.png">
<meta property="article:published_time" content="2022-08-22T14:45:47.000Z">
<meta property="article:modified_time" content="2022-08-30T11:59:59.054Z">
<meta property="article:author" content="Chen">
<meta property="article:tag" content="Leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://files.mdnice.com/user/1489/eb7c965d-59c0-4b08-8d6a-6d3943f10cf5.png">

<link rel="canonical" href="http://example.com/2022/08/22/Leetcode-problems-Solutions-Note/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Leetcode problems Solutions Note | Blog of Chen</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Blog of Chen" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog of Chen</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">陈同学的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/22/Leetcode-problems-Solutions-Note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of Chen">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Leetcode problems Solutions Note
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-22 22:45:47" itemprop="dateCreated datePublished" datetime="2022-08-22T22:45:47+08:00">2022-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-30 19:59:59" itemprop="dateModified" datetime="2022-08-30T19:59:59+08:00">2022-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
                </span>
            </span>

          
            <div class="post-description"> </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <meta name="referrer" content="no-referrer"/>

<h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">1. Two Sum</a></h1><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。<br>示例 2：</p>
<p>输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]<br>示例 3：</p>
<p>输入：nums &#x3D; [3,3], target &#x3D; 6<br>输出：[0,1]
 </p>
<p>提示：</p>
<p>2 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>-109 &lt;&#x3D; target &lt;&#x3D; 109<br>只会存在一个有效答案<br>进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？</p>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>双层遍历</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>哈希表</p>
<h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h1><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：digits &#x3D; “23”<br>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]<br>示例 2：</p>
<p>输入：digits &#x3D; “”<br>输出：[]<br>示例 3：</p>
<p>输入：digits &#x3D; “2”<br>输出：[“a”,”b”,”c”]
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; digits.length &lt;&#x3D; 4<br>digits[i] 是范围 [‘2’, ‘9’] 的一个数字。</p>
<h2 id="Solution-1-暴力"><a href="#Solution-1-暴力" class="headerlink" title="Solution 1  暴力"></a>Solution 1  暴力</h2><h2 id="Soulution-2-回溯"><a href="#Soulution-2-回溯" class="headerlink" title="Soulution 2  回溯"></a>Soulution 2  回溯</h2><p><img src="https://files.mdnice.com/user/1489/eb7c965d-59c0-4b08-8d6a-6d3943f10cf5.png"><br><img src="https://files.mdnice.com/user/1489/7821e311-00aa-40b0-8ab9-57471419d97b.png"></p>
<h2 id="Solution-3-队列"><a href="#Solution-3-队列" class="headerlink" title="Solution 3  队列"></a>Solution 3  队列</h2><p><img src="https://files.mdnice.com/user/1489/cd61b224-e4ae-4271-bef4-076a650f65b3.png"></p>
<p><img src="https://files.mdnice.com/user/1489/e078bf30-d641-4c56-b4c9-8d1da707d807.png"></p>
<p><img src="https://files.mdnice.com/user/1489/e4fa6f50-22c9-41c7-8f6c-e43aab780585.png"></p>
<h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h1><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<p>0 &lt;&#x3D; a, b, c, d &lt; n<br>a、b、c 和 d 互不相同<br>nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target<br>你可以按 任意顺序 返回答案 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0<br>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]<br>示例 2：</p>
<p>输入：nums &#x3D; [2,2,2,2,2], target &#x3D; 8<br>输出：[[2,2,2,2]]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>-109 &lt;&#x3D; target &lt;&#x3D; 109</p>
<h2 id="Solution-1-暴力枚举"><a href="#Solution-1-暴力枚举" class="headerlink" title="Solution 1  暴力枚举"></a>Solution 1  暴力枚举</h2><h2 id="Solution-2-双指针法"><a href="#Solution-2-双指针法" class="headerlink" title="Solution 2  双指针法"></a>Solution 2  双指针法</h2><p><img src="https://files.mdnice.com/user/1489/5cd09d98-bd6d-413f-a699-5d03755f5802.png"></p>
<h1 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list">19. 删除链表的倒数第 N 个结点</a></h1><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>输出：[1,2,3,5]<br>示例 2：</p>
<p>输入：head &#x3D; [1], n &#x3D; 1<br>输出：[]<br>示例 3：</p>
<p>输入：head &#x3D; [1,2], n &#x3D; 1<br>输出：[1]
 </p>
<p>提示：</p>
<p>链表中结点的数目为 sz<br>1 &lt;&#x3D; sz &lt;&#x3D; 30<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>1 &lt;&#x3D; n &lt;&#x3D; sz
 </p>
<h2 id="Solution1-计算链表长度"><a href="#Solution1-计算链表长度" class="headerlink" title="Solution1 计算链表长度"></a>Solution1 计算链表长度</h2><p><img src="https://files.mdnice.com/user/1489/5bfffdd4-470d-482c-849d-e4e82e2b40d8.png"></p>
<h2 id="Solution2-栈"><a href="#Solution2-栈" class="headerlink" title="Solution2 栈"></a>Solution2 栈</h2><p><img src="https://files.mdnice.com/user/1489/f6e5ea9e-b6b4-4545-97c5-2ef86e5fbd08.png"></p>
<p><img src="https://files.mdnice.com/user/1489/b3fb36fb-92e9-417d-9c00-60756ed04c17.png"></p>
<h2 id="Solution3-快慢指针"><a href="#Solution3-快慢指针" class="headerlink" title="Solution3 快慢指针"></a>Solution3 快慢指针</h2><p><img src="https://files.mdnice.com/user/1489/1d658e59-2c76-4ade-a9c5-39a2ff20161f.png"></p>
<p><img src="https://files.mdnice.com/user/1489/7fc31992-dc5b-4e11-bb5e-7c61942e6e57.png"></p>
<p>#<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></p>
<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。
 </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “()”<br>输出：true<br>示例 2：</p>
<p>输入：s &#x3D; “()[]{}”<br>输出：true<br>示例 3：</p>
<p>输入：s &#x3D; “(]”<br>输出：false<br>示例 4：</p>
<p>输入：s &#x3D; “([)]”<br>输出：false<br>示例 5：</p>
<p>输入：s &#x3D; “{[]}”<br>输出：true</p>
<h2 id="Solution1-栈"><a href="#Solution1-栈" class="headerlink" title="Solution1 栈"></a>Solution1 栈</h2><p><img src="https://files.mdnice.com/user/1489/4097f955-844e-4ceb-a4c1-513342bc6e37.png"></p>
<p>#<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></p>
<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
<p>示例 1：</p>
<p>输入：n &#x3D; 3<br>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]<br>示例 2：</p>
<p>输入：n &#x3D; 1<br>输出：[“()”]</p>
<p>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 8</p>
<h2 id="Solution1-暴力"><a href="#Solution1-暴力" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><p><img src="https://files.mdnice.com/user/1489/9e16db80-4a17-41b8-9d9d-cdef5be73f58.png"></p>
<h2 id="Solution2-递归-剪枝"><a href="#Solution2-递归-剪枝" class="headerlink" title="Solution2 递归 + 剪枝"></a>Solution2 递归 + 剪枝</h2><p><img src="https://files.mdnice.com/user/1489/10427a40-975c-4b6b-85ff-d17cc899c623.png"></p>
<h1 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h1><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4]<br>输出：[2,1,4,3]<br>示例 2：</p>
<p>输入：head &#x3D; []<br>输出：[]<br>示例 3：</p>
<p>输入：head &#x3D; [1]<br>输出：[1]</p>
<h2 id="Solution1-递归"><a href="#Solution1-递归" class="headerlink" title="Solution1  递归"></a>Solution1  递归</h2><p><img src="https://files.mdnice.com/user/1489/34777dfe-25ba-4a81-883e-b66110b1a8c9.png"></p>
<h2 id="Solution2-迭代"><a href="#Solution2-迭代" class="headerlink" title="Solution2 迭代"></a>Solution2 迭代</h2><p><img src="https://files.mdnice.com/user/1489/8b223432-03ba-43a5-8968-584c7c8d8068.png"></p>
<p><img src="https://files.mdnice.com/user/1489/36ee0f58-1bce-411c-b3fc-308d769ad869.png"></p>
<h1 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="[26. 删除有序数组中的重复项]"></a>[26. 删除有序数组中的重复项]</h1><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p>
<p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p>
<p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p>
<p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>判题标准:</p>
<p>系统会用下面的代码来测试你的题解:</p>
<p>int[] nums &#x3D; […]; &#x2F;&#x2F; 输入数组<br>int[] expectedNums &#x3D; […]; &#x2F;&#x2F; 长度正确的期望答案</p>
<p>int k &#x3D; removeDuplicates(nums); &#x2F;&#x2F; 调用</p>
<p>assert k &#x3D;&#x3D; expectedNums.length;<br>for (int i &#x3D; 0; i &lt; k; i++) {<br>    assert nums[i] &#x3D;&#x3D; expectedNums[i];<br>}<br>如果所有断言都通过，那么您的题解将被 通过。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,1,2]<br>输出：2, nums &#x3D; [1,2,_]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。<br>示例 2：</p>
<p>输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums &#x3D; [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>nums 已按 升序 排列</p>
<h2 id="Solution1-暴力-1"><a href="#Solution1-暴力-1" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-双指针"><a href="#Solution2-双指针" class="headerlink" title="Solution2 双指针"></a>Solution2 双指针</h2><p><img src="https://files.mdnice.com/user/1489/97cb5a3b-6aaa-4be9-9b17-dde9d86f17ab.png"></p>
<h2 id="Solution3-双指针-优化"><a href="#Solution3-双指针-优化" class="headerlink" title="Solution3 双指针 优化"></a>Solution3 双指针 优化</h2><p><img src="https://files.mdnice.com/user/1489/80714af6-4b56-4b6d-965a-6d0e396c1b63.png"></p>
<h1 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列</a></h1><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p>
<p>例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<p>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。</p>
<p>必须 原地 修改，只允许使用额外常数空间。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3]<br>输出：[1,3,2]<br>示例 2：</p>
<p>输入：nums &#x3D; [3,2,1]<br>输出：[1,2,3]<br>示例 3：</p>
<p>输入：nums &#x3D; [1,1,5]<br>输出：[1,5,1]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p>
<h2 id="Solution1-暴力-2"><a href="#Solution1-暴力-2" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p><img src="https://files.mdnice.com/user/1489/997007a2-0e00-49d3-88fc-6865a7578af8.png"></p>
<h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h1><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
<p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0<br>输出：4<br>示例 2：</p>
<p>输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3<br>输出：-1<br>示例 3：</p>
<p>输入：nums &#x3D; [1], target &#x3D; 0<br>输出：-1
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 5000<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>nums 中的每个值都 独一无二<br>题目数据保证 nums 在预先未知的某个下标上进行了旋转<br>-104 &lt;&#x3D; target &lt;&#x3D; 104</p>
<h2 id="Solution1-暴力-3"><a href="#Solution1-暴力-3" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-二分查找"><a href="#Solution2-二分查找" class="headerlink" title="Solution2 二分查找"></a>Solution2 二分查找</h2><p><img src="https://files.mdnice.com/user/1489/60ec6cc2-9148-40df-ad8e-2969def89c43.png"></p>
<h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h1><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8<br>输出：[3,4]<br>示例 2：</p>
<p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6<br>输出：[-1,-1]<br>示例 3：</p>
<p>输入：nums &#x3D; [], target &#x3D; 0<br>输出：[-1,-1]
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>nums 是一个非递减数组<br>-109 &lt;&#x3D; target &lt;&#x3D; 109</p>
<h2 id="Solution1-暴力-4"><a href="#Solution1-暴力-4" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-二分"><a href="#Solution2-二分" class="headerlink" title="Solution2 二分"></a>Solution2 二分</h2><p>二分搜索讲解<br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1fA4y1o715?spm_id_from=0.0.header_right.history_list.click">https://www.bilibili.com/video/BV1fA4y1o715?spm_id_from=0.0.header_right.history_list.click</a></p>
<p>寻找target在数组里的左右边界，有如下三种情况：</p>
<ul>
<li>情况一：target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1}</li>
<li>情况二：target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1}</li>
<li>情况三：target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{1, 1}</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int leftBorder = getLeftBorder(nums, target);</span><br><span class="line">        int rightBorder = getRightBorder(nums, target);</span><br><span class="line">        // 情况一</span><br><span class="line">        if (leftBorder == -2 || rightBorder == -2) return &#123;-1, -1&#125;;</span><br><span class="line">        // 情况三</span><br><span class="line">        if (rightBorder - leftBorder &gt; 1) return &#123;leftBorder + 1, rightBorder - 1&#125;;</span><br><span class="line">        // 情况二</span><br><span class="line">        return &#123;-1, -1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">     int getRightBorder(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.size() - 1;</span><br><span class="line">        int rightBorder = -2; // 记录一下rightBorder没有被赋值的情况</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int middle = left + ((right - left) / 2);</span><br><span class="line">            if (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - 1;</span><br><span class="line">            &#125; else &#123; // 寻找右边界，nums[middle] == target的时候更新left</span><br><span class="line">                left = middle + 1;</span><br><span class="line">                rightBorder = left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rightBorder;</span><br><span class="line">    &#125;</span><br><span class="line">    int getLeftBorder(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.size() - 1;</span><br><span class="line">        int leftBorder = -2; // 记录一下leftBorder没有被赋值的情况</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int middle = left + ((right - left) / 2);</span><br><span class="line">            if (nums[middle] &gt;= target) &#123; // 寻找左边界，nums[middle] == target的时候更新right</span><br><span class="line">                right = middle - 1;</span><br><span class="line">                leftBorder = right;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left = middle + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return leftBorder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id=""><a href="#" class="headerlink" title=""></a><a href=""></a></h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 O(log n) 的算法。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 5<br>输出: 2<br>示例 2:</p>
<p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 2<br>输出: 1<br>示例 3:</p>
<p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 7<br>输出: 4</p>
<h2 id="Solution1-暴力-5"><a href="#Solution1-暴力-5" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int searchInsert(int[] nums, int target) &#123;</span><br><span class="line">    for(int i = 0; i &lt; nums.length;i++)&#123;</span><br><span class="line">        if(nums[i] &gt;= target)&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-二分-1"><a href="#Solution2-二分-1" class="headerlink" title="Solution2 二分"></a>Solution2 二分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = n; // 定义target在左闭右开的区间里，[left, right)  target</span><br><span class="line">        while (left &lt; right) &#123; // 因为left == right的时候，在[left, right)是无效的空间</span><br><span class="line">            int middle = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">            if (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle; // target 在左区间，在[left, middle)中</span><br><span class="line">            &#125; else if (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + 1; // target 在右区间，在 [middle+1, right)中</span><br><span class="line">            &#125; else &#123; // nums[middle] == target</span><br><span class="line">                return middle; // 数组中找到目标值的情况，直接返回下标</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 分别处理如下四种情况</span><br><span class="line">        // 目标值在数组所有元素之前 [0,0)</span><br><span class="line">        // 目标值等于数组中某一个元素 return middle</span><br><span class="line">        // 目标值插入数组中的位置 [left, right) ，return right 即可</span><br><span class="line">        // 目标值在数组所有元素之后的情况 [left, right)，这是右开区间，return right 即可</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h1><h2 id="Solution1-暴力-6"><a href="#Solution1-暴力-6" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-回溯"><a href="#Solution2-回溯" class="headerlink" title="Solution2 回溯"></a>Solution2 回溯</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;int&gt;&amp; candidates, int target, vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt;&amp; combine, int idx) &#123;</span><br><span class="line">        if (idx == candidates.size()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (target == 0) &#123;</span><br><span class="line">            ans.emplace_back(combine);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 直接跳过</span><br><span class="line">        dfs(candidates, target, ans, combine, idx + 1);</span><br><span class="line">        // 选择当前数</span><br><span class="line">        if (target - candidates[idx] &gt;= 0) &#123;</span><br><span class="line">            combine.emplace_back(candidates[idx]);</span><br><span class="line">            dfs(candidates, target - candidates[idx], ans, combine, idx);</span><br><span class="line">            combine.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        vector&lt;int&gt; combine;</span><br><span class="line">        dfs(candidates, target, ans, combine, 0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h1><h2 id="Solution1-回溯"><a href="#Solution1-回溯" class="headerlink" title="Solution1 回溯"></a>Solution1 回溯</h2><p>方法一：回溯<br>思路与算法</p>
<p>由于我们需要求出所有和为 \textit{target}target 的组合，并且每个数只能使用一次，因此我们可以使用递归 + 回溯的方法来解决这个问题：</p>
<p>我们用 \textit{dfs}(\textit{pos}, \textit{rest})dfs(pos,rest) 表示递归的函数，其中 \textit{pos}pos 表示我们当前递归到了数组 \textit{candidates}candidates 中的第 \textit{pos}pos 个数，而 \textit{rest}rest 表示我们还需要选择和为 \textit{rest}rest 的数放入列表作为一个组合；</p>
<p>对于当前的第 \textit{pos}pos 个数，我们有两种方法：选或者不选。如果我们选了这个数，那么我们调用 \textit{dfs}(\textit{pos} + 1, \textit{rest} - \textit{candidates}[\textit{pos}])dfs(pos+1,rest−candidates[pos]) 进行递归，注意这里必须满足 \textit{rest} \geq \textit{candidates}[\textit{pos}]rest≥candidates[pos]。如果我们不选这个数，那么我们调用 \textit{dfs}(\textit{pos} + 1, \textit{rest})dfs(pos+1,rest) 进行递归；</p>
<p>在某次递归开始前，如果 \textit{rest}rest 的值为 00，说明我们找到了一个和为 \textit{target}target 的组合，将其放入答案中。每次调用递归函数前，如果我们选了那个数，就需要将其放入列表的末尾，该列表中存储了我们选的所有数。在回溯时，如果我们选了那个数，就要将其从列表的末尾删除。</p>
<p>上述算法就是一个标准的递归 + 回溯算法，但是它并不适用于本题。这是因为题目描述中规定了解集不能包含重复的组合，而上述的算法中并没有去除重复的组合。</p>
<p>例如当 \textit{candidates} &#x3D; [2, 2]candidates&#x3D;[2,2]，\textit{target} &#x3D; 2target&#x3D;2 时，上述算法会将列表 [2][2] 放入答案两次。</p>
<p>因此，我们需要改进上述算法，在求出组合的过程中就进行去重的操作。我们可以考虑将相同的数放在一起进行处理，也就是说，如果数 \textit{x}x 出现了 yy 次，那么在递归时一次性地处理它们，即分别调用选择 0, 1, \cdots, y0,1,⋯,y 次 xx 的递归函数。这样我们就不会得到重复的组合。具体地：</p>
<p>我们使用一个哈希映射（HashMap）统计数组 \textit{candidates}candidates 中每个数出现的次数。在统计完成之后，我们将结果放入一个列表 \textit{freq}freq 中，方便后续的递归使用。</p>
<p>列表 \textit{freq}freq 的长度即为数组 \textit{candidates}candidates 中不同数的个数。其中的每一项对应着哈希映射中的一个键值对，即某个数以及它出现的次数。<br>在递归时，对于当前的第 \textit{pos}pos 个数，它的值为 \textit{freq}[\textit{pos}][0]freq[pos][0]，出现的次数为 \textit{freq}[\textit{pos}][1]freq[pos][1]，那么我们可以调用</p>
<p>\textit{dfs}(\textit{pos} + 1, \textit{rest} - i \times \textit{freq}[\textit{pos}][0])<br>dfs(pos+1,rest−i×freq[pos][0])</p>
<p>即我们选择了这个数 ii 次。这里 ii 不能大于这个数出现的次数，并且 i \times \textit{freq}[\textit{pos}][0]i×freq[pos][0] 也不能大于 \textit{rest}rest。同时，我们需要将 ii 个 \textit{freq}[\textit{pos}][0]freq[pos][0] 放入列表中。</p>
<p>这样一来，我们就可以不重复地枚举所有的组合了。</p>
<p>我们还可以进行什么优化（剪枝）呢？一种比较常用的优化方法是，我们将 \textit{freq}freq 根据数从小到大排序，这样我们在递归时会先选择小的数，再选择大的数。这样做的好处是，当我们递归到 \textit{dfs}(\textit{pos}, \textit{rest})dfs(pos,rest) 时，如果 \textit{freq}[\textit{pos}][0]freq[pos][0] 已经大于 \textit{rest}rest，那么后面还没有递归到的数也都大于 \textit{rest}rest，这就说明不可能再选择若干个和为 \textit{rest}rest 的数放入列表了。此时，我们就可以直接回溯。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; freq;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    vector&lt;int&gt; sequence;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void dfs(int pos, int rest) &#123;</span><br><span class="line">        if (rest == 0) &#123;</span><br><span class="line">            ans.push_back(sequence);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (pos == freq.size() || rest &lt; freq[pos].first) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(pos + 1, rest);</span><br><span class="line"></span><br><span class="line">        int most = min(rest / freq[pos].first, freq[pos].second);</span><br><span class="line">        for (int i = 1; i &lt;= most; ++i) &#123;</span><br><span class="line">            sequence.push_back(freq[pos].first);</span><br><span class="line">            dfs(pos + 1, rest - i * freq[pos].first);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= most; ++i) &#123;</span><br><span class="line">            sequence.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        for (int num: candidates) &#123;</span><br><span class="line">            if (freq.empty() || num != freq.back().first) &#123;</span><br><span class="line">                freq.emplace_back(num, 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ++freq.back().second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(0, target);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h1><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]<br>示例 2：</p>
<p>输入：nums &#x3D; [0,1]<br>输出：[[0,1],[1,0]]<br>示例 3：</p>
<p>输入：nums &#x3D; [1]<br>输出：[[1]]
 </p>
<h2 id="Solution1-暴力-7"><a href="#Solution1-暴力-7" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-回溯-1"><a href="#Solution2-回溯-1" class="headerlink" title="Solution2 回溯"></a>Solution2 回溯</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void backtrack(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; output, int first, int len)&#123;</span><br><span class="line">        // 所有数都填完了</span><br><span class="line">        if (first == len) &#123;</span><br><span class="line">            res.emplace_back(output);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = first; i &lt; len; ++i) &#123;</span><br><span class="line">            // 动态维护数组</span><br><span class="line">            swap(output[i], output[first]);</span><br><span class="line">            // 继续递归填下一个数</span><br><span class="line">            backtrack(res, output, first + 1, len);</span><br><span class="line">            // 撤销操作</span><br><span class="line">            swap(output[i], output[first]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">        backtrack(res, nums, 0, (int)nums.size());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h1><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[[7,4,1],[8,5,2],[9,6,3]]<br>示例 2：</p>
<p>输入：matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]<br>输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
 </p>
<p>提示：</p>
<p>n &#x3D;&#x3D; matrix.length &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; n &lt;&#x3D; 20<br>-1000 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 1000
 </p>
<h2 id="Solution1-原地查找"><a href="#Solution1-原地查找" class="headerlink" title="Solution1 原地查找"></a>Solution1 原地查找</h2><h2 id="Solution2-先转置再竖直对称反转"><a href="#Solution2-先转置再竖直对称反转" class="headerlink" title="Solution2 先转置再竖直对称反转"></a>Solution2 先转置再竖直对称反转</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        //先转置</span><br><span class="line">        for(int row=0;row&lt;=matrix.size()-1;row++)&#123;</span><br><span class="line"></span><br><span class="line">            for(int col=row;col&lt;=matrix[0].size()-1;col++)&#123;</span><br><span class="line">                swap(matrix[row][col],matrix[col][row]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //在竖直对称翻转</span><br><span class="line">        for(int row=0;row&lt;=matrix.size()-1;row++)&#123;</span><br><span class="line">            for(int col = 0;col&lt;=(matrix.size()-1)/2;col++)&#123;</span><br><span class="line">                swap(matrix[row][col],matrix[row][matrix.size()-1-col]);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></h1><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p>
<p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: strs &#x3D; [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]<br>示例 2:</p>
<p>输入: strs &#x3D; [“”]<br>输出: [[“”]]<br>示例 3:</p>
<p>输入: strs &#x3D; [“a”]<br>输出: [[“a”]]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; strs.length &lt;&#x3D; 104<br>0 &lt;&#x3D; strs[i].length &lt;&#x3D; 100<br>strs[i] 仅包含小写字母</p>
<h2 id="Solution1-Map"><a href="#Solution1-Map" class="headerlink" title="Solution1 Map"></a>Solution1 Map</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        </span><br><span class="line">        map&lt;string,vector&lt;string&gt;&gt;res;</span><br><span class="line">        //遍历 </span><br><span class="line">        for(auto val:strs)&#123;</span><br><span class="line">            string tmp=val;</span><br><span class="line">               //以排序后的str作为key  vector&lt;string&gt;作为value 放进map</span><br><span class="line">            sort(val.begin(),val.end());</span><br><span class="line">            if(res.find(val)==res.end())&#123;</span><br><span class="line">                vector&lt;string&gt; t=&#123;tmp&#125;;</span><br><span class="line">                res.insert(&#123;val,t&#125;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res[val].push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历输出结果</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">        for(auto p:res)&#123;</span><br><span class="line">            result.push_back(p.second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/powx-n/">50. Pow(x, n)</a></h1><p>实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，xn ）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：x &#x3D; 2.00000, n &#x3D; 10<br>输出：1024.00000<br>示例 2：</p>
<p>输入：x &#x3D; 2.10000, n &#x3D; 3<br>输出：9.26100<br>示例 3：</p>
<p>输入：x &#x3D; 2.00000, n &#x3D; -2<br>输出：0.25000<br>解释：2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25
 </p>
<p>提示：</p>
<p>-100.0 &lt; x &lt; 100.0<br>-231 &lt;&#x3D; n &lt;&#x3D; 231-1<br>-104 &lt;&#x3D; xn &lt;&#x3D; 104</p>
<h2 id="Solution1-快速幂-递归"><a href="#Solution1-快速幂-递归" class="headerlink" title="Solution1  快速幂+递归"></a>Solution1  快速幂+递归</h2><p><img src="https://files.mdnice.com/user/1489/56d57700-be9b-4a89-b09c-1d373b1d5318.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double quickMul(double x, long long N) &#123;</span><br><span class="line">        if (N == 0) &#123;</span><br><span class="line">            return 1.0;</span><br><span class="line">        &#125;</span><br><span class="line">        double y = quickMul(x, N / 2);</span><br><span class="line">        return N % 2 == 0 ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double myPow(double x, int n) &#123;</span><br><span class="line">        long long N = n;</span><br><span class="line">        return N &gt;= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h1><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>子数组 是数组中的一个连续部分。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。<br>示例 2：</p>
<p>输入：nums &#x3D; [1]<br>输出：1<br>示例 3：</p>
<p>输入：nums &#x3D; [5,4,-1,7,8]<br>输出：23
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104
 </p>
<h2 id="Solution1-暴力-8"><a href="#Solution1-暴力-8" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-动态规划"><a href="#Solution2-动态规划" class="headerlink" title="Solution2 动态规划"></a>Solution2 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/8a4705a4-439c-4262-bdce-8186ee916289.png"></p>
<p><img src="https://files.mdnice.com/user/1489/5700074e-68cb-427a-9e58-a1858ab736e1.png"></p>
<h1 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></h1><p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br>示例 2：</p>
<p>输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]
 </p>
<p>提示：</p>
<p>m &#x3D;&#x3D; matrix.length<br>n &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 10<br>-100 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 100</p>
<h2 id="Solution1-原地遍历"><a href="#Solution1-原地遍历" class="headerlink" title="Solution1 原地遍历"></a>Solution1 原地遍历</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">          if(matrix.empty())&#123;return res;&#125;</span><br><span class="line">        int s=0,x=matrix.size()-1,z=0,y=matrix[0].size()-1;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">        while(true)&#123;</span><br><span class="line">            //在上边沿</span><br><span class="line">            for(int i=s,j=z;j&lt;=y;j++)&#123;</span><br><span class="line">                res.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(++s&gt;x)   break;</span><br><span class="line">            //在右边沿</span><br><span class="line">            for(int i=s,j=y;i&lt;=x;i++)&#123;</span><br><span class="line">                  res.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(--y&lt;z) break;</span><br><span class="line">            //在下边沿</span><br><span class="line">           for(int i=x,j=y;j&gt;=z;j--)&#123;</span><br><span class="line">                  res.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(--x&lt;s) break;</span><br><span class="line">            //在左边沿</span><br><span class="line">           for(int i=x,j=z;i&gt;=s;i--)&#123;</span><br><span class="line">                  res.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(++z&gt;y) break;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-按层遍历"><a href="#Solution2-按层遍历" class="headerlink" title="Solution2 按层遍历"></a>Solution2 按层遍历</h2><p><img src="https://files.mdnice.com/user/1489/6fc73b94-e500-4182-a9f9-e1d8a4e29a32.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        if (matrix.size() == 0 || matrix[0].size() == 0) &#123;</span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int rows = matrix.size(), columns = matrix[0].size();</span><br><span class="line">        vector&lt;int&gt; order;</span><br><span class="line">        int left = 0, right = columns - 1, top = 0, bottom = rows - 1;</span><br><span class="line">        while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">            for (int column = left; column &lt;= right; column++) &#123;</span><br><span class="line">                order.push_back(matrix[top][column]);</span><br><span class="line">            &#125;</span><br><span class="line">            for (int row = top + 1; row &lt;= bottom; row++) &#123;</span><br><span class="line">                order.push_back(matrix[row][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            if (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">                for (int column = right - 1; column &gt; left; column--) &#123;</span><br><span class="line">                    order.push_back(matrix[bottom][column]);</span><br><span class="line">                &#125;</span><br><span class="line">                for (int row = bottom; row &gt; top; row--) &#123;</span><br><span class="line">                    order.push_back(matrix[row][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        return order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h1><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<br>示例 2：</p>
<p>输入：intervals &#x3D; [[1,4],[4,5]]<br>输出：[[1,5]]<br>解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; intervals.length &lt;&#x3D; 104<br>intervals[i].length &#x3D;&#x3D; 2<br>0 &lt;&#x3D; starti &lt;&#x3D; endi &lt;&#x3D; 104</p>
<h2 id="Solution1-排序"><a href="#Solution1-排序" class="headerlink" title="Solution1 排序"></a>Solution1 排序</h2><p><img src="https://files.mdnice.com/user/1489/e8db6a23-fe74-4f65-b6a6-6cafbddff0bc.png"></p>
<p>复杂度分析</p>
<p>时间复杂度：O(n\log n)O(nlogn)，其中 nn 为区间的数量。除去排序的开销，我们只需要一次线性扫描，所以主要的时间开销是排序的 O(n\log n)O(nlogn)。</p>
<p>空间复杂度：O(\log n)O(logn)，其中 nn 为区间的数量。这里计算的是存储答案之外，使用的额外空间。O(\log n)O(logn) 即为排序所需要的空间复杂度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        if (intervals.size() == 0) &#123;</span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(intervals.begin(), intervals.end());</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; merged;</span><br><span class="line">        for (int i = 0; i &lt; intervals.size(); ++i) &#123;</span><br><span class="line">            int L = intervals[i][0], R = intervals[i][1];</span><br><span class="line">            if (!merged.size() || merged.back()[1] &lt; L) &#123;</span><br><span class="line">                merged.push_back(&#123;L, R&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                merged.back()[1] = max(merged.back()[1], R);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-list/">61. 旋转链表</a></h1><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2<br>输出：[4,5,1,2,3]<br>示例 2：</p>
<p>输入：head &#x3D; [0,1,2], k &#x3D; 4<br>输出：[2,0,1]
 </p>
<p>提示：</p>
<p>链表中节点的数目在范围 [0, 500] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>0 &lt;&#x3D; k &lt;&#x3D; 2 * 109</p>
<h2 id="Solution1-暴力-9"><a href="#Solution1-暴力-9" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Soluion2-闭环"><a href="#Soluion2-闭环" class="headerlink" title="Soluion2  闭环"></a>Soluion2  闭环</h2><p><img src="https://files.mdnice.com/user/1489/319c806f-a568-403a-9a39-c4ac50f30308.png"></p>
<h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p> </p>
<p>示例 1：</p>
<p>输入：m &#x3D; 3, n &#x3D; 7<br>输出：28<br>示例 2：</p>
<p>输入：m &#x3D; 3, n &#x3D; 2<br>输出：3<br>解释：<br>从左上角开始，总共有 3 条路径可以到达右下角。</p>
<ol>
<li>向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右</li>
<li>向下 -&gt; 向右 -&gt; 向下<br>示例 3：</li>
</ol>
<p>输入：m &#x3D; 7, n &#x3D; 3<br>输出：28<br>示例 4：</p>
<p>输入：m &#x3D; 3, n &#x3D; 3<br>输出：6
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; m, n &lt;&#x3D; 100<br>题目数据保证答案小于等于 2 * 109</p>
<h2 id="Solution1-排列组合"><a href="#Solution1-排列组合" class="headerlink" title="Solution1 排列组合"></a>Solution1 排列组合</h2><p><img src="https://files.mdnice.com/user/1489/4a4d21b3-ff48-457a-a612-9723074e0647.png"></p>
<h2 id="Solution2-动态规划-1"><a href="#Solution2-动态规划-1" class="headerlink" title="Solution2 动态规划"></a>Solution2 动态规划</h2><p>我们令 dp[i][j] 是到达 i, j 最多路径</p>
<p>动态方程：dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1]</p>
<p>注意，对于第一行 dp[0][j]，或者第一列 dp[i][0]，由于都是在边界，所以只能为 1</p>
<p>时间复杂度：O(m*n)O(m∗n)</p>
<p>空间复杂度：O(m * n)O(m∗n)</p>
<p>优化：因为我们每次只需要 dp[i-1][j],dp[i][j-1]</p>
<p>所以我们只要记录这两个数，直接看代码吧！</p>
<p>思路二：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[][] dp = new int[m][n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) dp[0][i] = 1;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) dp[i][0] = 1;</span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m - 1][n - 1];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>优化1：空间复杂度 O(2n)O(2n)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[] pre = new int[n];</span><br><span class="line">        int[] cur = new int[n];</span><br><span class="line">        Arrays.fill(pre, 1);</span><br><span class="line">        Arrays.fill(cur,1);</span><br><span class="line">        for (int i = 1; i &lt; m;i++)&#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++)&#123;</span><br><span class="line">                cur[j] = cur[j-1] + pre[j];</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        return pre[n-1]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化2：空间复杂度 O(n)O(n)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[] cur = new int[n];</span><br><span class="line">        Arrays.fill(cur,1);</span><br><span class="line">        for (int i = 1; i &lt; m;i++)&#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++)&#123;</span><br><span class="line">                cur[j] += cur[j-1] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur[n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h1><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。<br>示例 2：</p>
<p>输入：grid &#x3D; [[1,2,3],[4,5,6]]<br>输出：12
 </p>
<p>提示：</p>
<p>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 200<br>0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 100</p>
<h2 id="Solution0-暴力"><a href="#Solution0-暴力" class="headerlink" title="Solution0 暴力"></a>Solution0 暴力</h2><h2 id="Solution1-动态规划"><a href="#Solution1-动态规划" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/5984996e-8148-4ae1-8ed9-8198e3625d2f.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minPathSum(int[][] grid) &#123;</span><br><span class="line">        for(int i = 0; i &lt; grid.length; i++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; grid[0].length; j++) &#123;</span><br><span class="line">                if(i == 0 &amp;&amp; j == 0) continue;</span><br><span class="line">                else if(i == 0)  grid[i][j] = grid[i][j - 1] + grid[i][j];</span><br><span class="line">                else if(j == 0)  grid[i][j] = grid[i - 1][j] + grid[i][j];</span><br><span class="line">                else grid[i][j] = Math.min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return grid[grid.length - 1][grid[0].length - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/plus-one/">66. 加一</a></h1><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：digits &#x3D; [1,2,3]<br>输出：[1,2,4]<br>解释：输入数组表示数字 123。<br>示例 2：</p>
<p>输入：digits &#x3D; [4,3,2,1]<br>输出：[4,3,2,2]<br>解释：输入数组表示数字 4321。<br>示例 3：</p>
<p>输入：digits &#x3D; [0]<br>输出：[1]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; digits.length &lt;&#x3D; 100<br>0 &lt;&#x3D; digits[i] &lt;&#x3D; 9</p>
<h2 id="Solution-0-暴力"><a href="#Solution-0-暴力" class="headerlink" title="Solution 0  暴力"></a>Solution 0  暴力</h2><h2 id="Solution-1-逆序遍历-找到9"><a href="#Solution-1-逆序遍历-找到9" class="headerlink" title="Solution 1 逆序遍历 找到9"></a>Solution 1 逆序遍历 找到9</h2><p><img src="https://files.mdnice.com/user/1489/846120fb-5574-4fde-bd23-c798e938fa6e.png"></p>
<h1 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根 "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sqrtx/">69. x 的平方根 </a></h1><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p>
<p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p>
<p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：x &#x3D; 4<br>输出：2<br>示例 2：</p>
<p>输入：x &#x3D; 8<br>输出：2<br>解释：8 的算术平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; x &lt;&#x3D; 231 - 1</p>
<h2 id="Solution1-暴力-10"><a href="#Solution1-暴力-10" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-二分搜索"><a href="#Solution2-二分搜索" class="headerlink" title="Solution2 二分搜索"></a>Solution2 二分搜索</h2><p><img src="https://files.mdnice.com/user/1489/19d7f700-92c7-4591-bef6-efe163c000f3.png"></p>
<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h1><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶<br>示例 2：</li>
</ol>
<p>输入：n &#x3D; 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
<p> </p>
<p>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 45</p>
<h2 id="Solution1-递归-1"><a href="#Solution1-递归-1" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">      int dp0=1;</span><br><span class="line">       int dp1=1;</span><br><span class="line">        for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">            int tmp=dp0;</span><br><span class="line">            dp0=dp1;</span><br><span class="line">            dp1=tmp+dp1;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp1;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>






<h1 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a></h1><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>必须在不使用库的sort函数的情况下解决这个问题。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [2,0,2,1,1,0]<br>输出：[0,0,1,1,2,2]<br>示例 2：</p>
<p>输入：nums &#x3D; [2,0,1]<br>输出：[0,1,2]
 </p>
<p>提示：</p>
<p>n &#x3D;&#x3D; nums.length<br>1 &lt;&#x3D; n &lt;&#x3D; 300<br>nums[i] 为 0、1 或 2
 </p>
<p>进阶：</p>
<p>你可以不使用代码库中的排序函数来解决这道题吗？<br>你能想出一个仅使用常数空间的一趟扫描算法吗？</p>
<h2 id="Solution1-暴力-11"><a href="#Solution1-暴力-11" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><p>根据题目中的提示，我们可以统计出数组中 0, 1, 20,1,2 的个数，再根据它们的数量，重写整个数组。这种方法较为简单，也很容易想到，而本题解中会介绍两种基于指针进行交换的方法。</p>
<h2 id="Solution2-单指针"><a href="#Solution2-单指针" class="headerlink" title="Solution2 单指针"></a>Solution2 单指针</h2><p>我们可以考虑对数组进行两次遍历。在第一次遍历中，我们将数组中所有的 00 交换到数组的头部。在第二次遍历中，我们将数组中所有的 11 交换到头部的 00 之后。此时，所有的 22 都出现在数组的尾部，这样我们就完成了排序。</p>
<p>具体地，我们使用一个指针 \textit{ptr}ptr 表示「头部」的范围，\textit{ptr}ptr 中存储了一个整数，表示数组 \textit{nums}nums 从位置 00 到位置 \textit{ptr}-1ptr−1 都属于「头部」。\textit{ptr}ptr 的初始值为 00，表示还没有数处于「头部」。</p>
<p>在第一次遍历中，我们从左向右遍历整个数组，如果找到了 00，那么就需要将 00 与「头部」位置的元素进行交换，并将「头部」向后扩充一个位置。在遍历结束之后，所有的 00 都被交换到「头部」的范围，并且「头部」只包含 00。</p>
<p>在第二次遍历中，我们从「头部」开始，从左向右遍历整个数组，如果找到了 11，那么就需要将 11 与「头部」位置的元素进行交换，并将「头部」向后扩充一个位置。在遍历结束之后，所有的 11 都被交换到「头部」的范围，并且都在 00 之后，此时 22 只出现在「头部」之外的位置，因此排序完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void sortColors(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int ptr = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (nums[i] == 0) &#123;</span><br><span class="line">                swap(nums[i], nums[ptr]);</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = ptr; i &lt; n; ++i) &#123;</span><br><span class="line">            if (nums[i] == 1) &#123;</span><br><span class="line">                swap(nums[i], nums[ptr]);</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution3-双指针"><a href="#Solution3-双指针" class="headerlink" title="Solution3 双指针"></a>Solution3 双指针</h2><p><img src="https://files.mdnice.com/user/1489/d99bbb87-979c-426b-b6e5-647acf2cad20.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void sortColors(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int p0 = 0, p2 = n - 1;</span><br><span class="line">        for (int i = 0; i &lt;= p2; ++i) &#123;</span><br><span class="line">            while (i &lt;= p2 &amp;&amp; nums[i] == 2) &#123;</span><br><span class="line">                swap(nums[i], nums[p2]);</span><br><span class="line">                --p2;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums[i] == 0) &#123;</span><br><span class="line">                swap(nums[i], nums[p0]);</span><br><span class="line">                ++p0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">78. 子集</a></h1><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3]<br>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]<br>示例 2：</p>
<p>输入：nums &#x3D; [0]<br>输出：[[],[0]]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10<br>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10<br>nums 中的所有元素 互不相同</p>
<h2 id="Solution1-回溯-1"><a href="#Solution1-回溯-1" class="headerlink" title="Solution1 回溯"></a>Solution1 回溯</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/comments/1011321">https://leetcode.cn/problems/subsets/comments/1011321</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/">https://leetcode.cn/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line">    void backtracking(vector&lt;int&gt;&amp; nums, int startIndex) &#123;</span><br><span class="line">        result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉自己</span><br><span class="line">        if (startIndex &gt;= nums.size()) &#123; // 终止条件可以不加</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = startIndex; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            path.push_back(nums[i]);</span><br><span class="line">            backtracking(nums, i + 1);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        backtracking(nums, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="90-子集"><a href="#90-子集" class="headerlink" title="90.子集||"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets-ii/">90.子集||</a></h1><h1 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/">77. 组合</a></h1><h1 id="39-组合总和-1"><a href="#39-组合总和-1" class="headerlink" title="39. 组合总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h1><h1 id="40-组合总和-II-1"><a href="#40-组合总和-II-1" class="headerlink" title="40. 组合总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h1><h1 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h1><h1 id="784-字母大小写全排列"><a href="#784-字母大小写全排列" class="headerlink" title="784. 字母大小写全排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-case-permutation/">784. 字母大小写全排列</a></h1><h1 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search/comments/">79. 单词搜索</a></h1><h1 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h1><p>给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,1,2]<br>输出：[1,2]<br>示例 2：</p>
<p>输入：head &#x3D; [1,1,2,3,3]<br>输出：[1,2,3]
 </p>
<p>提示：</p>
<p>链表中节点数目在范围 [0, 300] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>题目数据保证链表已经按升序 排列</p>
<h2 id="Solution1-一次遍历"><a href="#Solution1-一次遍历" class="headerlink" title="Solution1 一次遍历"></a>Solution1 一次遍历</h2><p>方法一：一次遍历<br>思路与算法</p>
<p>由于给定的链表是排好序的，因此重复的元素在链表中出现的位置是连续的，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。</p>
<p>具体地，我们从指针 \textit{cur}cur 指向链表的头节点，随后开始对链表进行遍历。如果当前 \textit{cur}cur 与 \textit{cur.next}cur.next 对应的元素相同，那么我们就将 \textit{cur.next}cur.next 从链表中移除；否则说明链表中已经不存在其它与 \textit{cur}cur 对应的元素相同的节点，因此可以将 \textit{cur}cur 指向 \textit{cur.next}cur.next。</p>
<p>当遍历完整个链表之后，我们返回链表的头节点即可。</p>
<p>细节</p>
<p>当我们遍历到链表的最后一个节点时，\textit{cur.next}cur.next 为空节点，如果不加以判断，访问 \textit{cur.next}cur.next 对应的元素会产生运行错误。因此我们只需要遍历到链表的最后一个节点，而不需要遍历完整个链表。</p>
<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 是链表的长度。</p>
<p>空间复杂度：O(1)O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">        if (!head) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        while (cur-&gt;next) &#123;</span><br><span class="line">            if (cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-list/">86. 分隔链表</a></h1><p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p>
<p>你应当 保留 两个分区中每个节点的初始相对位置。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,4,3,2,5,2], x &#x3D; 3<br>输出：[1,2,2,4,3,5]<br>示例 2：</p>
<p>输入：head &#x3D; [2,1], x &#x3D; 2<br>输出：[1,2]
 </p>
<p>提示：</p>
<p>链表中节点的数目在范围 [0, 200] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>-200 &lt;&#x3D; x &lt;&#x3D; 200</p>
<h2 id="Solution1-双指针"><a href="#Solution1-双指针" class="headerlink" title="Solution1  双指针"></a>Solution1  双指针</h2><p><img src="https://files.mdnice.com/user/1489/1a1aae99-5b02-4641-9e50-5bd0913d1e4d.png"></p>
<h1 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-sorted-array/">88. 合并两个有序数组</a></h1><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>
<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>
<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3<br>输出：[1,2,2,3,5,6]<br>解释：需要合并 [1,2,3] 和 [2,5,6] 。<br>合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。<br>示例 2：</p>
<p>输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0<br>输出：[1]<br>解释：需要合并 [1] 和 [] 。<br>合并结果是 [1] 。<br>示例 3：</p>
<p>输入：nums1 &#x3D; [0], m &#x3D; 0, nums2 &#x3D; [1], n &#x3D; 1<br>输出：[1]<br>解释：需要合并的数组是 [] 和 [1] 。<br>合并结果是 [1] 。<br>注意，因为 m &#x3D; 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。
 </p>
<p>提示：</p>
<p>nums1.length &#x3D;&#x3D; m + n<br>nums2.length &#x3D;&#x3D; n<br>0 &lt;&#x3D; m, n &lt;&#x3D; 200<br>1 &lt;&#x3D; m + n &lt;&#x3D; 200<br>-109 &lt;&#x3D; nums1[i], nums2[j] &lt;&#x3D; 109
 </p>
<p>进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？</p>
<h2 id="Solution1-暴力直接合并后排序"><a href="#Solution1-暴力直接合并后排序" class="headerlink" title="Solution1 暴力直接合并后排序"></a>Solution1 暴力直接合并后排序</h2><p><img src="https://files.mdnice.com/user/1489/8aeff7af-53ed-467e-aebc-7835db5b52f5.png"></p>
<h2 id="Solution2-双指针-1"><a href="#Solution2-双指针-1" class="headerlink" title="Solution2 双指针"></a>Solution2 双指针</h2><p><img src="https://files.mdnice.com/user/1489/5be86979-df7c-4994-a29c-088dc60e24e6.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        int p1 = 0, p2 = 0;</span><br><span class="line">        int sorted[m + n];</span><br><span class="line">        int cur;</span><br><span class="line">        while (p1 &lt; m || p2 &lt; n) &#123;</span><br><span class="line">            if (p1 == m) &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125; else if (p2 == n) &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125; else if (nums1[p1] &lt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">            sorted[p1 + p2 - 1] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i != m + n; ++i) &#123;</span><br><span class="line">            nums1[i] = sorted[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(m+n)O(m+n)。<br>指针移动单调递增，最多移动 m+nm+n 次，因此时间复杂度为 O(m+n)O(m+n)。</p>
<p>空间复杂度：O(m+n)O(m+n)。<br>需要建立长度为 m+nm+n 的中间数组 \textit{sorted}sorted。</p>
<h2 id="Solution3-逆向双指针"><a href="#Solution3-逆向双指针" class="headerlink" title="Solution3 逆向双指针"></a>Solution3 逆向双指针</h2><p><img src="https://files.mdnice.com/user/1489/a825eedd-e311-4153-bc5b-ed31be497911.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        int p1 = m - 1, p2 = n - 1;</span><br><span class="line">        int tail = m + n - 1;</span><br><span class="line">        int cur;</span><br><span class="line">        while (p1 &gt;= 0 || p2 &gt;= 0) &#123;</span><br><span class="line">            if (p1 == -1) &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125; else if (p2 == -1) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; else if (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">            nums1[tail--] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-ways/">91. 解码方法</a></h1><p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p>
<p>‘A’ -&gt; “1”<br>‘B’ -&gt; “2”<br>…<br>‘Z’ -&gt; “26”<br>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p>
<p>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)<br>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p>
<p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p>
<p>题目数据保证答案肯定是一个 32 位 的整数。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “12”<br>输出：2<br>解释：它可以解码为 “AB”（1 2）或者 “L”（12）。<br>示例 2：</p>
<p>输入：s &#x3D; “226”<br>输出：3<br>解释：它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。<br>示例 3：</p>
<p>输入：s &#x3D; “0”<br>输出：0<br>解释：没有字符映射到以 0 开头的数字。<br>含有 0 的有效映射是 ‘J’ -&gt; “10” 和 ‘T’-&gt; “20” 。<br>由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 100<br>s 只包含数字，并且可能包含前导零。<br>通过次数235,094提交次数721,617</p>
<h2 id="Solution1-动态规划-1"><a href="#Solution1-动态规划-1" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/707aac6e-eec8-4f5a-8f0f-b7b45d344451.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numDecodings(string s) &#123;</span><br><span class="line">        if (s[0] == &#x27;0&#x27;) return 0;</span><br><span class="line">        vector&lt;int&gt; dp(s.size()+1);</span><br><span class="line">        dp[0]=1;dp[1]=1;</span><br><span class="line">        for (int i =1; i &lt; s.size(); i++) &#123;</span><br><span class="line">            if (s[i] == &#x27;0&#x27;)//1.s[i]为0的情况</span><br><span class="line">                if (s[i - 1] == &#x27;1&#x27; || s[i - 1] == &#x27;2&#x27;) //s[i - 1]等于1或2的情况</span><br><span class="line">                    dp[i+1] = dp[i-1];//由于s[1]指第二个下标，对应为dp[2],所以dp的下标要比s大1，故为dp[i+1]</span><br><span class="line">                else </span><br><span class="line">                    return 0;</span><br><span class="line">            else //2.s[i]不为0的情况</span><br><span class="line">                if (s[i - 1] == &#x27;1&#x27; || (s[i - 1] == &#x27;2&#x27; &amp;&amp; s[i] &lt;= &#x27;6&#x27;))//s[i-1]s[i]两位数要小于26的情况</span><br><span class="line">                    dp[i+1] = dp[i]+dp[i-1];</span><br><span class="line">                else//其他情况</span><br><span class="line">                    dp[i+1] = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-动态规划-空间复杂度优化为O-1"><a href="#Solution2-动态规划-空间复杂度优化为O-1" class="headerlink" title="Solution2 动态规划 空间复杂度优化为O(1)"></a>Solution2 动态规划 空间复杂度优化为O(1)</h2><p><img src="https://files.mdnice.com/user/1489/ebc2117f-b989-4c3d-b852-4b2b26c77453.png"></p>
<h1 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h1><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。
 </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4,5], left &#x3D; 2, right &#x3D; 4<br>输出：[1,4,3,2,5]<br>示例 2：</p>
<p>输入：head &#x3D; [5], left &#x3D; 1, right &#x3D; 1<br>输出：[5]
 </p>
<p>提示：</p>
<p>链表中节点数目为 n<br>1 &lt;&#x3D; n &lt;&#x3D; 500<br>-500 &lt;&#x3D; Node.val &lt;&#x3D; 500<br>1 &lt;&#x3D; left &lt;&#x3D; right &lt;&#x3D; n
 </p>
<p>进阶： 你可以使用一趟扫描完成反转吗？</p>
<h2 id="Solution1-原地反转"><a href="#Solution1-原地反转" class="headerlink" title="Solution1 原地反转"></a>Solution1 原地反转</h2><p><img src="https://files.mdnice.com/user/1489/1d9b3377-72f8-4c1b-8451-a2e484bfdc1c.png"></p>
<h1 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h1><p>给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,null,2,3]<br>输出：[1,3,2]<br>示例 2：</p>
<p>输入：root &#x3D; []<br>输出：[]<br>示例 3：</p>
<p>输入：root &#x3D; [1]<br>输出：[1]
 </p>
<p>提示：</p>
<p>树中节点数目在范围 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100
 </p>
<h2 id="Solution1-递归-2"><a href="#Solution1-递归-2" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><p><img src="https://files.mdnice.com/user/1489/166bca4c-bcc2-4718-b6f4-1576acf3ff36.png"></p>
<h2 id="Solution2-迭代-1"><a href="#Solution2-迭代-1" class="headerlink" title="Solution2 迭代"></a>Solution2 迭代</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        while (root != nullptr || !stk.empty()) &#123;</span><br><span class="line">            while (root != nullptr) &#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h1 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h1><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 3<br>输出：5<br>示例 2：</p>
<p>输入：n &#x3D; 1<br>输出：1
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 19</p>
<h2 id="Solution1-动态规划-2"><a href="#Solution1-动态规划-2" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p>结题思路：假设n个节点存在二叉排序树的个数是G(n)，1为根节点，2为根节点，…，n为根节点，<br>当1为根节点时，其左子树节点个数为0，右子树节点个数为n-1，<br>同理当2为根节点时，其左子树节点个数为1，右子树节点为n-2，<br>所以可得G(n) &#x3D; G(0)<em>G(n-1)+G(1)</em>(n-2)+…+G(n-1)*G(0)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numTrees(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n + 1);</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j - 1] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>






<h1 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a></h1><p>给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 3<br>输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]<br>示例 2：</p>
<p>输入：n &#x3D; 1<br>输出：[[1]]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 8</p>
<h2 id="Solution1-回溯-2"><a href="#Solution1-回溯-2" class="headerlink" title="Solution1 回溯"></a>Solution1 回溯</h2><p><img src="https://files.mdnice.com/user/1489/a150914f-1207-4dc6-8091-639f11405933.png"></p>
<p><img src="https://files.mdnice.com/user/1489/d66220b0-0d89-479e-9313-6adce6816e8c.png"></p>
<h1 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h1><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p>有效 二叉搜索树定义如下：</p>
<p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。
 </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [2,1,3]<br>输出：true<br>示例 2：</p>
<p>输入：root &#x3D; [5,1,4,null,null,3,6]<br>输出：false<br>解释：根节点的值是 5 ，但是右子节点的值是 4 。
 </p>
<p>提示：</p>
<p>树中节点数目范围在[1, 104] 内<br>-231 &lt;&#x3D; Node.val &lt;&#x3D; 231 - 1</p>
<h2 id="Solution1-递归-3"><a href="#Solution1-递归-3" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><p>方法一: 递归<br>思路和算法</p>
<p>要解决这道题首先我们要了解二叉搜索树有什么性质可以给我们利用，由题目给出的信息我们可以知道：如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。</p>
<p>这启示我们设计一个递归函数 helper(root, lower, upper) 来递归判断，函数表示考虑以 root 为根的子树，判断子树中所有节点的值是否都在 (l,r)(l,r) 的范围内（注意是开区间）。如果 root 节点的值 val 不在 (l,r)(l,r) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。</p>
<p>那么根据二叉搜索树的性质，在递归调用左子树时，我们需要把上界 upper 改为 root.val，即调用 helper(root.left, lower, root.val)，因为左子树里所有节点的值均小于它的根节点的值。同理递归调用右子树时，我们需要把下界 lower 改为 root.val，即调用 helper(root.right, root.val, upper)。</p>
<p>函数递归调用的入口为 helper(root, -inf, +inf)， inf 表示一个无穷大的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool helper(TreeNode* root, long long lower, long long upper) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root -&gt; val &lt;= lower || root -&gt; val &gt;= upper) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return helper(root -&gt; left, lower, root -&gt; val) &amp;&amp; helper(root -&gt; right, root -&gt; val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        return helper(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 为二叉树的节点个数。在递归调用的时候二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)O(n)。</p>
<p>空间复杂度：O(n)O(n)，其中 nn 为二叉树的节点个数。递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，即二叉树的高度。最坏情况下二叉树为一条链，树的高度为 nn ，递归最深达到 nn 层，故最坏情况下空间复杂度为 O(n)O(n) 。</p>
<h2 id="Solution2-中序遍历为升序"><a href="#Solution2-中序遍历为升序" class="headerlink" title="Solution2 中序遍历为升序"></a>Solution2 中序遍历为升序</h2><p>基于方法一中提及的性质，我们可以进一步知道二叉搜索树「中序遍历」得到的值构成的序列一定是升序的，这启示我们在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。如果均大于说明这个序列是升序的，整棵树是二叉搜索树，否则不是，下面的代码我们使用栈来模拟中序遍历的过程。</p>
<p>可能有读者不知道中序遍历是什么，我们这里简单提及。中序遍历是二叉树的一种遍历方式，它先遍历左子树，再遍历根节点，最后遍历右子树。而我们二叉搜索树保证了左子树的节点的值均小于根节点的值，根节点的值均小于右子树的值，因此中序遍历以后得到的序列一定是升序序列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stack;</span><br><span class="line">        long long inorder = (long long)INT_MIN - 1;</span><br><span class="line"></span><br><span class="line">        while (!stack.empty() || root != nullptr) &#123;</span><br><span class="line">            while (root != nullptr) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root -&gt; left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.top();</span><br><span class="line">            stack.pop();</span><br><span class="line">            // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树</span><br><span class="line">            if (root -&gt; val &lt;= inorder) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            inorder = root -&gt; val;</span><br><span class="line">            root = root -&gt; right;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 为二叉树的节点个数。二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)O(n)。</p>
<p>空间复杂度：O(n)O(n)，其中 nn 为二叉树的节点个数。栈最多存储 nn 个节点，因此需要额外的 O(n)O(n) 的空间。</p>
<h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h1><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,2,2,3,4,4,3]<br>输出：true<br>示例 2：</p>
<p>输入：root &#x3D; [1,2,2,null,3,null,3]<br>输出：false
 </p>
<p>提示：</p>
<p>树中节点数目在范围 [1, 1000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100
 </p>
<p>进阶：你可以运用递归和迭代两种方法解决这个问题吗？</p>
<h2 id="Solution1-递归-4"><a href="#Solution1-递归-4" class="headerlink" title="Solution1  递归"></a>Solution1  递归</h2><p><img src="https://files.mdnice.com/user/1489/17bcb971-2dd2-4659-a84f-24493a37c88e.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">		if(root==null) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		//调用递归函数，比较左节点，右节点</span><br><span class="line">		return dfs(root.left,root.right);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	boolean dfs(TreeNode left, TreeNode right) &#123;</span><br><span class="line">		//递归的终止条件是两个节点都为空</span><br><span class="line">		//或者两个节点中有一个为空</span><br><span class="line">		//或者两个节点的值不相等</span><br><span class="line">		if(left==null &amp;&amp; right==null) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		if(left==null || right==null) &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		if(left.val!=right.val) &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		//再递归的比较 左节点的左孩子 和 右节点的右孩子</span><br><span class="line">		//以及比较  左节点的右孩子 和 右节点的左孩子</span><br><span class="line">		return dfs(left.left,right.right) &amp;&amp; dfs(left.right,right.left);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution2-队列"><a href="#Solution2-队列" class="headerlink" title="Solution2 队列"></a>Solution2 队列</h2><p>回想下递归的实现：<br>当两个子树的根节点相等时，就比较:<br>左子树的 left 和 右子树的 right，这个比较是用递归实现的。<br>现在我们改用队列来实现，思路如下：<br>首先从队列中拿出两个节点(left 和 right)比较<br>将 left 的 left 节点和 right 的 right 节点放入队列<br>将 left 的 right 节点和 right 的 left 节点放入队列<br>时间复杂度是 O(n)O(n)，空间复杂度是 O(n)O(n)<br>动画演示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">		if(root==null || (root.left==null &amp;&amp; root.right==null)) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		//用队列保存节点</span><br><span class="line">		LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">		//将根节点的左右孩子放到队列中</span><br><span class="line">		queue.add(root.left);</span><br><span class="line">		queue.add(root.right);</span><br><span class="line">		while(queue.size()&gt;0) &#123;</span><br><span class="line">			//从队列中取出两个节点，再比较这两个节点</span><br><span class="line">			TreeNode left = queue.removeFirst();</span><br><span class="line">			TreeNode right = queue.removeFirst();</span><br><span class="line">			//如果两个节点都为空就继续循环，两者有一个为空就返回false</span><br><span class="line">			if(left==null &amp;&amp; right==null) &#123;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			if(left==null || right==null) &#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">			if(left.val!=right.val) &#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">			//将左节点的左孩子， 右节点的右孩子放入队列</span><br><span class="line">			queue.add(left.left);</span><br><span class="line">			queue.add(right.right);</span><br><span class="line">			//将左节点的右孩子，右节点的左孩子放入队列</span><br><span class="line">			queue.add(left.right);</span><br><span class="line">			queue.add(right.left);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h1><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]<br>示例 2：</p>
<p>输入：root &#x3D; [1]<br>输出：[[1]]<br>示例 3：</p>
<p>输入：root &#x3D; []<br>输出：[]
 </p>
<p>提示：</p>
<p>树中节点数目在范围 [0, 2000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p>
<h2 id="Solution1-队列实现"><a href="#Solution1-队列实现" class="headerlink" title="Solution1 队列实现"></a>Solution1 队列实现</h2><p><img src="https://files.mdnice.com/user/1489/35a4e4dc-eb76-4d87-ba29-735a5042bfe1.png"></p>
<p><img src="https://files.mdnice.com/user/1489/3f09955d-d39b-41e9-8495-445cf9b35418.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector &lt;vector &lt;int&gt;&gt; ret;</span><br><span class="line">        if (!root) &#123;</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue &lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            int currentLevelSize = q.size();</span><br><span class="line">            ret.push_back(vector &lt;int&gt; ());</span><br><span class="line">            for (int i = 1; i &lt;= currentLevelSize; ++i) &#123;</span><br><span class="line">                auto node = q.front(); q.pop();</span><br><span class="line">                ret.back().push_back(node-&gt;val);</span><br><span class="line">                if (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                if (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="Solution2-递归实现"><a href="#Solution2-递归实现" class="headerlink" title="Solution2 递归实现"></a>Solution2 递归实现</h2><p>层序遍历一般来说确实是用队列实现的，但是这里很明显用递归前序遍历就能实现呀，而且复杂度O(n)。。。</p>
<p>要点有几个：</p>
<p>利用depth变量记录当前在第几层（从0开始），进入下层时depth + 1；<br>如果depth &gt;&#x3D; vector.size()说明这一层还没来过，这是第一次来，所以得扩容咯；<br>因为是前序遍历，中-左-右，对于每一层来说，左边的肯定比右边先被遍历到，实际上后序中序都是一样的。。。<br>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        pre(root, 0, ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void pre(TreeNode *root, int depth, vector&lt;vector&lt;int&gt;&gt; &amp;ans) &#123;</span><br><span class="line">        if (!root) return ;</span><br><span class="line">        if (depth &gt;= ans.size())</span><br><span class="line">            ans.push_back(vector&lt;int&gt; &#123;&#125;);</span><br><span class="line">        ans[depth].push_back(root-&gt;val);</span><br><span class="line">        pre(root-&gt;left, depth + 1, ans);</span><br><span class="line">        pre(root-&gt;right, depth + 1, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h1><p>给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[3],[20,9],[15,7]]<br>示例 2：</p>
<p>输入：root &#x3D; [1]<br>输出：[[1]]<br>示例 3：</p>
<p>输入：root &#x3D; []<br>输出：[]
 </p>
<p>提示：</p>
<p>树中节点数目在范围 [0, 2000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p>
<h2 id="Solution1-层序遍历"><a href="#Solution1-层序遍历" class="headerlink" title="Solution1 层序遍历"></a>Solution1 层序遍历</h2><p>层序遍历，然后在奇数时逆序一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">        if(!root) return res;</span><br><span class="line">        </span><br><span class="line">        queue&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        int flag = 0;</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; out;</span><br><span class="line">            int size = q.size(); //取得每一层的长度</span><br><span class="line">            for(int i = 0; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                auto temp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                out.push_back(temp-&gt;val);</span><br><span class="line">                if(temp-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag%2==1)</span><br><span class="line">            &#123;</span><br><span class="line">                reverse(out.begin(),out.end());</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(out);</span><br><span class="line">            flag++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h1><h2 id="Solution1-DFS"><a href="#Solution1-DFS" class="headerlink" title="Solution1 DFS"></a>Solution1 DFS</h2><p><img src="https://files.mdnice.com/user/1489/f28b6ed7-01b5-4a89-952f-d626edf15d9e.png"></p>
<p><img src="https://files.mdnice.com/user/1489/988437b9-f65e-4111-8cde-79a687333027.png"></p>
<h2 id="Slution2-BFS"><a href="#Slution2-BFS" class="headerlink" title="Slution2 BFS"></a>Slution2 BFS</h2><p><img src="https://files.mdnice.com/user/1489/c915e202-251b-48cd-816b-cfcabdbf2214.png"></p>
<h1 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h1><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]<br>输出: [3,9,20,null,null,15,7]<br>示例 2:</p>
<p>输入: preorder &#x3D; [-1], inorder &#x3D; [-1]<br>输出: [-1]
 </p>
<p>提示:</p>
<p>1 &lt;&#x3D; preorder.length &lt;&#x3D; 3000<br>inorder.length &#x3D;&#x3D; preorder.length<br>-3000 &lt;&#x3D; preorder[i], inorder[i] &lt;&#x3D; 3000<br>preorder 和 inorder 均 无重复 元素<br>inorder 均出现在 preorder<br>preorder 保证 为二叉树的前序遍历序列<br>inorder 保证 为二叉树的中序遍历序列</p>
<h1 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/pascals-triangle/">118. 杨辉三角</a></h1><p>给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: numRows &#x3D; 5<br>输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]<br>示例 2:</p>
<p>输入: numRows &#x3D; 1<br>输出: [[1]]</p>
<h2 id="Solution1-直接求解"><a href="#Solution1-直接求解" class="headerlink" title="Solution1 直接求解"></a>Solution1 直接求解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; yanghui;</span><br><span class="line">        for (int i = 0; i &lt; numRows; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; data(i + 1);</span><br><span class="line">            yanghui.push_back(data);</span><br><span class="line">            for (int j = 0; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                if(j == 0) yanghui[i][j] = 1;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    yanghui[i][j] = yanghui[i - 1][j - 1] + yanghui[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            yanghui[i][yanghui[i].size() - 1] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return yanghui;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h1 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h1><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。
 </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,2,5,3,4,null,6]<br>输出：[1,null,2,null,3,null,4,null,5,null,6]<br>示例 2：</p>
<p>输入：root &#x3D; []<br>输出：[]<br>示例 3：</p>
<p>输入：root &#x3D; [0]<br>输出：[0]
 </p>
<p>提示：</p>
<p>树中结点数在范围 [0, 2000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100
 </p>
<h2 id="Solution1-递归-5"><a href="#Solution1-递归-5" class="headerlink" title="Solution1  递归"></a>Solution1  递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* last = nullptr;</span><br><span class="line">void flatten(TreeNode* root) &#123;</span><br><span class="line">    if (root == nullptr) return;</span><br><span class="line">    flatten(root-&gt;right);</span><br><span class="line">    flatten(root-&gt;left);</span><br><span class="line">    root-&gt;right = last;</span><br><span class="line">    root-&gt;left = nullptr;</span><br><span class="line">    last = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Solution2-迭代-2"><a href="#Solution2-迭代-2" class="headerlink" title="Solution2   迭代"></a>Solution2   迭代</h2><p><img src="https://files.mdnice.com/user/1489/5f3de36e-929d-4f22-adcb-a8070f305409.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        while(root)&#123;</span><br><span class="line">            TreeNode* p = root-&gt;left;</span><br><span class="line">            if(p)&#123;</span><br><span class="line">                while(p-&gt;right) p = p-&gt;right; </span><br><span class="line">                p-&gt;right = root-&gt;right;</span><br><span class="line">                root-&gt;right = root-&gt;left;</span><br><span class="line">                root-&gt;left = nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h1><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22<br>输出：[[5,4,11,2],[5,8,4,5]]<br>示例 2：</p>
<p>输入：root &#x3D; [1,2,3], targetSum &#x3D; 5<br>输出：[]<br>示例 3：</p>
<p>输入：root &#x3D; [1,2], targetSum &#x3D; 0<br>输出：[]
 </p>
<p>提示：</p>
<p>树中节点总数在范围 [0, 5000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000<br>-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000</p>
<h2 id="Solution1-DFS-1"><a href="#Solution1-DFS-1" class="headerlink" title="Solution1 DFS"></a>Solution1 DFS</h2><p>我们可以采用深度优先搜索的方式，枚举每一条从根节点到叶子节点的路径。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p>
<p>复杂度分析</p>
<p><img src="https://files.mdnice.com/user/1489/070d05a3-3ee3-4b0a-90da-bed5c1c2b9a8.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ret;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line"></span><br><span class="line">    void dfs(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        path.emplace_back(root-&gt;val);</span><br><span class="line">        targetSum -= root-&gt;val;</span><br><span class="line">        if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr &amp;&amp; targetSum == 0) &#123;</span><br><span class="line">            ret.emplace_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left, targetSum);</span><br><span class="line">        dfs(root-&gt;right, targetSum);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        dfs(root, targetSum);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Solution2-BFS"><a href="#Solution2-BFS" class="headerlink" title="Solution2 BFS"></a>Solution2 BFS</h2><p>方法二：广度优先搜索<br>思路及算法</p>
<p>我们也可以采用广度优先搜索的方式，遍历这棵树。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p>
<p>为了节省空间，我们使用哈希表记录树中的每一个节点的父节点。每次找到一个满足条件的节点，我们就从该节点出发不断向父节点迭代，即可还原出从根节点到当前节点的路径。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ret;</span><br><span class="line">    unordered_map&lt;TreeNode*, TreeNode*&gt; parent;</span><br><span class="line"></span><br><span class="line">    void getPath(TreeNode* node) &#123;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        while (node != nullptr) &#123;</span><br><span class="line">            tmp.emplace_back(node-&gt;val);</span><br><span class="line">            node = parent[node];</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(tmp.begin(), tmp.end());</span><br><span class="line">        ret.emplace_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; que_node;</span><br><span class="line">        queue&lt;int&gt; que_sum;</span><br><span class="line">        que_node.emplace(root);</span><br><span class="line">        que_sum.emplace(0);</span><br><span class="line"></span><br><span class="line">        while (!que_node.empty()) &#123;</span><br><span class="line">            TreeNode* node = que_node.front();</span><br><span class="line">            que_node.pop();</span><br><span class="line">            int rec = que_sum.front() + node-&gt;val;</span><br><span class="line">            que_sum.pop();</span><br><span class="line"></span><br><span class="line">            if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr) &#123;</span><br><span class="line">                if (rec == targetSum) &#123;</span><br><span class="line">                    getPath(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (node-&gt;left != nullptr) &#123;</span><br><span class="line">                    parent[node-&gt;left] = node;</span><br><span class="line">                    que_node.emplace(node-&gt;left);</span><br><span class="line">                    que_sum.emplace(rec);</span><br><span class="line">                &#125;</span><br><span class="line">                if (node-&gt;right != nullptr) &#123;</span><br><span class="line">                    parent[node-&gt;right] = node;</span><br><span class="line">                    que_node.emplace(node-&gt;right);</span><br><span class="line">                    que_sum.emplace(rec);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></h1><p>给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: head &#x3D; [-10,-3,0,5,9]<br>输出: [0,-3,9,-10,null,5]<br>解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。<br>示例 2:</p>
<p>输入: head &#x3D; []<br>输出: []
 </p>
<p>提示:</p>
<p>head 中的节点数在[0, 2 * 104] 范围内<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105</p>
<h2 id="Solution1-先找中点-然后再左右分别构造"><a href="#Solution1-先找中点-然后再左右分别构造" class="headerlink" title="Solution1 先找中点 然后再左右分别构造"></a>Solution1 先找中点 然后再左右分别构造</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode sortedListToBST(ListNode head) &#123;</span><br><span class="line">        if(head == null) return null;</span><br><span class="line">        else if(head.next == null) return new TreeNode(head.val);</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        ListNode p = pre.next;</span><br><span class="line">        ListNode q = p.next;</span><br><span class="line">        //找到链表的中点p</span><br><span class="line">        while(q!=null &amp;&amp; q.next!=null)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            p = pre.next;</span><br><span class="line">            q = q.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //将中点左边的链表分开</span><br><span class="line">        pre.next = null;</span><br><span class="line">        TreeNode root = new TreeNode(p.val);</span><br><span class="line">        root.left = sortedListToBST(head);</span><br><span class="line">        root.right = sortedListToBST(p.next);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="105-从前序与中序遍历序列构造二叉树-1"><a href="#105-从前序与中序遍历序列构造二叉树-1" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h1><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]<br>输出: [3,9,20,null,null,15,7]<br>示例 2:</p>
<p>输入: preorder &#x3D; [-1], inorder &#x3D; [-1]<br>输出: [-1]
 </p>
<p>提示:</p>
<p>1 &lt;&#x3D; preorder.length &lt;&#x3D; 3000<br>inorder.length &#x3D;&#x3D; preorder.length<br>-3000 &lt;&#x3D; preorder[i], inorder[i] &lt;&#x3D; 3000<br>preorder 和 inorder 均 无重复 元素<br>inorder 均出现在 preorder<br>preorder 保证 为二叉树的前序遍历序列<br>inorder 保证 为二叉树的中序遍历序列</p>
<h2 id="Solution1-递归-6"><a href="#Solution1-递归-6" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">        // preorder: [root, [left], [right]]</span><br><span class="line">        // inorder:  [[left], root, [right]]</span><br><span class="line">        return buildTree(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, int lo1, int hi1, vector&lt;int&gt;&amp; inorder, int lo2, int hi2) &#123;</span><br><span class="line">        if (lo1 &gt; hi1 || lo2 &gt; hi2) return nullptr;</span><br><span class="line">        int root = preorder[lo1];</span><br><span class="line">        int mid = lo2;</span><br><span class="line">        // 在 inorder 中查找 root 位置</span><br><span class="line">        for (int i = lo2; i &lt;= hi2; ++i) &#123;</span><br><span class="line">            if (inorder[i] == root) &#123;</span><br><span class="line">                mid = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        auto s = new TreeNode(root);</span><br><span class="line">        // 下面的数组表示分割长度</span><br><span class="line">        // inorder: [mid-lo2, mid, hi2-mid]</span><br><span class="line">        // preorder:[root, mid-lo2, hi2-mid]</span><br><span class="line">        s-&gt;left = buildTree(preorder, lo1+1, lo1+mid-lo2, inorder, lo2, mid-1);</span><br><span class="line">        s-&gt;right = buildTree(preorder, lo1+mid-lo2+1, hi1, inorder, mid+1, hi2);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="Solution2-1"><a href="#Solution2-1" class="headerlink" title="Solution2"></a>Solution2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int getLength(ListNode* head) &#123;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (; head != nullptr; ++ret, head = head-&gt;next);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* buildTree(ListNode*&amp; head, int left, int right) &#123;</span><br><span class="line">        if (left &gt; right) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = (left + right + 1) / 2;</span><br><span class="line">        TreeNode* root = new TreeNode();</span><br><span class="line">        root-&gt;left = buildTree(head, left, mid - 1);</span><br><span class="line">        root-&gt;val = head-&gt;val;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        root-&gt;right = buildTree(head, mid + 1, right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* sortedListToBST(ListNode* head) &#123;</span><br><span class="line">        int length = getLength(head);</span><br><span class="line">        return buildTree(head, 0, length - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h1><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。<br>     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br>示例 2：</p>
<p>输入：prices &#x3D; [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; prices.length &lt;&#x3D; 105<br>0 &lt;&#x3D; prices[i] &lt;&#x3D; 104</p>
<h2 id="Solution0-暴力解法"><a href="#Solution0-暴力解法" class="headerlink" title="Solution0 暴力解法"></a>Solution0 暴力解法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int n = (int)prices.size(), ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            for (int j = i + 1; j &lt; n; ++j) &#123;</span><br><span class="line">                ans = max(ans, prices[j] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-动态规划-3"><a href="#Solution1-动态规划-3" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p>动态规划 前i天的最大收益 &#x3D; max{前i-1天的最大收益，第i天的价格-前i-1天中的最小价格}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        if(prices.length &lt;= 1)</span><br><span class="line">            return 0;</span><br><span class="line">        int min = prices[0], max = 0;</span><br><span class="line">        for(int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, prices[i] - min);</span><br><span class="line">            min = Math.min(min, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h1><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p>
<p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p>
<p>返回 你能获得的 最大 利润 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：prices &#x3D; [7,1,5,3,6,4]<br>输出：7<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。<br>     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6 - 3 &#x3D; 3 。<br>     总利润为 4 + 3 &#x3D; 7 。<br>示例 2：</p>
<p>输入：prices &#x3D; [1,2,3,4,5]<br>输出：4<br>解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。<br>     总利润为 4 。<br>示例 3：</p>
<p>输入：prices &#x3D; [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; prices.length &lt;&#x3D; 3 * 104<br>0 &lt;&#x3D; prices[i] &lt;&#x3D; 104</p>
<h2 id="Solution1-贪心算法"><a href="#Solution1-贪心算法" class="headerlink" title="Solution1 贪心算法"></a>Solution1 贪心算法</h2><p><img src="https://files.mdnice.com/user/1489/5536a636-d181-42b9-a760-57aff155691a.png"></p>
<h2 id="Solution2-动态规划-2"><a href="#Solution2-动态规划-2" class="headerlink" title="Solution2 动态规划"></a>Solution2 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/9d910293-a6c0-4c4b-bfd8-c8e32fae01e8.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int [] dp = new int [prices.length+1];//这里从第0天开始，到底i天</span><br><span class="line">        dp[0] = 0;//第0天没有股票，最大利润为0</span><br><span class="line">        dp[1] = 0;//第一天只能买，不能买，因此最大利润也是0</span><br><span class="line">        for(int i = 1;i&lt;prices.length;i++)&#123;</span><br><span class="line">            int A =dp[i]+prices[i]-prices[i-1];//第一种选择</span><br><span class="line">            int B = dp[i];//第二种选择</span><br><span class="line">            dp[i+1] = A&gt;B ? A : B;//i从0开始，所以dp[I＋1]是当前天数 </span><br><span class="line">        &#125;</span><br><span class="line">        return dp[prices.length];</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-palindrome/">125. 验证回文串</a></h1><p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个回文串。</p>
<p>字母和数字都属于字母数字字符。</p>
<p>给你一个字符串 s，如果它是回文串，返回 true ；否则，返回 false 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入: “A man, a plan, a canal: Panama”<br>输出：true<br>解释：”amanaplanacanalpanama” 是回文串。<br>示例 2：</p>
<p>输入：”race a car”<br>输出：false<br>解释：”raceacar” 不是回文串。<br>示例 3：</p>
<p>输入：s &#x3D; “ “<br>输出：true<br>解释：在移除非字母数字字符之后，s 是一个空字符串 “” 。<br>由于空字符串正着反着读都一样，所以是回文串。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 2 * 105<br>s 仅由可打印的 ASCII 字符组成</p>
<h2 id="Solution1-筛选-判断"><a href="#Solution1-筛选-判断" class="headerlink" title="Solution1 筛选 + 判断"></a>Solution1 筛选 + 判断</h2><p><img src="https://files.mdnice.com/user/1489/fb453ee9-27d8-4bad-86ea-346219e70b18.png"></p>
<h2 id="Solution2-筛选-判断-02"><a href="#Solution2-筛选-判断-02" class="headerlink" title="Solution2 筛选 + 判断 02"></a>Solution2 筛选 + 判断 02</h2><p><img src="https://files.mdnice.com/user/1489/bd915655-54ae-4387-8d94-22cabd830f19.png"></p>
<h2 id="Solution03-在原字符串上直接判断"><a href="#Solution03-在原字符串上直接判断" class="headerlink" title="Solution03 在原字符串上直接判断"></a>Solution03 在原字符串上直接判断</h2><p><img src="https://files.mdnice.com/user/1489/4391ada0-91de-488d-a3a9-23fa346ea804.png"></p>
<h1 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="">136. 只出现一次的数字</a></h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p>示例 1:</p>
<p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p>
<p>输入: [4,1,2,1,2]<br>输出: 4</p>
<h2 id="Solution1-空间复杂度O-n-方法"><a href="#Solution1-空间复杂度O-n-方法" class="headerlink" title="Solution1  空间复杂度O(n)方法"></a>Solution1  空间复杂度O(n)方法</h2><p>如果不考虑时间复杂度和空间复杂度的限制，这道题有很多种解法，可能的解法有如下几种。</p>
<p>使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。</p>
<p>使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。</p>
<p>使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。</p>
<h2 id="Solution2-空间复杂夫O-1-方法"><a href="#Solution2-空间复杂夫O-1-方法" class="headerlink" title="Solution2 空间复杂夫O(1)方法"></a>Solution2 空间复杂夫O(1)方法</h2><p><img src="https://files.mdnice.com/user/1489/ae0e1058-6b96-43e8-9daa-10bf26ee4ccd.png"></p>
<p><img src="https://files.mdnice.com/user/1489/779a4035-c7d9-4b9a-b232-3f2cddeaa550.png"></p>
<h1 id="137-只出现一次的数字-II"><a href="#137-只出现一次的数字-II" class="headerlink" title="137. 只出现一次的数字 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/single-number-ii/">137. 只出现一次的数字 II</a></h1><p>给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [2,2,3,2]<br>输出：3<br>示例 2：</p>
<p>输入：nums &#x3D; [0,1,0,1,0,1,99]<br>输出：99
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104<br>-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1<br>nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次
 </p>
<p>进阶：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<h2 id="Solution1-哈希表"><a href="#Solution1-哈希表" class="headerlink" title="Solution1 哈希表"></a>Solution1 哈希表</h2><p><img src="https://files.mdnice.com/user/1489/12eb162d-772a-41e8-b79b-1e8acfb28d87.png"></p>
<h2 id="Solution2-二进制"><a href="#Solution2-二进制" class="headerlink" title="Solution2 二进制"></a>Solution2 二进制</h2><p><img src="https://files.mdnice.com/user/1489/7e979e15-b4a4-41bb-92d8-1cfb54630ee6.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; 32; ++i) &#123;</span><br><span class="line">            int total = 0;</span><br><span class="line">            for (int num: nums) &#123;</span><br><span class="line">                total += ((num &gt;&gt; i) &amp; 1);</span><br><span class="line">            &#125;</span><br><span class="line">            if (total % 3) &#123;</span><br><span class="line">                ans |= (1 &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(n \log C)O(nlogC)，其中 nn 是数组的长度，CC 是元素的数据范围，在本题中 \log C&#x3D;\log 2^{32} &#x3D; 32logC&#x3D;log2<br>32<br> &#x3D;32，也就是我们需要遍历第 0\sim310∼31 个二进制位。</p>
<p>空间复杂度：O(1)O(1)。</p>
<h1 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></h1><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</p>
<p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<p> </p>
<p>示例 1：</p>
<p>输入: s &#x3D; “leetcode”, wordDict &#x3D; [“leet”, “code”]<br>输出: true<br>解释: 返回 true 因为 “leetcode” 可以由 “leet” 和 “code” 拼接成。<br>示例 2：</p>
<p>输入: s &#x3D; “applepenapple”, wordDict &#x3D; [“apple”, “pen”]<br>输出: true<br>解释: 返回 true 因为 “applepenapple” 可以由 “apple” “pen” “apple” 拼接成。<br>     注意，你可以重复使用字典中的单词。<br>示例 3：</p>
<p>输入: s &#x3D; “catsandog”, wordDict &#x3D; [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出: false
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 300<br>1 &lt;&#x3D; wordDict.length &lt;&#x3D; 1000<br>1 &lt;&#x3D; wordDict[i].length &lt;&#x3D; 20<br>s 和 wordDict[i] 仅有小写英文字母组成<br>wordDict 中的所有字符串 互不相同</p>
<h2 id="Solution1-动态规划-4"><a href="#Solution1-动态规划-4" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</span><br><span class="line">    vector&lt;bool&gt; dp(s.size()+1, false);</span><br><span class="line">    unordered_set&lt;string&gt; m(wordDict.begin(), wordDict.end());</span><br><span class="line">    dp[0] = true;</span><br><span class="line">    for (int i = 1; i &lt;= s.size(); ++i)&#123;</span><br><span class="line">        for (int j = 0; j &lt; i; ++j)&#123;</span><br><span class="line">            if (dp[j] &amp;&amp; m.find(s.substr(j, i-j)) != m.end())&#123;</span><br><span class="line">                dp[i] = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[s.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-动态规划-优化版"><a href="#Solution2-动态规划-优化版" class="headerlink" title="Solution2 动态规划 优化版"></a>Solution2 动态规划 优化版</h2><p>【优化】对于以上代码可以优化。每次并不需要从s[0]开始搜索。因为wordDict中的字符串长度是有限的。只需要从i-maxWordLength开始搜索就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</span><br><span class="line">    vector&lt;bool&gt; dp(s.size()+1, false);</span><br><span class="line">    unordered_set&lt;string&gt; m(wordDict.begin(), wordDict.end());</span><br><span class="line">    dp[0] = true;</span><br><span class="line">    //获取最长字符串长度</span><br><span class="line">    int maxWordLength = 0;</span><br><span class="line">    for (int i = 0; i &lt; wordDict.size(); ++i)&#123;</span><br><span class="line">        maxWordLength = std::max(maxWordLength, (int)wordDict[i].size());</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= s.size(); ++i)&#123;</span><br><span class="line">        for (int j = std::max(i-maxWordLength, 0); j &lt; i; ++j)&#123;</span><br><span class="line">            if (dp[j] &amp;&amp; m.find(s.substr(j, i-j)) != m.end())&#123;</span><br><span class="line">                dp[i] = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[s.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h1><p>给你一个链表的头节点 head ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p>
<p>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p>
<p>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：false<br>解释：链表中没有环。
 </p>
<p>提示：</p>
<p>链表中节点的数目范围是 [0, 104]<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>pos 为 -1 或者链表中的一个 有效索引 。
 </p>
<p>进阶：你能用 O(1)（即，常量）内存解决此问题吗？</p>
<h2 id="Solution1-哈希表-1"><a href="#Solution1-哈希表-1" class="headerlink" title="Solution1 哈希表"></a>Solution1 哈希表</h2><p><img src="https://files.mdnice.com/user/1489/f65c3a6a-debe-4c68-ac3b-171b07af7262.png"></p>
<h2 id="Solution2-2"><a href="#Solution2-2" class="headerlink" title="Solution2"></a>Solution2</h2><p><img src="https://files.mdnice.com/user/1489/9add3a1c-b13f-4277-a2b6-e511bf914864.png"></p>
<p><img src="https://files.mdnice.com/user/1489/1411c0a9-8a0f-452f-8fc6-ff371d70d1d0.png"></p>
<p><img src="https://files.mdnice.com/user/1489/fc7adb50-508e-4b31-b28e-f3f11eea8217.png"></p>
<h1 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h1><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>不允许修改 链表。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p>
<p>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p>
<p>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：返回 null<br>解释：链表中没有环。
 </p>
<p>提示：</p>
<p>链表中节点的数目范围在范围 [0, 104] 内<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>pos 的值为 -1 或者链表中的一个有效索引</p>
<h2 id="Solution1-哈希表-2"><a href="#Solution1-哈希表-2" class="headerlink" title="Solution1 哈希表"></a>Solution1 哈希表</h2><p><img src="https://files.mdnice.com/user/1489/335701cf-1815-4ee0-a266-d54c6c35669b.png"></p>
<h2 id="Solution2-双指针-2"><a href="#Solution2-双指针-2" class="headerlink" title="Solution2 双指针"></a>Solution2 双指针</h2><p><img src="https://files.mdnice.com/user/1489/725fc0e8-c8e6-4660-b971-9c47beb3c888.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        while (fast != nullptr) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            if (fast-&gt;next == nullptr) &#123;</span><br><span class="line">                return nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            if (fast == slow) &#123;</span><br><span class="line">                ListNode *ptr = head;</span><br><span class="line">                while (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                return ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://files.mdnice.com/user/1489/7323d75f-2b46-4b8a-9908-4f5c654281f5.png"></p>
<h1 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reorder-list/">143. 重排链表</a></h1><p>给定一个单链表 L 的头节点 head ，单链表 L 表示为：</p>
<p>L0 → L1 → … → Ln - 1 → Ln<br>请将其重新排列后变为：</p>
<p>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …<br>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4]<br>输出：[1,4,2,3]<br>示例 2：</p>
<p>输入：head &#x3D; [1,2,3,4,5]<br>输出：[1,5,2,4,3]
 </p>
<p>提示：</p>
<p>链表的长度范围为 [1, 5 * 104]<br>1 &lt;&#x3D; node.val &lt;&#x3D; 1000</p>
<h2 id="Solution0-暴力-1"><a href="#Solution0-暴力-1" class="headerlink" title="Solution0 暴力"></a>Solution0 暴力</h2><h2 id="Solution1-双指针-1"><a href="#Solution1-双指针-1" class="headerlink" title="Solution1 双指针"></a>Solution1 双指针</h2><p>1.快慢指针找到中点 2.拆成两个链表 3.遍历两个链表，后面的塞到前面的“缝隙里”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">void reorderList(ListNode* head) &#123;</span><br><span class="line">    </span><br><span class="line">    if(head==NULL || head-&gt;next == NULL)</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line">    //快慢指针分出两段</span><br><span class="line">    ListNode *slow = head,*fast = head;</span><br><span class="line">    </span><br><span class="line">    while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123;</span><br><span class="line">        </span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //后端反转</span><br><span class="line">    ListNode *needReverser = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = NULL;</span><br><span class="line">    needReverser = reverse(needReverser);</span><br><span class="line">    </span><br><span class="line">    //插入前端缝隙</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    while(cur &amp;&amp; needReverser)&#123;</span><br><span class="line">        ListNode *curSecond = needReverser;</span><br><span class="line">        needReverser = needReverser-&gt;next;</span><br><span class="line">        ListNode *nextCur = cur-&gt;next;</span><br><span class="line">        curSecond-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = curSecond;</span><br><span class="line">        </span><br><span class="line">        cur = nextCur;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode *reverse(ListNode *head)&#123;</span><br><span class="line">    </span><br><span class="line">    ListNode *p1 = NULL;</span><br><span class="line">    ListNode *p2 = head;</span><br><span class="line">    ListNode *p3 = p2;</span><br><span class="line">    </span><br><span class="line">    while(p2)&#123;</span><br><span class="line">        p3 = p2-&gt;next;</span><br><span class="line">        p2-&gt;next = p1;</span><br><span class="line">        p1 = p2;</span><br><span class="line">        p2 = p3;            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return p1;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h1><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,null,2,3]<br>输出：[1,2,3]<br>示例 2：</p>
<p>输入：root &#x3D; []<br>输出：[]<br>示例 3：</p>
<p>输入：root &#x3D; [1]<br>输出：[1]<br>示例 4：</p>
<p>输入：root &#x3D; [1,2]<br>输出：[1,2]<br>示例 5：</p>
<p>输入：root &#x3D; [1,null,2]<br>输出：[1,2]
 </p>
<p>提示：</p>
<p>树中节点数目在范围 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p>
<h2 id="Solution1-递归-7"><a href="#Solution1-递归-7" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><p><img src="https://files.mdnice.com/user/1489/04aefe28-f537-4f0f-a96c-e08abbe1030f.png"></p>
<h2 id="Solution2-迭代-3"><a href="#Solution2-迭代-3" class="headerlink" title="Solution2 迭代"></a>Solution2 迭代</h2><p><img src="https://files.mdnice.com/user/1489/de302c02-3172-4795-81bf-b52f9a497fcf.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        while (!stk.empty() || node != nullptr) &#123;</span><br><span class="line">            while (node != nullptr) &#123;</span><br><span class="line">                res.emplace_back(node-&gt;val);</span><br><span class="line">                stk.emplace(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 是二叉树的节点数。每一个节点恰好被遍历一次。</p>
<p>空间复杂度：O(n)O(n)，为迭代过程中显式栈的开销，平均情况下为 O(\log n)O(logn)，最坏情况下树呈现链状，为 O(n)O(n)。</p>
<h1 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h1><p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：<br>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。<br>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p>
<p> </p>
<p>示例：</p>
<p>输入<br>[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”]<br>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]<br>输出<br>[null, null, null, 1, null, -1, null, -1, 3, 4]</p>
<p>解释<br>LRUCache lRUCache &#x3D; new LRUCache(2);<br>lRUCache.put(1, 1); &#x2F;&#x2F; 缓存是 {1&#x3D;1}<br>lRUCache.put(2, 2); &#x2F;&#x2F; 缓存是 {1&#x3D;1, 2&#x3D;2}<br>lRUCache.get(1);    &#x2F;&#x2F; 返回 1<br>lRUCache.put(3, 3); &#x2F;&#x2F; 该操作会使得关键字 2 作废，缓存是 {1&#x3D;1, 3&#x3D;3}<br>lRUCache.get(2);    &#x2F;&#x2F; 返回 -1 (未找到)<br>lRUCache.put(4, 4); &#x2F;&#x2F; 该操作会使得关键字 1 作废，缓存是 {4&#x3D;4, 3&#x3D;3}<br>lRUCache.get(1);    &#x2F;&#x2F; 返回 -1 (未找到)<br>lRUCache.get(3);    &#x2F;&#x2F; 返回 3<br>lRUCache.get(4);    &#x2F;&#x2F; 返回 4
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; capacity &lt;&#x3D; 3000<br>0 &lt;&#x3D; key &lt;&#x3D; 10000<br>0 &lt;&#x3D; value &lt;&#x3D; 105<br>最多调用 2 * 105 次 get 和 put</p>
<h2 id="Solution1-哈希表-双向链表"><a href="#Solution1-哈希表-双向链表" class="headerlink" title="Solution1 哈希表 + 双向链表"></a>Solution1 哈希表 + 双向链表</h2><p>方法一：哈希表 + 双向链表<br>算法</p>
<p>LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。</p>
<p>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</p>
<p>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。</p>
<p>这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1)O(1) 的时间内完成 get 或者 put 操作。具体的方法如下：</p>
<p>对于 get 操作，首先判断 key 是否存在：</p>
<p>如果 key 不存在，则返回 -1−1；</p>
<p>如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。</p>
<p>对于 put 操作，首先判断 key 是否存在：</p>
<p>如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；</p>
<p>如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。</p>
<p>上述各项操作中，访问哈希表的时间复杂度为 O(1)O(1)，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 O(1)O(1)。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 O(1)O(1) 时间内完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">struct DLinkedNode &#123;</span><br><span class="line">    int key, value;</span><br><span class="line">    DLinkedNode* prev;</span><br><span class="line">    DLinkedNode* next;</span><br><span class="line">    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) &#123;&#125;</span><br><span class="line">    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LRUCache &#123;</span><br><span class="line">private:</span><br><span class="line">    unordered_map&lt;int, DLinkedNode*&gt; cache;</span><br><span class="line">    DLinkedNode* head;</span><br><span class="line">    DLinkedNode* tail;</span><br><span class="line">    int size;</span><br><span class="line">    int capacity;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    LRUCache(int _capacity): capacity(_capacity), size(0) &#123;</span><br><span class="line">        // 使用伪头部和伪尾部节点</span><br><span class="line">        head = new DLinkedNode();</span><br><span class="line">        tail = new DLinkedNode();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int get(int key) &#123;</span><br><span class="line">        if (!cache.count(key)) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果 key 存在，先通过哈希表定位，再移到头部</span><br><span class="line">        DLinkedNode* node = cache[key];</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        return node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void put(int key, int value) &#123;</span><br><span class="line">        if (!cache.count(key)) &#123;</span><br><span class="line">            // 如果 key 不存在，创建一个新的节点</span><br><span class="line">            DLinkedNode* node = new DLinkedNode(key, value);</span><br><span class="line">            // 添加进哈希表</span><br><span class="line">            cache[key] = node;</span><br><span class="line">            // 添加至双向链表的头部</span><br><span class="line">            addToHead(node);</span><br><span class="line">            ++size;</span><br><span class="line">            if (size &gt; capacity) &#123;</span><br><span class="line">                // 如果超出容量，删除双向链表的尾部节点</span><br><span class="line">                DLinkedNode* removed = removeTail();</span><br><span class="line">                // 删除哈希表中对应的项</span><br><span class="line">                cache.erase(removed-&gt;key);</span><br><span class="line">                // 防止内存泄漏</span><br><span class="line">                delete removed;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span><br><span class="line">            DLinkedNode* node = cache[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void addToHead(DLinkedNode* node) &#123;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void removeNode(DLinkedNode* node) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void moveToHead(DLinkedNode* node) &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DLinkedNode* removeTail() &#123;</span><br><span class="line">        DLinkedNode* node = tail-&gt;prev;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></h1><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [4,2,1,3]<br>输出：[1,2,3,4]<br>示例 2：</p>
<p>输入：head &#x3D; [-1,5,3,4,0]<br>输出：[-1,0,3,4,5]<br>示例 3：</p>
<p>输入：head &#x3D; []<br>输出：[]
 </p>
<p>提示：</p>
<p>链表中节点的数目在范围 [0, 5 * 104] 内<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105</p>
<h2 id="Solution1-自顶向下归并排序"><a href="#Solution1-自顶向下归并排序" class="headerlink" title="Solution1 自顶向下归并排序"></a>Solution1 自顶向下归并排序</h2><p><img src="https://files.mdnice.com/user/1489/d5233fdc-b942-4252-b385-aeaa32428270.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* sortList(ListNode* head) &#123;</span><br><span class="line">        return sortList(head, nullptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* sortList(ListNode* head, ListNode* tail) &#123;</span><br><span class="line">        if (head == nullptr) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        if (head-&gt;next == tail) &#123;</span><br><span class="line">            head-&gt;next = nullptr;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow = head, *fast = head;</span><br><span class="line">        while (fast != tail) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            if (fast != tail) &#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* mid = slow;</span><br><span class="line">        return merge(sortList(head, mid), sortList(mid, tail));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* merge(ListNode* head1, ListNode* head2) &#123;</span><br><span class="line">        ListNode* dummyHead = new ListNode(0);</span><br><span class="line">        ListNode* temp = dummyHead, *temp1 = head1, *temp2 = head2;</span><br><span class="line">        while (temp1 != nullptr &amp;&amp; temp2 != nullptr) &#123;</span><br><span class="line">            if (temp1-&gt;val &lt;= temp2-&gt;val) &#123;</span><br><span class="line">                temp-&gt;next = temp1;</span><br><span class="line">                temp1 = temp1-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                temp-&gt;next = temp2;</span><br><span class="line">                temp2 = temp2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (temp1 != nullptr) &#123;</span><br><span class="line">            temp-&gt;next = temp1;</span><br><span class="line">        &#125; else if (temp2 != nullptr) &#123;</span><br><span class="line">            temp-&gt;next = temp2;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution2-自底向上归并排序"><a href="#Solution2-自底向上归并排序" class="headerlink" title="Solution2 自底向上归并排序"></a>Solution2 自底向上归并排序</h2><p><img src="https://files.mdnice.com/user/1489/76432652-12d7-4385-8ea8-6dae686cd490.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* sortList(ListNode* head) &#123;</span><br><span class="line">        if (head == nullptr) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        int length = 0;</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        while (node != nullptr) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* dummyHead = new ListNode(0, head);</span><br><span class="line">        for (int subLength = 1; subLength &lt; length; subLength &lt;&lt;= 1) &#123;</span><br><span class="line">            ListNode* prev = dummyHead, *curr = dummyHead-&gt;next;</span><br><span class="line">            while (curr != nullptr) &#123;</span><br><span class="line">                ListNode* head1 = curr;</span><br><span class="line">                for (int i = 1; i &lt; subLength &amp;&amp; curr-&gt;next != nullptr; i++) &#123;</span><br><span class="line">                    curr = curr-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode* head2 = curr-&gt;next;</span><br><span class="line">                curr-&gt;next = nullptr;</span><br><span class="line">                curr = head2;</span><br><span class="line">                for (int i = 1; i &lt; subLength &amp;&amp; curr != nullptr &amp;&amp; curr-&gt;next != nullptr; i++) &#123;</span><br><span class="line">                    curr = curr-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode* next = nullptr;</span><br><span class="line">                if (curr != nullptr) &#123;</span><br><span class="line">                    next = curr-&gt;next;</span><br><span class="line">                    curr-&gt;next = nullptr;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode* merged = merge(head1, head2);</span><br><span class="line">                prev-&gt;next = merged;</span><br><span class="line">                while (prev-&gt;next != nullptr) &#123;</span><br><span class="line">                    prev = prev-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* merge(ListNode* head1, ListNode* head2) &#123;</span><br><span class="line">        ListNode* dummyHead = new ListNode(0);</span><br><span class="line">        ListNode* temp = dummyHead, *temp1 = head1, *temp2 = head2;</span><br><span class="line">        while (temp1 != nullptr &amp;&amp; temp2 != nullptr) &#123;</span><br><span class="line">            if (temp1-&gt;val &lt;= temp2-&gt;val) &#123;</span><br><span class="line">                temp-&gt;next = temp1;</span><br><span class="line">                temp1 = temp1-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                temp-&gt;next = temp2;</span><br><span class="line">                temp2 = temp2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (temp1 != nullptr) &#123;</span><br><span class="line">            temp-&gt;next = temp1;</span><br><span class="line">        &#125; else if (temp2 != nullptr) &#123;</span><br><span class="line">            temp-&gt;next = temp2;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h1><p>根据 逆波兰表示法，求表达式的值。</p>
<p>有效的算符包括 +、-、*、&#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p>注意 两个整数之间的除法只保留整数部分。</p>
<p>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：tokens &#x3D; [“2”,”1”,”+”,”3”,”*”]<br>输出：9<br>解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9<br>示例 2：</p>
<p>输入：tokens &#x3D; [“4”,”13”,”5”,”&#x2F;“,”+”]<br>输出：6<br>解释：该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6<br>示例 3：</p>
<p>输入：tokens &#x3D; [“10”,”6”,”9”,”3”,”+”,”-11”,”<em>“,”&#x2F;“,”</em>“,”17”,”+”,”5”,”+”]<br>输出：22<br>解释：该算式转化为常见的中缀算术表达式为：<br>  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5<br>&#x3D; ((10 * 0) + 17) + 5<br>&#x3D; (0 + 17) + 5<br>&#x3D; 17 + 5<br>&#x3D; 22
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; tokens.length &lt;&#x3D; 104<br>tokens[i] 是一个算符（”+”、”-“、”*” 或 “&#x2F;“），或是在范围 [-200, 200] 内的一个整数
 </p>
<p>逆波兰表达式：</p>
<p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p>
<p>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。<br>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。<br>逆波兰表达式主要有以下两个优点：</p>
<p>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。<br>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</p>
<h2 id="Solution1-栈-1"><a href="#Solution1-栈-1" class="headerlink" title="Solution1  栈"></a>Solution1  栈</h2><p><img src="https://files.mdnice.com/user/1489/e7ac0fe5-7797-4094-a619-f13588081fd5.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">        stack&lt;int&gt; stk;</span><br><span class="line">        int n = tokens.size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            string&amp; token = tokens[i];</span><br><span class="line">            if (isNumber(token)) &#123;</span><br><span class="line">                stk.push(atoi(token.c_str()));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int num2 = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                int num1 = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                switch (token[0]) &#123;</span><br><span class="line">                    case &#x27;+&#x27;:</span><br><span class="line">                        stk.push(num1 + num2);</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;-&#x27;:</span><br><span class="line">                        stk.push(num1 - num2);</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;*&#x27;:</span><br><span class="line">                        stk.push(num1 * num2);</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;/&#x27;:</span><br><span class="line">                        stk.push(num1 / num2);</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stk.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isNumber(string&amp; token) &#123;</span><br><span class="line">        return !(token == &quot;+&quot; || token == &quot;-&quot; || token == &quot;*&quot; || token == &quot;/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 是数组 \textit{tokens}tokens 的长度。需要遍历数组 \textit{tokens}tokens 一次，计算逆波兰表达式的值。</p>
<p>空间复杂度：O(n)O(n)，其中 nn 是数组 \textit{tokens}tokens 的长度。使用栈存储计算过程中的数，栈内元素个数不会超过逆波兰表达式的长度。</p>
<h2 id="Solution2-数组模拟栈"><a href="#Solution2-数组模拟栈" class="headerlink" title="Solution2 数组模拟栈"></a>Solution2 数组模拟栈</h2><p><img src="https://files.mdnice.com/user/1489/f40bfb53-0680-426d-b458-8de6820f7bae.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">        int n = tokens.size();</span><br><span class="line">        vector&lt;int&gt; stk((n + 1) / 2);</span><br><span class="line">        int index = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            string&amp; token = tokens[i];</span><br><span class="line">            if (token.length() &gt; 1 || isdigit(token[0])) &#123;</span><br><span class="line">                index++;</span><br><span class="line">                stk[index] = atoi(token.c_str());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                switch (token[0]) &#123;</span><br><span class="line">                    case &#x27;+&#x27;:</span><br><span class="line">                        index--;</span><br><span class="line">                        stk[index] += stk[index + 1];</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;-&#x27;:</span><br><span class="line">                        index--;</span><br><span class="line">                        stk[index] -= stk[index + 1];</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;*&#x27;:</span><br><span class="line">                        index--;</span><br><span class="line">                        stk[index] *= stk[index + 1];</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;/&#x27;:</span><br><span class="line">                        index--;</span><br><span class="line">                        stk[index] /= stk[index + 1];</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stk[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-product-subarray/">152. 乘积最大子数组</a></h1><p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>测试用例的答案是一个 32-位 整数。</p>
<p>子数组 是数组的连续子序列。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: nums &#x3D; [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。<br>示例 2:</p>
<p>输入: nums &#x3D; [-2,0,-1]<br>输出: 0<br>解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
 </p>
<p>提示:</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 104<br>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10<br>nums 的任何前缀或后缀的乘积都 保证 是一个 32-位 整数</p>
<h2 id="Solution0-暴力-2"><a href="#Solution0-暴力-2" class="headerlink" title="Solution0 暴力"></a>Solution0 暴力</h2><h2 id="Solution1-动态规划-5"><a href="#Solution1-动态规划-5" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/8079c50a-6dbe-4779-9b7d-ff76f481397d.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if(n == 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else if(n == 1) &#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        int p = nums[0];</span><br><span class="line">        int maxP = nums[0];</span><br><span class="line">        int minP = nums[0];</span><br><span class="line">        for(int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            int t = maxP;</span><br><span class="line">            maxP = max(max(maxP * nums[i], nums[i]), minP *nums[i]);</span><br><span class="line">            minP = min(min(t * nums[i], nums[i]), minP * nums[i]);</span><br><span class="line">            p = max(maxP, p);</span><br><span class="line">        &#125;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="171-Excel-表列序号"><a href="#171-Excel-表列序号" class="headerlink" title="171. Excel 表列序号"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/excel-sheet-column-number/">171. Excel 表列序号</a></h1><p>给你一个字符串 columnTitle ，表示 Excel 表格中的列名称。返回 该列名称对应的列序号 。</p>
<p>例如：</p>
<p>A -&gt; 1<br>B -&gt; 2<br>C -&gt; 3<br>…<br>Z -&gt; 26<br>AA -&gt; 27<br>AB -&gt; 28<br>…
 </p>
<p>示例 1:</p>
<p>输入: columnTitle &#x3D; “A”<br>输出: 1<br>示例 2:</p>
<p>输入: columnTitle &#x3D; “AB”<br>输出: 28<br>示例 3:</p>
<p>输入: columnTitle &#x3D; “ZY”<br>输出: 701
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; columnTitle.length &lt;&#x3D; 7<br>columnTitle 仅由大写英文组成<br>columnTitle 在范围 [“A”, “FXSHRXW”] 内</p>
<h2 id="Solution1-26进制"><a href="#Solution1-26进制" class="headerlink" title="Solution1  26进制"></a>Solution1  26进制</h2><p><img src="https://files.mdnice.com/user/1489/ca4fbbe4-2cea-43f3-ac48-3d192c40bacf.png"></p>
<h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-stack/comments/">155. 最小栈</a></h1><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>实现 MinStack 类:</p>
<p>MinStack() 初始化堆栈对象。<br>void push(int val) 将元素val推入堆栈。<br>void pop() 删除堆栈顶部的元素。<br>int top() 获取堆栈顶部的元素。<br>int getMin() 获取堆栈中的最小元素。
 </p>
<p>示例 1:</p>
<p>输入：<br>[“MinStack”,”push”,”push”,”push”,”getMin”,”pop”,”top”,”getMin”]<br>[[],[-2],[0],[-3],[],[],[],[]]</p>
<p>输出：<br>[null,null,null,null,-3,null,0,-2]</p>
<p>解释：<br>MinStack minStack &#x3D; new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.
 </p>
<p>提示：</p>
<p>-231 &lt;&#x3D; val &lt;&#x3D; 231 - 1<br>pop、top 和 getMin 操作总是在 非空栈 上调用<br>push, pop, top, and getMin最多被调用 3 * 104 次</p>
<h2 id="Solution1-辅助栈"><a href="#Solution1-辅助栈" class="headerlink" title="Solution1 辅助栈"></a>Solution1 辅助栈</h2><p><img src="https://files.mdnice.com/user/1489/0b64394f-ee13-447f-835a-965086697e94.png"></p>
<p><img src="https://files.mdnice.com/user/1489/a01bf43a-aa9c-45e4-8e02-e38f1a09bba3.png"></p>
<h2 id="Solution2-不用辅助栈"><a href="#Solution2-不用辅助栈" class="headerlink" title="Solution2 不用辅助栈"></a>Solution2 不用辅助栈</h2><p><img src="https://files.mdnice.com/user/1489/5f397d41-0fd5-406a-befb-20bb996d6862.png"></p>
<h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h1><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p>
<p>图示两个链表在节点 c1 开始相交：</p>
<p>题目数据 保证 整个链式结构中不存在环。</p>
<p>注意，函数返回结果后，链表必须 保持其原始结构 。</p>
<p>自定义评测：</p>
<p>评测系统 的输入如下（你设计的程序 不适用 此输入）：</p>
<p>intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0<br>listA - 第一个链表<br>listB - 第二个链表<br>skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数<br>skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数<br>评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3<br>输出：Intersected at ‘8’<br>解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。<br>在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。<br>示例 2：</p>
<p>输入：intersectVal &#x3D; 2, listA &#x3D; [1,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1<br>输出：Intersected at ‘2’<br>解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。<br>在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。<br>示例 3：</p>
<p>输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2<br>输出：null<br>解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。<br>由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 null 。
 </p>
<p>提示：</p>
<p>listA 中节点数目为 m<br>listB 中节点数目为 n<br>1 &lt;&#x3D; m, n &lt;&#x3D; 3 * 104<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>0 &lt;&#x3D; skipA &lt;&#x3D; m<br>0 &lt;&#x3D; skipB &lt;&#x3D; n<br>如果 listA 和 listB 没有交点，intersectVal 为 0<br>如果 listA 和 listB 有交点，intersectVal &#x3D;&#x3D; listA[skipA] &#x3D;&#x3D; listB[skipB]
 </p>
<p>进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？</p>
<h2 id="Solution1-哈希集合"><a href="#Solution1-哈希集合" class="headerlink" title="Solution1 哈希集合"></a>Solution1 哈希集合</h2><p><img src="https://files.mdnice.com/user/1489/6ed11899-abbb-4316-b5f5-0905cc477414.png"></p>
<h2 id="Solution2-双指针-3"><a href="#Solution2-双指针-3" class="headerlink" title="Solution2 双指针"></a>Solution2 双指针</h2><p><img src="https://files.mdnice.com/user/1489/eef3c25b-9218-4dd9-83d7-392ec8df5f36.png"></p>
<p><img src="https://files.mdnice.com/user/1489/a181f628-892e-4ab3-9509-236d9b01c497.png"></p>
<p><img src="https://files.mdnice.com/user/1489/a1ffabf9-420e-46a6-a2e1-ae5db89d9a6e.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        if (headA == nullptr || headB == nullptr) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *pA = headA, *pB = headB;</span><br><span class="line">        while (pA != pB) &#123;</span><br><span class="line">            pA = pA == nullptr ? headB : pA-&gt;next;</span><br><span class="line">            pB = pB == nullptr ? headA : pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162. 寻找峰值"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-peak-element/">162. 寻找峰值</a></h1><p>峰值元素是指其值严格大于左右相邻值的元素。</p>
<p>给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</p>
<p>你可以假设 nums[-1] &#x3D; nums[n] &#x3D; -∞ 。</p>
<p>你必须实现时间复杂度为 O(log n) 的算法来解决此问题。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3,1]<br>输出：2<br>解释：3 是峰值元素，你的函数应该返回其索引 2。<br>示例 2：</p>
<p>输入：nums &#x3D; [1,2,1,3,5,6,4]<br>输出：1 或 5<br>解释：你的函数可以返回索引 1，其峰值元素为 2；<br>     或者返回索引 5， 其峰值元素为 6。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 1000<br>-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1<br>对于所有有效的 i 都有 nums[i] !&#x3D; nums[i + 1]</p>
<h2 id="Solution1-暴力-12"><a href="#Solution1-暴力-12" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><p><img src="https://files.mdnice.com/user/1489/423b6ac9-a7bd-4bd4-9840-3813d62617b5.png"></p>
<h2 id="Solution2-二分法"><a href="#Solution2-二分法" class="headerlink" title="Solution2 二分法"></a>Solution2 二分法</h2><p><img src="https://files.mdnice.com/user/1489/ec008965-da09-4c78-9ad1-83de91a31f4c.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int findPeakElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int left = 0, right = nums.size() - 1;</span><br><span class="line">    while (left &lt; right ) &#123;</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if (nums[mid] &lt; nums[mid + 1]) &#123;</span><br><span class="line">            left = mid+1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right = mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/majority-element/">169. 多数元素</a></h1><p><img src="https://files.mdnice.com/user/1489/edd0b34a-aae0-4667-8e36-645c0c1fbd04.png"></p>
<h2 id="Solution-1-哈希表"><a href="#Solution-1-哈希表" class="headerlink" title="Solution 1 哈希表"></a>Solution 1 哈希表</h2><p><img src="https://files.mdnice.com/user/1489/eb446da9-85b1-4898-b238-ee7548e16cc1.png"></p>
<p><img src="https://files.mdnice.com/user/1489/d6347f35-ca4c-425c-b8ca-6b7e2ae2ab07.png"></p>
<h2 id="Solution-2-排序"><a href="#Solution-2-排序" class="headerlink" title="Solution 2  排序"></a>Solution 2  排序</h2><p><img src="https://files.mdnice.com/user/1489/a8de2fa0-7abe-474d-a113-bca524a5c19d.png"></p>
<h2 id="Solution-3-Boyer-Moore-投票法"><a href="#Solution-3-Boyer-Moore-投票法" class="headerlink" title="Solution 3  Boyer-Moore 投票法"></a>Solution 3  Boyer-Moore 投票法</h2><p><img src="https://files.mdnice.com/user/1489/f451fbd9-f97d-4b05-9a25-92f9f405369b.png"></p>
<h1 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172. 阶乘后的零"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/factorial-trailing-zeroes/">172. 阶乘后的零</a></h1><p>给定一个整数 n ，返回 n! 结果中尾随零的数量。</p>
<p>提示 n! &#x3D; n * (n - 1) * (n - 2) * … * 3 * 2 * 1</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 3<br>输出：0<br>解释：3! &#x3D; 6 ，不含尾随 0<br>示例 2：</p>
<p>输入：n &#x3D; 5<br>输出：1<br>解释：5! &#x3D; 120 ，有一个尾随 0<br>示例 3：</p>
<p>输入：n &#x3D; 0<br>输出：0
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; n &lt;&#x3D; 104
 </p>
<h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p>首先题目的意思是末尾有几个0<br> 比如6! &#x3D; 【1* 2* 3* 4* 5* 6】<br>    其中只有2<em>5末尾才有0，所以就可以抛去其他数据 专门看2 5 以及其倍数 毕竟 4 * 25末尾也是0<br>    比如10！ &#x3D; 【2</em>4<em>5</em>6<em>8</em>10】<br>    其中 4能拆成2<em>2  10能拆成2</em>5<br>    所以10！ &#x3D; 【2<em>（2</em>2）<em>5</em>（2<em>3）</em>（2<em>2</em>2）<em>（2</em>5）】<br>    一个2和一个5配对 就产生一个0 所以10！末尾2个0</p>
<pre><code>转头一想 2肯定比5多 所以只数5的个数就行了

假若N=31 31里能凑10的5为[5, 2*5, 3*5, 4*5, 25, 6*5] 
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trailingZeroes(int n) &#123;</span><br><span class="line">        int res=0;</span><br><span class="line">	    for(int i=n;i&gt;0;i/=5)&#123;</span><br><span class="line">		    res+=i/5;</span><br><span class="line">	    &#125;</span><br><span class="line">	    return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179. 最大数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-number/">179. 最大数</a></h1><p>给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p>
<p>注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [10,2]<br>输出：”210”<br>示例 2：</p>
<p>输入：nums &#x3D; [3,30,34,5,9]<br>输出：”9534330”
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p>
<h2 id="Solution0-暴力-3"><a href="#Solution0-暴力-3" class="headerlink" title="Solution0 暴力"></a>Solution0 暴力</h2><h2 id="Solution1-排序-1"><a href="#Solution1-排序-1" class="headerlink" title="Solution1 排序"></a>Solution1 排序</h2><p>自定义一种排序方式 比较 s1 + s2 和 s2 + s1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    static bool cmp(int a,int b)&#123;</span><br><span class="line">        string sa = to_string(a);</span><br><span class="line">        string sb = to_string(b);</span><br><span class="line">        return sa+sb&gt;sb+sa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string largestNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(),nums.end(),cmp);</span><br><span class="line">        string ret;</span><br><span class="line">        for(auto num:nums)&#123;</span><br><span class="line">            if(!(num==0&amp;&amp;ret[0]==&#x27;0&#x27;)) ret+=to_string(num);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><img src="https://files.mdnice.com/user/1489/724583f7-e9bf-46be-a2e9-235ba7e2d358.png"></p>
<h1 id="187-重复的DNA序列"><a href="#187-重复的DNA序列" class="headerlink" title="187. 重复的DNA序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></h1><p>DNA序列 由一系列核苷酸组成，缩写为 ‘A’, ‘C’, ‘G’ 和 ‘T’.。</p>
<p>例如，”ACGAATTCCG” 是一个 DNA序列 。<br>在研究 DNA 时，识别 DNA 中的重复序列非常有用。</p>
<p>给定一个表示 DNA序列 的字符串 s ，返回所有在 DNA 分子中出现不止一次的 长度为 10 的序列(子字符串)。你可以按 任意顺序 返回答案。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT”<br>输出：[“AAAAACCCCC”,”CCCCCAAAAA”]<br>示例 2：</p>
<p>输入：s &#x3D; “AAAAAAAAAAAAA”<br>输出：[“AAAAAAAAAA”]
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; s.length &lt;&#x3D; 105<br>s[i]&#x3D;&#x3D;’A’、’C’、’G’ or ‘T’</p>
<h2 id="Solution1-哈希表-3"><a href="#Solution1-哈希表-3" class="headerlink" title="Solution1 哈希表"></a>Solution1 哈希表</h2><p>我们可以用一个哈希表统计 ss 所有长度为 1010 的子串的出现次数，返回所有出现次数超过 1010 的子串。</p>
<p>代码实现时，可以一边遍历子串一边记录答案，为了不重复记录答案，我们只统计当前出现次数为 22 的子串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    const int L = 10;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        unordered_map&lt;string, int&gt; cnt;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        for (int i = 0; i &lt;= n - L; ++i) &#123;</span><br><span class="line">            string sub = s.substr(i, L);</span><br><span class="line">            if (++cnt[sub] == 2) &#123;</span><br><span class="line">                ans.push_back(sub);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution2-哈希表-滑动窗口-二进制"><a href="#Solution2-哈希表-滑动窗口-二进制" class="headerlink" title="Solution2 哈希表 滑动窗口 二进制"></a>Solution2 哈希表 滑动窗口 二进制</h2><p><img src="https://files.mdnice.com/user/1489/971e09e6-1b22-4c78-a3bc-956a6d4f1827.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    const int L = 10;</span><br><span class="line">    unordered_map&lt;char, int&gt; bin = &#123;&#123;&#x27;A&#x27;, 0&#125;, &#123;&#x27;C&#x27;, 1&#125;, &#123;&#x27;G&#x27;, 2&#125;, &#123;&#x27;T&#x27;, 3&#125;&#125;;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        if (n &lt;= L) &#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int i = 0; i &lt; L - 1; ++i) &#123;</span><br><span class="line">            x = (x &lt;&lt; 2) | bin[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;int, int&gt; cnt;</span><br><span class="line">        for (int i = 0; i &lt;= n - L; ++i) &#123;</span><br><span class="line">            x = ((x &lt;&lt; 2) | bin[s[i + L - 1]]) &amp; ((1 &lt;&lt; (L * 2)) - 1);</span><br><span class="line">            if (++cnt[x] == 2) &#123;</span><br><span class="line">                ans.push_back(s.substr(i, L));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>






<h1 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></h1><p>给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右轮转 1 步: [7,1,2,3,4,5,6]<br>向右轮转 2 步: [6,7,1,2,3,4,5]<br>向右轮转 3 步: [5,6,7,1,2,3,4]<br>示例 2:</p>
<p>输入：nums &#x3D; [-1,-100,3,99], k &#x3D; 2<br>输出：[3,99,-1,-100]<br>解释:<br>向右轮转 1 步: [99,-1,-100,3]<br>向右轮转 2 步: [3,99,-1,-100]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1<br>0 &lt;&#x3D; k &lt;&#x3D; 105</p>
<h2 id="Solution1-使用额外的数组"><a href="#Solution1-使用额外的数组" class="headerlink" title="Solution1 使用额外的数组"></a>Solution1 使用额外的数组</h2><p><img src="https://files.mdnice.com/user/1489/df37bbbe-bbbb-4e52-b5ae-5ba6fd84cd30.png"></p>
<h2 id="Solution2-数组翻转"><a href="#Solution2-数组翻转" class="headerlink" title="Solution2  数组翻转"></a>Solution2  数组翻转</h2><p><img src="https://files.mdnice.com/user/1489/cd09a3b7-fdbb-469a-8609-f64f592fda01.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reverse(vector&lt;int&gt;&amp; nums, int start, int end) &#123;</span><br><span class="line">        while (start &lt; end) &#123;</span><br><span class="line">            swap(nums[start], nums[end]);</span><br><span class="line">            start += 1;</span><br><span class="line">            end -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        k %= nums.size();</span><br><span class="line">        reverse(nums, 0, nums.size() - 1);</span><br><span class="line">        reverse(nums, 0, k - 1);</span><br><span class="line">        reverse(nums, k, nums.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。<br>示例 2：</p>
<p>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。<br>     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 400</p>
<h2 id="Solution1-动态规划-6"><a href="#Solution1-动态规划-6" class="headerlink" title="Solution1  动态规划"></a>Solution1  动态规划</h2><p>dp 方程 dp[i] &#x3D; max(dp[i-2]+nums[i], dp[i-1])</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.empty()) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        if (size == 1) &#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; dp = vector&lt;int&gt;(size, 0);</span><br><span class="line">        dp[0] = nums[0];</span><br><span class="line">        dp[1] = max(nums[0], nums[1]);</span><br><span class="line">        for (int i = 2; i &lt; size; i++) &#123;</span><br><span class="line">            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[size - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-动态规划-3"><a href="#Solution2-动态规划-3" class="headerlink" title="Solution2 动态规划"></a>Solution2 动态规划</h2><p>上述方法使用了数组存储结果。考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.empty()) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        if (size == 1) &#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        int first = nums[0], second = max(nums[0], nums[1]);</span><br><span class="line">        for (int i = 2; i &lt; size; i++) &#123;</span><br><span class="line">            int temp = second;</span><br><span class="line">            second = max(first + nums[i], second);</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 是数组长度。只需要对数组遍历一次。</p>
<p>空间复杂度：O(1)O(1)。使用滚动数组，可以只存储前两间房屋的最高总金额，而不需要存储整个数组的结果，因此空间复杂度是 O(1)O(1)。</p>
<h1 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h1><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: [1,2,3,null,5,null,4]<br>输出: [1,3,4]<br>示例 2:</p>
<p>输入: [1,null,3]<br>输出: [1,3]<br>示例 3:</p>
<p>输入: []<br>输出: []
 </p>
<p>提示:</p>
<p>二叉树的节点个数的范围是 [0,100]<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100 </p>
<h2 id="Solution1-层序遍历-1"><a href="#Solution1-层序遍历-1" class="headerlink" title="Solution1 层序遍历"></a>Solution1 层序遍历</h2><p>使用层序遍历，并只保留每层最后一个节点的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; rightmostValueAtDepth;</span><br><span class="line">        int max_depth = -1;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; nodeQueue;</span><br><span class="line">        queue&lt;int&gt; depthQueue;</span><br><span class="line">        nodeQueue.push(root);</span><br><span class="line">        depthQueue.push(0);</span><br><span class="line"></span><br><span class="line">        while (!nodeQueue.empty()) &#123;</span><br><span class="line">            TreeNode* node = nodeQueue.front();nodeQueue.pop();</span><br><span class="line">            int depth = depthQueue.front();depthQueue.pop();</span><br><span class="line"></span><br><span class="line">            if (node != NULL) &#123;</span><br><span class="line">            	// 维护二叉树的最大深度</span><br><span class="line">                max_depth = max(max_depth, depth);</span><br><span class="line"></span><br><span class="line">                // 由于每一层最后一个访问到的节点才是我们要的答案，因此不断更新对应深度的信息即可</span><br><span class="line">                rightmostValueAtDepth[depth] =  node -&gt; val;</span><br><span class="line"></span><br><span class="line">                nodeQueue.push(node -&gt; left);</span><br><span class="line">                nodeQueue.push(node -&gt; right);</span><br><span class="line">                depthQueue.push(depth + 1);</span><br><span class="line">                depthQueue.push(depth + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; rightView;</span><br><span class="line">        for (int depth = 0; depth &lt;= max_depth; ++depth) &#123;</span><br><span class="line">            rightView.push_back(rightmostValueAtDepth[depth]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return rightView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="https://files.mdnice.com/user/1489/fb683879-39db-4823-890b-e02d5deeb48c.png"></p>
<p>这里可以通过维护两个node queue来实现</p>
<h1 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h1><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：grid &#x3D; [<br>  [“1”,”1”,”1”,”1”,”0”],<br>  [“1”,”1”,”0”,”1”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”0”,”0”,”0”]<br>]<br>输出：1<br>示例 2：</p>
<p>输入：grid &#x3D; [<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”1”,”0”,”0”],<br>  [“0”,”0”,”0”,”1”,”1”]<br>]<br>输出：3
 </p>
<p>提示：</p>
<p>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 300<br>grid[i][j] 的值为 ‘0’ 或 ‘1’</p>
<h2 id="Solution1-DFS-2"><a href="#Solution1-DFS-2" class="headerlink" title="Solution1  DFS"></a>Solution1  DFS</h2><p>思路：遍历岛这个二维数组，如果当前数为1，则进入感染函数并将岛个数+1<br>感染函数：其实就是一个递归标注的过程，它会将所有相连的1都标注成2。为什么要标注？这样就避免了遍历过程中的重复计数的情况，一个岛所有的1都变成了2后，遍历的时候就不会重复遍历了。建议没想明白的同学画个图看看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numIslands(char[][] grid) &#123;</span><br><span class="line">        int islandNum = 0;</span><br><span class="line">        for(int i = 0; i &lt; grid.length; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; grid[0].length; j++)&#123;</span><br><span class="line">                if(grid[i][j] == &#x27;1&#x27;)&#123;</span><br><span class="line">                    infect(grid, i, j);</span><br><span class="line">                    islandNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return islandNum;</span><br><span class="line">    &#125;</span><br><span class="line">    //感染函数</span><br><span class="line">    public void infect(char[][] grid, int i, int j)&#123;</span><br><span class="line">        if(i &lt; 0 || i &gt;= grid.length ||</span><br><span class="line">           j &lt; 0 || j &gt;= grid[0].length || grid[i][j] != &#x27;1&#x27;)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = &#x27;2&#x27;;</span><br><span class="line">        infect(grid, i + 1, j);</span><br><span class="line">        infect(grid, i - 1, j);</span><br><span class="line">        infect(grid, i, j + 1);</span><br><span class="line">        infect(grid, i, j - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution2-BFS-1"><a href="#Solution2-BFS-1" class="headerlink" title="Solution2 BFS"></a>Solution2 BFS</h2><p>主循环和思路一类似，不同点是在于搜索某岛屿边界的方法不同。<br>bfs 方法：<br>借用一个队列 queue，判断队列首部节点 (i, j) 是否未越界且为 1：<br>若是则置零（删除岛屿节点），并将此节点上下左右节点 (i+1,j),(i-1,j),(i,j+1),(i,j-1) 加入队列；<br>若不是则跳过此节点；<br>循环 pop 队列首节点，直到整个队列为空，此时已经遍历完此岛屿。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numIslands(char[][] grid) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for(int i = 0; i &lt; grid.length; i++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; grid[0].length; j++) &#123;</span><br><span class="line">                if(grid[i][j] == &#x27;1&#x27;)&#123;</span><br><span class="line">                    bfs(grid, i, j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">    private void bfs(char[][] grid, int i, int j)&#123;</span><br><span class="line">        Queue&lt;int[]&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line">        list.add(new int[] &#123; i, j &#125;);</span><br><span class="line">        while(!list.isEmpty())&#123;</span><br><span class="line">            int[] cur = list.remove();</span><br><span class="line">            i = cur[0]; j = cur[1];</span><br><span class="line">            if(0 &lt;= i &amp;&amp; i &lt; grid.length &amp;&amp; 0 &lt;= j &amp;&amp; j &lt; grid[0].length &amp;&amp; grid[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                grid[i][j] = &#x27;0&#x27;;</span><br><span class="line">                list.add(new int[] &#123; i + 1, j &#125;);</span><br><span class="line">                list.add(new int[] &#123; i - 1, j &#125;);</span><br><span class="line">                list.add(new int[] &#123; i, j + 1 &#125;);</span><br><span class="line">                list.add(new int[] &#123; i, j - 1 &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></h1><p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」 定义为：</p>
<p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<br>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。<br>如果这个过程 结果为 1，那么这个数就是快乐数。<br>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 19<br>输出：true<br>解释：<br>12 + 92 &#x3D; 82<br>82 + 22 &#x3D; 68<br>62 + 82 &#x3D; 100<br>12 + 02 + 02 &#x3D; 1<br>示例 2：</p>
<p>输入：n &#x3D; 2<br>输出：false
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 231 - 1</p>
<h2 id="Solution1-快慢指针"><a href="#Solution1-快慢指针" class="headerlink" title="Solution1 快慢指针"></a>Solution1 快慢指针</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//参考英文网站热评第一。这题可以用快慢指针的思想去做，有点类似于检测是否为环形链表那道题</span><br><span class="line">//如果给定的数字最后会一直循环重复，那么快的指针（值）一定会追上慢的指针（值），也就是</span><br><span class="line">//两者一定会相等。如果没有循环重复，那么最后快慢指针也会相等，且都等于1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isHappy(int n) &#123;</span><br><span class="line">        int fast=n;</span><br><span class="line">        int slow=n;</span><br><span class="line">        do&#123;</span><br><span class="line">            slow=squareSum(slow);</span><br><span class="line">            fast=squareSum(fast);</span><br><span class="line">            fast=squareSum(fast);</span><br><span class="line">        &#125;while(slow!=fast);</span><br><span class="line">        if(fast==1)</span><br><span class="line">            return true;</span><br><span class="line">        else return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private int squareSum(int m)&#123;</span><br><span class="line">        int squaresum=0;</span><br><span class="line">        while(m!=0)&#123;</span><br><span class="line">           squaresum+=(m%10)*(m%10);</span><br><span class="line">            m/=10;</span><br><span class="line">        &#125;</span><br><span class="line">        return squaresum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution2-暴力"><a href="#Solution2-暴力" class="headerlink" title="Solution2 暴力"></a>Solution2 暴力</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isHappy(int n) &#123;</span><br><span class="line">        int ans=0;</span><br><span class="line">        for(int i = 0 ; i&lt; 100;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            while(n&gt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                ans += (n%10)*(n%10);</span><br><span class="line">                n = n /10;</span><br><span class="line">            &#125;</span><br><span class="line">            n = ans;</span><br><span class="line">            if(n==1)</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></h1><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。
 </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6<br>输出：[1,2,3,4,5]<br>示例 2：</p>
<p>输入：head &#x3D; [], val &#x3D; 1<br>输出：[]<br>示例 3：</p>
<p>输入：head &#x3D; [7,7,7,7], val &#x3D; 7<br>输出：[]
 </p>
<p>提示：</p>
<p>列表中的节点数目在范围 [0, 104] 内<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 50<br>0 &lt;&#x3D; val &lt;&#x3D; 50</p>
<h2 id="Solution1-迭代"><a href="#Solution1-迭代" class="headerlink" title="Solution1 迭代"></a>Solution1 迭代</h2><p><img src="https://files.mdnice.com/user/1489/b2e898e8-a1bf-4e57-88b2-00546145e9d0.png"></p>
<h2 id="Solution2-递归"><a href="#Solution2-递归" class="headerlink" title="Solution2 递归"></a>Solution2 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListNode *removeElements(ListNode *head, int val)</span><br><span class="line">&#123;</span><br><span class="line">    if (!head)</span><br><span class="line">        return head;</span><br><span class="line">    head-&gt;next = removeElements(head-&gt;next, val);</span><br><span class="line">    return head-&gt;val == val ? head-&gt;next : head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析<br>时间复杂度：O(n)O(n)，其中 nn 是链表的长度。需要遍历链表一次。<br>空间复杂度：O(1)O(1)。</p>
<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h1><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
 </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4,5]<br>输出：[5,4,3,2,1]<br>示例 2：</p>
<p>输入：head &#x3D; [1,2]<br>输出：[2,1]<br>示例 3：</p>
<p>输入：head &#x3D; []<br>输出：[]
 </p>
<p>提示：</p>
<p>链表中节点的数目范围是 [0, 5000]<br>-5000 &lt;&#x3D; Node.val &lt;&#x3D; 5000
 </p>
<h2 id="Solution1-迭代-1"><a href="#Solution1-迭代-1" class="headerlink" title="Solution1 迭代"></a>Solution1 迭代</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/迭代法</span><br><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">    ListNode pre = null;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    while(cur!=null) &#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-递归-1"><a href="#Solution2-递归-1" class="headerlink" title="Solution2 递归"></a>Solution2 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//尾递归</span><br><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">    return reverse(null,head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static ListNode reverse(ListNode pre,ListNode cur)&#123;</span><br><span class="line">    if(cur==null) return pre;</span><br><span class="line">    ListNode next = cur.next;</span><br><span class="line">    cur.next = pre;</span><br><span class="line">    return reverse(cur,next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h1><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: [3,2,1,5,6,4], k &#x3D; 2<br>输出: 5<br>示例 2:</p>
<p>输入: [3,2,3,1,2,4,5,5,6], k &#x3D; 4<br>输出: 4
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; k &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</p>
<h2 id="Solution1-堆排序"><a href="#Solution1-堆排序" class="headerlink" title="Solution1  堆排序"></a>Solution1  堆排序</h2><p><img src="https://files.mdnice.com/user/1489/bb70337e-337f-4525-9b82-628e0ababa73.png"></p>
<p>复杂度分析</p>
<p>时间复杂度：O(n \log n)O(nlogn)，建堆的时间代价是 O(n)O(n)，删除的总代价是 O(k \log n)O(klogn)，因为 k &lt; nk&lt;n，故渐进时间复杂为 O(n + k \log n) &#x3D; O(n \log n)O(n+klogn)&#x3D;O(nlogn)。<br>空间复杂度：O(\log n)O(logn)，即递归使用栈空间的空间代价。</p>
<p><img src="https://files.mdnice.com/user/1489/6b0ad4c7-d06d-477f-a7be-fc2e043a0db5.png"></p>
<h1 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/contains-duplicate/">217. 存在重复元素</a></h1><p>给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。
 </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3,1]<br>输出：true<br>示例 2：</p>
<p>输入：nums &#x3D; [1,2,3,4]<br>输出：false<br>示例 3：</p>
<p>输入：nums &#x3D; [1,1,1,3,3,4,3,2,4,2]<br>输出：true
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p>
<h2 id="Solution1-排序-2"><a href="#Solution1-排序-2" class="headerlink" title="Solution1  排序"></a>Solution1  排序</h2><p><img src="https://files.mdnice.com/user/1489/30ba428f-42b6-472b-8b8b-23aaef1c23b6.png"></p>
<h2 id="Solution2-3"><a href="#Solution2-3" class="headerlink" title="Solution2"></a>Solution2</h2><p><img src="https://files.mdnice.com/user/1489/f14525cf-e0bb-44a5-a385-54ae95316f9b.png"></p>
<h1 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221. 最大正方形"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximal-square/">221. 最大正方形</a></h1><p><img src="https://files.mdnice.com/user/1489/317b8a93-0319-40c0-9273-c7d6ea72516a.png"></p>
<h2 id="Solution0-暴力法"><a href="#Solution0-暴力法" class="headerlink" title="Solution0 暴力法"></a>Solution0 暴力法</h2><p><img src="https://files.mdnice.com/user/1489/19e5cf6f-0c41-4a7c-804d-9d81beac4123.png"></p>
<h2 id="Solution1-动态规划-7"><a href="#Solution1-动态规划-7" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p>class Solution {<br>    public int maximalSquare(char[][] matrix) {<br>        &#x2F;**<br>        dp[i][j]表示以第i行第j列为右下角所能构成的最大正方形边长, 则递推式为:<br>        dp[i][j] &#x3D; 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]);<br>        **&#x2F;<br>        int m &#x3D; matrix.length;<br>        if(m &lt; 1) return 0;<br>        int n &#x3D; matrix[0].length;<br>        int max &#x3D; 0;<br>        int[][] dp &#x3D; new int[m+1][n+1];</p>
<pre><code>    for(int i = 1; i &lt;= m; ++i) &#123;
        for(int j = 1; j &lt;= n; ++j) &#123;
            if(matrix[i-1][j-1] == &#39;1&#39;) &#123;
                dp[i][j] = 1 + Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1]));
                max = Math.max(max, dp[i][j]); 
            &#125;
        &#125;
    &#125;
    
    return max*max;
&#125;
</code></pre>
<p>}</p>
<h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h1><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p>
<p>实现 MyStack 类：</p>
<p>void push(int x) 将元素 x 压入栈顶。<br>int pop() 移除并返回栈顶元素。<br>int top() 返回栈顶元素。<br>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。
 </p>
<p>注意：</p>
<p>你只能使用队列的基本操作 —— 也就是 push to back、peek&#x2F;pop from front、size 和 is empty 这些操作。<br>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
 </p>
<p>示例：</p>
<p>输入：<br>[“MyStack”, “push”, “push”, “top”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>输出：<br>[null, null, null, 2, 2, false]</p>
<p>解释：<br>MyStack myStack &#x3D; new MyStack();<br>myStack.push(1);<br>myStack.push(2);<br>myStack.top(); &#x2F;&#x2F; 返回 2<br>myStack.pop(); &#x2F;&#x2F; 返回 2<br>myStack.empty(); &#x2F;&#x2F; 返回 False
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; x &lt;&#x3D; 9<br>最多调用100 次 push、pop、top 和 empty<br>每次调用 pop 和 top 都保证栈不为空</p>
<h2 id="Solution1-两个队列"><a href="#Solution1-两个队列" class="headerlink" title="Solution1  两个队列"></a>Solution1  两个队列</h2><p><img src="https://files.mdnice.com/user/1489/44e2b2c5-3a86-4e20-97d1-45502d4bfc29.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line">public:</span><br><span class="line">    queue&lt;int&gt; queue1;</span><br><span class="line">    queue&lt;int&gt; queue2;</span><br><span class="line"></span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    MyStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Push element x onto stack. */</span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        queue2.push(x);</span><br><span class="line">        while (!queue1.empty()) &#123;</span><br><span class="line">            queue2.push(queue1.front());</span><br><span class="line">            queue1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        swap(queue1, queue2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Removes the element on top of the stack and returns that element. */</span><br><span class="line">    int pop() &#123;</span><br><span class="line">        int r = queue1.front();</span><br><span class="line">        queue1.pop();</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Get the top element. */</span><br><span class="line">    int top() &#123;</span><br><span class="line">        int r = queue1.front();</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns whether the stack is empty. */</span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return queue1.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution2-单个队列"><a href="#Solution2-单个队列" class="headerlink" title="Solution2 单个队列"></a>Solution2 单个队列</h2><p><img src="https://files.mdnice.com/user/1489/aa634f7b-decf-4a6c-8e21-80efe413f3c1.png"></p>
<h1 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h1><p><img src="https://files.mdnice.com/user/1489/69e49a83-545c-483f-8a37-ec3b834d2e93.png"></p>
<h2 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1"></a>Solution1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">利用前序遍历</span><br><span class="line">class Solution &#123;</span><br><span class="line">        // 先序遍历--从顶向下交换</span><br><span class="line">        public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">            if (root == null) return null;</span><br><span class="line">            // 保存右子树</span><br><span class="line">            TreeNode rightTree = root.right;</span><br><span class="line">            // 交换左右子树的位置</span><br><span class="line">            root.right = invertTree(root.left);</span><br><span class="line">            root.left = invertTree(rightTree);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">利用中序遍历</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">            if (root == null) return null;</span><br><span class="line">            invertTree(root.left); // 递归找到左节点</span><br><span class="line">            TreeNode rightNode= root.right; // 保存右节点</span><br><span class="line">            root.right = root.left;</span><br><span class="line">            root.left = rightNode;</span><br><span class="line">            // 递归找到右节点 继续交换 : 因为此时左右节点已经交换了,所以此时的右节点为root.left</span><br><span class="line">            invertTree(root.left); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">利用后序遍历</span><br><span class="line"> class Solution &#123;</span><br><span class="line">        public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">            // 后序遍历-- 从下向上交换</span><br><span class="line">            if (root == null) return null;</span><br><span class="line">            TreeNode leftNode = invertTree(root.left);</span><br><span class="line">            TreeNode rightNode = invertTree(root.right);</span><br><span class="line">            root.right = leftNode;</span><br><span class="line">            root.left = rightNode;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">利用层次遍历</span><br><span class="line">   class Solution &#123;</span><br><span class="line">        public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">            // 层次遍历--直接左右交换即可</span><br><span class="line">            if (root == null) return null;</span><br><span class="line">            Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">            queue.offer(root);</span><br><span class="line">            while (!queue.isEmpty())&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                TreeNode rightTree = node.right;</span><br><span class="line">                node.right = node.left;</span><br><span class="line">                node.left = rightTree;</span><br><span class="line">                if (node.left != null)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (node.right != null)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="227-基本计算器-II"><a href="#227-基本计算器-II" class="headerlink" title="227. 基本计算器 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/basic-calculator-ii/">227. 基本计算器 II</a></h1><p>给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。</p>
<p>整数除法仅保留整数部分。</p>
<p>你可以假设给定的表达式总是有效的。所有中间结果将在 [-231, 231 - 1] 的范围内。</p>
<p>注意：不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “3+2*2”<br>输出：7<br>示例 2：</p>
<p>输入：s &#x3D; “ 3&#x2F;2 “<br>输出：1<br>示例 3：</p>
<p>输入：s &#x3D; “ 3+5 &#x2F; 2 “<br>输出：5
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 3 * 105<br>s 由整数和算符 (‘+’, ‘-‘, ‘*’, ‘&#x2F;‘) 组成，中间由一些空格隔开<br>s 表示一个 有效表达式<br>表达式中的所有整数都是非负整数，且在范围 [0, 231 - 1] 内<br>题目数据保证答案是一个 32-bit 整数</p>
<h2 id="Solution1-栈-2"><a href="#Solution1-栈-2" class="headerlink" title="Solution1 栈"></a>Solution1 栈</h2><p>方法一：栈<br>思路</p>
<p>由于乘除优先于加减计算，因此不妨考虑先进行所有乘除运算，并将这些乘除运算后的整数值放回原表达式的相应位置，则随后整个表达式的值，就等于一系列整数加减后的值。</p>
<p>基于此，我们可以用一个栈，保存这些（进行乘除运算后的）整数的值。对于加减号后的数字，将其直接压入栈中；对于乘除号后的数字，可以直接与栈顶元素计算，并替换栈顶元素为计算后的结果。</p>
<p>具体来说，遍历字符串 ss，并用变量 \textit{preSign}preSign 记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。每次遍历到数字末尾时，根据 \textit{preSign}preSign 来决定计算方式：</p>
<p>加号：将数字压入栈；<br>减号：将数字的相反数压入栈；<br>乘除号：计算数字与栈顶元素，并将栈顶元素替换为计算结果。<br>代码实现中，若读到一个运算符，或者遍历到字符串末尾，即认为是遍历到了数字末尾。处理完该数字后，更新 \textit{preSign}preSign 为当前遍历的字符。</p>
<p>遍历完字符串 ss 后，将栈中元素累加，即为该字符串表达式的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int calculate(string s) &#123;</span><br><span class="line">        vector&lt;int&gt; stk;</span><br><span class="line">        char preSign = &#x27;+&#x27;;</span><br><span class="line">        int num = 0;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (isdigit(s[i])) &#123;</span><br><span class="line">                num = num * 10 + int(s[i] - &#x27;0&#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!isdigit(s[i]) &amp;&amp; s[i] != &#x27; &#x27; || i == n - 1) &#123;</span><br><span class="line">                switch (preSign) &#123;</span><br><span class="line">                    case &#x27;+&#x27;:</span><br><span class="line">                        stk.push_back(num);</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;-&#x27;:</span><br><span class="line">                        stk.push_back(-num);</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;*&#x27;:</span><br><span class="line">                        stk.back() *= num;</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        stk.back() /= num;</span><br><span class="line">                &#125;</span><br><span class="line">                preSign = s[i];</span><br><span class="line">                num = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return accumulate(stk.begin(), stk.end(), 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 为字符串 ss 的长度。需要遍历字符串 ss 一次，计算表达式的值。</p>
<p>空间复杂度：O(n)O(n)，其中 nn 为字符串 ss 的长度。空间复杂度主要取决于栈的空间，栈的元素个数不超过 nn。</p>
<h1 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h1><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p>
<p>实现 MyQueue 类：</p>
<p>void push(int x) 将元素 x 推到队列的末尾<br>int pop() 从队列的开头移除并返回元素<br>int peek() 返回队列开头的元素<br>boolean empty() 如果队列为空，返回 true ；否则，返回 false<br>说明：</p>
<p>你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
 </p>
<p>示例 1：</p>
<p>输入：<br>[“MyQueue”, “push”, “push”, “peek”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>输出：<br>[null, null, null, 1, 1, false]</p>
<p>解释：<br>MyQueue myQueue &#x3D; new MyQueue();<br>myQueue.push(1); &#x2F;&#x2F; queue is: [1]<br>myQueue.push(2); &#x2F;&#x2F; queue is: [1, 2] (leftmost is front of the queue)<br>myQueue.peek(); &#x2F;&#x2F; return 1<br>myQueue.pop(); &#x2F;&#x2F; return 1, queue is [2]<br>myQueue.empty(); &#x2F;&#x2F; return false</p>
<h2 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1"></a>Solution1</h2><p><img src="https://files.mdnice.com/user/1489/3cd35f16-15b6-4698-8053-935ffdd85349.png"><br>思路</p>
<p>将一个栈当作输入栈，用于压入 \texttt{push}push 传入的数据；另一个栈当作输出栈，用于 \texttt{pop}pop 和 \texttt{peek}peek 操作。</p>
<p>每次 \texttt{pop}pop 或 \texttt{peek}peek 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class MyQueue &#123;</span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; inStack, outStack;</span><br><span class="line"></span><br><span class="line">    void in2out() &#123;</span><br><span class="line">        while (!inStack.empty()) &#123;</span><br><span class="line">            outStack.push(inStack.top());</span><br><span class="line">            inStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    MyQueue() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">        if (outStack.empty()) &#123;</span><br><span class="line">            in2out();</span><br><span class="line">        &#125;</span><br><span class="line">        int x = outStack.top();</span><br><span class="line">        outStack.pop();</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int peek() &#123;</span><br><span class="line">        if (outStack.empty()) &#123;</span><br><span class="line">            in2out();</span><br><span class="line">        &#125;</span><br><span class="line">        return outStack.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return inStack.empty() &amp;&amp; outStack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="https://files.mdnice.com/user/1489/7ee6b978-400a-44f6-8197-a9507c8e058b.png"></p>
<h1 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></h1><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,2,1]<br>输出：true<br>示例 2：</p>
<p>输入：head &#x3D; [1,2]<br>输出：false
 </p>
<p>提示：</p>
<p>链表中节点数目在范围[1, 105] 内<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 9
 </p>
<p>进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<h2 id="Solution0-将链表复制到数组"><a href="#Solution0-将链表复制到数组" class="headerlink" title="Solution0 将链表复制到数组"></a>Solution0 将链表复制到数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        vector&lt;int&gt; vals;</span><br><span class="line">        while (head != nullptr) &#123;</span><br><span class="line">            vals.emplace_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0, j = (int)vals.size() - 1; i &lt; j; ++i, --j) &#123;</span><br><span class="line">            if (vals[i] != vals[j]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="Solution1-中点开始比较"><a href="#Solution1-中点开始比较" class="headerlink" title="Solution1 中点开始比较"></a>Solution1 中点开始比较</h2><p><img src="https://files.mdnice.com/user/1489/86154c4e-b8da-4890-ab23-b2612d4c5777.png"></p>
<h1 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h1><p>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。</p>
<h2 id="Solution1-非递归"><a href="#Solution1-非递归" class="headerlink" title="Solution1  非递归"></a>Solution1  非递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int kthSmallest(TreeNode* root, int k) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        int num=0;</span><br><span class="line">        TreeNode *cur=root;</span><br><span class="line">        while(!s.empty() || cur)</span><br><span class="line">        &#123;</span><br><span class="line">            if(cur)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur=cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                cur=s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                num++;</span><br><span class="line">                if(num==k)</span><br><span class="line">                    return cur-&gt;val;</span><br><span class="line">                cur=cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution2-记录子节点数目"><a href="#Solution2-记录子节点数目" class="headerlink" title="Solution2 记录子节点数目"></a>Solution2 记录子节点数目</h2><p><img src="https://files.mdnice.com/user/1489/e65a5f5c-4e4e-4bb7-857a-f5fd4309020f.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class MyBst &#123;</span><br><span class="line">public:</span><br><span class="line">    MyBst(TreeNode *root) &#123;</span><br><span class="line">        this-&gt;root = root;</span><br><span class="line">        countNodeNum(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回二叉搜索树中第k小的元素</span><br><span class="line">    int kthSmallest(int k) &#123;</span><br><span class="line">        TreeNode *node = root;</span><br><span class="line">        while (node != nullptr) &#123;</span><br><span class="line">            int left = getNodeNum(node-&gt;left);</span><br><span class="line">            if (left &lt; k - 1) &#123;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">                k -= left + 1;</span><br><span class="line">            &#125; else if (left == k - 1) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return node-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    TreeNode *root;</span><br><span class="line">    unordered_map&lt;TreeNode *, int&gt; nodeNum;</span><br><span class="line"></span><br><span class="line">    // 统计以node为根结点的子树的结点数</span><br><span class="line">    int countNodeNum(TreeNode * node) &#123;</span><br><span class="line">        if (node == nullptr) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        nodeNum[node] = 1 + countNodeNum(node-&gt;left) + countNodeNum(node-&gt;right);</span><br><span class="line">        return nodeNum[node];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取以node为根结点的子树的结点数</span><br><span class="line">    int getNodeNum(TreeNode * node) &#123;</span><br><span class="line">        if (node != nullptr &amp;&amp; nodeNum.count(node)) &#123;</span><br><span class="line">            return nodeNum[node];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int kthSmallest(TreeNode* root, int k) &#123;</span><br><span class="line">        MyBst bst(root);</span><br><span class="line">        return bst.kthSmallest(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h1><p><img src="https://files.mdnice.com/user/1489/183fb47d-cb82-4909-bfae-8f78c632e7ea.png"></p>
<h2 id="Solution1-非递归-1"><a href="#Solution1-非递归-1" class="headerlink" title="Solution1  非递归"></a>Solution1  非递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">      //如果根节点和p,q的差相乘是正数，说明这两个差值要么都是正数要么都是负数，也就是说</span><br><span class="line">      //他们肯定都位于根节点的同一侧，就继续往下找</span><br><span class="line">      while ((root.val - p.val) * (root.val - q.val) &gt; 0)</span><br><span class="line">          root = p.val &lt; root.val ? root.left : root.right;</span><br><span class="line">      //如果相乘的结果是负数，说明p和q位于根节点的两侧，如果等于0，说明至少有一个就是根节点</span><br><span class="line">      return root;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h2 id="Solution2-递归-2"><a href="#Solution2-递归-2" class="headerlink" title="Solution2 递归"></a>Solution2 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">    //如果小于等于0，说明p和q位于root的两侧，直接返回即可</span><br><span class="line">    if ((root.val - p.val) * (root.val - q.val) &lt;= 0)</span><br><span class="line">        return root;</span><br><span class="line">    //否则，p和q位于root的同一侧，就继续往下找</span><br><span class="line">    return lowestCommonAncestor(p.val &lt; root.val ? root.left : root.right, p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。<br>示例 2：</p>
<p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4<br>输出：5<br>解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。<br>示例 3：</p>
<p>输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2<br>输出：1
 </p>
<p>提示：</p>
<p>树中节点数目在范围 [2, 105] 内。<br>-109 &lt;&#x3D; Node.val &lt;&#x3D; 109<br>所有 Node.val 互不相同 。<br>p !&#x3D; q<br>p 和 q 均存在于给定的二叉树中。</p>
<h2 id="Solution1-递归-8"><a href="#Solution1-递归-8" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if (root == null) return null;</span><br><span class="line">        // 如果p,q为根节点，则公共祖先为根节点</span><br><span class="line">        if (root.val == p.val || root.val == q.val) return root;</span><br><span class="line">        // 如果p,q在左子树，则公共祖先在左子树查找</span><br><span class="line">        if (find(root.left, p) &amp;&amp; find(root.left, q)) &#123;</span><br><span class="line">            return lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果p,q在右子树，则公共祖先在右子树查找</span><br><span class="line">        if (find(root.right, p) &amp;&amp; find(root.right, q)) &#123;</span><br><span class="line">            return lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果p,q分属两侧，则公共祖先为根节点</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private boolean find(TreeNode root, TreeNode c) &#123;</span><br><span class="line">        if (root == null) return false;</span><br><span class="line">        if (root.val == c.val) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return find(root.left, c) || find(root.right, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/19/Linux-Command-Wildcard/" rel="prev" title="Linux Command —— Wildcard">
      <i class="fa fa-chevron-left"></i> Linux Command —— Wildcard
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Two-Sum"><span class="nav-number">1.</span> <span class="nav-text">1. Two Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-1"><span class="nav-number">1.1.</span> <span class="nav-text">Solution 1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-2"><span class="nav-number">1.2.</span> <span class="nav-text">Solution 2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="nav-number">2.</span> <span class="nav-text">17. 电话号码的字母组合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-1-%E6%9A%B4%E5%8A%9B"><span class="nav-number">2.1.</span> <span class="nav-text">Solution 1  暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Soulution-2-%E5%9B%9E%E6%BA%AF"><span class="nav-number">2.2.</span> <span class="nav-text">Soulution 2  回溯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-3-%E9%98%9F%E5%88%97"><span class="nav-number">2.3.</span> <span class="nav-text">Solution 3  队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">3.</span> <span class="nav-text">18. 四数之和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-1-%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE"><span class="nav-number">3.1.</span> <span class="nav-text">Solution 1  暴力枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-2-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">Solution 2  双指针法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-number">4.</span> <span class="nav-text">19. 删除链表的倒数第 N 个结点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%AE%A1%E7%AE%97%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6"><span class="nav-number">4.1.</span> <span class="nav-text">Solution1 计算链表长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E6%A0%88"><span class="nav-number">4.2.</span> <span class="nav-text">Solution2 栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution3-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="nav-number">4.3.</span> <span class="nav-text">Solution3 快慢指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%A0%88"><span class="nav-number">4.4.</span> <span class="nav-text">Solution1 栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B"><span class="nav-number">4.5.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E9%80%92%E5%BD%92-%E5%89%AA%E6%9E%9D"><span class="nav-number">4.6.</span> <span class="nav-text">Solution2 递归 + 剪枝</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">5.</span> <span class="nav-text">24. 两两交换链表中的节点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92"><span class="nav-number">5.1.</span> <span class="nav-text">Solution1  递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%BF%AD%E4%BB%A3"><span class="nav-number">5.2.</span> <span class="nav-text">Solution2 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="nav-number">6.</span> <span class="nav-text">[26. 删除有序数组中的重复项]</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-1"><span class="nav-number">6.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">6.2.</span> <span class="nav-text">Solution2 双指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution3-%E5%8F%8C%E6%8C%87%E9%92%88-%E4%BC%98%E5%8C%96"><span class="nav-number">6.3.</span> <span class="nav-text">Solution3 双指针 优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="nav-number">7.</span> <span class="nav-text">31. 下一个排列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-2"><span class="nav-number">7.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2"><span class="nav-number">7.2.</span> <span class="nav-text">Solution2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">8.</span> <span class="nav-text">33. 搜索旋转排序数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-3"><span class="nav-number">8.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">8.2.</span> <span class="nav-text">Solution2 二分查找</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="nav-number">9.</span> <span class="nav-text">34. 在排序数组中查找元素的第一个和最后一个位置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-4"><span class="nav-number">9.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%BA%8C%E5%88%86"><span class="nav-number">9.2.</span> <span class="nav-text">Solution2 二分</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">10.</span> <span class="nav-text"></span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-5"><span class="nav-number">10.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%BA%8C%E5%88%86-1"><span class="nav-number">10.2.</span> <span class="nav-text">Solution2 二分</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="nav-number">11.</span> <span class="nav-text">39. 组合总和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-6"><span class="nav-number">11.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%9B%9E%E6%BA%AF"><span class="nav-number">11.2.</span> <span class="nav-text">Solution2 回溯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="nav-number">12.</span> <span class="nav-text">40. 组合总和 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%9B%9E%E6%BA%AF"><span class="nav-number">12.1.</span> <span class="nav-text">Solution1 回溯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">13.</span> <span class="nav-text">46. 全排列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-7"><span class="nav-number">13.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%9B%9E%E6%BA%AF-1"><span class="nav-number">13.2.</span> <span class="nav-text">Solution2 回溯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="nav-number">14.</span> <span class="nav-text">48. 旋转图像</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8E%9F%E5%9C%B0%E6%9F%A5%E6%89%BE"><span class="nav-number">14.1.</span> <span class="nav-text">Solution1 原地查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%85%88%E8%BD%AC%E7%BD%AE%E5%86%8D%E7%AB%96%E7%9B%B4%E5%AF%B9%E7%A7%B0%E5%8F%8D%E8%BD%AC"><span class="nav-number">14.2.</span> <span class="nav-text">Solution2 先转置再竖直对称反转</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="nav-number">15.</span> <span class="nav-text">49. 字母异位词分组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-Map"><span class="nav-number">15.1.</span> <span class="nav-text">Solution1 Map</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#50-Pow-x-n"><span class="nav-number">16.</span> <span class="nav-text">50. Pow(x, n)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%BF%AB%E9%80%9F%E5%B9%82-%E9%80%92%E5%BD%92"><span class="nav-number">16.1.</span> <span class="nav-text">Solution1  快速幂+递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-number">17.</span> <span class="nav-text">53. 最大子数组和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-8"><span class="nav-number">17.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">17.2.</span> <span class="nav-text">Solution2 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="nav-number">18.</span> <span class="nav-text">54. 螺旋矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8E%9F%E5%9C%B0%E9%81%8D%E5%8E%86"><span class="nav-number">18.1.</span> <span class="nav-text">Solution1 原地遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E6%8C%89%E5%B1%82%E9%81%8D%E5%8E%86"><span class="nav-number">18.2.</span> <span class="nav-text">Solution2 按层遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="nav-number">19.</span> <span class="nav-text">56. 合并区间</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%8E%92%E5%BA%8F"><span class="nav-number">19.1.</span> <span class="nav-text">Solution1 排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">20.</span> <span class="nav-text">61. 旋转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-9"><span class="nav-number">20.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Soluion2-%E9%97%AD%E7%8E%AF"><span class="nav-number">20.2.</span> <span class="nav-text">Soluion2  闭环</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="nav-number">21.</span> <span class="nav-text">62. 不同路径</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88"><span class="nav-number">21.1.</span> <span class="nav-text">Solution1 排列组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="nav-number">21.2.</span> <span class="nav-text">Solution2 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">22.</span> <span class="nav-text">64. 最小路径和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E6%9A%B4%E5%8A%9B"><span class="nav-number">22.1.</span> <span class="nav-text">Solution0 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">22.2.</span> <span class="nav-text">Solution1 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#66-%E5%8A%A0%E4%B8%80"><span class="nav-number">23.</span> <span class="nav-text">66. 加一</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-0-%E6%9A%B4%E5%8A%9B"><span class="nav-number">23.1.</span> <span class="nav-text">Solution 0  暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-1-%E9%80%86%E5%BA%8F%E9%81%8D%E5%8E%86-%E6%89%BE%E5%88%B09"><span class="nav-number">23.2.</span> <span class="nav-text">Solution 1 逆序遍历 找到9</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#69-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9"><span class="nav-number">24.</span> <span class="nav-text">69. x 的平方根 </span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-10"><span class="nav-number">24.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="nav-number">24.2.</span> <span class="nav-text">Solution2 二分搜索</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="nav-number">25.</span> <span class="nav-text">70. 爬楼梯</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-1"><span class="nav-number">25.1.</span> <span class="nav-text">Solution1 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB"><span class="nav-number">26.</span> <span class="nav-text">75. 颜色分类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-11"><span class="nav-number">26.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8D%95%E6%8C%87%E9%92%88"><span class="nav-number">26.2.</span> <span class="nav-text">Solution2 单指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution3-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">26.3.</span> <span class="nav-text">Solution3 双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#78-%E5%AD%90%E9%9B%86"><span class="nav-number">27.</span> <span class="nav-text">78. 子集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%9B%9E%E6%BA%AF-1"><span class="nav-number">27.1.</span> <span class="nav-text">Solution1 回溯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#90-%E5%AD%90%E9%9B%86"><span class="nav-number">28.</span> <span class="nav-text">90.子集||</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#77-%E7%BB%84%E5%90%88"><span class="nav-number">29.</span> <span class="nav-text">77. 组合</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-1"><span class="nav-number">30.</span> <span class="nav-text">39. 组合总和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II-1"><span class="nav-number">31.</span> <span class="nav-text">40. 组合总和 II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-number">32.</span> <span class="nav-text">剑指 Offer 38. 字符串的排列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#784-%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">33.</span> <span class="nav-text">784. 字母大小写全排列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="nav-number">34.</span> <span class="nav-text">79. 单词搜索</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-number">35.</span> <span class="nav-text">83. 删除排序链表中的重复元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="nav-number">35.1.</span> <span class="nav-text">Solution1 一次遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8"><span class="nav-number">36.</span> <span class="nav-text">86. 分隔链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">36.1.</span> <span class="nav-text">Solution1  双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">37.</span> <span class="nav-text">88. 合并两个有序数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B%E7%9B%B4%E6%8E%A5%E5%90%88%E5%B9%B6%E5%90%8E%E6%8E%92%E5%BA%8F"><span class="nav-number">37.1.</span> <span class="nav-text">Solution1 暴力直接合并后排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8F%8C%E6%8C%87%E9%92%88-1"><span class="nav-number">37.2.</span> <span class="nav-text">Solution2 双指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution3-%E9%80%86%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">37.3.</span> <span class="nav-text">Solution3 逆向双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95"><span class="nav-number">38.</span> <span class="nav-text">91. 解码方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="nav-number">38.1.</span> <span class="nav-text">Solution1 动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BC%98%E5%8C%96%E4%B8%BAO-1"><span class="nav-number">38.2.</span> <span class="nav-text">Solution2 动态规划 空间复杂度优化为O(1)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II"><span class="nav-number">39.</span> <span class="nav-text">92. 反转链表 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8E%9F%E5%9C%B0%E5%8F%8D%E8%BD%AC"><span class="nav-number">39.1.</span> <span class="nav-text">Solution1 原地反转</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">40.</span> <span class="nav-text">94. 二叉树的中序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-2"><span class="nav-number">40.1.</span> <span class="nav-text">Solution1 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%BF%AD%E4%BB%A3-1"><span class="nav-number">40.2.</span> <span class="nav-text">Solution2 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">41.</span> <span class="nav-text">96. 不同的二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2"><span class="nav-number">41.1.</span> <span class="nav-text">Solution1 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-II"><span class="nav-number">42.</span> <span class="nav-text">95. 不同的二叉搜索树 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%9B%9E%E6%BA%AF-2"><span class="nav-number">42.1.</span> <span class="nav-text">Solution1 回溯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">43.</span> <span class="nav-text">98. 验证二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-3"><span class="nav-number">43.1.</span> <span class="nav-text">Solution1 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%BA%E5%8D%87%E5%BA%8F"><span class="nav-number">43.2.</span> <span class="nav-text">Solution2 中序遍历为升序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">44.</span> <span class="nav-text">101. 对称二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-4"><span class="nav-number">44.1.</span> <span class="nav-text">Solution1  递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E9%98%9F%E5%88%97"><span class="nav-number">44.2.</span> <span class="nav-text">Solution2 队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">45.</span> <span class="nav-text">102. 二叉树的层序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="nav-number">45.1.</span> <span class="nav-text">Solution1 队列实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0"><span class="nav-number">45.2.</span> <span class="nav-text">Solution2 递归实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">46.</span> <span class="nav-text">103. 二叉树的锯齿形层序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">46.1.</span> <span class="nav-text">Solution1 层序遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">47.</span> <span class="nav-text">104. 二叉树的最大深度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-DFS"><span class="nav-number">47.1.</span> <span class="nav-text">Solution1 DFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Slution2-BFS"><span class="nav-number">47.2.</span> <span class="nav-text">Slution2 BFS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">48.</span> <span class="nav-text">105. 从前序与中序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="nav-number">49.</span> <span class="nav-text">118. 杨辉三角</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E7%9B%B4%E6%8E%A5%E6%B1%82%E8%A7%A3"><span class="nav-number">49.1.</span> <span class="nav-text">Solution1 直接求解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="nav-number">50.</span> <span class="nav-text">114. 二叉树展开为链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-5"><span class="nav-number">50.1.</span> <span class="nav-text">Solution1  递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%BF%AD%E4%BB%A3-2"><span class="nav-number">50.2.</span> <span class="nav-text">Solution2   迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II"><span class="nav-number">51.</span> <span class="nav-text">113. 路径总和 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-DFS-1"><span class="nav-number">51.1.</span> <span class="nav-text">Solution1 DFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-BFS"><span class="nav-number">51.2.</span> <span class="nav-text">Solution2 BFS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#109-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">52.</span> <span class="nav-text">109. 有序链表转换二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%85%88%E6%89%BE%E4%B8%AD%E7%82%B9-%E7%84%B6%E5%90%8E%E5%86%8D%E5%B7%A6%E5%8F%B3%E5%88%86%E5%88%AB%E6%9E%84%E9%80%A0"><span class="nav-number">52.1.</span> <span class="nav-text">Solution1 先找中点 然后再左右分别构造</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-1"><span class="nav-number">53.</span> <span class="nav-text">105. 从前序与中序遍历序列构造二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-6"><span class="nav-number">53.1.</span> <span class="nav-text">Solution1 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-1"><span class="nav-number">53.2.</span> <span class="nav-text">Solution2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="nav-number">54.</span> <span class="nav-text">121. 买卖股票的最佳时机</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95"><span class="nav-number">54.1.</span> <span class="nav-text">Solution0 暴力解法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3"><span class="nav-number">54.2.</span> <span class="nav-text">Solution1 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II"><span class="nav-number">55.</span> <span class="nav-text">122. 买卖股票的最佳时机 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-number">55.1.</span> <span class="nav-text">Solution1 贪心算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2"><span class="nav-number">55.2.</span> <span class="nav-text">Solution2 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="nav-number">56.</span> <span class="nav-text">125. 验证回文串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E7%AD%9B%E9%80%89-%E5%88%A4%E6%96%AD"><span class="nav-number">56.1.</span> <span class="nav-text">Solution1 筛选 + 判断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E7%AD%9B%E9%80%89-%E5%88%A4%E6%96%AD-02"><span class="nav-number">56.2.</span> <span class="nav-text">Solution2 筛选 + 判断 02</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution03-%E5%9C%A8%E5%8E%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8A%E7%9B%B4%E6%8E%A5%E5%88%A4%E6%96%AD"><span class="nav-number">56.3.</span> <span class="nav-text">Solution03 在原字符串上直接判断</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">57.</span> <span class="nav-text">136. 只出现一次的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O-n-%E6%96%B9%E6%B3%95"><span class="nav-number">57.1.</span> <span class="nav-text">Solution1  空间复杂度O(n)方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%A4%ABO-1-%E6%96%B9%E6%B3%95"><span class="nav-number">57.2.</span> <span class="nav-text">Solution2 空间复杂夫O(1)方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#137-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-II"><span class="nav-number">58.</span> <span class="nav-text">137. 只出现一次的数字 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">58.1.</span> <span class="nav-text">Solution1 哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="nav-number">58.2.</span> <span class="nav-text">Solution2 二进制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="nav-number">59.</span> <span class="nav-text">139. 单词拆分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-4"><span class="nav-number">59.1.</span> <span class="nav-text">Solution1 动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%BC%98%E5%8C%96%E7%89%88"><span class="nav-number">59.2.</span> <span class="nav-text">Solution2 动态规划 优化版</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="nav-number">60.</span> <span class="nav-text">141. 环形链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%93%88%E5%B8%8C%E8%A1%A8-1"><span class="nav-number">60.1.</span> <span class="nav-text">Solution1 哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-2"><span class="nav-number">60.2.</span> <span class="nav-text">Solution2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II"><span class="nav-number">61.</span> <span class="nav-text">142. 环形链表 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%93%88%E5%B8%8C%E8%A1%A8-2"><span class="nav-number">61.1.</span> <span class="nav-text">Solution1 哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8F%8C%E6%8C%87%E9%92%88-2"><span class="nav-number">61.2.</span> <span class="nav-text">Solution2 双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"><span class="nav-number">62.</span> <span class="nav-text">143. 重排链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E6%9A%B4%E5%8A%9B-1"><span class="nav-number">62.1.</span> <span class="nav-text">Solution0 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8F%8C%E6%8C%87%E9%92%88-1"><span class="nav-number">62.2.</span> <span class="nav-text">Solution1 双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">63.</span> <span class="nav-text">144. 二叉树的前序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-7"><span class="nav-number">63.1.</span> <span class="nav-text">Solution1 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%BF%AD%E4%BB%A3-3"><span class="nav-number">63.2.</span> <span class="nav-text">Solution2 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#146-LRU-%E7%BC%93%E5%AD%98"><span class="nav-number">64.</span> <span class="nav-text">146. LRU 缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%93%88%E5%B8%8C%E8%A1%A8-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">64.1.</span> <span class="nav-text">Solution1 哈希表 + 双向链表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">65.</span> <span class="nav-text">148. 排序链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">65.1.</span> <span class="nav-text">Solution1 自顶向下归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">65.2.</span> <span class="nav-text">Solution2 自底向上归并排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-number">66.</span> <span class="nav-text">150. 逆波兰表达式求值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%A0%88-1"><span class="nav-number">66.1.</span> <span class="nav-text">Solution1  栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E6%A0%88"><span class="nav-number">66.2.</span> <span class="nav-text">Solution2 数组模拟栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">67.</span> <span class="nav-text">152. 乘积最大子数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E6%9A%B4%E5%8A%9B-2"><span class="nav-number">67.1.</span> <span class="nav-text">Solution0 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-5"><span class="nav-number">67.2.</span> <span class="nav-text">Solution1 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#171-Excel-%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7"><span class="nav-number">68.</span> <span class="nav-text">171. Excel 表列序号</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-26%E8%BF%9B%E5%88%B6"><span class="nav-number">68.1.</span> <span class="nav-text">Solution1  26进制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88"><span class="nav-number">69.</span> <span class="nav-text">155. 最小栈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%BE%85%E5%8A%A9%E6%A0%88"><span class="nav-number">69.1.</span> <span class="nav-text">Solution1 辅助栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%B8%8D%E7%94%A8%E8%BE%85%E5%8A%A9%E6%A0%88"><span class="nav-number">69.2.</span> <span class="nav-text">Solution2 不用辅助栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="nav-number">70.</span> <span class="nav-text">160. 相交链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88"><span class="nav-number">70.1.</span> <span class="nav-text">Solution1 哈希集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8F%8C%E6%8C%87%E9%92%88-3"><span class="nav-number">70.2.</span> <span class="nav-text">Solution2 双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#162-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC"><span class="nav-number">71.</span> <span class="nav-text">162. 寻找峰值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-12"><span class="nav-number">71.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%BA%8C%E5%88%86%E6%B3%95"><span class="nav-number">71.2.</span> <span class="nav-text">Solution2 二分法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0"><span class="nav-number">72.</span> <span class="nav-text">169. 多数元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-1-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">72.1.</span> <span class="nav-text">Solution 1 哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-2-%E6%8E%92%E5%BA%8F"><span class="nav-number">72.2.</span> <span class="nav-text">Solution 2  排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-3-Boyer-Moore-%E6%8A%95%E7%A5%A8%E6%B3%95"><span class="nav-number">72.3.</span> <span class="nav-text">Solution 3  Boyer-Moore 投票法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6"><span class="nav-number">73.</span> <span class="nav-text">172. 阶乘后的零</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1"><span class="nav-number">73.1.</span> <span class="nav-text">Solution1</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#179-%E6%9C%80%E5%A4%A7%E6%95%B0"><span class="nav-number">74.</span> <span class="nav-text">179. 最大数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E6%9A%B4%E5%8A%9B-3"><span class="nav-number">74.1.</span> <span class="nav-text">Solution0 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%8E%92%E5%BA%8F-1"><span class="nav-number">74.2.</span> <span class="nav-text">Solution1 排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#187-%E9%87%8D%E5%A4%8D%E7%9A%84DNA%E5%BA%8F%E5%88%97"><span class="nav-number">75.</span> <span class="nav-text">187. 重复的DNA序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%93%88%E5%B8%8C%E8%A1%A8-3"><span class="nav-number">75.1.</span> <span class="nav-text">Solution1 哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%93%88%E5%B8%8C%E8%A1%A8-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="nav-number">75.2.</span> <span class="nav-text">Solution2 哈希表 滑动窗口 二进制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="nav-number">76.</span> <span class="nav-text">189. 轮转数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E4%BD%BF%E7%94%A8%E9%A2%9D%E5%A4%96%E7%9A%84%E6%95%B0%E7%BB%84"><span class="nav-number">76.1.</span> <span class="nav-text">Solution1 使用额外的数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E6%95%B0%E7%BB%84%E7%BF%BB%E8%BD%AC"><span class="nav-number">76.2.</span> <span class="nav-text">Solution2  数组翻转</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D"><span class="nav-number">77.</span> <span class="nav-text">198. 打家劫舍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-6"><span class="nav-number">77.1.</span> <span class="nav-text">Solution1  动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3"><span class="nav-number">77.2.</span> <span class="nav-text">Solution2 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="nav-number">78.</span> <span class="nav-text">199. 二叉树的右视图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-1"><span class="nav-number">78.1.</span> <span class="nav-text">Solution1 层序遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="nav-number">79.</span> <span class="nav-text">200. 岛屿数量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-DFS-2"><span class="nav-number">79.1.</span> <span class="nav-text">Solution1  DFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-BFS-1"><span class="nav-number">79.2.</span> <span class="nav-text">Solution2 BFS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#202-%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="nav-number">80.</span> <span class="nav-text">202. 快乐数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="nav-number">80.1.</span> <span class="nav-text">Solution1 快慢指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E6%9A%B4%E5%8A%9B"><span class="nav-number">80.2.</span> <span class="nav-text">Solution2 暴力</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="nav-number">81.</span> <span class="nav-text">203. 移除链表元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%BF%AD%E4%BB%A3"><span class="nav-number">81.1.</span> <span class="nav-text">Solution1 迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E9%80%92%E5%BD%92"><span class="nav-number">81.2.</span> <span class="nav-text">Solution2 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">82.</span> <span class="nav-text">206. 反转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%BF%AD%E4%BB%A3-1"><span class="nav-number">82.1.</span> <span class="nav-text">Solution1 迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E9%80%92%E5%BD%92-1"><span class="nav-number">82.2.</span> <span class="nav-text">Solution2 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="nav-number">83.</span> <span class="nav-text">215. 数组中的第K个最大元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">83.1.</span> <span class="nav-text">Solution1  堆排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-number">84.</span> <span class="nav-text">217. 存在重复元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%8E%92%E5%BA%8F-2"><span class="nav-number">84.1.</span> <span class="nav-text">Solution1  排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-3"><span class="nav-number">84.2.</span> <span class="nav-text">Solution2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="nav-number">85.</span> <span class="nav-text">221. 最大正方形</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E6%9A%B4%E5%8A%9B%E6%B3%95"><span class="nav-number">85.1.</span> <span class="nav-text">Solution0 暴力法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-7"><span class="nav-number">85.2.</span> <span class="nav-text">Solution1 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88"><span class="nav-number">86.</span> <span class="nav-text">225. 用队列实现栈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97"><span class="nav-number">86.1.</span> <span class="nav-text">Solution1  两个队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8D%95%E4%B8%AA%E9%98%9F%E5%88%97"><span class="nav-number">86.2.</span> <span class="nav-text">Solution2 单个队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">87.</span> <span class="nav-text">226. 翻转二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-1"><span class="nav-number">87.1.</span> <span class="nav-text">Solution1</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#227-%E5%9F%BA%E6%9C%AC%E8%AE%A1%E7%AE%97%E5%99%A8-II"><span class="nav-number">88.</span> <span class="nav-text">227. 基本计算器 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%A0%88-2"><span class="nav-number">88.1.</span> <span class="nav-text">Solution1 栈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-number">89.</span> <span class="nav-text">232. 用栈实现队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-2"><span class="nav-number">89.1.</span> <span class="nav-text">Solution1</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="nav-number">90.</span> <span class="nav-text">234. 回文链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E5%B0%86%E9%93%BE%E8%A1%A8%E5%A4%8D%E5%88%B6%E5%88%B0%E6%95%B0%E7%BB%84"><span class="nav-number">90.1.</span> <span class="nav-text">Solution0 将链表复制到数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E4%B8%AD%E7%82%B9%E5%BC%80%E5%A7%8B%E6%AF%94%E8%BE%83"><span class="nav-number">90.2.</span> <span class="nav-text">Solution1 中点开始比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">91.</span> <span class="nav-text">230. 二叉搜索树中第K小的元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%9D%9E%E9%80%92%E5%BD%92"><span class="nav-number">91.1.</span> <span class="nav-text">Solution1  非递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%AE%B0%E5%BD%95%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE"><span class="nav-number">91.2.</span> <span class="nav-text">Solution2 记录子节点数目</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">92.</span> <span class="nav-text">235. 二叉搜索树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%9D%9E%E9%80%92%E5%BD%92-1"><span class="nav-number">92.1.</span> <span class="nav-text">Solution1  非递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E9%80%92%E5%BD%92-2"><span class="nav-number">92.2.</span> <span class="nav-text">Solution2 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">93.</span> <span class="nav-text">236. 二叉树的最近公共祖先</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-8"><span class="nav-number">93.1.</span> <span class="nav-text">Solution1 递归</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
