<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="Leetcode problems Solutions Note">
<meta property="og:url" content="http://example.com/2022/08/22/Leetcode-problems-Solutions-Note/index.html">
<meta property="og:site_name" content="Blog of Chen">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://files.mdnice.com/user/1489/eb7c965d-59c0-4b08-8d6a-6d3943f10cf5.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7821e311-00aa-40b0-8ab9-57471419d97b.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/cd61b224-e4ae-4271-bef4-076a650f65b3.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e078bf30-d641-4c56-b4c9-8d1da707d807.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e4fa6f50-22c9-41c7-8f6c-e43aab780585.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5cd09d98-bd6d-413f-a699-5d03755f5802.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5bfffdd4-470d-482c-849d-e4e82e2b40d8.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f6e5ea9e-b6b4-4545-97c5-2ef86e5fbd08.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/b3fb36fb-92e9-417d-9c00-60756ed04c17.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/1d658e59-2c76-4ade-a9c5-39a2ff20161f.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7fc31992-dc5b-4e11-bb5e-7c61942e6e57.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4097f955-844e-4ceb-a4c1-513342bc6e37.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/9e16db80-4a17-41b8-9d9d-cdef5be73f58.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/10427a40-975c-4b6b-85ff-d17cc899c623.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/34777dfe-25ba-4a81-883e-b66110b1a8c9.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8b223432-03ba-43a5-8968-584c7c8d8068.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/36ee0f58-1bce-411c-b3fc-308d769ad869.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/97cb5a3b-6aaa-4be9-9b17-dde9d86f17ab.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/80714af6-4b56-4b6d-965a-6d0e396c1b63.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/997007a2-0e00-49d3-88fc-6865a7578af8.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/60ec6cc2-9148-40df-ad8e-2969def89c43.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/56d57700-be9b-4a89-b09c-1d373b1d5318.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8a4705a4-439c-4262-bdce-8186ee916289.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5700074e-68cb-427a-9e58-a1858ab736e1.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/6fc73b94-e500-4182-a9f9-e1d8a4e29a32.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/e8db6a23-fe74-4f65-b6a6-6cafbddff0bc.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/319c806f-a568-403a-9a39-c4ac50f30308.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4a4d21b3-ff48-457a-a612-9723074e0647.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5984996e-8148-4ae1-8ed9-8198e3625d2f.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/846120fb-5574-4fde-bd23-c798e938fa6e.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/19d7f700-92c7-4591-bef6-efe163c000f3.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d99bbb87-979c-426b-b6e5-647acf2cad20.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/1a1aae99-5b02-4641-9e50-5bd0913d1e4d.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/8aeff7af-53ed-467e-aebc-7835db5b52f5.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5be86979-df7c-4994-a29c-088dc60e24e6.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a825eedd-e311-4153-bc5b-ed31be497911.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/707aac6e-eec8-4f5a-8f0f-b7b45d344451.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ebc2117f-b989-4c3d-b852-4b2b26c77453.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/1d9b3377-72f8-4c1b-8451-a2e484bfdc1c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/166bca4c-bcc2-4718-b6f4-1576acf3ff36.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/a150914f-1207-4dc6-8091-639f11405933.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/d66220b0-0d89-479e-9313-6adce6816e8c.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/17bcb971-2dd2-4659-a84f-24493a37c88e.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/35a4e4dc-eb76-4d87-ba29-735a5042bfe1.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/3f09955d-d39b-41e9-8495-445cf9b35418.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f28b6ed7-01b5-4a89-952f-d626edf15d9e.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/988437b9-f65e-4111-8cde-79a687333027.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/c915e202-251b-48cd-816b-cfcabdbf2214.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5f3de36e-929d-4f22-adcb-a8070f305409.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/070d05a3-3ee3-4b0a-90da-bed5c1c2b9a8.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/5536a636-d181-42b9-a760-57aff155691a.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/9d910293-a6c0-4c4b-bfd8-c8e32fae01e8.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/fb453ee9-27d8-4bad-86ea-346219e70b18.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/bd915655-54ae-4387-8d94-22cabd830f19.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/4391ada0-91de-488d-a3a9-23fa346ea804.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/ae0e1058-6b96-43e8-9daa-10bf26ee4ccd.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/779a4035-c7d9-4b9a-b232-3f2cddeaa550.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/12eb162d-772a-41e8-b79b-1e8acfb28d87.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7e979e15-b4a4-41bb-92d8-1cfb54630ee6.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/f65c3a6a-debe-4c68-ac3b-171b07af7262.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/9add3a1c-b13f-4277-a2b6-e511bf914864.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/1411c0a9-8a0f-452f-8fc6-ff371d70d1d0.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/fc7adb50-508e-4b31-b28e-f3f11eea8217.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/335701cf-1815-4ee0-a266-d54c6c35669b.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/725fc0e8-c8e6-4660-b971-9c47beb3c888.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/7323d75f-2b46-4b8a-9908-4f5c654281f5.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/04aefe28-f537-4f0f-a96c-e08abbe1030f.png">
<meta property="og:image" content="https://files.mdnice.com/user/1489/de302c02-3172-4795-81bf-b52f9a497fcf.png">
<meta property="article:published_time" content="2022-08-22T14:45:47.000Z">
<meta property="article:modified_time" content="2022-08-27T08:14:59.793Z">
<meta property="article:author" content="Chen">
<meta property="article:tag" content="Leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://files.mdnice.com/user/1489/eb7c965d-59c0-4b08-8d6a-6d3943f10cf5.png">

<link rel="canonical" href="http://example.com/2022/08/22/Leetcode-problems-Solutions-Note/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Leetcode problems Solutions Note | Blog of Chen</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Blog of Chen" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Blog of Chen</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">陈同学的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/22/Leetcode-problems-Solutions-Note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blog of Chen">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Leetcode problems Solutions Note
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-22 22:45:47" itemprop="dateCreated datePublished" datetime="2022-08-22T22:45:47+08:00">2022-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-27 16:14:59" itemprop="dateModified" datetime="2022-08-27T16:14:59+08:00">2022-08-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
                </span>
            </span>

          
            <div class="post-description"> </div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <meta name="referrer" content="no-referrer"/>

<h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">1. Two Sum</a></h1><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。<br>示例 2：</p>
<p>输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]<br>示例 3：</p>
<p>输入：nums &#x3D; [3,3], target &#x3D; 6<br>输出：[0,1]
 </p>
<p>提示：</p>
<p>2 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>-109 &lt;&#x3D; target &lt;&#x3D; 109<br>只会存在一个有效答案<br>进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？</p>
<h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>双层遍历</p>
<h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>哈希表</p>
<h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h1><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：digits &#x3D; “23”<br>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]<br>示例 2：</p>
<p>输入：digits &#x3D; “”<br>输出：[]<br>示例 3：</p>
<p>输入：digits &#x3D; “2”<br>输出：[“a”,”b”,”c”]
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; digits.length &lt;&#x3D; 4<br>digits[i] 是范围 [‘2’, ‘9’] 的一个数字。</p>
<h2 id="Solution-1-暴力"><a href="#Solution-1-暴力" class="headerlink" title="Solution 1  暴力"></a>Solution 1  暴力</h2><h2 id="Soulution-2-回溯"><a href="#Soulution-2-回溯" class="headerlink" title="Soulution 2  回溯"></a>Soulution 2  回溯</h2><p><img src="https://files.mdnice.com/user/1489/eb7c965d-59c0-4b08-8d6a-6d3943f10cf5.png"><br><img src="https://files.mdnice.com/user/1489/7821e311-00aa-40b0-8ab9-57471419d97b.png"></p>
<h2 id="Solution-3-队列"><a href="#Solution-3-队列" class="headerlink" title="Solution 3  队列"></a>Solution 3  队列</h2><p><img src="https://files.mdnice.com/user/1489/cd61b224-e4ae-4271-bef4-076a650f65b3.png"></p>
<p><img src="https://files.mdnice.com/user/1489/e078bf30-d641-4c56-b4c9-8d1da707d807.png"></p>
<p><img src="https://files.mdnice.com/user/1489/e4fa6f50-22c9-41c7-8f6c-e43aab780585.png"></p>
<h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h1><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<p>0 &lt;&#x3D; a, b, c, d &lt; n<br>a、b、c 和 d 互不相同<br>nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target<br>你可以按 任意顺序 返回答案 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0<br>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]<br>示例 2：</p>
<p>输入：nums &#x3D; [2,2,2,2,2], target &#x3D; 8<br>输出：[[2,2,2,2]]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>-109 &lt;&#x3D; target &lt;&#x3D; 109</p>
<h2 id="Solution-1-暴力枚举"><a href="#Solution-1-暴力枚举" class="headerlink" title="Solution 1  暴力枚举"></a>Solution 1  暴力枚举</h2><h2 id="Solution-2-双指针法"><a href="#Solution-2-双指针法" class="headerlink" title="Solution 2  双指针法"></a>Solution 2  双指针法</h2><p><img src="https://files.mdnice.com/user/1489/5cd09d98-bd6d-413f-a699-5d03755f5802.png"></p>
<h1 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list">19. 删除链表的倒数第 N 个结点</a></h1><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>输出：[1,2,3,5]<br>示例 2：</p>
<p>输入：head &#x3D; [1], n &#x3D; 1<br>输出：[]<br>示例 3：</p>
<p>输入：head &#x3D; [1,2], n &#x3D; 1<br>输出：[1]
 </p>
<p>提示：</p>
<p>链表中结点的数目为 sz<br>1 &lt;&#x3D; sz &lt;&#x3D; 30<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>1 &lt;&#x3D; n &lt;&#x3D; sz
 </p>
<h2 id="Solution1-计算链表长度"><a href="#Solution1-计算链表长度" class="headerlink" title="Solution1 计算链表长度"></a>Solution1 计算链表长度</h2><p><img src="https://files.mdnice.com/user/1489/5bfffdd4-470d-482c-849d-e4e82e2b40d8.png"></p>
<h2 id="Solution2-栈"><a href="#Solution2-栈" class="headerlink" title="Solution2 栈"></a>Solution2 栈</h2><p><img src="https://files.mdnice.com/user/1489/f6e5ea9e-b6b4-4545-97c5-2ef86e5fbd08.png"></p>
<p><img src="https://files.mdnice.com/user/1489/b3fb36fb-92e9-417d-9c00-60756ed04c17.png"></p>
<h2 id="Solution3-快慢指针"><a href="#Solution3-快慢指针" class="headerlink" title="Solution3 快慢指针"></a>Solution3 快慢指针</h2><p><img src="https://files.mdnice.com/user/1489/1d658e59-2c76-4ade-a9c5-39a2ff20161f.png"></p>
<p><img src="https://files.mdnice.com/user/1489/7fc31992-dc5b-4e11-bb5e-7c61942e6e57.png"></p>
<p>#<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></p>
<p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。
 </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “()”<br>输出：true<br>示例 2：</p>
<p>输入：s &#x3D; “()[]{}”<br>输出：true<br>示例 3：</p>
<p>输入：s &#x3D; “(]”<br>输出：false<br>示例 4：</p>
<p>输入：s &#x3D; “([)]”<br>输出：false<br>示例 5：</p>
<p>输入：s &#x3D; “{[]}”<br>输出：true</p>
<h2 id="Solution1-栈"><a href="#Solution1-栈" class="headerlink" title="Solution1 栈"></a>Solution1 栈</h2><p><img src="https://files.mdnice.com/user/1489/4097f955-844e-4ceb-a4c1-513342bc6e37.png"></p>
<p>#<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></p>
<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
<p>示例 1：</p>
<p>输入：n &#x3D; 3<br>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]<br>示例 2：</p>
<p>输入：n &#x3D; 1<br>输出：[“()”]</p>
<p>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 8</p>
<h2 id="Solution1-暴力"><a href="#Solution1-暴力" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><p><img src="https://files.mdnice.com/user/1489/9e16db80-4a17-41b8-9d9d-cdef5be73f58.png"></p>
<h2 id="Solution2-递归-剪枝"><a href="#Solution2-递归-剪枝" class="headerlink" title="Solution2 递归 + 剪枝"></a>Solution2 递归 + 剪枝</h2><p><img src="https://files.mdnice.com/user/1489/10427a40-975c-4b6b-85ff-d17cc899c623.png"></p>
<h1 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h1><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4]<br>输出：[2,1,4,3]<br>示例 2：</p>
<p>输入：head &#x3D; []<br>输出：[]<br>示例 3：</p>
<p>输入：head &#x3D; [1]<br>输出：[1]</p>
<h2 id="Solution1-递归"><a href="#Solution1-递归" class="headerlink" title="Solution1  递归"></a>Solution1  递归</h2><p><img src="https://files.mdnice.com/user/1489/34777dfe-25ba-4a81-883e-b66110b1a8c9.png"></p>
<h2 id="Solution2-迭代"><a href="#Solution2-迭代" class="headerlink" title="Solution2 迭代"></a>Solution2 迭代</h2><p><img src="https://files.mdnice.com/user/1489/8b223432-03ba-43a5-8968-584c7c8d8068.png"></p>
<p><img src="https://files.mdnice.com/user/1489/36ee0f58-1bce-411c-b3fc-308d769ad869.png"></p>
<h1 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="[26. 删除有序数组中的重复项]"></a>[26. 删除有序数组中的重复项]</h1><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p>
<p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p>
<p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p>
<p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<p>判题标准:</p>
<p>系统会用下面的代码来测试你的题解:</p>
<p>int[] nums &#x3D; […]; &#x2F;&#x2F; 输入数组<br>int[] expectedNums &#x3D; […]; &#x2F;&#x2F; 长度正确的期望答案</p>
<p>int k &#x3D; removeDuplicates(nums); &#x2F;&#x2F; 调用</p>
<p>assert k &#x3D;&#x3D; expectedNums.length;<br>for (int i &#x3D; 0; i &lt; k; i++) {<br>    assert nums[i] &#x3D;&#x3D; expectedNums[i];<br>}<br>如果所有断言都通过，那么您的题解将被 通过。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,1,2]<br>输出：2, nums &#x3D; [1,2,_]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。<br>示例 2：</p>
<p>输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums &#x3D; [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>nums 已按 升序 排列</p>
<h2 id="Solution1-暴力-1"><a href="#Solution1-暴力-1" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-双指针"><a href="#Solution2-双指针" class="headerlink" title="Solution2 双指针"></a>Solution2 双指针</h2><p><img src="https://files.mdnice.com/user/1489/97cb5a3b-6aaa-4be9-9b17-dde9d86f17ab.png"></p>
<h2 id="Solution3-双指针-优化"><a href="#Solution3-双指针-优化" class="headerlink" title="Solution3 双指针 优化"></a>Solution3 双指针 优化</h2><p><img src="https://files.mdnice.com/user/1489/80714af6-4b56-4b6d-965a-6d0e396c1b63.png"></p>
<h1 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列</a></h1><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p>
<p>例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<p>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。</p>
<p>必须 原地 修改，只允许使用额外常数空间。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3]<br>输出：[1,3,2]<br>示例 2：</p>
<p>输入：nums &#x3D; [3,2,1]<br>输出：[1,2,3]<br>示例 3：</p>
<p>输入：nums &#x3D; [1,1,5]<br>输出：[1,5,1]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p>
<h2 id="Solution1-暴力-2"><a href="#Solution1-暴力-2" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p><img src="https://files.mdnice.com/user/1489/997007a2-0e00-49d3-88fc-6865a7578af8.png"></p>
<h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h1><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
<p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0<br>输出：4<br>示例 2：</p>
<p>输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3<br>输出：-1<br>示例 3：</p>
<p>输入：nums &#x3D; [1], target &#x3D; 0<br>输出：-1
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 5000<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>nums 中的每个值都 独一无二<br>题目数据保证 nums 在预先未知的某个下标上进行了旋转<br>-104 &lt;&#x3D; target &lt;&#x3D; 104</p>
<h2 id="Solution1-暴力-3"><a href="#Solution1-暴力-3" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-二分查找"><a href="#Solution2-二分查找" class="headerlink" title="Solution2 二分查找"></a>Solution2 二分查找</h2><p><img src="https://files.mdnice.com/user/1489/60ec6cc2-9148-40df-ad8e-2969def89c43.png"></p>
<h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h1><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8<br>输出：[3,4]<br>示例 2：</p>
<p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6<br>输出：[-1,-1]<br>示例 3：</p>
<p>输入：nums &#x3D; [], target &#x3D; 0<br>输出：[-1,-1]
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>nums 是一个非递减数组<br>-109 &lt;&#x3D; target &lt;&#x3D; 109</p>
<h2 id="Solution1-暴力-4"><a href="#Solution1-暴力-4" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-二分"><a href="#Solution2-二分" class="headerlink" title="Solution2 二分"></a>Solution2 二分</h2><p>二分搜索讲解<br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1fA4y1o715?spm_id_from=0.0.header_right.history_list.click">https://www.bilibili.com/video/BV1fA4y1o715?spm_id_from=0.0.header_right.history_list.click</a></p>
<p>寻找target在数组里的左右边界，有如下三种情况：</p>
<ul>
<li>情况一：target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1}</li>
<li>情况二：target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1}</li>
<li>情况三：target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{1, 1}</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int leftBorder = getLeftBorder(nums, target);</span><br><span class="line">        int rightBorder = getRightBorder(nums, target);</span><br><span class="line">        // 情况一</span><br><span class="line">        if (leftBorder == -2 || rightBorder == -2) return &#123;-1, -1&#125;;</span><br><span class="line">        // 情况三</span><br><span class="line">        if (rightBorder - leftBorder &gt; 1) return &#123;leftBorder + 1, rightBorder - 1&#125;;</span><br><span class="line">        // 情况二</span><br><span class="line">        return &#123;-1, -1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">     int getRightBorder(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.size() - 1;</span><br><span class="line">        int rightBorder = -2; // 记录一下rightBorder没有被赋值的情况</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int middle = left + ((right - left) / 2);</span><br><span class="line">            if (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - 1;</span><br><span class="line">            &#125; else &#123; // 寻找右边界，nums[middle] == target的时候更新left</span><br><span class="line">                left = middle + 1;</span><br><span class="line">                rightBorder = left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rightBorder;</span><br><span class="line">    &#125;</span><br><span class="line">    int getLeftBorder(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.size() - 1;</span><br><span class="line">        int leftBorder = -2; // 记录一下leftBorder没有被赋值的情况</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int middle = left + ((right - left) / 2);</span><br><span class="line">            if (nums[middle] &gt;= target) &#123; // 寻找左边界，nums[middle] == target的时候更新right</span><br><span class="line">                right = middle - 1;</span><br><span class="line">                leftBorder = right;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left = middle + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return leftBorder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id=""><a href="#" class="headerlink" title=""></a><a href=""></a></h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 O(log n) 的算法。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 5<br>输出: 2<br>示例 2:</p>
<p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 2<br>输出: 1<br>示例 3:</p>
<p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 7<br>输出: 4</p>
<h2 id="Solution1-暴力-5"><a href="#Solution1-暴力-5" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int searchInsert(int[] nums, int target) &#123;</span><br><span class="line">    for(int i = 0; i &lt; nums.length;i++)&#123;</span><br><span class="line">        if(nums[i] &gt;= target)&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-二分-1"><a href="#Solution2-二分-1" class="headerlink" title="Solution2 二分"></a>Solution2 二分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = n; // 定义target在左闭右开的区间里，[left, right)  target</span><br><span class="line">        while (left &lt; right) &#123; // 因为left == right的时候，在[left, right)是无效的空间</span><br><span class="line">            int middle = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">            if (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle; // target 在左区间，在[left, middle)中</span><br><span class="line">            &#125; else if (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + 1; // target 在右区间，在 [middle+1, right)中</span><br><span class="line">            &#125; else &#123; // nums[middle] == target</span><br><span class="line">                return middle; // 数组中找到目标值的情况，直接返回下标</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 分别处理如下四种情况</span><br><span class="line">        // 目标值在数组所有元素之前 [0,0)</span><br><span class="line">        // 目标值等于数组中某一个元素 return middle</span><br><span class="line">        // 目标值插入数组中的位置 [left, right) ，return right 即可</span><br><span class="line">        // 目标值在数组所有元素之后的情况 [left, right)，这是右开区间，return right 即可</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h1><h2 id="Solution1-暴力-6"><a href="#Solution1-暴力-6" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-回溯"><a href="#Solution2-回溯" class="headerlink" title="Solution2 回溯"></a>Solution2 回溯</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;int&gt;&amp; candidates, int target, vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt;&amp; combine, int idx) &#123;</span><br><span class="line">        if (idx == candidates.size()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (target == 0) &#123;</span><br><span class="line">            ans.emplace_back(combine);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 直接跳过</span><br><span class="line">        dfs(candidates, target, ans, combine, idx + 1);</span><br><span class="line">        // 选择当前数</span><br><span class="line">        if (target - candidates[idx] &gt;= 0) &#123;</span><br><span class="line">            combine.emplace_back(candidates[idx]);</span><br><span class="line">            dfs(candidates, target - candidates[idx], ans, combine, idx);</span><br><span class="line">            combine.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        vector&lt;int&gt; combine;</span><br><span class="line">        dfs(candidates, target, ans, combine, 0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h1><h2 id="Solution1-回溯"><a href="#Solution1-回溯" class="headerlink" title="Solution1 回溯"></a>Solution1 回溯</h2><p>方法一：回溯<br>思路与算法</p>
<p>由于我们需要求出所有和为 \textit{target}target 的组合，并且每个数只能使用一次，因此我们可以使用递归 + 回溯的方法来解决这个问题：</p>
<p>我们用 \textit{dfs}(\textit{pos}, \textit{rest})dfs(pos,rest) 表示递归的函数，其中 \textit{pos}pos 表示我们当前递归到了数组 \textit{candidates}candidates 中的第 \textit{pos}pos 个数，而 \textit{rest}rest 表示我们还需要选择和为 \textit{rest}rest 的数放入列表作为一个组合；</p>
<p>对于当前的第 \textit{pos}pos 个数，我们有两种方法：选或者不选。如果我们选了这个数，那么我们调用 \textit{dfs}(\textit{pos} + 1, \textit{rest} - \textit{candidates}[\textit{pos}])dfs(pos+1,rest−candidates[pos]) 进行递归，注意这里必须满足 \textit{rest} \geq \textit{candidates}[\textit{pos}]rest≥candidates[pos]。如果我们不选这个数，那么我们调用 \textit{dfs}(\textit{pos} + 1, \textit{rest})dfs(pos+1,rest) 进行递归；</p>
<p>在某次递归开始前，如果 \textit{rest}rest 的值为 00，说明我们找到了一个和为 \textit{target}target 的组合，将其放入答案中。每次调用递归函数前，如果我们选了那个数，就需要将其放入列表的末尾，该列表中存储了我们选的所有数。在回溯时，如果我们选了那个数，就要将其从列表的末尾删除。</p>
<p>上述算法就是一个标准的递归 + 回溯算法，但是它并不适用于本题。这是因为题目描述中规定了解集不能包含重复的组合，而上述的算法中并没有去除重复的组合。</p>
<p>例如当 \textit{candidates} &#x3D; [2, 2]candidates&#x3D;[2,2]，\textit{target} &#x3D; 2target&#x3D;2 时，上述算法会将列表 [2][2] 放入答案两次。</p>
<p>因此，我们需要改进上述算法，在求出组合的过程中就进行去重的操作。我们可以考虑将相同的数放在一起进行处理，也就是说，如果数 \textit{x}x 出现了 yy 次，那么在递归时一次性地处理它们，即分别调用选择 0, 1, \cdots, y0,1,⋯,y 次 xx 的递归函数。这样我们就不会得到重复的组合。具体地：</p>
<p>我们使用一个哈希映射（HashMap）统计数组 \textit{candidates}candidates 中每个数出现的次数。在统计完成之后，我们将结果放入一个列表 \textit{freq}freq 中，方便后续的递归使用。</p>
<p>列表 \textit{freq}freq 的长度即为数组 \textit{candidates}candidates 中不同数的个数。其中的每一项对应着哈希映射中的一个键值对，即某个数以及它出现的次数。<br>在递归时，对于当前的第 \textit{pos}pos 个数，它的值为 \textit{freq}[\textit{pos}][0]freq[pos][0]，出现的次数为 \textit{freq}[\textit{pos}][1]freq[pos][1]，那么我们可以调用</p>
<p>\textit{dfs}(\textit{pos} + 1, \textit{rest} - i \times \textit{freq}[\textit{pos}][0])<br>dfs(pos+1,rest−i×freq[pos][0])</p>
<p>即我们选择了这个数 ii 次。这里 ii 不能大于这个数出现的次数，并且 i \times \textit{freq}[\textit{pos}][0]i×freq[pos][0] 也不能大于 \textit{rest}rest。同时，我们需要将 ii 个 \textit{freq}[\textit{pos}][0]freq[pos][0] 放入列表中。</p>
<p>这样一来，我们就可以不重复地枚举所有的组合了。</p>
<p>我们还可以进行什么优化（剪枝）呢？一种比较常用的优化方法是，我们将 \textit{freq}freq 根据数从小到大排序，这样我们在递归时会先选择小的数，再选择大的数。这样做的好处是，当我们递归到 \textit{dfs}(\textit{pos}, \textit{rest})dfs(pos,rest) 时，如果 \textit{freq}[\textit{pos}][0]freq[pos][0] 已经大于 \textit{rest}rest，那么后面还没有递归到的数也都大于 \textit{rest}rest，这就说明不可能再选择若干个和为 \textit{rest}rest 的数放入列表了。此时，我们就可以直接回溯。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; freq;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    vector&lt;int&gt; sequence;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void dfs(int pos, int rest) &#123;</span><br><span class="line">        if (rest == 0) &#123;</span><br><span class="line">            ans.push_back(sequence);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (pos == freq.size() || rest &lt; freq[pos].first) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(pos + 1, rest);</span><br><span class="line"></span><br><span class="line">        int most = min(rest / freq[pos].first, freq[pos].second);</span><br><span class="line">        for (int i = 1; i &lt;= most; ++i) &#123;</span><br><span class="line">            sequence.push_back(freq[pos].first);</span><br><span class="line">            dfs(pos + 1, rest - i * freq[pos].first);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= most; ++i) &#123;</span><br><span class="line">            sequence.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        for (int num: candidates) &#123;</span><br><span class="line">            if (freq.empty() || num != freq.back().first) &#123;</span><br><span class="line">                freq.emplace_back(num, 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ++freq.back().second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(0, target);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h1><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]<br>示例 2：</p>
<p>输入：nums &#x3D; [0,1]<br>输出：[[0,1],[1,0]]<br>示例 3：</p>
<p>输入：nums &#x3D; [1]<br>输出：[[1]]
 </p>
<h2 id="Solution1-暴力-7"><a href="#Solution1-暴力-7" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-回溯-1"><a href="#Solution2-回溯-1" class="headerlink" title="Solution2 回溯"></a>Solution2 回溯</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void backtrack(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; output, int first, int len)&#123;</span><br><span class="line">        // 所有数都填完了</span><br><span class="line">        if (first == len) &#123;</span><br><span class="line">            res.emplace_back(output);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = first; i &lt; len; ++i) &#123;</span><br><span class="line">            // 动态维护数组</span><br><span class="line">            swap(output[i], output[first]);</span><br><span class="line">            // 继续递归填下一个数</span><br><span class="line">            backtrack(res, output, first + 1, len);</span><br><span class="line">            // 撤销操作</span><br><span class="line">            swap(output[i], output[first]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">        backtrack(res, nums, 0, (int)nums.size());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h1><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[[7,4,1],[8,5,2],[9,6,3]]<br>示例 2：</p>
<p>输入：matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]<br>输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
 </p>
<p>提示：</p>
<p>n &#x3D;&#x3D; matrix.length &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; n &lt;&#x3D; 20<br>-1000 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 1000
 </p>
<h2 id="Solution1-原地查找"><a href="#Solution1-原地查找" class="headerlink" title="Solution1 原地查找"></a>Solution1 原地查找</h2><h2 id="Solution2-先转置再竖直对称反转"><a href="#Solution2-先转置再竖直对称反转" class="headerlink" title="Solution2 先转置再竖直对称反转"></a>Solution2 先转置再竖直对称反转</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        //先转置</span><br><span class="line">        for(int row=0;row&lt;=matrix.size()-1;row++)&#123;</span><br><span class="line"></span><br><span class="line">            for(int col=row;col&lt;=matrix[0].size()-1;col++)&#123;</span><br><span class="line">                swap(matrix[row][col],matrix[col][row]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //在竖直对称翻转</span><br><span class="line">        for(int row=0;row&lt;=matrix.size()-1;row++)&#123;</span><br><span class="line">            for(int col = 0;col&lt;=(matrix.size()-1)/2;col++)&#123;</span><br><span class="line">                swap(matrix[row][col],matrix[row][matrix.size()-1-col]);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></h1><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p>
<p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: strs &#x3D; [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]<br>示例 2:</p>
<p>输入: strs &#x3D; [“”]<br>输出: [[“”]]<br>示例 3:</p>
<p>输入: strs &#x3D; [“a”]<br>输出: [[“a”]]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; strs.length &lt;&#x3D; 104<br>0 &lt;&#x3D; strs[i].length &lt;&#x3D; 100<br>strs[i] 仅包含小写字母</p>
<h2 id="Solution1-Map"><a href="#Solution1-Map" class="headerlink" title="Solution1 Map"></a>Solution1 Map</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        </span><br><span class="line">        map&lt;string,vector&lt;string&gt;&gt;res;</span><br><span class="line">        //遍历 </span><br><span class="line">        for(auto val:strs)&#123;</span><br><span class="line">            string tmp=val;</span><br><span class="line">               //以排序后的str作为key  vector&lt;string&gt;作为value 放进map</span><br><span class="line">            sort(val.begin(),val.end());</span><br><span class="line">            if(res.find(val)==res.end())&#123;</span><br><span class="line">                vector&lt;string&gt; t=&#123;tmp&#125;;</span><br><span class="line">                res.insert(&#123;val,t&#125;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res[val].push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历输出结果</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">        for(auto p:res)&#123;</span><br><span class="line">            result.push_back(p.second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/powx-n/">50. Pow(x, n)</a></h1><p>实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，xn ）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：x &#x3D; 2.00000, n &#x3D; 10<br>输出：1024.00000<br>示例 2：</p>
<p>输入：x &#x3D; 2.10000, n &#x3D; 3<br>输出：9.26100<br>示例 3：</p>
<p>输入：x &#x3D; 2.00000, n &#x3D; -2<br>输出：0.25000<br>解释：2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25
 </p>
<p>提示：</p>
<p>-100.0 &lt; x &lt; 100.0<br>-231 &lt;&#x3D; n &lt;&#x3D; 231-1<br>-104 &lt;&#x3D; xn &lt;&#x3D; 104</p>
<h2 id="Solution1-快速幂-递归"><a href="#Solution1-快速幂-递归" class="headerlink" title="Solution1  快速幂+递归"></a>Solution1  快速幂+递归</h2><p><img src="https://files.mdnice.com/user/1489/56d57700-be9b-4a89-b09c-1d373b1d5318.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double quickMul(double x, long long N) &#123;</span><br><span class="line">        if (N == 0) &#123;</span><br><span class="line">            return 1.0;</span><br><span class="line">        &#125;</span><br><span class="line">        double y = quickMul(x, N / 2);</span><br><span class="line">        return N % 2 == 0 ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double myPow(double x, int n) &#123;</span><br><span class="line">        long long N = n;</span><br><span class="line">        return N &gt;= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h1><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>子数组 是数组中的一个连续部分。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。<br>示例 2：</p>
<p>输入：nums &#x3D; [1]<br>输出：1<br>示例 3：</p>
<p>输入：nums &#x3D; [5,4,-1,7,8]<br>输出：23
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104
 </p>
<h2 id="Solution1-暴力-8"><a href="#Solution1-暴力-8" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-动态规划"><a href="#Solution2-动态规划" class="headerlink" title="Solution2 动态规划"></a>Solution2 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/8a4705a4-439c-4262-bdce-8186ee916289.png"></p>
<p><img src="https://files.mdnice.com/user/1489/5700074e-68cb-427a-9e58-a1858ab736e1.png"></p>
<h1 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></h1><p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br>示例 2：</p>
<p>输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7]
 </p>
<p>提示：</p>
<p>m &#x3D;&#x3D; matrix.length<br>n &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 10<br>-100 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 100</p>
<h2 id="Solution1-原地遍历"><a href="#Solution1-原地遍历" class="headerlink" title="Solution1 原地遍历"></a>Solution1 原地遍历</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">          if(matrix.empty())&#123;return res;&#125;</span><br><span class="line">        int s=0,x=matrix.size()-1,z=0,y=matrix[0].size()-1;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">        while(true)&#123;</span><br><span class="line">            //在上边沿</span><br><span class="line">            for(int i=s,j=z;j&lt;=y;j++)&#123;</span><br><span class="line">                res.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(++s&gt;x)   break;</span><br><span class="line">            //在右边沿</span><br><span class="line">            for(int i=s,j=y;i&lt;=x;i++)&#123;</span><br><span class="line">                  res.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(--y&lt;z) break;</span><br><span class="line">            //在下边沿</span><br><span class="line">           for(int i=x,j=y;j&gt;=z;j--)&#123;</span><br><span class="line">                  res.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(--x&lt;s) break;</span><br><span class="line">            //在左边沿</span><br><span class="line">           for(int i=x,j=z;i&gt;=s;i--)&#123;</span><br><span class="line">                  res.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(++z&gt;y) break;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-按层遍历"><a href="#Solution2-按层遍历" class="headerlink" title="Solution2 按层遍历"></a>Solution2 按层遍历</h2><p><img src="https://files.mdnice.com/user/1489/6fc73b94-e500-4182-a9f9-e1d8a4e29a32.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        if (matrix.size() == 0 || matrix[0].size() == 0) &#123;</span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int rows = matrix.size(), columns = matrix[0].size();</span><br><span class="line">        vector&lt;int&gt; order;</span><br><span class="line">        int left = 0, right = columns - 1, top = 0, bottom = rows - 1;</span><br><span class="line">        while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">            for (int column = left; column &lt;= right; column++) &#123;</span><br><span class="line">                order.push_back(matrix[top][column]);</span><br><span class="line">            &#125;</span><br><span class="line">            for (int row = top + 1; row &lt;= bottom; row++) &#123;</span><br><span class="line">                order.push_back(matrix[row][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            if (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">                for (int column = right - 1; column &gt; left; column--) &#123;</span><br><span class="line">                    order.push_back(matrix[bottom][column]);</span><br><span class="line">                &#125;</span><br><span class="line">                for (int row = bottom; row &gt; top; row--) &#123;</span><br><span class="line">                    order.push_back(matrix[row][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        return order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h1><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<br>示例 2：</p>
<p>输入：intervals &#x3D; [[1,4],[4,5]]<br>输出：[[1,5]]<br>解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; intervals.length &lt;&#x3D; 104<br>intervals[i].length &#x3D;&#x3D; 2<br>0 &lt;&#x3D; starti &lt;&#x3D; endi &lt;&#x3D; 104</p>
<h2 id="Solution1-排序"><a href="#Solution1-排序" class="headerlink" title="Solution1 排序"></a>Solution1 排序</h2><p><img src="https://files.mdnice.com/user/1489/e8db6a23-fe74-4f65-b6a6-6cafbddff0bc.png"></p>
<p>复杂度分析</p>
<p>时间复杂度：O(n\log n)O(nlogn)，其中 nn 为区间的数量。除去排序的开销，我们只需要一次线性扫描，所以主要的时间开销是排序的 O(n\log n)O(nlogn)。</p>
<p>空间复杂度：O(\log n)O(logn)，其中 nn 为区间的数量。这里计算的是存储答案之外，使用的额外空间。O(\log n)O(logn) 即为排序所需要的空间复杂度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        if (intervals.size() == 0) &#123;</span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(intervals.begin(), intervals.end());</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; merged;</span><br><span class="line">        for (int i = 0; i &lt; intervals.size(); ++i) &#123;</span><br><span class="line">            int L = intervals[i][0], R = intervals[i][1];</span><br><span class="line">            if (!merged.size() || merged.back()[1] &lt; L) &#123;</span><br><span class="line">                merged.push_back(&#123;L, R&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                merged.back()[1] = max(merged.back()[1], R);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-list/">61. 旋转链表</a></h1><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2<br>输出：[4,5,1,2,3]<br>示例 2：</p>
<p>输入：head &#x3D; [0,1,2], k &#x3D; 4<br>输出：[2,0,1]
 </p>
<p>提示：</p>
<p>链表中节点的数目在范围 [0, 500] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>0 &lt;&#x3D; k &lt;&#x3D; 2 * 109</p>
<h2 id="Solution1-暴力-9"><a href="#Solution1-暴力-9" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Soluion2-闭环"><a href="#Soluion2-闭环" class="headerlink" title="Soluion2  闭环"></a>Soluion2  闭环</h2><p><img src="https://files.mdnice.com/user/1489/319c806f-a568-403a-9a39-c4ac50f30308.png"></p>
<h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p> </p>
<p>示例 1：</p>
<p>输入：m &#x3D; 3, n &#x3D; 7<br>输出：28<br>示例 2：</p>
<p>输入：m &#x3D; 3, n &#x3D; 2<br>输出：3<br>解释：<br>从左上角开始，总共有 3 条路径可以到达右下角。</p>
<ol>
<li>向右 -&gt; 向下 -&gt; 向下</li>
<li>向下 -&gt; 向下 -&gt; 向右</li>
<li>向下 -&gt; 向右 -&gt; 向下<br>示例 3：</li>
</ol>
<p>输入：m &#x3D; 7, n &#x3D; 3<br>输出：28<br>示例 4：</p>
<p>输入：m &#x3D; 3, n &#x3D; 3<br>输出：6
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; m, n &lt;&#x3D; 100<br>题目数据保证答案小于等于 2 * 109</p>
<h2 id="Solution1-排列组合"><a href="#Solution1-排列组合" class="headerlink" title="Solution1 排列组合"></a>Solution1 排列组合</h2><p><img src="https://files.mdnice.com/user/1489/4a4d21b3-ff48-457a-a612-9723074e0647.png"></p>
<h2 id="Solution2-动态规划-1"><a href="#Solution2-动态规划-1" class="headerlink" title="Solution2 动态规划"></a>Solution2 动态规划</h2><p>我们令 dp[i][j] 是到达 i, j 最多路径</p>
<p>动态方程：dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1]</p>
<p>注意，对于第一行 dp[0][j]，或者第一列 dp[i][0]，由于都是在边界，所以只能为 1</p>
<p>时间复杂度：O(m*n)O(m∗n)</p>
<p>空间复杂度：O(m * n)O(m∗n)</p>
<p>优化：因为我们每次只需要 dp[i-1][j],dp[i][j-1]</p>
<p>所以我们只要记录这两个数，直接看代码吧！</p>
<p>思路二：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[][] dp = new int[m][n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) dp[0][i] = 1;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) dp[i][0] = 1;</span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m - 1][n - 1];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>优化1：空间复杂度 O(2n)O(2n)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[] pre = new int[n];</span><br><span class="line">        int[] cur = new int[n];</span><br><span class="line">        Arrays.fill(pre, 1);</span><br><span class="line">        Arrays.fill(cur,1);</span><br><span class="line">        for (int i = 1; i &lt; m;i++)&#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++)&#123;</span><br><span class="line">                cur[j] = cur[j-1] + pre[j];</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        return pre[n-1]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化2：空间复杂度 O(n)O(n)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[] cur = new int[n];</span><br><span class="line">        Arrays.fill(cur,1);</span><br><span class="line">        for (int i = 1; i &lt; m;i++)&#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++)&#123;</span><br><span class="line">                cur[j] += cur[j-1] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur[n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h1><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。<br>示例 2：</p>
<p>输入：grid &#x3D; [[1,2,3],[4,5,6]]<br>输出：12
 </p>
<p>提示：</p>
<p>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 200<br>0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 100</p>
<h2 id="Solution0-暴力"><a href="#Solution0-暴力" class="headerlink" title="Solution0 暴力"></a>Solution0 暴力</h2><h2 id="Solution1-动态规划"><a href="#Solution1-动态规划" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/5984996e-8148-4ae1-8ed9-8198e3625d2f.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minPathSum(int[][] grid) &#123;</span><br><span class="line">        for(int i = 0; i &lt; grid.length; i++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; grid[0].length; j++) &#123;</span><br><span class="line">                if(i == 0 &amp;&amp; j == 0) continue;</span><br><span class="line">                else if(i == 0)  grid[i][j] = grid[i][j - 1] + grid[i][j];</span><br><span class="line">                else if(j == 0)  grid[i][j] = grid[i - 1][j] + grid[i][j];</span><br><span class="line">                else grid[i][j] = Math.min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return grid[grid.length - 1][grid[0].length - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/plus-one/">66. 加一</a></h1><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：digits &#x3D; [1,2,3]<br>输出：[1,2,4]<br>解释：输入数组表示数字 123。<br>示例 2：</p>
<p>输入：digits &#x3D; [4,3,2,1]<br>输出：[4,3,2,2]<br>解释：输入数组表示数字 4321。<br>示例 3：</p>
<p>输入：digits &#x3D; [0]<br>输出：[1]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; digits.length &lt;&#x3D; 100<br>0 &lt;&#x3D; digits[i] &lt;&#x3D; 9</p>
<h2 id="Solution-0-暴力"><a href="#Solution-0-暴力" class="headerlink" title="Solution 0  暴力"></a>Solution 0  暴力</h2><h2 id="Solution-1-逆序遍历-找到9"><a href="#Solution-1-逆序遍历-找到9" class="headerlink" title="Solution 1 逆序遍历 找到9"></a>Solution 1 逆序遍历 找到9</h2><p><img src="https://files.mdnice.com/user/1489/846120fb-5574-4fde-bd23-c798e938fa6e.png"></p>
<h1 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根 "></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sqrtx/">69. x 的平方根 </a></h1><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p>
<p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p>
<p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：x &#x3D; 4<br>输出：2<br>示例 2：</p>
<p>输入：x &#x3D; 8<br>输出：2<br>解释：8 的算术平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。
 </p>
<p>提示：</p>
<p>0 &lt;&#x3D; x &lt;&#x3D; 231 - 1</p>
<h2 id="Solution1-暴力-10"><a href="#Solution1-暴力-10" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-二分搜索"><a href="#Solution2-二分搜索" class="headerlink" title="Solution2 二分搜索"></a>Solution2 二分搜索</h2><p><img src="https://files.mdnice.com/user/1489/19d7f700-92c7-4591-bef6-efe163c000f3.png"></p>
<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h1><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶<br>示例 2：</li>
</ol>
<p>输入：n &#x3D; 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
<p> </p>
<p>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 45</p>
<h2 id="Solution1-递归-1"><a href="#Solution1-递归-1" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">      int dp0=1;</span><br><span class="line">       int dp1=1;</span><br><span class="line">        for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">            int tmp=dp0;</span><br><span class="line">            dp0=dp1;</span><br><span class="line">            dp1=tmp+dp1;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp1;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>






<h1 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a></h1><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>必须在不使用库的sort函数的情况下解决这个问题。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [2,0,2,1,1,0]<br>输出：[0,0,1,1,2,2]<br>示例 2：</p>
<p>输入：nums &#x3D; [2,0,1]<br>输出：[0,1,2]
 </p>
<p>提示：</p>
<p>n &#x3D;&#x3D; nums.length<br>1 &lt;&#x3D; n &lt;&#x3D; 300<br>nums[i] 为 0、1 或 2
 </p>
<p>进阶：</p>
<p>你可以不使用代码库中的排序函数来解决这道题吗？<br>你能想出一个仅使用常数空间的一趟扫描算法吗？</p>
<h2 id="Solution1-暴力-11"><a href="#Solution1-暴力-11" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><p>根据题目中的提示，我们可以统计出数组中 0, 1, 20,1,2 的个数，再根据它们的数量，重写整个数组。这种方法较为简单，也很容易想到，而本题解中会介绍两种基于指针进行交换的方法。</p>
<h2 id="Solution2-单指针"><a href="#Solution2-单指针" class="headerlink" title="Solution2 单指针"></a>Solution2 单指针</h2><p>我们可以考虑对数组进行两次遍历。在第一次遍历中，我们将数组中所有的 00 交换到数组的头部。在第二次遍历中，我们将数组中所有的 11 交换到头部的 00 之后。此时，所有的 22 都出现在数组的尾部，这样我们就完成了排序。</p>
<p>具体地，我们使用一个指针 \textit{ptr}ptr 表示「头部」的范围，\textit{ptr}ptr 中存储了一个整数，表示数组 \textit{nums}nums 从位置 00 到位置 \textit{ptr}-1ptr−1 都属于「头部」。\textit{ptr}ptr 的初始值为 00，表示还没有数处于「头部」。</p>
<p>在第一次遍历中，我们从左向右遍历整个数组，如果找到了 00，那么就需要将 00 与「头部」位置的元素进行交换，并将「头部」向后扩充一个位置。在遍历结束之后，所有的 00 都被交换到「头部」的范围，并且「头部」只包含 00。</p>
<p>在第二次遍历中，我们从「头部」开始，从左向右遍历整个数组，如果找到了 11，那么就需要将 11 与「头部」位置的元素进行交换，并将「头部」向后扩充一个位置。在遍历结束之后，所有的 11 都被交换到「头部」的范围，并且都在 00 之后，此时 22 只出现在「头部」之外的位置，因此排序完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void sortColors(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int ptr = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (nums[i] == 0) &#123;</span><br><span class="line">                swap(nums[i], nums[ptr]);</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = ptr; i &lt; n; ++i) &#123;</span><br><span class="line">            if (nums[i] == 1) &#123;</span><br><span class="line">                swap(nums[i], nums[ptr]);</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution3-双指针"><a href="#Solution3-双指针" class="headerlink" title="Solution3 双指针"></a>Solution3 双指针</h2><p><img src="https://files.mdnice.com/user/1489/d99bbb87-979c-426b-b6e5-647acf2cad20.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void sortColors(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int p0 = 0, p2 = n - 1;</span><br><span class="line">        for (int i = 0; i &lt;= p2; ++i) &#123;</span><br><span class="line">            while (i &lt;= p2 &amp;&amp; nums[i] == 2) &#123;</span><br><span class="line">                swap(nums[i], nums[p2]);</span><br><span class="line">                --p2;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums[i] == 0) &#123;</span><br><span class="line">                swap(nums[i], nums[p0]);</span><br><span class="line">                ++p0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">78. 子集</a></h1><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [1,2,3]<br>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]<br>示例 2：</p>
<p>输入：nums &#x3D; [0]<br>输出：[[],[0]]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10<br>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10<br>nums 中的所有元素 互不相同</p>
<h2 id="Solution1-回溯-1"><a href="#Solution1-回溯-1" class="headerlink" title="Solution1 回溯"></a>Solution1 回溯</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/comments/1011321">https://leetcode.cn/problems/subsets/comments/1011321</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/">https://leetcode.cn/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line">    void backtracking(vector&lt;int&gt;&amp; nums, int startIndex) &#123;</span><br><span class="line">        result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉自己</span><br><span class="line">        if (startIndex &gt;= nums.size()) &#123; // 终止条件可以不加</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = startIndex; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            path.push_back(nums[i]);</span><br><span class="line">            backtracking(nums, i + 1);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        backtracking(nums, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="90-子集"><a href="#90-子集" class="headerlink" title="90.子集||"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets-ii/">90.子集||</a></h1><h1 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/">77. 组合</a></h1><h1 id="39-组合总和-1"><a href="#39-组合总和-1" class="headerlink" title="39. 组合总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h1><h1 id="40-组合总和-II-1"><a href="#40-组合总和-II-1" class="headerlink" title="40. 组合总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h1><h1 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h1><h1 id="784-字母大小写全排列"><a href="#784-字母大小写全排列" class="headerlink" title="784. 字母大小写全排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-case-permutation/">784. 字母大小写全排列</a></h1><h1 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search/comments/">79. 单词搜索</a></h1><h1 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h1><p>给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,1,2]<br>输出：[1,2]<br>示例 2：</p>
<p>输入：head &#x3D; [1,1,2,3,3]<br>输出：[1,2,3]
 </p>
<p>提示：</p>
<p>链表中节点数目在范围 [0, 300] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>题目数据保证链表已经按升序 排列</p>
<h2 id="Solution1-一次遍历"><a href="#Solution1-一次遍历" class="headerlink" title="Solution1 一次遍历"></a>Solution1 一次遍历</h2><p>方法一：一次遍历<br>思路与算法</p>
<p>由于给定的链表是排好序的，因此重复的元素在链表中出现的位置是连续的，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。</p>
<p>具体地，我们从指针 \textit{cur}cur 指向链表的头节点，随后开始对链表进行遍历。如果当前 \textit{cur}cur 与 \textit{cur.next}cur.next 对应的元素相同，那么我们就将 \textit{cur.next}cur.next 从链表中移除；否则说明链表中已经不存在其它与 \textit{cur}cur 对应的元素相同的节点，因此可以将 \textit{cur}cur 指向 \textit{cur.next}cur.next。</p>
<p>当遍历完整个链表之后，我们返回链表的头节点即可。</p>
<p>细节</p>
<p>当我们遍历到链表的最后一个节点时，\textit{cur.next}cur.next 为空节点，如果不加以判断，访问 \textit{cur.next}cur.next 对应的元素会产生运行错误。因此我们只需要遍历到链表的最后一个节点，而不需要遍历完整个链表。</p>
<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 是链表的长度。</p>
<p>空间复杂度：O(1)O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">        if (!head) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        while (cur-&gt;next) &#123;</span><br><span class="line">            if (cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-list/">86. 分隔链表</a></h1><p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p>
<p>你应当 保留 两个分区中每个节点的初始相对位置。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,4,3,2,5,2], x &#x3D; 3<br>输出：[1,2,2,4,3,5]<br>示例 2：</p>
<p>输入：head &#x3D; [2,1], x &#x3D; 2<br>输出：[1,2]
 </p>
<p>提示：</p>
<p>链表中节点的数目在范围 [0, 200] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>-200 &lt;&#x3D; x &lt;&#x3D; 200</p>
<h2 id="Solution1-双指针"><a href="#Solution1-双指针" class="headerlink" title="Solution1  双指针"></a>Solution1  双指针</h2><p><img src="https://files.mdnice.com/user/1489/1a1aae99-5b02-4641-9e50-5bd0913d1e4d.png"></p>
<h1 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-sorted-array/">88. 合并两个有序数组</a></h1><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>
<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>
<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3<br>输出：[1,2,2,3,5,6]<br>解释：需要合并 [1,2,3] 和 [2,5,6] 。<br>合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。<br>示例 2：</p>
<p>输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0<br>输出：[1]<br>解释：需要合并 [1] 和 [] 。<br>合并结果是 [1] 。<br>示例 3：</p>
<p>输入：nums1 &#x3D; [0], m &#x3D; 0, nums2 &#x3D; [1], n &#x3D; 1<br>输出：[1]<br>解释：需要合并的数组是 [] 和 [1] 。<br>合并结果是 [1] 。<br>注意，因为 m &#x3D; 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。
 </p>
<p>提示：</p>
<p>nums1.length &#x3D;&#x3D; m + n<br>nums2.length &#x3D;&#x3D; n<br>0 &lt;&#x3D; m, n &lt;&#x3D; 200<br>1 &lt;&#x3D; m + n &lt;&#x3D; 200<br>-109 &lt;&#x3D; nums1[i], nums2[j] &lt;&#x3D; 109
 </p>
<p>进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？</p>
<h2 id="Solution1-暴力直接合并后排序"><a href="#Solution1-暴力直接合并后排序" class="headerlink" title="Solution1 暴力直接合并后排序"></a>Solution1 暴力直接合并后排序</h2><p><img src="https://files.mdnice.com/user/1489/8aeff7af-53ed-467e-aebc-7835db5b52f5.png"></p>
<h2 id="Solution2-双指针-1"><a href="#Solution2-双指针-1" class="headerlink" title="Solution2 双指针"></a>Solution2 双指针</h2><p><img src="https://files.mdnice.com/user/1489/5be86979-df7c-4994-a29c-088dc60e24e6.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        int p1 = 0, p2 = 0;</span><br><span class="line">        int sorted[m + n];</span><br><span class="line">        int cur;</span><br><span class="line">        while (p1 &lt; m || p2 &lt; n) &#123;</span><br><span class="line">            if (p1 == m) &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125; else if (p2 == n) &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125; else if (nums1[p1] &lt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">            sorted[p1 + p2 - 1] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i != m + n; ++i) &#123;</span><br><span class="line">            nums1[i] = sorted[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(m+n)O(m+n)。<br>指针移动单调递增，最多移动 m+nm+n 次，因此时间复杂度为 O(m+n)O(m+n)。</p>
<p>空间复杂度：O(m+n)O(m+n)。<br>需要建立长度为 m+nm+n 的中间数组 \textit{sorted}sorted。</p>
<h2 id="Solution3-逆向双指针"><a href="#Solution3-逆向双指针" class="headerlink" title="Solution3 逆向双指针"></a>Solution3 逆向双指针</h2><p><img src="https://files.mdnice.com/user/1489/a825eedd-e311-4153-bc5b-ed31be497911.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        int p1 = m - 1, p2 = n - 1;</span><br><span class="line">        int tail = m + n - 1;</span><br><span class="line">        int cur;</span><br><span class="line">        while (p1 &gt;= 0 || p2 &gt;= 0) &#123;</span><br><span class="line">            if (p1 == -1) &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125; else if (p2 == -1) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; else if (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">            nums1[tail--] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-ways/">91. 解码方法</a></h1><p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p>
<p>‘A’ -&gt; “1”<br>‘B’ -&gt; “2”<br>…<br>‘Z’ -&gt; “26”<br>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p>
<p>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)<br>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p>
<p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p>
<p>题目数据保证答案肯定是一个 32 位 的整数。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s &#x3D; “12”<br>输出：2<br>解释：它可以解码为 “AB”（1 2）或者 “L”（12）。<br>示例 2：</p>
<p>输入：s &#x3D; “226”<br>输出：3<br>解释：它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。<br>示例 3：</p>
<p>输入：s &#x3D; “0”<br>输出：0<br>解释：没有字符映射到以 0 开头的数字。<br>含有 0 的有效映射是 ‘J’ -&gt; “10” 和 ‘T’-&gt; “20” 。<br>由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 100<br>s 只包含数字，并且可能包含前导零。<br>通过次数235,094提交次数721,617</p>
<h2 id="Solution1-动态规划-1"><a href="#Solution1-动态规划-1" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/707aac6e-eec8-4f5a-8f0f-b7b45d344451.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numDecodings(string s) &#123;</span><br><span class="line">        if (s[0] == &#x27;0&#x27;) return 0;</span><br><span class="line">        vector&lt;int&gt; dp(s.size()+1);</span><br><span class="line">        dp[0]=1;dp[1]=1;</span><br><span class="line">        for (int i =1; i &lt; s.size(); i++) &#123;</span><br><span class="line">            if (s[i] == &#x27;0&#x27;)//1.s[i]为0的情况</span><br><span class="line">                if (s[i - 1] == &#x27;1&#x27; || s[i - 1] == &#x27;2&#x27;) //s[i - 1]等于1或2的情况</span><br><span class="line">                    dp[i+1] = dp[i-1];//由于s[1]指第二个下标，对应为dp[2],所以dp的下标要比s大1，故为dp[i+1]</span><br><span class="line">                else </span><br><span class="line">                    return 0;</span><br><span class="line">            else //2.s[i]不为0的情况</span><br><span class="line">                if (s[i - 1] == &#x27;1&#x27; || (s[i - 1] == &#x27;2&#x27; &amp;&amp; s[i] &lt;= &#x27;6&#x27;))//s[i-1]s[i]两位数要小于26的情况</span><br><span class="line">                    dp[i+1] = dp[i]+dp[i-1];</span><br><span class="line">                else//其他情况</span><br><span class="line">                    dp[i+1] = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-动态规划-空间复杂度优化为O-1"><a href="#Solution2-动态规划-空间复杂度优化为O-1" class="headerlink" title="Solution2 动态规划 空间复杂度优化为O(1)"></a>Solution2 动态规划 空间复杂度优化为O(1)</h2><p><img src="https://files.mdnice.com/user/1489/ebc2117f-b989-4c3d-b852-4b2b26c77453.png"></p>
<h1 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h1><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。
 </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4,5], left &#x3D; 2, right &#x3D; 4<br>输出：[1,4,3,2,5]<br>示例 2：</p>
<p>输入：head &#x3D; [5], left &#x3D; 1, right &#x3D; 1<br>输出：[5]
 </p>
<p>提示：</p>
<p>链表中节点数目为 n<br>1 &lt;&#x3D; n &lt;&#x3D; 500<br>-500 &lt;&#x3D; Node.val &lt;&#x3D; 500<br>1 &lt;&#x3D; left &lt;&#x3D; right &lt;&#x3D; n
 </p>
<p>进阶： 你可以使用一趟扫描完成反转吗？</p>
<h2 id="Solution1-原地反转"><a href="#Solution1-原地反转" class="headerlink" title="Solution1 原地反转"></a>Solution1 原地反转</h2><p><img src="https://files.mdnice.com/user/1489/1d9b3377-72f8-4c1b-8451-a2e484bfdc1c.png"></p>
<h1 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h1><p>给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,null,2,3]<br>输出：[1,3,2]<br>示例 2：</p>
<p>输入：root &#x3D; []<br>输出：[]<br>示例 3：</p>
<p>输入：root &#x3D; [1]<br>输出：[1]
 </p>
<p>提示：</p>
<p>树中节点数目在范围 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100
 </p>
<h2 id="Solution1-递归-2"><a href="#Solution1-递归-2" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><p><img src="https://files.mdnice.com/user/1489/166bca4c-bcc2-4718-b6f4-1576acf3ff36.png"></p>
<h2 id="Solution2-迭代-1"><a href="#Solution2-迭代-1" class="headerlink" title="Solution2 迭代"></a>Solution2 迭代</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        while (root != nullptr || !stk.empty()) &#123;</span><br><span class="line">            while (root != nullptr) &#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h1 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h1><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 3<br>输出：5<br>示例 2：</p>
<p>输入：n &#x3D; 1<br>输出：1
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 19</p>
<h2 id="Solution1-动态规划-2"><a href="#Solution1-动态规划-2" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p>结题思路：假设n个节点存在二叉排序树的个数是G(n)，1为根节点，2为根节点，…，n为根节点，<br>当1为根节点时，其左子树节点个数为0，右子树节点个数为n-1，<br>同理当2为根节点时，其左子树节点个数为1，右子树节点为n-2，<br>所以可得G(n) &#x3D; G(0)<em>G(n-1)+G(1)</em>(n-2)+…+G(n-1)*G(0)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numTrees(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n + 1);</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j - 1] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>






<h1 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a></h1><p>给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：n &#x3D; 3<br>输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]<br>示例 2：</p>
<p>输入：n &#x3D; 1<br>输出：[[1]]
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; n &lt;&#x3D; 8</p>
<h2 id="Solution1-回溯-2"><a href="#Solution1-回溯-2" class="headerlink" title="Solution1 回溯"></a>Solution1 回溯</h2><p><img src="https://files.mdnice.com/user/1489/a150914f-1207-4dc6-8091-639f11405933.png"></p>
<p><img src="https://files.mdnice.com/user/1489/d66220b0-0d89-479e-9313-6adce6816e8c.png"></p>
<h1 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h1><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p>有效 二叉搜索树定义如下：</p>
<p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。
 </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [2,1,3]<br>输出：true<br>示例 2：</p>
<p>输入：root &#x3D; [5,1,4,null,null,3,6]<br>输出：false<br>解释：根节点的值是 5 ，但是右子节点的值是 4 。
 </p>
<p>提示：</p>
<p>树中节点数目范围在[1, 104] 内<br>-231 &lt;&#x3D; Node.val &lt;&#x3D; 231 - 1</p>
<h2 id="Solution1-递归-3"><a href="#Solution1-递归-3" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><p>方法一: 递归<br>思路和算法</p>
<p>要解决这道题首先我们要了解二叉搜索树有什么性质可以给我们利用，由题目给出的信息我们可以知道：如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。</p>
<p>这启示我们设计一个递归函数 helper(root, lower, upper) 来递归判断，函数表示考虑以 root 为根的子树，判断子树中所有节点的值是否都在 (l,r)(l,r) 的范围内（注意是开区间）。如果 root 节点的值 val 不在 (l,r)(l,r) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。</p>
<p>那么根据二叉搜索树的性质，在递归调用左子树时，我们需要把上界 upper 改为 root.val，即调用 helper(root.left, lower, root.val)，因为左子树里所有节点的值均小于它的根节点的值。同理递归调用右子树时，我们需要把下界 lower 改为 root.val，即调用 helper(root.right, root.val, upper)。</p>
<p>函数递归调用的入口为 helper(root, -inf, +inf)， inf 表示一个无穷大的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool helper(TreeNode* root, long long lower, long long upper) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root -&gt; val &lt;= lower || root -&gt; val &gt;= upper) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return helper(root -&gt; left, lower, root -&gt; val) &amp;&amp; helper(root -&gt; right, root -&gt; val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        return helper(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 为二叉树的节点个数。在递归调用的时候二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)O(n)。</p>
<p>空间复杂度：O(n)O(n)，其中 nn 为二叉树的节点个数。递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，即二叉树的高度。最坏情况下二叉树为一条链，树的高度为 nn ，递归最深达到 nn 层，故最坏情况下空间复杂度为 O(n)O(n) 。</p>
<h2 id="Solution2-中序遍历为升序"><a href="#Solution2-中序遍历为升序" class="headerlink" title="Solution2 中序遍历为升序"></a>Solution2 中序遍历为升序</h2><p>基于方法一中提及的性质，我们可以进一步知道二叉搜索树「中序遍历」得到的值构成的序列一定是升序的，这启示我们在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。如果均大于说明这个序列是升序的，整棵树是二叉搜索树，否则不是，下面的代码我们使用栈来模拟中序遍历的过程。</p>
<p>可能有读者不知道中序遍历是什么，我们这里简单提及。中序遍历是二叉树的一种遍历方式，它先遍历左子树，再遍历根节点，最后遍历右子树。而我们二叉搜索树保证了左子树的节点的值均小于根节点的值，根节点的值均小于右子树的值，因此中序遍历以后得到的序列一定是升序序列。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stack;</span><br><span class="line">        long long inorder = (long long)INT_MIN - 1;</span><br><span class="line"></span><br><span class="line">        while (!stack.empty() || root != nullptr) &#123;</span><br><span class="line">            while (root != nullptr) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root -&gt; left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.top();</span><br><span class="line">            stack.pop();</span><br><span class="line">            // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树</span><br><span class="line">            if (root -&gt; val &lt;= inorder) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            inorder = root -&gt; val;</span><br><span class="line">            root = root -&gt; right;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 为二叉树的节点个数。二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)O(n)。</p>
<p>空间复杂度：O(n)O(n)，其中 nn 为二叉树的节点个数。栈最多存储 nn 个节点，因此需要额外的 O(n)O(n) 的空间。</p>
<h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h1><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,2,2,3,4,4,3]<br>输出：true<br>示例 2：</p>
<p>输入：root &#x3D; [1,2,2,null,3,null,3]<br>输出：false
 </p>
<p>提示：</p>
<p>树中节点数目在范围 [1, 1000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100
 </p>
<p>进阶：你可以运用递归和迭代两种方法解决这个问题吗？</p>
<h2 id="Solution1-递归-4"><a href="#Solution1-递归-4" class="headerlink" title="Solution1  递归"></a>Solution1  递归</h2><p><img src="https://files.mdnice.com/user/1489/17bcb971-2dd2-4659-a84f-24493a37c88e.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">		if(root==null) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		//调用递归函数，比较左节点，右节点</span><br><span class="line">		return dfs(root.left,root.right);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	boolean dfs(TreeNode left, TreeNode right) &#123;</span><br><span class="line">		//递归的终止条件是两个节点都为空</span><br><span class="line">		//或者两个节点中有一个为空</span><br><span class="line">		//或者两个节点的值不相等</span><br><span class="line">		if(left==null &amp;&amp; right==null) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		if(left==null || right==null) &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		if(left.val!=right.val) &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		//再递归的比较 左节点的左孩子 和 右节点的右孩子</span><br><span class="line">		//以及比较  左节点的右孩子 和 右节点的左孩子</span><br><span class="line">		return dfs(left.left,right.right) &amp;&amp; dfs(left.right,right.left);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Solution2-队列"><a href="#Solution2-队列" class="headerlink" title="Solution2 队列"></a>Solution2 队列</h2><p>回想下递归的实现：<br>当两个子树的根节点相等时，就比较:<br>左子树的 left 和 右子树的 right，这个比较是用递归实现的。<br>现在我们改用队列来实现，思路如下：<br>首先从队列中拿出两个节点(left 和 right)比较<br>将 left 的 left 节点和 right 的 right 节点放入队列<br>将 left 的 right 节点和 right 的 left 节点放入队列<br>时间复杂度是 O(n)O(n)，空间复杂度是 O(n)O(n)<br>动画演示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">		if(root==null || (root.left==null &amp;&amp; root.right==null)) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		//用队列保存节点</span><br><span class="line">		LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">		//将根节点的左右孩子放到队列中</span><br><span class="line">		queue.add(root.left);</span><br><span class="line">		queue.add(root.right);</span><br><span class="line">		while(queue.size()&gt;0) &#123;</span><br><span class="line">			//从队列中取出两个节点，再比较这两个节点</span><br><span class="line">			TreeNode left = queue.removeFirst();</span><br><span class="line">			TreeNode right = queue.removeFirst();</span><br><span class="line">			//如果两个节点都为空就继续循环，两者有一个为空就返回false</span><br><span class="line">			if(left==null &amp;&amp; right==null) &#123;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			if(left==null || right==null) &#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">			if(left.val!=right.val) &#123;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line">			//将左节点的左孩子， 右节点的右孩子放入队列</span><br><span class="line">			queue.add(left.left);</span><br><span class="line">			queue.add(right.right);</span><br><span class="line">			//将左节点的右孩子，右节点的左孩子放入队列</span><br><span class="line">			queue.add(left.right);</span><br><span class="line">			queue.add(right.left);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h1><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]<br>示例 2：</p>
<p>输入：root &#x3D; [1]<br>输出：[[1]]<br>示例 3：</p>
<p>输入：root &#x3D; []<br>输出：[]
 </p>
<p>提示：</p>
<p>树中节点数目在范围 [0, 2000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p>
<h2 id="Solution1-队列实现"><a href="#Solution1-队列实现" class="headerlink" title="Solution1 队列实现"></a>Solution1 队列实现</h2><p><img src="https://files.mdnice.com/user/1489/35a4e4dc-eb76-4d87-ba29-735a5042bfe1.png"></p>
<p><img src="https://files.mdnice.com/user/1489/3f09955d-d39b-41e9-8495-445cf9b35418.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector &lt;vector &lt;int&gt;&gt; ret;</span><br><span class="line">        if (!root) &#123;</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue &lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            int currentLevelSize = q.size();</span><br><span class="line">            ret.push_back(vector &lt;int&gt; ());</span><br><span class="line">            for (int i = 1; i &lt;= currentLevelSize; ++i) &#123;</span><br><span class="line">                auto node = q.front(); q.pop();</span><br><span class="line">                ret.back().push_back(node-&gt;val);</span><br><span class="line">                if (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                if (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="Solution2-递归实现"><a href="#Solution2-递归实现" class="headerlink" title="Solution2 递归实现"></a>Solution2 递归实现</h2><p>层序遍历一般来说确实是用队列实现的，但是这里很明显用递归前序遍历就能实现呀，而且复杂度O(n)。。。</p>
<p>要点有几个：</p>
<p>利用depth变量记录当前在第几层（从0开始），进入下层时depth + 1；<br>如果depth &gt;&#x3D; vector.size()说明这一层还没来过，这是第一次来，所以得扩容咯；<br>因为是前序遍历，中-左-右，对于每一层来说，左边的肯定比右边先被遍历到，实际上后序中序都是一样的。。。<br>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        pre(root, 0, ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void pre(TreeNode *root, int depth, vector&lt;vector&lt;int&gt;&gt; &amp;ans) &#123;</span><br><span class="line">        if (!root) return ;</span><br><span class="line">        if (depth &gt;= ans.size())</span><br><span class="line">            ans.push_back(vector&lt;int&gt; &#123;&#125;);</span><br><span class="line">        ans[depth].push_back(root-&gt;val);</span><br><span class="line">        pre(root-&gt;left, depth + 1, ans);</span><br><span class="line">        pre(root-&gt;right, depth + 1, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h1><p>给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[3],[20,9],[15,7]]<br>示例 2：</p>
<p>输入：root &#x3D; [1]<br>输出：[[1]]<br>示例 3：</p>
<p>输入：root &#x3D; []<br>输出：[]
 </p>
<p>提示：</p>
<p>树中节点数目在范围 [0, 2000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p>
<h2 id="Solution1-层序遍历"><a href="#Solution1-层序遍历" class="headerlink" title="Solution1 层序遍历"></a>Solution1 层序遍历</h2><p>层序遍历，然后在奇数时逆序一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">        if(!root) return res;</span><br><span class="line">        </span><br><span class="line">        queue&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        int flag = 0;</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; out;</span><br><span class="line">            int size = q.size(); //取得每一层的长度</span><br><span class="line">            for(int i = 0; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                auto temp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                out.push_back(temp-&gt;val);</span><br><span class="line">                if(temp-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag%2==1)</span><br><span class="line">            &#123;</span><br><span class="line">                reverse(out.begin(),out.end());</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(out);</span><br><span class="line">            flag++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h1><h2 id="Solution1-DFS"><a href="#Solution1-DFS" class="headerlink" title="Solution1 DFS"></a>Solution1 DFS</h2><p><img src="https://files.mdnice.com/user/1489/f28b6ed7-01b5-4a89-952f-d626edf15d9e.png"></p>
<p><img src="https://files.mdnice.com/user/1489/988437b9-f65e-4111-8cde-79a687333027.png"></p>
<h2 id="Slution2-BFS"><a href="#Slution2-BFS" class="headerlink" title="Slution2 BFS"></a>Slution2 BFS</h2><p><img src="https://files.mdnice.com/user/1489/c915e202-251b-48cd-816b-cfcabdbf2214.png"></p>
<h1 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h1><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]<br>输出: [3,9,20,null,null,15,7]<br>示例 2:</p>
<p>输入: preorder &#x3D; [-1], inorder &#x3D; [-1]<br>输出: [-1]
 </p>
<p>提示:</p>
<p>1 &lt;&#x3D; preorder.length &lt;&#x3D; 3000<br>inorder.length &#x3D;&#x3D; preorder.length<br>-3000 &lt;&#x3D; preorder[i], inorder[i] &lt;&#x3D; 3000<br>preorder 和 inorder 均 无重复 元素<br>inorder 均出现在 preorder<br>preorder 保证 为二叉树的前序遍历序列<br>inorder 保证 为二叉树的中序遍历序列</p>
<h1 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/pascals-triangle/">118. 杨辉三角</a></h1><p>给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: numRows &#x3D; 5<br>输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]<br>示例 2:</p>
<p>输入: numRows &#x3D; 1<br>输出: [[1]]</p>
<h2 id="Solution1-直接求解"><a href="#Solution1-直接求解" class="headerlink" title="Solution1 直接求解"></a>Solution1 直接求解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; yanghui;</span><br><span class="line">        for (int i = 0; i &lt; numRows; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; data(i + 1);</span><br><span class="line">            yanghui.push_back(data);</span><br><span class="line">            for (int j = 0; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                if(j == 0) yanghui[i][j] = 1;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    yanghui[i][j] = yanghui[i - 1][j - 1] + yanghui[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            yanghui[i][yanghui[i].size() - 1] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return yanghui;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h1 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h1><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p>
<p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。
 </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,2,5,3,4,null,6]<br>输出：[1,null,2,null,3,null,4,null,5,null,6]<br>示例 2：</p>
<p>输入：root &#x3D; []<br>输出：[]<br>示例 3：</p>
<p>输入：root &#x3D; [0]<br>输出：[0]
 </p>
<p>提示：</p>
<p>树中结点数在范围 [0, 2000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100
 </p>
<h2 id="Solution1-递归-5"><a href="#Solution1-递归-5" class="headerlink" title="Solution1  递归"></a>Solution1  递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* last = nullptr;</span><br><span class="line">void flatten(TreeNode* root) &#123;</span><br><span class="line">    if (root == nullptr) return;</span><br><span class="line">    flatten(root-&gt;right);</span><br><span class="line">    flatten(root-&gt;left);</span><br><span class="line">    root-&gt;right = last;</span><br><span class="line">    root-&gt;left = nullptr;</span><br><span class="line">    last = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Solution2-迭代-2"><a href="#Solution2-迭代-2" class="headerlink" title="Solution2   迭代"></a>Solution2   迭代</h2><p><img src="https://files.mdnice.com/user/1489/5f3de36e-929d-4f22-adcb-a8070f305409.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        while(root)&#123;</span><br><span class="line">            TreeNode* p = root-&gt;left;</span><br><span class="line">            if(p)&#123;</span><br><span class="line">                while(p-&gt;right) p = p-&gt;right; </span><br><span class="line">                p-&gt;right = root-&gt;right;</span><br><span class="line">                root-&gt;right = root-&gt;left;</span><br><span class="line">                root-&gt;left = nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h1><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>
<p>叶子节点 是指没有子节点的节点。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22<br>输出：[[5,4,11,2],[5,8,4,5]]<br>示例 2：</p>
<p>输入：root &#x3D; [1,2,3], targetSum &#x3D; 5<br>输出：[]<br>示例 3：</p>
<p>输入：root &#x3D; [1,2], targetSum &#x3D; 0<br>输出：[]
 </p>
<p>提示：</p>
<p>树中节点总数在范围 [0, 5000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000<br>-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000</p>
<h2 id="Solution1-DFS-1"><a href="#Solution1-DFS-1" class="headerlink" title="Solution1 DFS"></a>Solution1 DFS</h2><p>我们可以采用深度优先搜索的方式，枚举每一条从根节点到叶子节点的路径。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p>
<p>复杂度分析</p>
<p><img src="https://files.mdnice.com/user/1489/070d05a3-3ee3-4b0a-90da-bed5c1c2b9a8.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ret;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line"></span><br><span class="line">    void dfs(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        path.emplace_back(root-&gt;val);</span><br><span class="line">        targetSum -= root-&gt;val;</span><br><span class="line">        if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr &amp;&amp; targetSum == 0) &#123;</span><br><span class="line">            ret.emplace_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left, targetSum);</span><br><span class="line">        dfs(root-&gt;right, targetSum);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        dfs(root, targetSum);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Solution2-BFS"><a href="#Solution2-BFS" class="headerlink" title="Solution2 BFS"></a>Solution2 BFS</h2><p>方法二：广度优先搜索<br>思路及算法</p>
<p>我们也可以采用广度优先搜索的方式，遍历这棵树。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p>
<p>为了节省空间，我们使用哈希表记录树中的每一个节点的父节点。每次找到一个满足条件的节点，我们就从该节点出发不断向父节点迭代，即可还原出从根节点到当前节点的路径。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ret;</span><br><span class="line">    unordered_map&lt;TreeNode*, TreeNode*&gt; parent;</span><br><span class="line"></span><br><span class="line">    void getPath(TreeNode* node) &#123;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        while (node != nullptr) &#123;</span><br><span class="line">            tmp.emplace_back(node-&gt;val);</span><br><span class="line">            node = parent[node];</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(tmp.begin(), tmp.end());</span><br><span class="line">        ret.emplace_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; que_node;</span><br><span class="line">        queue&lt;int&gt; que_sum;</span><br><span class="line">        que_node.emplace(root);</span><br><span class="line">        que_sum.emplace(0);</span><br><span class="line"></span><br><span class="line">        while (!que_node.empty()) &#123;</span><br><span class="line">            TreeNode* node = que_node.front();</span><br><span class="line">            que_node.pop();</span><br><span class="line">            int rec = que_sum.front() + node-&gt;val;</span><br><span class="line">            que_sum.pop();</span><br><span class="line"></span><br><span class="line">            if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr) &#123;</span><br><span class="line">                if (rec == targetSum) &#123;</span><br><span class="line">                    getPath(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (node-&gt;left != nullptr) &#123;</span><br><span class="line">                    parent[node-&gt;left] = node;</span><br><span class="line">                    que_node.emplace(node-&gt;left);</span><br><span class="line">                    que_sum.emplace(rec);</span><br><span class="line">                &#125;</span><br><span class="line">                if (node-&gt;right != nullptr) &#123;</span><br><span class="line">                    parent[node-&gt;right] = node;</span><br><span class="line">                    que_node.emplace(node-&gt;right);</span><br><span class="line">                    que_sum.emplace(rec);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></h1><p>给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: head &#x3D; [-10,-3,0,5,9]<br>输出: [0,-3,9,-10,null,5]<br>解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。<br>示例 2:</p>
<p>输入: head &#x3D; []<br>输出: []
 </p>
<p>提示:</p>
<p>head 中的节点数在[0, 2 * 104] 范围内<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105</p>
<h2 id="Solution1-先找中点-然后再左右分别构造"><a href="#Solution1-先找中点-然后再左右分别构造" class="headerlink" title="Solution1 先找中点 然后再左右分别构造"></a>Solution1 先找中点 然后再左右分别构造</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode sortedListToBST(ListNode head) &#123;</span><br><span class="line">        if(head == null) return null;</span><br><span class="line">        else if(head.next == null) return new TreeNode(head.val);</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        ListNode p = pre.next;</span><br><span class="line">        ListNode q = p.next;</span><br><span class="line">        //找到链表的中点p</span><br><span class="line">        while(q!=null &amp;&amp; q.next!=null)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            p = pre.next;</span><br><span class="line">            q = q.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //将中点左边的链表分开</span><br><span class="line">        pre.next = null;</span><br><span class="line">        TreeNode root = new TreeNode(p.val);</span><br><span class="line">        root.left = sortedListToBST(head);</span><br><span class="line">        root.right = sortedListToBST(p.next);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="105-从前序与中序遍历序列构造二叉树-1"><a href="#105-从前序与中序遍历序列构造二叉树-1" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h1><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p>
<p> </p>
<p>示例 1:</p>
<p>输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]<br>输出: [3,9,20,null,null,15,7]<br>示例 2:</p>
<p>输入: preorder &#x3D; [-1], inorder &#x3D; [-1]<br>输出: [-1]
 </p>
<p>提示:</p>
<p>1 &lt;&#x3D; preorder.length &lt;&#x3D; 3000<br>inorder.length &#x3D;&#x3D; preorder.length<br>-3000 &lt;&#x3D; preorder[i], inorder[i] &lt;&#x3D; 3000<br>preorder 和 inorder 均 无重复 元素<br>inorder 均出现在 preorder<br>preorder 保证 为二叉树的前序遍历序列<br>inorder 保证 为二叉树的中序遍历序列</p>
<h2 id="Solution1-递归-6"><a href="#Solution1-递归-6" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">        // preorder: [root, [left], [right]]</span><br><span class="line">        // inorder:  [[left], root, [right]]</span><br><span class="line">        return buildTree(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, int lo1, int hi1, vector&lt;int&gt;&amp; inorder, int lo2, int hi2) &#123;</span><br><span class="line">        if (lo1 &gt; hi1 || lo2 &gt; hi2) return nullptr;</span><br><span class="line">        int root = preorder[lo1];</span><br><span class="line">        int mid = lo2;</span><br><span class="line">        // 在 inorder 中查找 root 位置</span><br><span class="line">        for (int i = lo2; i &lt;= hi2; ++i) &#123;</span><br><span class="line">            if (inorder[i] == root) &#123;</span><br><span class="line">                mid = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        auto s = new TreeNode(root);</span><br><span class="line">        // 下面的数组表示分割长度</span><br><span class="line">        // inorder: [mid-lo2, mid, hi2-mid]</span><br><span class="line">        // preorder:[root, mid-lo2, hi2-mid]</span><br><span class="line">        s-&gt;left = buildTree(preorder, lo1+1, lo1+mid-lo2, inorder, lo2, mid-1);</span><br><span class="line">        s-&gt;right = buildTree(preorder, lo1+mid-lo2+1, hi1, inorder, mid+1, hi2);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="Solution2-1"><a href="#Solution2-1" class="headerlink" title="Solution2"></a>Solution2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int getLength(ListNode* head) &#123;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (; head != nullptr; ++ret, head = head-&gt;next);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* buildTree(ListNode*&amp; head, int left, int right) &#123;</span><br><span class="line">        if (left &gt; right) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = (left + right + 1) / 2;</span><br><span class="line">        TreeNode* root = new TreeNode();</span><br><span class="line">        root-&gt;left = buildTree(head, left, mid - 1);</span><br><span class="line">        root-&gt;val = head-&gt;val;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        root-&gt;right = buildTree(head, mid + 1, right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* sortedListToBST(ListNode* head) &#123;</span><br><span class="line">        int length = getLength(head);</span><br><span class="line">        return buildTree(head, 0, length - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h1><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>
<p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。<br>     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br>示例 2：</p>
<p>输入：prices &#x3D; [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; prices.length &lt;&#x3D; 105<br>0 &lt;&#x3D; prices[i] &lt;&#x3D; 104</p>
<h2 id="Solution0-暴力解法"><a href="#Solution0-暴力解法" class="headerlink" title="Solution0 暴力解法"></a>Solution0 暴力解法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int n = (int)prices.size(), ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            for (int j = i + 1; j &lt; n; ++j) &#123;</span><br><span class="line">                ans = max(ans, prices[j] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Solution1-动态规划-3"><a href="#Solution1-动态规划-3" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p>动态规划 前i天的最大收益 &#x3D; max{前i-1天的最大收益，第i天的价格-前i-1天中的最小价格}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        if(prices.length &lt;= 1)</span><br><span class="line">            return 0;</span><br><span class="line">        int min = prices[0], max = 0;</span><br><span class="line">        for(int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, prices[i] - min);</span><br><span class="line">            min = Math.min(min, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h1><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p>
<p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p>
<p>返回 你能获得的 最大 利润 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：prices &#x3D; [7,1,5,3,6,4]<br>输出：7<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。<br>     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6 - 3 &#x3D; 3 。<br>     总利润为 4 + 3 &#x3D; 7 。<br>示例 2：</p>
<p>输入：prices &#x3D; [1,2,3,4,5]<br>输出：4<br>解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。<br>     总利润为 4 。<br>示例 3：</p>
<p>输入：prices &#x3D; [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; prices.length &lt;&#x3D; 3 * 104<br>0 &lt;&#x3D; prices[i] &lt;&#x3D; 104</p>
<h2 id="Solution1-贪心算法"><a href="#Solution1-贪心算法" class="headerlink" title="Solution1 贪心算法"></a>Solution1 贪心算法</h2><p><img src="https://files.mdnice.com/user/1489/5536a636-d181-42b9-a760-57aff155691a.png"></p>
<h2 id="Solution2-动态规划-2"><a href="#Solution2-动态规划-2" class="headerlink" title="Solution2 动态规划"></a>Solution2 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/9d910293-a6c0-4c4b-bfd8-c8e32fae01e8.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int [] dp = new int [prices.length+1];//这里从第0天开始，到底i天</span><br><span class="line">        dp[0] = 0;//第0天没有股票，最大利润为0</span><br><span class="line">        dp[1] = 0;//第一天只能买，不能买，因此最大利润也是0</span><br><span class="line">        for(int i = 1;i&lt;prices.length;i++)&#123;</span><br><span class="line">            int A =dp[i]+prices[i]-prices[i-1];//第一种选择</span><br><span class="line">            int B = dp[i];//第二种选择</span><br><span class="line">            dp[i+1] = A&gt;B ? A : B;//i从0开始，所以dp[I＋1]是当前天数 </span><br><span class="line">        &#125;</span><br><span class="line">        return dp[prices.length];</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-palindrome/">125. 验证回文串</a></h1><p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个回文串。</p>
<p>字母和数字都属于字母数字字符。</p>
<p>给你一个字符串 s，如果它是回文串，返回 true ；否则，返回 false 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入: “A man, a plan, a canal: Panama”<br>输出：true<br>解释：”amanaplanacanalpanama” 是回文串。<br>示例 2：</p>
<p>输入：”race a car”<br>输出：false<br>解释：”raceacar” 不是回文串。<br>示例 3：</p>
<p>输入：s &#x3D; “ “<br>输出：true<br>解释：在移除非字母数字字符之后，s 是一个空字符串 “” 。<br>由于空字符串正着反着读都一样，所以是回文串。
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 2 * 105<br>s 仅由可打印的 ASCII 字符组成</p>
<h2 id="Solution1-筛选-判断"><a href="#Solution1-筛选-判断" class="headerlink" title="Solution1 筛选 + 判断"></a>Solution1 筛选 + 判断</h2><p><img src="https://files.mdnice.com/user/1489/fb453ee9-27d8-4bad-86ea-346219e70b18.png"></p>
<h2 id="Solution2-筛选-判断-02"><a href="#Solution2-筛选-判断-02" class="headerlink" title="Solution2 筛选 + 判断 02"></a>Solution2 筛选 + 判断 02</h2><p><img src="https://files.mdnice.com/user/1489/bd915655-54ae-4387-8d94-22cabd830f19.png"></p>
<h2 id="Solution03-在原字符串上直接判断"><a href="#Solution03-在原字符串上直接判断" class="headerlink" title="Solution03 在原字符串上直接判断"></a>Solution03 在原字符串上直接判断</h2><p><img src="https://files.mdnice.com/user/1489/4391ada0-91de-488d-a3a9-23fa346ea804.png"></p>
<h1 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="">136. 只出现一次的数字</a></h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<p>示例 1:</p>
<p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p>
<p>输入: [4,1,2,1,2]<br>输出: 4</p>
<h2 id="Solution1-空间复杂度O-n-方法"><a href="#Solution1-空间复杂度O-n-方法" class="headerlink" title="Solution1  空间复杂度O(n)方法"></a>Solution1  空间复杂度O(n)方法</h2><p>如果不考虑时间复杂度和空间复杂度的限制，这道题有很多种解法，可能的解法有如下几种。</p>
<p>使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。</p>
<p>使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。</p>
<p>使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。</p>
<h2 id="Solution2-空间复杂夫O-1-方法"><a href="#Solution2-空间复杂夫O-1-方法" class="headerlink" title="Solution2 空间复杂夫O(1)方法"></a>Solution2 空间复杂夫O(1)方法</h2><p><img src="https://files.mdnice.com/user/1489/ae0e1058-6b96-43e8-9daa-10bf26ee4ccd.png"></p>
<p><img src="https://files.mdnice.com/user/1489/779a4035-c7d9-4b9a-b232-3f2cddeaa550.png"></p>
<h1 id="137-只出现一次的数字-II"><a href="#137-只出现一次的数字-II" class="headerlink" title="137. 只出现一次的数字 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/single-number-ii/">137. 只出现一次的数字 II</a></h1><p>给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：nums &#x3D; [2,2,3,2]<br>输出：3<br>示例 2：</p>
<p>输入：nums &#x3D; [0,1,0,1,0,1,99]<br>输出：99
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104<br>-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1<br>nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次
 </p>
<p>进阶：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<h2 id="Solution1-哈希表"><a href="#Solution1-哈希表" class="headerlink" title="Solution1 哈希表"></a>Solution1 哈希表</h2><p><img src="https://files.mdnice.com/user/1489/12eb162d-772a-41e8-b79b-1e8acfb28d87.png"></p>
<h2 id="Solution2-二进制"><a href="#Solution2-二进制" class="headerlink" title="Solution2 二进制"></a>Solution2 二进制</h2><p><img src="https://files.mdnice.com/user/1489/7e979e15-b4a4-41bb-92d8-1cfb54630ee6.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; 32; ++i) &#123;</span><br><span class="line">            int total = 0;</span><br><span class="line">            for (int num: nums) &#123;</span><br><span class="line">                total += ((num &gt;&gt; i) &amp; 1);</span><br><span class="line">            &#125;</span><br><span class="line">            if (total % 3) &#123;</span><br><span class="line">                ans |= (1 &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(n \log C)O(nlogC)，其中 nn 是数组的长度，CC 是元素的数据范围，在本题中 \log C&#x3D;\log 2^{32} &#x3D; 32logC&#x3D;log2<br>32<br> &#x3D;32，也就是我们需要遍历第 0\sim310∼31 个二进制位。</p>
<p>空间复杂度：O(1)O(1)。</p>
<h1 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></h1><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</p>
<p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<p> </p>
<p>示例 1：</p>
<p>输入: s &#x3D; “leetcode”, wordDict &#x3D; [“leet”, “code”]<br>输出: true<br>解释: 返回 true 因为 “leetcode” 可以由 “leet” 和 “code” 拼接成。<br>示例 2：</p>
<p>输入: s &#x3D; “applepenapple”, wordDict &#x3D; [“apple”, “pen”]<br>输出: true<br>解释: 返回 true 因为 “applepenapple” 可以由 “apple” “pen” “apple” 拼接成。<br>     注意，你可以重复使用字典中的单词。<br>示例 3：</p>
<p>输入: s &#x3D; “catsandog”, wordDict &#x3D; [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出: false
 </p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length &lt;&#x3D; 300<br>1 &lt;&#x3D; wordDict.length &lt;&#x3D; 1000<br>1 &lt;&#x3D; wordDict[i].length &lt;&#x3D; 20<br>s 和 wordDict[i] 仅有小写英文字母组成<br>wordDict 中的所有字符串 互不相同</p>
<h2 id="Solution1-动态规划-4"><a href="#Solution1-动态规划-4" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</span><br><span class="line">    vector&lt;bool&gt; dp(s.size()+1, false);</span><br><span class="line">    unordered_set&lt;string&gt; m(wordDict.begin(), wordDict.end());</span><br><span class="line">    dp[0] = true;</span><br><span class="line">    for (int i = 1; i &lt;= s.size(); ++i)&#123;</span><br><span class="line">        for (int j = 0; j &lt; i; ++j)&#123;</span><br><span class="line">            if (dp[j] &amp;&amp; m.find(s.substr(j, i-j)) != m.end())&#123;</span><br><span class="line">                dp[i] = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[s.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution2-动态规划-优化版"><a href="#Solution2-动态规划-优化版" class="headerlink" title="Solution2 动态规划 优化版"></a>Solution2 动态规划 优化版</h2><p>【优化】对于以上代码可以优化。每次并不需要从s[0]开始搜索。因为wordDict中的字符串长度是有限的。只需要从i-maxWordLength开始搜索就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</span><br><span class="line">    vector&lt;bool&gt; dp(s.size()+1, false);</span><br><span class="line">    unordered_set&lt;string&gt; m(wordDict.begin(), wordDict.end());</span><br><span class="line">    dp[0] = true;</span><br><span class="line">    //获取最长字符串长度</span><br><span class="line">    int maxWordLength = 0;</span><br><span class="line">    for (int i = 0; i &lt; wordDict.size(); ++i)&#123;</span><br><span class="line">        maxWordLength = std::max(maxWordLength, (int)wordDict[i].size());</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= s.size(); ++i)&#123;</span><br><span class="line">        for (int j = std::max(i-maxWordLength, 0); j &lt; i; ++j)&#123;</span><br><span class="line">            if (dp[j] &amp;&amp; m.find(s.substr(j, i-j)) != m.end())&#123;</span><br><span class="line">                dp[i] = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[s.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h1><p>给你一个链表的头节点 head ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p>
<p>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p>
<p>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：false<br>解释：链表中没有环。
 </p>
<p>提示：</p>
<p>链表中节点的数目范围是 [0, 104]<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>pos 为 -1 或者链表中的一个 有效索引 。
 </p>
<p>进阶：你能用 O(1)（即，常量）内存解决此问题吗？</p>
<h2 id="Solution1-哈希表-1"><a href="#Solution1-哈希表-1" class="headerlink" title="Solution1 哈希表"></a>Solution1 哈希表</h2><p><img src="https://files.mdnice.com/user/1489/f65c3a6a-debe-4c68-ac3b-171b07af7262.png"></p>
<h2 id="Solution2-2"><a href="#Solution2-2" class="headerlink" title="Solution2"></a>Solution2</h2><p><img src="https://files.mdnice.com/user/1489/9add3a1c-b13f-4277-a2b6-e511bf914864.png"></p>
<p><img src="https://files.mdnice.com/user/1489/1411c0a9-8a0f-452f-8fc6-ff371d70d1d0.png"></p>
<p><img src="https://files.mdnice.com/user/1489/fc7adb50-508e-4b31-b28e-f3f11eea8217.png"></p>
<h1 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h1><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>不允许修改 链表。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p>
<p>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p>
<p>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：返回 null<br>解释：链表中没有环。
 </p>
<p>提示：</p>
<p>链表中节点的数目范围在范围 [0, 104] 内<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>pos 的值为 -1 或者链表中的一个有效索引</p>
<h2 id="Solution1-哈希表-2"><a href="#Solution1-哈希表-2" class="headerlink" title="Solution1 哈希表"></a>Solution1 哈希表</h2><p><img src="https://files.mdnice.com/user/1489/335701cf-1815-4ee0-a266-d54c6c35669b.png"></p>
<h2 id="Solution2-双指针-2"><a href="#Solution2-双指针-2" class="headerlink" title="Solution2 双指针"></a>Solution2 双指针</h2><p><img src="https://files.mdnice.com/user/1489/725fc0e8-c8e6-4660-b971-9c47beb3c888.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        while (fast != nullptr) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            if (fast-&gt;next == nullptr) &#123;</span><br><span class="line">                return nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            if (fast == slow) &#123;</span><br><span class="line">                ListNode *ptr = head;</span><br><span class="line">                while (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                return ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://files.mdnice.com/user/1489/7323d75f-2b46-4b8a-9908-4f5c654281f5.png"></p>
<h1 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reorder-list/">143. 重排链表</a></h1><p>给定一个单链表 L 的头节点 head ，单链表 L 表示为：</p>
<p>L0 → L1 → … → Ln - 1 → Ln<br>请将其重新排列后变为：</p>
<p>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …<br>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：head &#x3D; [1,2,3,4]<br>输出：[1,4,2,3]<br>示例 2：</p>
<p>输入：head &#x3D; [1,2,3,4,5]<br>输出：[1,5,2,4,3]
 </p>
<p>提示：</p>
<p>链表的长度范围为 [1, 5 * 104]<br>1 &lt;&#x3D; node.val &lt;&#x3D; 1000</p>
<h2 id="Solution0-暴力-1"><a href="#Solution0-暴力-1" class="headerlink" title="Solution0 暴力"></a>Solution0 暴力</h2><h2 id="Solution1-双指针-1"><a href="#Solution1-双指针-1" class="headerlink" title="Solution1 双指针"></a>Solution1 双指针</h2><p>1.快慢指针找到中点 2.拆成两个链表 3.遍历两个链表，后面的塞到前面的“缝隙里”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">void reorderList(ListNode* head) &#123;</span><br><span class="line">    </span><br><span class="line">    if(head==NULL || head-&gt;next == NULL)</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line">    //快慢指针分出两段</span><br><span class="line">    ListNode *slow = head,*fast = head;</span><br><span class="line">    </span><br><span class="line">    while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123;</span><br><span class="line">        </span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //后端反转</span><br><span class="line">    ListNode *needReverser = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = NULL;</span><br><span class="line">    needReverser = reverse(needReverser);</span><br><span class="line">    </span><br><span class="line">    //插入前端缝隙</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    while(cur &amp;&amp; needReverser)&#123;</span><br><span class="line">        ListNode *curSecond = needReverser;</span><br><span class="line">        needReverser = needReverser-&gt;next;</span><br><span class="line">        ListNode *nextCur = cur-&gt;next;</span><br><span class="line">        curSecond-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = curSecond;</span><br><span class="line">        </span><br><span class="line">        cur = nextCur;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode *reverse(ListNode *head)&#123;</span><br><span class="line">    </span><br><span class="line">    ListNode *p1 = NULL;</span><br><span class="line">    ListNode *p2 = head;</span><br><span class="line">    ListNode *p3 = p2;</span><br><span class="line">    </span><br><span class="line">    while(p2)&#123;</span><br><span class="line">        p3 = p2-&gt;next;</span><br><span class="line">        p2-&gt;next = p1;</span><br><span class="line">        p1 = p2;</span><br><span class="line">        p2 = p3;            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return p1;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h1><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：root &#x3D; [1,null,2,3]<br>输出：[1,2,3]<br>示例 2：</p>
<p>输入：root &#x3D; []<br>输出：[]<br>示例 3：</p>
<p>输入：root &#x3D; [1]<br>输出：[1]<br>示例 4：</p>
<p>输入：root &#x3D; [1,2]<br>输出：[1,2]<br>示例 5：</p>
<p>输入：root &#x3D; [1,null,2]<br>输出：[1,2]
 </p>
<p>提示：</p>
<p>树中节点数目在范围 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p>
<h2 id="Solution1-递归-7"><a href="#Solution1-递归-7" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><p><img src="https://files.mdnice.com/user/1489/04aefe28-f537-4f0f-a96c-e08abbe1030f.png"></p>
<h2 id="Solution2-迭代-3"><a href="#Solution2-迭代-3" class="headerlink" title="Solution2 迭代"></a>Solution2 迭代</h2><p><img src="https://files.mdnice.com/user/1489/de302c02-3172-4795-81bf-b52f9a497fcf.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        while (!stk.empty() || node != nullptr) &#123;</span><br><span class="line">            while (node != nullptr) &#123;</span><br><span class="line">                res.emplace_back(node-&gt;val);</span><br><span class="line">                stk.emplace(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(n)O(n)，其中 nn 是二叉树的节点数。每一个节点恰好被遍历一次。</p>
<p>空间复杂度：O(n)O(n)，为迭代过程中显式栈的开销，平均情况下为 O(\log n)O(logn)，最坏情况下树呈现链状，为 O(n)O(n)。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/19/Linux-Command-Wildcard/" rel="prev" title="Linux Command —— Wildcard">
      <i class="fa fa-chevron-left"></i> Linux Command —— Wildcard
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Two-Sum"><span class="nav-number">1.</span> <span class="nav-text">1. Two Sum</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-1"><span class="nav-number">1.1.</span> <span class="nav-text">Solution 1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-2"><span class="nav-number">1.2.</span> <span class="nav-text">Solution 2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="nav-number">2.</span> <span class="nav-text">17. 电话号码的字母组合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-1-%E6%9A%B4%E5%8A%9B"><span class="nav-number">2.1.</span> <span class="nav-text">Solution 1  暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Soulution-2-%E5%9B%9E%E6%BA%AF"><span class="nav-number">2.2.</span> <span class="nav-text">Soulution 2  回溯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-3-%E9%98%9F%E5%88%97"><span class="nav-number">2.3.</span> <span class="nav-text">Solution 3  队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">3.</span> <span class="nav-text">18. 四数之和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-1-%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE"><span class="nav-number">3.1.</span> <span class="nav-text">Solution 1  暴力枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-2-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">Solution 2  双指针法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-number">4.</span> <span class="nav-text">19. 删除链表的倒数第 N 个结点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%AE%A1%E7%AE%97%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6"><span class="nav-number">4.1.</span> <span class="nav-text">Solution1 计算链表长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E6%A0%88"><span class="nav-number">4.2.</span> <span class="nav-text">Solution2 栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution3-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="nav-number">4.3.</span> <span class="nav-text">Solution3 快慢指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%A0%88"><span class="nav-number">4.4.</span> <span class="nav-text">Solution1 栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B"><span class="nav-number">4.5.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E9%80%92%E5%BD%92-%E5%89%AA%E6%9E%9D"><span class="nav-number">4.6.</span> <span class="nav-text">Solution2 递归 + 剪枝</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">5.</span> <span class="nav-text">24. 两两交换链表中的节点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92"><span class="nav-number">5.1.</span> <span class="nav-text">Solution1  递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%BF%AD%E4%BB%A3"><span class="nav-number">5.2.</span> <span class="nav-text">Solution2 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="nav-number">6.</span> <span class="nav-text">[26. 删除有序数组中的重复项]</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-1"><span class="nav-number">6.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">6.2.</span> <span class="nav-text">Solution2 双指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution3-%E5%8F%8C%E6%8C%87%E9%92%88-%E4%BC%98%E5%8C%96"><span class="nav-number">6.3.</span> <span class="nav-text">Solution3 双指针 优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="nav-number">7.</span> <span class="nav-text">31. 下一个排列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-2"><span class="nav-number">7.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2"><span class="nav-number">7.2.</span> <span class="nav-text">Solution2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">8.</span> <span class="nav-text">33. 搜索旋转排序数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-3"><span class="nav-number">8.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">8.2.</span> <span class="nav-text">Solution2 二分查找</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="nav-number">9.</span> <span class="nav-text">34. 在排序数组中查找元素的第一个和最后一个位置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-4"><span class="nav-number">9.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%BA%8C%E5%88%86"><span class="nav-number">9.2.</span> <span class="nav-text">Solution2 二分</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">10.</span> <span class="nav-text"></span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-5"><span class="nav-number">10.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%BA%8C%E5%88%86-1"><span class="nav-number">10.2.</span> <span class="nav-text">Solution2 二分</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="nav-number">11.</span> <span class="nav-text">39. 组合总和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-6"><span class="nav-number">11.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%9B%9E%E6%BA%AF"><span class="nav-number">11.2.</span> <span class="nav-text">Solution2 回溯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II"><span class="nav-number">12.</span> <span class="nav-text">40. 组合总和 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%9B%9E%E6%BA%AF"><span class="nav-number">12.1.</span> <span class="nav-text">Solution1 回溯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">13.</span> <span class="nav-text">46. 全排列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-7"><span class="nav-number">13.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%9B%9E%E6%BA%AF-1"><span class="nav-number">13.2.</span> <span class="nav-text">Solution2 回溯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="nav-number">14.</span> <span class="nav-text">48. 旋转图像</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8E%9F%E5%9C%B0%E6%9F%A5%E6%89%BE"><span class="nav-number">14.1.</span> <span class="nav-text">Solution1 原地查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%85%88%E8%BD%AC%E7%BD%AE%E5%86%8D%E7%AB%96%E7%9B%B4%E5%AF%B9%E7%A7%B0%E5%8F%8D%E8%BD%AC"><span class="nav-number">14.2.</span> <span class="nav-text">Solution2 先转置再竖直对称反转</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="nav-number">15.</span> <span class="nav-text">49. 字母异位词分组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-Map"><span class="nav-number">15.1.</span> <span class="nav-text">Solution1 Map</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#50-Pow-x-n"><span class="nav-number">16.</span> <span class="nav-text">50. Pow(x, n)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%BF%AB%E9%80%9F%E5%B9%82-%E9%80%92%E5%BD%92"><span class="nav-number">16.1.</span> <span class="nav-text">Solution1  快速幂+递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-number">17.</span> <span class="nav-text">53. 最大子数组和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-8"><span class="nav-number">17.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">17.2.</span> <span class="nav-text">Solution2 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="nav-number">18.</span> <span class="nav-text">54. 螺旋矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8E%9F%E5%9C%B0%E9%81%8D%E5%8E%86"><span class="nav-number">18.1.</span> <span class="nav-text">Solution1 原地遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E6%8C%89%E5%B1%82%E9%81%8D%E5%8E%86"><span class="nav-number">18.2.</span> <span class="nav-text">Solution2 按层遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="nav-number">19.</span> <span class="nav-text">56. 合并区间</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%8E%92%E5%BA%8F"><span class="nav-number">19.1.</span> <span class="nav-text">Solution1 排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">20.</span> <span class="nav-text">61. 旋转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-9"><span class="nav-number">20.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Soluion2-%E9%97%AD%E7%8E%AF"><span class="nav-number">20.2.</span> <span class="nav-text">Soluion2  闭环</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="nav-number">21.</span> <span class="nav-text">62. 不同路径</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88"><span class="nav-number">21.1.</span> <span class="nav-text">Solution1 排列组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="nav-number">21.2.</span> <span class="nav-text">Solution2 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="nav-number">22.</span> <span class="nav-text">64. 最小路径和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E6%9A%B4%E5%8A%9B"><span class="nav-number">22.1.</span> <span class="nav-text">Solution0 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">22.2.</span> <span class="nav-text">Solution1 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#66-%E5%8A%A0%E4%B8%80"><span class="nav-number">23.</span> <span class="nav-text">66. 加一</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-0-%E6%9A%B4%E5%8A%9B"><span class="nav-number">23.1.</span> <span class="nav-text">Solution 0  暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution-1-%E9%80%86%E5%BA%8F%E9%81%8D%E5%8E%86-%E6%89%BE%E5%88%B09"><span class="nav-number">23.2.</span> <span class="nav-text">Solution 1 逆序遍历 找到9</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#69-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9"><span class="nav-number">24.</span> <span class="nav-text">69. x 的平方根 </span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-10"><span class="nav-number">24.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2"><span class="nav-number">24.2.</span> <span class="nav-text">Solution2 二分搜索</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="nav-number">25.</span> <span class="nav-text">70. 爬楼梯</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-1"><span class="nav-number">25.1.</span> <span class="nav-text">Solution1 递归</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB"><span class="nav-number">26.</span> <span class="nav-text">75. 颜色分类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B-11"><span class="nav-number">26.1.</span> <span class="nav-text">Solution1 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8D%95%E6%8C%87%E9%92%88"><span class="nav-number">26.2.</span> <span class="nav-text">Solution2 单指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution3-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">26.3.</span> <span class="nav-text">Solution3 双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#78-%E5%AD%90%E9%9B%86"><span class="nav-number">27.</span> <span class="nav-text">78. 子集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%9B%9E%E6%BA%AF-1"><span class="nav-number">27.1.</span> <span class="nav-text">Solution1 回溯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#90-%E5%AD%90%E9%9B%86"><span class="nav-number">28.</span> <span class="nav-text">90.子集||</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#77-%E7%BB%84%E5%90%88"><span class="nav-number">29.</span> <span class="nav-text">77. 组合</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-1"><span class="nav-number">30.</span> <span class="nav-text">39. 组合总和</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II-1"><span class="nav-number">31.</span> <span class="nav-text">40. 组合总和 II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-number">32.</span> <span class="nav-text">剑指 Offer 38. 字符串的排列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#784-%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-number">33.</span> <span class="nav-text">784. 字母大小写全排列</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2"><span class="nav-number">34.</span> <span class="nav-text">79. 单词搜索</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-number">35.</span> <span class="nav-text">83. 删除排序链表中的重复元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="nav-number">35.1.</span> <span class="nav-text">Solution1 一次遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8"><span class="nav-number">36.</span> <span class="nav-text">86. 分隔链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">36.1.</span> <span class="nav-text">Solution1  双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">37.</span> <span class="nav-text">88. 合并两个有序数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E6%9A%B4%E5%8A%9B%E7%9B%B4%E6%8E%A5%E5%90%88%E5%B9%B6%E5%90%8E%E6%8E%92%E5%BA%8F"><span class="nav-number">37.1.</span> <span class="nav-text">Solution1 暴力直接合并后排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8F%8C%E6%8C%87%E9%92%88-1"><span class="nav-number">37.2.</span> <span class="nav-text">Solution2 双指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution3-%E9%80%86%E5%90%91%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">37.3.</span> <span class="nav-text">Solution3 逆向双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95"><span class="nav-number">38.</span> <span class="nav-text">91. 解码方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="nav-number">38.1.</span> <span class="nav-text">Solution1 动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BC%98%E5%8C%96%E4%B8%BAO-1"><span class="nav-number">38.2.</span> <span class="nav-text">Solution2 动态规划 空间复杂度优化为O(1)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II"><span class="nav-number">39.</span> <span class="nav-text">92. 反转链表 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8E%9F%E5%9C%B0%E5%8F%8D%E8%BD%AC"><span class="nav-number">39.1.</span> <span class="nav-text">Solution1 原地反转</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">40.</span> <span class="nav-text">94. 二叉树的中序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-2"><span class="nav-number">40.1.</span> <span class="nav-text">Solution1 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%BF%AD%E4%BB%A3-1"><span class="nav-number">40.2.</span> <span class="nav-text">Solution2 迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">41.</span> <span class="nav-text">96. 不同的二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2"><span class="nav-number">41.1.</span> <span class="nav-text">Solution1 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-II"><span class="nav-number">42.</span> <span class="nav-text">95. 不同的二叉搜索树 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%9B%9E%E6%BA%AF-2"><span class="nav-number">42.1.</span> <span class="nav-text">Solution1 回溯</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">43.</span> <span class="nav-text">98. 验证二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-3"><span class="nav-number">43.1.</span> <span class="nav-text">Solution1 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%BA%E5%8D%87%E5%BA%8F"><span class="nav-number">43.2.</span> <span class="nav-text">Solution2 中序遍历为升序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">44.</span> <span class="nav-text">101. 对称二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-4"><span class="nav-number">44.1.</span> <span class="nav-text">Solution1  递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E9%98%9F%E5%88%97"><span class="nav-number">44.2.</span> <span class="nav-text">Solution2 队列</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">45.</span> <span class="nav-text">102. 二叉树的层序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="nav-number">45.1.</span> <span class="nav-text">Solution1 队列实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0"><span class="nav-number">45.2.</span> <span class="nav-text">Solution2 递归实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">46.</span> <span class="nav-text">103. 二叉树的锯齿形层序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">46.1.</span> <span class="nav-text">Solution1 层序遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">47.</span> <span class="nav-text">104. 二叉树的最大深度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-DFS"><span class="nav-number">47.1.</span> <span class="nav-text">Solution1 DFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Slution2-BFS"><span class="nav-number">47.2.</span> <span class="nav-text">Slution2 BFS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">48.</span> <span class="nav-text">105. 从前序与中序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="nav-number">49.</span> <span class="nav-text">118. 杨辉三角</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E7%9B%B4%E6%8E%A5%E6%B1%82%E8%A7%A3"><span class="nav-number">49.1.</span> <span class="nav-text">Solution1 直接求解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="nav-number">50.</span> <span class="nav-text">114. 二叉树展开为链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-5"><span class="nav-number">50.1.</span> <span class="nav-text">Solution1  递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%BF%AD%E4%BB%A3-2"><span class="nav-number">50.2.</span> <span class="nav-text">Solution2   迭代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II"><span class="nav-number">51.</span> <span class="nav-text">113. 路径总和 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-DFS-1"><span class="nav-number">51.1.</span> <span class="nav-text">Solution1 DFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-BFS"><span class="nav-number">51.2.</span> <span class="nav-text">Solution2 BFS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#109-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">52.</span> <span class="nav-text">109. 有序链表转换二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%85%88%E6%89%BE%E4%B8%AD%E7%82%B9-%E7%84%B6%E5%90%8E%E5%86%8D%E5%B7%A6%E5%8F%B3%E5%88%86%E5%88%AB%E6%9E%84%E9%80%A0"><span class="nav-number">52.1.</span> <span class="nav-text">Solution1 先找中点 然后再左右分别构造</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-1"><span class="nav-number">53.</span> <span class="nav-text">105. 从前序与中序遍历序列构造二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-6"><span class="nav-number">53.1.</span> <span class="nav-text">Solution1 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-1"><span class="nav-number">53.2.</span> <span class="nav-text">Solution2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="nav-number">54.</span> <span class="nav-text">121. 买卖股票的最佳时机</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95"><span class="nav-number">54.1.</span> <span class="nav-text">Solution0 暴力解法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3"><span class="nav-number">54.2.</span> <span class="nav-text">Solution1 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II"><span class="nav-number">55.</span> <span class="nav-text">122. 买卖股票的最佳时机 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-number">55.1.</span> <span class="nav-text">Solution1 贪心算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2"><span class="nav-number">55.2.</span> <span class="nav-text">Solution2 动态规划</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="nav-number">56.</span> <span class="nav-text">125. 验证回文串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E7%AD%9B%E9%80%89-%E5%88%A4%E6%96%AD"><span class="nav-number">56.1.</span> <span class="nav-text">Solution1 筛选 + 判断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E7%AD%9B%E9%80%89-%E5%88%A4%E6%96%AD-02"><span class="nav-number">56.2.</span> <span class="nav-text">Solution2 筛选 + 判断 02</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution03-%E5%9C%A8%E5%8E%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8A%E7%9B%B4%E6%8E%A5%E5%88%A4%E6%96%AD"><span class="nav-number">56.3.</span> <span class="nav-text">Solution03 在原字符串上直接判断</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">57.</span> <span class="nav-text">136. 只出现一次的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O-n-%E6%96%B9%E6%B3%95"><span class="nav-number">57.1.</span> <span class="nav-text">Solution1  空间复杂度O(n)方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%A4%ABO-1-%E6%96%B9%E6%B3%95"><span class="nav-number">57.2.</span> <span class="nav-text">Solution2 空间复杂夫O(1)方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#137-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-II"><span class="nav-number">58.</span> <span class="nav-text">137. 只出现一次的数字 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">58.1.</span> <span class="nav-text">Solution1 哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E4%BA%8C%E8%BF%9B%E5%88%B6"><span class="nav-number">58.2.</span> <span class="nav-text">Solution2 二进制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="nav-number">59.</span> <span class="nav-text">139. 单词拆分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-4"><span class="nav-number">59.1.</span> <span class="nav-text">Solution1 动态规划</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%BC%98%E5%8C%96%E7%89%88"><span class="nav-number">59.2.</span> <span class="nav-text">Solution2 动态规划 优化版</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="nav-number">60.</span> <span class="nav-text">141. 环形链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%93%88%E5%B8%8C%E8%A1%A8-1"><span class="nav-number">60.1.</span> <span class="nav-text">Solution1 哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-2"><span class="nav-number">60.2.</span> <span class="nav-text">Solution2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II"><span class="nav-number">61.</span> <span class="nav-text">142. 环形链表 II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%93%88%E5%B8%8C%E8%A1%A8-2"><span class="nav-number">61.1.</span> <span class="nav-text">Solution1 哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E5%8F%8C%E6%8C%87%E9%92%88-2"><span class="nav-number">61.2.</span> <span class="nav-text">Solution2 双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"><span class="nav-number">62.</span> <span class="nav-text">143. 重排链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution0-%E6%9A%B4%E5%8A%9B-1"><span class="nav-number">62.1.</span> <span class="nav-text">Solution0 暴力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E5%8F%8C%E6%8C%87%E9%92%88-1"><span class="nav-number">62.2.</span> <span class="nav-text">Solution1 双指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">63.</span> <span class="nav-text">144. 二叉树的前序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution1-%E9%80%92%E5%BD%92-7"><span class="nav-number">63.1.</span> <span class="nav-text">Solution1 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solution2-%E8%BF%AD%E4%BB%A3-3"><span class="nav-number">63.2.</span> <span class="nav-text">Solution2 迭代</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
