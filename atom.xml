<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kyle Chen&#39;s Blog</title>
  
  <subtitle>Action speaks louder than Words</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-06-05T13:46:39.723Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>陈同学</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【C++】C++中的IO类总结——上篇</title>
    <link href="http://example.com/2023/06/05/%E3%80%90C-%E3%80%91C-%E4%B8%AD%E7%9A%84IO%E7%B1%BB%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E4%B8%8A%E7%AF%87/"/>
    <id>http://example.com/2023/06/05/%E3%80%90C-%E3%80%91C-%E4%B8%AD%E7%9A%84IO%E7%B1%BB%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E4%B8%8A%E7%AF%87/</id>
    <published>2023-06-04T16:36:59.000Z</published>
    <updated>2023-06-05T13:46:39.723Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Hello World!&quot;</span>&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>我们在学习C++时，往往都是从上面这段程序开始的<br>也就是在控制台窗口上打印Hello World</p></li><li><p>但是现在回过头去看这段简单的程序<br>你有没有思考过<br>cout代表什么？<br>iostream代表什么？<br>endl又代表了什么？<br>&lt;&lt;运算符的作用是什么？<br>为什么这样的操作就可以在屏幕上打印”Hello World”？<br>等等问题</p></li><li><p>看似简单的代码，背后却蕴含着庞大的知识体系</p></li><li><p>之前一直对这些问题不太清晰<br>现在重新回过头来总结一下</p></li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>C++的标准库中有专门用来进行IO操作的一种类，叫IO类，也叫输入输出流<br>通过这些IO类可以实现<code>控制台IO,文件IO,内存IO</code><br>也就是向<code>控制台/文件/内存</code>写入数据，<br>以及从<code>控制台/文件/内存</code>读取数据，</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li><p>IO类一共有9中</p></li><li><p>在iostream.hpp中定义了ostream istream iostream这三个类</p><pre><code>  (1)istream是用于从控制台读取内容的流类，cin就是该类的对象    (2)ostream是用于把内容输出到控制台的流类，cout就是该类的对象.    (3)iostream是既能用于从控制台读取，又能把内容输出到控制台的类。</code></pre></li><li><p>在fstream.hpp中定义了ofstream ifstream fstream这三个类</p><pre><code>  (1)ifstream是用于从文件读取数据的类.    (2)ofstream是用于向文件写人数据的类.    (3)fstream是既能从文件读取数据，又能向文件写人数据的类，</code></pre></li><li><p>在sstream.hpp这个头文件中 定义了stringstream类 ostringstream 类 istringstream类</p><pre><code>  (1)istringstream是用于从内存读取数据的类.    (2)ostringstream是用于向内存写人数据的类.    (3)stringstream是既能从内存读取数据，又能向内存写入数据的类，</code></pre></li></ul><p>下面两张图展示了不同的IO类之间的继承关系</p><p><img src="https://img-blog.csdnimg.cn/fe5ad6568b9c4b299a783bed5d033259.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/8371ae41123e4c4cb2a1bcc0822f94ec.png" alt="在这里插入图片描述"></p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li><ol><li>不能对IO对象赋值或者拷贝。</li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ofstream out1,out2;</span><br><span class="line">out1 = out2; <span class="comment">//错误：不能对流对象赋值</span></span><br><span class="line"><span class="function">ofstream <span class="title">print</span> <span class="params">(ofstream)</span></span>; 错误：不能初始化ofstream参数</span><br><span class="line">out2 =  <span class="built_in">print</span> (out2);  错误：不能拷贝流对象</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>2.函数参数和返回值</p><pre><code>  由1得知 ,当函数的参数或者返回值使用了IO对象类型，不能采用值传递，  不能采用const 引用方式传递 ，   只能采用非const 引用方式传递</code></pre></li><li><ol start="3"><li>错误处理</li></ol><p>  在通过IO类进行读取的时候 不可避免会出现一些错误，比如文件格式错误 ，输入了错误的格式等等，<br>  C++中定义了一种叫 strm::iostate的bitset来表示对IO类读取操作时的不同状态  包含以下四种状态：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.strm::goodbit：流处于有效状态。该位为 0 表示流没有出现任何错误。</span><br><span class="line">2.strm::failbit：由于格式或类型错误，读写操作失败。</span><br><span class="line">                          例如，从流中读取的值无法转换为有效的目标类型。该位为 1 表示发生了此类错误。</span><br><span class="line">3.strm::eofbit：已经读到流的末尾，即无法继续读取数据。</span><br><span class="line">                该位为 1 表示读取操作已到达流的末尾。</span><br><span class="line">7.strm::badbit：流发生严重的错误，无法恢复。例如，数据无法从磁盘读取或写入磁盘，</span><br><span class="line">                         或者与底层设备的通信失败。该位为 1 表示发生了此类错误。</span><br></pre></td></tr></table></figure><br>      以上四种条件状态可以按位组合使用，例如 s.fail() | s.eof() 表示流可能发生了读取失败或到达末尾的情况。<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同时C++的IO类提供了下面这些接口进行状态判定和状态清除</span><br></pre></td></tr></table></figure><br>              1.s.eof()：判断输入流 s 是否读到文件末尾，即文件读取是否结束。如果已经到达文件结尾，就返回 true，否则返回 false。<br>              2.s.fail()：判断是否在读取或写入流的过程中出现了错误，例如读取了无效的数据类型。如果流发生了 failbit 或 badbit 错误，则返回 true，否则返回 false。<br>              3.s.bad()：判断流是否发生了不可恢复的错误，例如在程序运行时无法打开文件或者无法从流中读取数据。如果流发生了 badbit 错误，则返回 true，否则返回 false。<br>              4.s.good()：判断流是否处于有效状态，即没有发生任何错误。如果流处于有效状态，则返回 true，否则返回 false。<br>              5.s.clear()：将流 s 的所有条件状态位都复位，将流的状态设置为有效。该函数没有参数，返回值为 void。<br>              6.s.clear(flags)：根据给定的 flags 标志位，将流 s 中对应条件状态位复位。flags 的类型为 strm::iostate，可以使用 | 运算符同时设置多个标志位。该函数没有返回值。<br>              7.s.setstate(flags)：根据给定的 flags 标志位，将流 s 中对应条件状态位置位。flags 的类型为 strm::iostate，可以使用 | 运算符同时设置多个标志位。该函数没有返回值。<br>              8.s.rdstate()：返回流 s 的当前条件状态，</p></li></ul><p>下面是使用实例<br><img src="https://img-blog.csdnimg.cn/c4caa1143f6d4c9b9035be531e6d85b6.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/839570c3c2e44120932c8bee82042441.png" alt="在这里插入图片描述"></p><ul><li><p>4.缓冲区机制</p><p>  <strong>什么是缓冲区机制？</strong></p><pre><code>  当我们在用std::cout的时候  如果这样写的话std::cout&lt;&lt;&quot;Hello World&quot;;  那么当程序执行完这句时 屏幕上可能不会打印Hello world 也可能会打印  这是因为每个输出流都管理一个缓冲区，用来保存程序读写的数据。  当你执行上面的cout时，  内容有可能被操作系统保存在缓冲区中，随后再打印。  也有可能刚好缓冲区满了然后立刻打印</code></pre><p>  <strong>为什么要有缓冲区机制？</strong></p><pre><code>  有了缓冲机制，  操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。  由于操作系统级的写操作可能很耗时，  允许操作系统将多个输出操作组合 为单一的设备写操作可以带来很大的性能提升。</code></pre><p>  <strong>缓冲区什么时候会刷新？</strong></p><p>  1.程序正常结束<br>      程序异常结束，输出缓冲区不会被刷新<br>      <img src="https://img-blog.csdnimg.cn/ac9f4874ddfd4277b969ad7b3d6f9ac3.png" alt="在这里插入图片描述"><br>  2.缓冲区满时</p><p>  3.使用endl&#x2F;flush&#x2F;ends来强制刷新<br>     <img src="https://img-blog.csdnimg.cn/c6277b99271143e28a3f46419b5088a8.png" alt="在这里插入图片描述"><br>  4.进行unitbuf设置</p><p>  注意 默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。<br>  <img src="https://img-blog.csdnimg.cn/1dda6b666baa47b6b13a0ce080001f49.png" alt="在这里插入图片描述"></p><p>  ·5.一个输出流可能被关联到另一个流。<br>  在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。<br>  例如，默认情况下，cin和cerr都关联到cout。因此，读cin或写cerr都会导致cout的缓冲区被刷新。</p></li></ul>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【C++】C++中的boost库—String_Algorithm_Library</title>
    <link href="http://example.com/2023/05/31/%E3%80%90C-%E3%80%91C-%E4%B8%AD%E7%9A%84boost%E5%BA%93%E2%80%94String-Algorithm-Library/"/>
    <id>http://example.com/2023/05/31/%E3%80%90C-%E3%80%91C-%E4%B8%AD%E7%9A%84boost%E5%BA%93%E2%80%94String-Algorithm-Library/</id>
    <published>2023-05-30T16:36:59.000Z</published>
    <updated>2023-05-31T11:00:07.250Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><ul><li>本篇文章讲讲Boost库中String_Algorithm_Library常用的那些接口</li><li><a href="https://www.boost.org/doc/libs/1_62_0/doc/html/string_algo/reference.html">参考</a></li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><code>&lt;boost/algorithm/string/case_conv.hpp&gt;</code>：提供字符串大小写转换函数，包括 <code>to_lower()</code>、<code>to_upper()</code>、<code>to_title()</code>、<code>to_lower_copy()</code>、<code>to_upper_copy()</code> 和 <code>to_title_copy()</code>。</li><li><code>&lt;boost/algorithm/string/classification.hpp&gt;</code>：提供用于判断字符分类的函数对象，如 <code>is_any_of</code>、<code>is_alpha</code>、<code>is_digit</code>、<code>is_space</code> 等。</li><li><code>&lt;boost/algorithm/string/compare.hpp&gt;</code>：提供字符串比较函数，包括 <code>is_equal()</code>、<code>ilexicographical_compare()</code>、<code>iless()</code> 和 <code>ilexicographical_compare()</code>。</li><li><code>&lt;boost/algorithm/string/concept.hpp&gt;</code>：定义了用于实现字符串算法及其特征的概念、标准化和接口文档。</li><li><code>&lt;boost/algorithm/string/constants.hpp&gt;</code>：定义一些与字符串算法相关的常量，如空格字符、单引号、双引号等。</li><li><code>&lt;boost/algorithm/string/erase.hpp&gt;</code>：提供字符串删除函数，包括 <code>erase_first()</code>、<code>erase_nth()</code> 和 <code>erase_all()</code>。</li><li><code>&lt;boost/algorithm/string/find.hpp&gt;</code>：提供字符串查找函数，包括 <code>find_first()</code>、<code>find_last()</code>、<code>find_nth()</code> 和 <code>find_all()</code>。</li><li><code>&lt;boost/algorithm/string/find_format.hpp&gt;</code>：提供字符串查找并替换函数，包括 <code>replace_first()</code>、<code>replace_last()</code>、<code>replace_nth()</code> 和 <code>replace_all()</code>。</li><li><code>&lt;boost/algorithm/string/find_iterator.hpp&gt;</code>：提供一系列查找字符串的迭代器，如 <code>find_iterator</code>、<code>token_iterator</code> 和 <code>split_iterator</code>。</li><li><code>&lt;boost/algorithm/string/finder.hpp&gt;</code>：定义了在字符串中查找子串的算法，包括简单查找算法和 KMP 算法。</li><li><code>&lt;boost/algorithm/string/formatter.hpp&gt;</code>：定义了用于格式化输出字符串的函数对象，如 <code>repeat_formatter</code>、<code>range_formatter</code> 和 <code>join_formatter</code>。</li><li><code>&lt;boost/algorithm/string/iter_find.hpp&gt;</code>：定义了一个类模板 <code>iter_find_t</code>，可以在字符串中查找子串并返回迭代器。</li><li><code>&lt;boost/algorithm/string/join.hpp&gt;</code>：提供字符串连接函数，包括 <code>join()</code>、<code>join_if()</code> 和 <code>concat()</code>。</li><li><code>&lt;boost/algorithm/string/predicate.hpp&gt;</code>：提供字符串谓词函数，包括 <code>starts_with()</code>、<code>ends_with()</code>、<code>contains()</code>、<code>equals()</code>、<code>iequals()</code> 和 <code>iless()</code>。</li><li><code>&lt;boost/algorithm/string/regex.hpp&gt;</code>：提供与正则表达式相关的字符串函数，包括 <code>regex_match()</code>、<code>regex_search()</code>、<code>regex_replace()</code>。</li><li><code>&lt;boost/algorithm/string/regex_find_format.hpp&gt;</code>：提供使用正则表达式查找并替换字符串的函数，包括 <code>regex_replace()</code> 和 <code>regex_transform()</code>。</li><li><code>&lt;boost/algorithm/string/replace.hpp&gt;</code>：提供替换字符串函数，包括 <code>replace_first()</code>、<code>replace_last()</code>、<code>replace_nth()</code> 和 <code>replace_all()</code>。</li><li><code>&lt;boost/algorithm/string/sequence_traits.hpp&gt;</code>：定义了判断序列类型的函数模板 <code>is_sequence</code>，用于判断一个类型是否为序列。</li><li><code>&lt;boost/algorithm/string/split.hpp&gt;</code>：提供字符串分割函数，包括 <code>split()</code>、<code>split_if()</code> 和 <code>splitted()</code>。</li><li><code>&lt;boost/algorithm/string/std_containers_traits.hpp&gt;</code>：定义了用于实现 STL 容器的特化模板 <code>sequence_traits</code>。</li><li><code>&lt;boost/algorithm/string/trim.hpp&gt;</code>：提供字符串去除空格函数，包括 <code>trim()</code>、<code>trim_left()</code>、<code>trim_right()</code> 和 <code>trim_copy()</code>。</li><li><code>&lt;boost/algorithm/string/trim_all.hpp&gt;</code>：提供字符串去除所有空格函数，包括 <code>trim_all()</code>、<code>trim_all_copy()</code>。</li></ul><h2 id="0-lt-boost-algorithm-string-case-conv-hpp-gt"><a href="#0-lt-boost-algorithm-string-case-conv-hpp-gt" class="headerlink" title="0.&lt;boost/algorithm/string/case_conv.hpp&gt;"></a>0.<code>&lt;boost/algorithm/string/case_conv.hpp&gt;</code></h2><ul><li>to_lower()：将一个字符串转换为全小写格式。</li><li>to_upper()：将一个字符串转换为全大写格式。</li><li>to_title()：将一个字符串所有单词的首字母转换为大写。</li><li>to_lower_copy()：生成一个全小写格式的副本。</li><li>to_upper_copy()：生成一个全大写格式的副本。</li><li>to_title_copy()：生成一个标题格式的副本。</li></ul><h2 id="1-lt-boost-algorithm-string-compare-hpp-gt-："><a href="#1-lt-boost-algorithm-string-compare-hpp-gt-：" class="headerlink" title="1. &lt;boost/algorithm/string/compare.hpp&gt;："></a>1. <code>&lt;boost/algorithm/string/compare.hpp&gt;</code>：</h2><p>该头文件提供字符串的比较函数。主要包括以下函数：</p><ul><li><code>is_equal()</code>：用于判断两个字符串是否相等，可以指定比较大小写敏感或不敏感。</li><li><code>ilexicographical_compare()</code>：用于比较字符串的字典序，可以指定比较大小写敏感或不敏感。</li><li><code>iless()</code>：用于判断一个字符串是否小于另一个字符串，可以指定比较大小写敏感或不敏感。</li><li><code>ilexicographical_compare()</code>：用于比较字符串的字典序，可以指定比较大小写敏感或不敏感。</li></ul><h2 id="2-lt-boost-algorithm-string-erase-hpp-gt-："><a href="#2-lt-boost-algorithm-string-erase-hpp-gt-：" class="headerlink" title="2. &lt;boost/algorithm/string/erase.hpp&gt;："></a>2. <code>&lt;boost/algorithm/string/erase.hpp&gt;</code>：</h2><p>该头文件提供了删除字符串子串的函数。主要包括以下函数：</p><ul><li><code>erase_first()</code>：用于删除第一个出现的指定子串。</li><li><code>erase_nth()</code>：用于删除第 n 个出现的指定子串。</li><li><code>erase_all()</code>：用于删除所有出现的指定子串。</li></ul><h2 id="3-lt-boost-algorithm-string-find-hpp-gt-："><a href="#3-lt-boost-algorithm-string-find-hpp-gt-：" class="headerlink" title="3. &lt;boost/algorithm/string/find.hpp&gt;："></a>3. <code>&lt;boost/algorithm/string/find.hpp&gt;</code>：</h2><p>该头文件提供了查找字符串子串的函数。主要包括以下函数：</p><ul><li><code>find_first()</code>：用于查找第一个出现的指定子串，返回子串起始位置和结束位置。</li><li><code>find_last()</code>：用于查找最后一个出现的指定子串，返回子串起始位置和结束位置。</li><li><code>find_nth()</code>：用于查找第 n 个出现的指定子串，返回子串起始位置和结束位置。</li><li><code>find_all()</code>：用于查找所有出现的指定子串，返回子串起始位置和结束位置的迭代器。</li></ul><h2 id="4-lt-boost-algorithm-string-find-format-hpp-gt-："><a href="#4-lt-boost-algorithm-string-find-format-hpp-gt-：" class="headerlink" title="4. &lt;boost/algorithm/string/find_format.hpp&gt;："></a>4. <code>&lt;boost/algorithm/string/find_format.hpp&gt;</code>：</h2><p>该头文件提供了查找并替换字符串子串的函数。主要包括以下函数：</p><ul><li><code>replace_first()</code>：用于查找并替换第一个出现的指定子串。</li><li><code>replace_last()</code>：用于查找并替换最后一个出现的指定子串。</li><li><code>replace_nth()</code>：用于查找并替换第 n 个出现的指定子串。</li><li><code>replace_all()</code>：用于查找并替换所有出现的指定子串。</li></ul><h2 id="5-lt-boost-algorithm-string-finder-hpp-gt-："><a href="#5-lt-boost-algorithm-string-finder-hpp-gt-：" class="headerlink" title="5. &lt;boost/algorithm/string/finder.hpp&gt;："></a>5. <code>&lt;boost/algorithm/string/finder.hpp&gt;</code>：</h2><p>该头文件提供了在字符串中查找子串的算法。其中包含了一些简单查找算法和 KMP 算法。</p><h2 id="6-lt-boost-algorithm-string-join-hpp-gt-："><a href="#6-lt-boost-algorithm-string-join-hpp-gt-：" class="headerlink" title="6. &lt;boost/algorithm/string/join.hpp&gt;："></a>6. <code>&lt;boost/algorithm/string/join.hpp&gt;</code>：</h2><p>该头文件提供了连接多个字符串为一个字符串的函数。主要包括以下函数：</p><ul><li><code>join()</code>：用于连接多个字符串，并添加指定的分隔符。</li><li><code>join_if()</code>：用于只连接满足指定谓词条件的字符串，并添加指定的分隔符。</li><li><code>concat()</code>：用于连接两个字符串。</li></ul><h2 id="7-lt-boost-algorithm-string-split-hpp-gt-："><a href="#7-lt-boost-algorithm-string-split-hpp-gt-：" class="headerlink" title="7. &lt;boost/algorithm/string/split.hpp&gt;："></a>7. <code>&lt;boost/algorithm/string/split.hpp&gt;</code>：</h2><p>该头文件提供了将字符串分割为多个子串的函数。主要包括以下函数：</p><ul><li><code>split()</code>：用于按指定分隔符分割字符串，并将结果存入一个容器中。</li><li><code>split_if()</code>：用于根据指定谓词函数判断是否需要分割，并将结果存入一个容器中。</li><li><code>splitted()</code>：用于返回按指定分隔符分割后的结果，作为一个可迭代对象使用。</li></ul><h2 id="8-lt-boost-algorithm-string-trim-hpp-gt-："><a href="#8-lt-boost-algorithm-string-trim-hpp-gt-：" class="headerlink" title="8. &lt;boost/algorithm/string/trim.hpp&gt;："></a>8. <code>&lt;boost/algorithm/string/trim.hpp&gt;</code>：</h2><p>该头文件提供了去除字符串首尾空白字符的函数。主要包括以下函数：</p><ul><li><code>trim()</code>：用于去除字符串首尾空白字符。</li><li><code>trim_left()</code>：用于去除字符串左侧空白字符。</li><li><code>trim_right()</code>：用于去除字符串右侧空白字符。</li><li><code>trim_copy()</code>：用于返回去除首尾空白字符后的字符串副本。</li></ul><h2 id="9-lt-boost-algorithm-string-regex-hpp-gt-："><a href="#9-lt-boost-algorithm-string-regex-hpp-gt-：" class="headerlink" title="9. &lt;boost/algorithm/string/regex.hpp&gt;："></a>9. <code>&lt;boost/algorithm/string/regex.hpp&gt;</code>：</h2><p>该头文件提供了与正则表达式相关的函数。主要包括以下函数：</p><ul><li><code>regex_match()</code>：用于检测一个字符串是否符合正则表达式的模式。</li><li><code>regex_search()</code>：用于在一个字符串中查找匹配正则表达式模式的子串。</li><li><code>regex_replace()</code>：用于查找并替换匹配正则表达式模式的子串。</li></ul><h2 id="10-lt-boost-algorithm-string-regex-find-format-hpp-gt-："><a href="#10-lt-boost-algorithm-string-regex-find-format-hpp-gt-：" class="headerlink" title="10. &lt;boost/algorithm/string/regex_find_format.hpp&gt;："></a>10. <code>&lt;boost/algorithm/string/regex_find_format.hpp&gt;</code>：</h2><p>该头文件提供了使用正则表达式进行查找和替换的函数。主要包括以下函数：</p><ul><li><code>regex_replace()</code>：用于通过正则表达式查找并替换字符串中的相应子串。</li><li><code>regex_transform()</code>：用于通过正则表达式查找某些子串并返回一个格式化后的副本。</li></ul><h1 id="11-lt-boost-algorithm-string-replace-hpp-gt"><a href="#11-lt-boost-algorithm-string-replace-hpp-gt" class="headerlink" title="11. &lt;boost/algorithm/string/replace.hpp&gt;"></a>11. <code>&lt;boost/algorithm/string/replace.hpp&gt;</code></h1><p>头文件。该头文件提供了替换字符串子串的函数，主要包括以下函数：</p><ul><li><code>replace_first_copy()</code>：用于替换第一个出现的指定子串，并返回替换后的字符串副本。</li><li><code>replace_last_copy()</code>：用于替换最后一个出现的指定子串，并返回替换后的字符串副本。</li><li><code>replace_nth_copy()</code>：用于替换第 n 个出现的指定子串，并返回替换后的字符串副本。</li><li><code>replace_all_copy()</code>：用于替换所有出现的指定子串，并返回替换后的字符串副本。</li></ul><p>此外，还有以下函数可以直接在原字符串上进行替换操作：</p><ul><li><code>replace_first()</code>：用于替换第一个出现的指定子串。</li><li><code>replace_last()</code>：用于替换最后一个出现的指定子串。</li><li><code>replace_nth()</code>：用于替换第 n 个出现的指定子串。</li><li><code>replace_all()</code>：用于替换所有出现的指定子串。</li></ul>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【经验总结】关于浮点数double/float精度误差问题的总结</title>
    <link href="http://example.com/2023/05/29/%E3%80%90%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%E3%80%91%E5%85%B3%E4%BA%8E%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AF%AF%E5%B7%AE%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2023/05/29/%E3%80%90%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%E3%80%91%E5%85%B3%E4%BA%8E%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9%E6%95%B0%E8%AF%AF%E5%B7%AE%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%BB%E7%BB%93/</id>
    <published>2023-05-28T16:36:59.000Z</published>
    <updated>2023-05-28T16:36:59.257Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li><p>最近做的项目中经常会在C++环境下和高精度的double浮点类型数据打交道</p></li><li><p>这些double类型数据精度级别可能到 pico级别(10^-12) 甚至 femto级别(10^-15),用来表示集成电路的一些微观属性</p></li><li><p>但是非常诡异的是，不知道为什么在对这些高精度的浮点数进行运算时，往往最后运算产生的数据会和你预期的不一样。比如下面这些场景</p></li><li><p>1:使用double数据进行大小判定踩的坑</p><pre><code>  我有两个double 类型数据val1 和val2，经过运算后  能够确定的是它们大小是相等的   按照预期 val1 = val2= 1.0000000025  但是用if( val1 == val2 )去做相等判定的时候 得到的结果却是false  </code></pre></li><li><p>2:使用QDoubleSpinBox获取数据时踩的坑</p></li><li><pre><code>  QDoubleSpinBox是QT库中的一个可调节数值大小的文本框  QDoubleSpinBox有一个value接口可以用来获取当前显示的值  假设此时文本框显示的值时0.0000000267  当我用value()获取这个值，赋值给val1   并且用if( val1 == 0.0000000267)判定时返回false  </code></pre></li><li><p>3:使用QDoubleSpinBox设定数据进行运算时踩的坑</p></li><li><pre><code>  QDoubleSpinBox可以通过setValue()接口设定要显示的值  当我用setValue(0.000000102)时  最后显示的结果时0.0000001020001</code></pre></li><li><p>4:使用std::to_string数据进行运算时踩的坑</p><pre><code> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double val = 0.23165498;</span><br><span class="line">auto res = std::to_string(0.23165498);</span><br></pre></td></tr></table></figure> 最后res的结果不是0.23165498 ，而是0.23165498</code></pre></li><li><p>5:使用double数据进行运算时踩的坑</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double val = 0.00000104;</span><br><span class="line">val = val / 10;</span><br></pre></td></tr></table></figure><p>  最后val的结果是0.0000001040001</p></li><li><p>踩了很多的坑，后来了解了一下原因</p></li><li><p>发现<code>原来计算机在记录这些浮点类数据的时候 ，用的记录方式本身就是不精确的，也就是说double类型数据本质上自带误差的</code></p></li><li><p>比如你定义了<code> float fval = 0.45，但其实它的真实值为0.449999988。定义了double dval = 0.45 但它的真实值为0.45000000000000001</code> 这是为什么呢？</p></li></ul><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ul><li><p>要想详细的解释上面的现象出现的原因，就得聊聊计算机是怎么存储浮点数的<br>以下内容引用自<a href="https://cloud.tencent.com/developer/article/1473541">https://cloud.tencent.com/developer/article/1473541</a><br>发现这位horstxu大佬写的很好。</p></li><li><p>在编程中，浮点类型数据主要用于表示小数，例如Java或C++中的float、double类型，Golang中的float32、float64类型。我们在开始学编程的时候也经常被教育，浮点数有精度问题，不适用于比较大小或比较相等性的逻辑。任何数字在计算机中都是用0和1二进制来表示，对于float（占据4字节）和double（占据8字节）类型，又是如何使用一串0和1表示出来呢？</p></li><li><p>浮点数的存储方案是来自于IEEE 754（IEEE Standard for Floating-Point Arithmetic）标准，这一标准最早在1985年提出，基本上已经被用于所有计算机中。IEEE 754经历了几次标准更新，但是最核心的内容，即浮点数表示规则，从来没有变过。该标准一共经历了1985版，1987版，2008版，2019版等几个版本的更新，最新版2019版的官网链接在此：<a href="https://standards.ieee.org/content/ieee-standards/en/standard/754-2019.html">https://standards.ieee.org/content/ieee-standards/en/standard/754-2019.html</a> ，感兴趣的话可以延伸阅读。</p></li><li><p>要表示浮点数的第一步，就是让小数也能使用二进制来表示。我们知道二进制表示整数时，最低位代表2的0次方，往高位依次是2的1次方，2次方，3次方……那么对应的，二进制数小数点后面，最高位则是2的-1次方，-2次方，-3次方……如下图所示：</p></li></ul><p><img src="https://img-blog.csdnimg.cn/189857ab7fe54f469ea0f6ca8ef3a812.png" alt="在这里插入图片描述"></p><ul><li>二进制浮点数每一位对应的十进制数值<br>下面举几个例子：</li></ul><p><img src="https://img-blog.csdnimg.cn/05f93d75c2ba4fabb7316c4ba23b3823.png" alt="在这里插入图片描述"></p><ul><li><p>十进制与二进制转换<br>十进制数字10.625，用二进制表示为1010.101 。其实这种二进制表示小数的方法，造成了一个隐含的问题：一些本来不是无限循环的十进制小数，表示成二进制之后成了无限循环小数。比如上图中的十进制数字0.6，表示成二进制之后成了循环体为1001的无限循环小数。这就是“浮点数有精度问题”的根源之一，你在代码中声明一个变量double a &#x3D; 0.6;时，计算机底层其实是无法精确存储那个无限循环二进制数的，只能存一个四舍五入（准确说应该是零舍一入，毕竟是二进制）后的近似值。</p></li><li><p>下一步，将二进制表示为以2为底的科学计数法，如图：</p></li></ul><p><img src="https://img-blog.csdnimg.cn/26f8d483888b46608c2092ed40384e06.png" alt="在这里插入图片描述"></p><ul><li>二进制科学计数法<br>对于任何数字表示成二进制科学计数法以后，一定是1点几（尾数）乘以2的多少次方（指数）。对于小于零的负数来说，就是负1点几（尾数）乘以2的多少次方（指数）。所以要存这个数，需要存储三个部分：正负号，尾数，指数。</li></ul><p><img src="https://img-blog.csdnimg.cn/f0dbd3c57095461983297bf52d040410.png" alt="在这里插入图片描述"></p><ul><li>浮点数在内存中的表示方式<br>具体存储方式如上图所示。最高位有1bit存储正负号，然后指数部分占据8bits（4字节）或11bits（8字节），其余部分全都用来存储尾数部分。对于指数部分，这里存储的结果是实际的指数加上偏移量之后的结果。这里设置偏移量，是为了让指数部分不出现负数，全都为大于等于0的正整数。尾数部分的存储，因为二进制的科学计数法，小数点前一定是1开头，因此我们尾数只需要存储小数点后面的部分即可。接下来依然是举例说明：</li></ul><p><img src="https://img-blog.csdnimg.cn/bccb040c0e59430f97d0439c8f9cde86.png" alt="在这里插入图片描述"></p><ul><li><p>4字节浮点数0.6的存储方式</p></li><li><p>再来看一个8字节浮点数的例子：<br><img src="https://img-blog.csdnimg.cn/08f41b81d88c44e2bf7520e4911c4295.png" alt="在这里插入图片描述"></p></li><li><p>8字节-0.1的存储方式<br>8字节数字-0.1，可以看到最高位为1，表示负数。后面逻辑和前文的4字节浮点数类似，只是偏移量略有区别。</p></li><li><p>浮点数的这种表示法，其实对于绝对值比较大的数来说，小数点后面的精度会比较差。对于绝对值接近0的比较小的数来说，小数点后面的精度反而会非常高。我们用一段简单的golang代码来说明一下（非常简单，非golang开发也能看懂）。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/6882115bba15427fa69b7793af755eb3.png" alt="在这里插入图片描述"></p><ul><li><p>浮点数的相等性比较<br>我们可以看到，变量a和b的差距只有0.00000001，但是他们在内存中所存储的值依然是不同的，a和b比较会返回false。但是对于c和d来说，他们值只差了0.001，小数点后的差距比a和b的差距要大很多，c和d的判断结果依然是相等。这是由于c和d整数部分占据了4字节太多位置，导致小数部分的数值差距，在4字节内已经体现不出来了。c和d在内存中存的值是完全一样的。前文所说的零舍一入机制，加上浮点数在内存中本身的存储机制，导致了我们编程中经常被提醒的：“浮点数有精度问题”。</p></li><li><p>由此我们也就知道了为什么double类型数据会在加减乘除计算和字符串转换过程中产生精度误差 。主要是由于浮点数在计算机内部的二进制表示与实际小数值之间存在的差异，这种差异通常被称为“舍入误差”。舍入误差会在多次运算中积累，从而导致误差不断放大。例如，两个看似相等的浮点数进行运算时，其结果可能会因为舍入误差而不同。</p></li></ul><h2 id="措施"><a href="#措施" class="headerlink" title="措施"></a>措施</h2><h3 id="1-如何对浮点类型数据做相等判定？"><a href="#1-如何对浮点类型数据做相等判定？" class="headerlink" title="1. 如何对浮点类型数据做相等判定？"></a>1. 如何对浮点类型数据做相等判定？</h3><p>在最开始说到的问题1 和问题2都是和double数据相等判定相关的问题<br>对于浮点类型数据做相等判定<br>我们可以提前定义一个确定大小的误差值，当val1 和 val2的差绝对值小于这个误差值的时候就认定位相等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#define eps 1e-6</span><br><span class="line"></span><br><span class="line">bool EQ(double a, double b) &#123;   //等于</span><br><span class="line">return fabs(a - b) &lt; eps;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool GET(double a, double b) &#123;    // 大于等于</span><br><span class="line">return a &gt; b || EQ(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool SET(double a, double b) &#123;   // 小于等于</span><br><span class="line">return a &lt; b || EQ(a, b);</span><br><span class="line">&#125;</span><br><span class="line">bool ST(double a, double b) &#123;   // 小于</span><br><span class="line">return a &lt; b &amp;&amp; NEQ(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool GT(double a, double b) &#123;   // 大于</span><br><span class="line">return a &gt; b &amp;&amp; NEQ(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>boost库中好像有一些API把两个值之间的差计算到精度级别</p><h3 id="2-如何让QDoubleSpinBox精确的显示浮点类型数据？"><a href="#2-如何让QDoubleSpinBox精确的显示浮点类型数据？" class="headerlink" title="2. 如何让QDoubleSpinBox精确的显示浮点类型数据？"></a>2. 如何让QDoubleSpinBox精确的显示浮点类型数据？</h3><ul><li>这里说的精确其实只是一种规避手段，并不能真正做到精确<br>我们可以使用QDoubleSpinBox的setDemical接口去设定显示在文本框中数据的小数点后面的位数<br>比如setDemical(5)则表示我们只会用四舍五入的方式显示原数据小数点后面的5位<br>只要前5位小数是精确的，那么显示在文本框上的数据就是精确的</li></ul><h3 id="3-如何有效的将浮点数转为字符串？"><a href="#3-如何有效的将浮点数转为字符串？" class="headerlink" title="3. 如何有效的将浮点数转为字符串？"></a>3. 如何有效的将浮点数转为字符串？</h3><ul><li><p>sprintf函数<br>这里不细说</p></li><li><p>std::to_string</p><p>  std:to_string()方法只能精确到6位小数点</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double d = 3.1415926535897932384;</span><br><span class="line">std::string str = std::to_string(d);</span><br><span class="line">std::cout &lt;&lt; str &lt;&lt; std::endl; // 3.141593</span><br></pre></td></tr></table></figure></li><li><p>std::stringstream<br>使用stringstream，在输入流时使用setprecision设置精度<br>注意头文件要包含下面两个</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;sstream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line"></span><br><span class="line">std::stringstream ss;</span><br><span class="line">ss &lt;&lt; std::setprecision(15) &lt;&lt; d;</span><br><span class="line">str = ss.str();  // 3.14159265358979</span><br></pre></td></tr></table></figure><p>  std::setprecision如果设定大于15那么后面的数据会不可靠</p><p>  关于std::stringstream和 std::to_string更详细的讲解可以看这篇文章 <a href="https://www.cnblogs.com/chorulex/p/7660187.html">https://www.cnblogs.com/chorulex/p/7660187.html</a></p></li></ul><h3 id="4-如何有效的解决浮点数在运算时产生的精度误差"><a href="#4-如何有效的解决浮点数在运算时产生的精度误差" class="headerlink" title="4. 如何有效的解决浮点数在运算时产生的精度误差"></a>4. 如何有效的解决浮点数在运算时产生的精度误差</h3><p>不能完全解决 只能尽量缓解</p><ul><li><p>尽量避免直接进行连续的加减乘除操作，而是采用累加器或积累器等数据结构，减少中间结果的累计误差。</p></li><li><p>利用算术运算法则，将算式转换为更加稳定的计算方式。例如，可以将 A&#x2F;B * C 转换为 A * (C&#x2F;B)，或者将 A&#x2F;C * B 转换为 A * (B&#x2F;C)。</p></li><li><p>使用高精度库（如 GMP、MPFR 等）或自定义实现高精度运算的数据结构，来代替原本的浮点数类型进行计算。</p></li><li><p>在具体问题中选择合适的计算精度。例如，在实现一个简单的计算器时，可以将小数部分保留 4-5 位来避免累计误差。</p></li><li><p>了解浮点数的特性和运算规则，合理利用舍入误差和向零取整等特性，减小误差的产生。例如，在求平均数时采用 Kahan 总和算法等技巧，可以有效减少舍入误差对结果的影响。</p></li><li><p>需要根据具体的问题和实际情况来选择合适的方法，以达到减小误差、提高计算精度的目的。</p></li></ul>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="经验总结" scheme="http://example.com/categories/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="经验总结" scheme="http://example.com/tags/%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode problems Solutions Note</title>
    <link href="http://example.com/2022/08/22/Leetcode-problems-Solutions-Note/"/>
    <id>http://example.com/2022/08/22/Leetcode-problems-Solutions-Note/</id>
    <published>2022-08-22T14:45:47.000Z</published>
    <updated>2023-02-25T14:43:47.237Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>@<a href="Content">toc</a></p><h1 id="回溯-字符串的排列"><a href="#回溯-字符串的排列" class="headerlink" title="回溯: 字符串的排列"></a><a href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof">回溯: 字符串的排列</a></h1><p><img src="https://files.mdnice.com/user/1489/8984e78f-719b-4640-a513-787d3b23d9ce.jpg"></p><p><img src="https://files.mdnice.com/user/1489/a31ff962-6681-4f7c-8888-acccb902ddf6.jpg"></p><p><img src="https://files.mdnice.com/user/1489/f28df7df-9f6a-4428-8716-43437dbb7779.jpg"></p><h1 id="回溯：78-子集"><a href="#回溯：78-子集" class="headerlink" title="回溯：78. 子集"></a><a href="https://leetcode.com/problems/subsets/">回溯：78. 子集</a></h1><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3]<br>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]<br>示例 2：</p><p>输入：nums &#x3D; [0]<br>输出：[[],[0]] </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10<br>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10<br>nums 中的所有元素 互不相同</p><p><img src="https://files.mdnice.com/user/1489/f5a5009f-b372-4ff7-b09b-9fccd294c442.png"></p><h2 id="Solution1-回溯"><a href="#Solution1-回溯" class="headerlink" title="Solution1 回溯"></a>Solution1 回溯</h2><p><a href="https://leetcode.com/problems/subsets/comments/1011321">https://leetcode.com/problems/subsets/comments/1011321</a></p><p><a href="https://leetcode.com/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/">https://leetcode.com/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line">    void backtracking(vector&lt;int&gt;&amp; nums, int startIndex) &#123;</span><br><span class="line">        result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉自己</span><br><span class="line">        if (startIndex &gt;= nums.size()) &#123; // 终止条件可以不加</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = startIndex; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            path.push_back(nums[i]);</span><br><span class="line">            backtracking(nums, i + 1);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        backtracking(nums, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="回溯：-39-组合总和"><a href="#回溯：-39-组合总和" class="headerlink" title="回溯： 39. 组合总和"></a><a href="https://leetcode.com/problems/combination-sum/">回溯： 39. 组合总和</a></h1><h2 id="Solution1-暴力"><a href="#Solution1-暴力" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-回溯"><a href="#Solution2-回溯" class="headerlink" title="Solution2 回溯"></a>Solution2 回溯</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;int&gt;&amp; candidates, int target, vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt;&amp; combine, int idx) &#123;</span><br><span class="line">        if (idx == candidates.size()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (target == 0) &#123;</span><br><span class="line">            ans.emplace_back(combine);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 直接跳过</span><br><span class="line">        dfs(candidates, target, ans, combine, idx + 1);</span><br><span class="line">        // 选择当前数</span><br><span class="line">        if (target - candidates[idx] &gt;= 0) &#123;</span><br><span class="line">            combine.emplace_back(candidates[idx]);</span><br><span class="line">            dfs(candidates, target - candidates[idx], ans, combine, idx);</span><br><span class="line">            combine.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        vector&lt;int&gt; combine;</span><br><span class="line">        dfs(candidates, target, ans, combine, 0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/9949d0b3-c8b0-4e41-9117-458fa434ec6d.png"></p><p><img src="https://files.mdnice.com/user/1489/be1e0e85-5bb2-4832-8fe5-3b4aeea1ed1d.png"></p><h1 id="回溯：-40-组合总和-II"><a href="#回溯：-40-组合总和-II" class="headerlink" title="回溯： 40. 组合总和 II"></a><a href="https://leetcode.com/problems/combination-sum-ii/">回溯： 40. 组合总和 II</a></h1><h2 id="Solution1-回溯-1"><a href="#Solution1-回溯-1" class="headerlink" title="Solution1 回溯"></a>Solution1 回溯</h2><p>方法一：回溯<br>思路与算法</p><p>由于我们需要求出所有和为 \textit{target}target 的组合，并且每个数只能使用一次，因此我们可以使用递归 + 回溯的方法来解决这个问题：</p><p>我们用 \textit{dfs}(\textit{pos}, \textit{rest})dfs(pos,rest) 表示递归的函数，其中 \textit{pos}pos 表示我们当前递归到了数组 \textit{candidates}candidates 中的第 \textit{pos}pos 个数，而 \textit{rest}rest 表示我们还需要选择和为 \textit{rest}rest 的数放入列表作为一个组合；</p><p>对于当前的第 \textit{pos}pos 个数，我们有两种方法：选或者不选。如果我们选了这个数，那么我们调用 \textit{dfs}(\textit{pos} + 1, \textit{rest} - \textit{candidates}[\textit{pos}])dfs(pos+1,rest−candidates[pos]) 进行递归，注意这里必须满足 \textit{rest} \geq \textit{candidates}[\textit{pos}]rest≥candidates[pos]。如果我们不选这个数，那么我们调用 \textit{dfs}(\textit{pos} + 1, \textit{rest})dfs(pos+1,rest) 进行递归；</p><p>在某次递归开始前，如果 \textit{rest}rest 的值为 00，说明我们找到了一个和为 \textit{target}target 的组合，将其放入答案中。每次调用递归函数前，如果我们选了那个数，就需要将其放入列表的末尾，该列表中存储了我们选的所有数。在回溯时，如果我们选了那个数，就要将其从列表的末尾删除。</p><p>上述算法就是一个标准的递归 + 回溯算法，但是它并不适用于本题。这是因为题目描述中规定了解集不能包含重复的组合，而上述的算法中并没有去除重复的组合。</p><p>例如当 \textit{candidates} &#x3D; [2, 2]candidates&#x3D;[2,2]，\textit{target} &#x3D; 2target&#x3D;2 时，上述算法会将列表 [2][2] 放入答案两次。</p><p>因此，我们需要改进上述算法，在求出组合的过程中就进行去重的操作。我们可以考虑将相同的数放在一起进行处理，也就是说，如果数 \textit{x}x 出现了 yy 次，那么在递归时一次性地处理它们，即分别调用选择 0, 1, \cdots, y0,1,⋯,y 次 xx 的递归函数。这样我们就不会得到重复的组合。具体地：</p><p>我们使用一个哈希映射（HashMap）统计数组 \textit{candidates}candidates 中每个数出现的次数。在统计完成之后，我们将结果放入一个列表 \textit{freq}freq 中，方便后续的递归使用。</p><p>列表 \textit{freq}freq 的长度即为数组 \textit{candidates}candidates 中不同数的个数。其中的每一项对应着哈希映射中的一个键值对，即某个数以及它出现的次数。<br>在递归时，对于当前的第 \textit{pos}pos 个数，它的值为 \textit{freq}[\textit{pos}][0]freq[pos][0]，出现的次数为 \textit{freq}[\textit{pos}][1]freq[pos][1]，那么我们可以调用</p><p>\textit{dfs}(\textit{pos} + 1, \textit{rest} - i \times \textit{freq}[\textit{pos}][0])<br>dfs(pos+1,rest−i×freq[pos][0])</p><p>即我们选择了这个数 ii 次。这里 ii 不能大于这个数出现的次数，并且 i \times \textit{freq}[\textit{pos}][0]i×freq[pos][0] 也不能大于 \textit{rest}rest。同时，我们需要将 ii 个 \textit{freq}[\textit{pos}][0]freq[pos][0] 放入列表中。</p><p>这样一来，我们就可以不重复地枚举所有的组合了。</p><p>我们还可以进行什么优化（剪枝）呢？一种比较常用的优化方法是，我们将 \textit{freq}freq 根据数从小到大排序，这样我们在递归时会先选择小的数，再选择大的数。这样做的好处是，当我们递归到 \textit{dfs}(\textit{pos}, \textit{rest})dfs(pos,rest) 时，如果 \textit{freq}[\textit{pos}][0]freq[pos][0] 已经大于 \textit{rest}rest，那么后面还没有递归到的数也都大于 \textit{rest}rest，这就说明不可能再选择若干个和为 \textit{rest}rest 的数放入列表了。此时，我们就可以直接回溯。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; freq;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    vector&lt;int&gt; sequence;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void dfs(int pos, int rest) &#123;</span><br><span class="line">        if (rest == 0) &#123;</span><br><span class="line">            ans.push_back(sequence);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (pos == freq.size() || rest &lt; freq[pos].first) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(pos + 1, rest);</span><br><span class="line"></span><br><span class="line">        int most = min(rest / freq[pos].first, freq[pos].second);</span><br><span class="line">        for (int i = 1; i &lt;= most; ++i) &#123;</span><br><span class="line">            sequence.push_back(freq[pos].first);</span><br><span class="line">            dfs(pos + 1, rest - i * freq[pos].first);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= most; ++i) &#123;</span><br><span class="line">            sequence.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        for (int num: candidates) &#123;</span><br><span class="line">            if (freq.empty() || num != freq.back().first) &#123;</span><br><span class="line">                freq.emplace_back(num, 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ++freq.back().second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(0, target);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/b7b13ea4-d13d-4598-94ce-ec786ecf8b35.png"></p><p><img src="https://files.mdnice.com/user/1489/446d76db-4a42-44f6-a05e-c86ab53f9f3a.png"></p><p><img src="https://files.mdnice.com/user/1489/2fffdd14-ecfd-44ae-be8e-cc052773364c.png"></p><p><img src="https://files.mdnice.com/user/1489/64d338a3-86ff-4faa-bff8-1527f2709f45.png"></p><p><img src="https://files.mdnice.com/user/1489/4ac75bae-a807-4e46-b70e-041156c86e71.png"></p><p><img src="https://files.mdnice.com/user/1489/648936e5-1214-439f-9b79-8a72dd0b1b8a.png"></p><h1 id="回溯：-46-全排列"><a href="#回溯：-46-全排列" class="headerlink" title="回溯： 46. 全排列"></a><a href="https://leetcode.com/problems/permutations/">回溯： 46. 全排列</a></h1><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]<br>示例 2：</p><p>输入：nums &#x3D; [0,1]<br>输出：[[0,1],[1,0]]<br>示例 3：</p><p>输入：nums &#x3D; [1]<br>输出：[[1]] </p><h2 id="Solution1-暴力-1"><a href="#Solution1-暴力-1" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-回溯-1"><a href="#Solution2-回溯-1" class="headerlink" title="Solution2 回溯"></a>Solution2 回溯</h2><p><img src="https://files.mdnice.com/user/1489/bb3a62d2-9b82-4f3b-9ef2-3acc64df36c3.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void backtrack(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; output, int first, int len)&#123;</span><br><span class="line">        // 所有数都填完了</span><br><span class="line">        if (first == len) &#123;</span><br><span class="line">            res.emplace_back(output);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = first; i &lt; len; ++i) &#123;</span><br><span class="line">            // 动态维护数组</span><br><span class="line">            swap(output[i], output[first]);</span><br><span class="line">            // 继续递归填下一个数</span><br><span class="line">            backtrack(res, output, first + 1, len);</span><br><span class="line">            // 撤销操作</span><br><span class="line">            swap(output[i], output[first]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">        backtrack(res, nums, 0, (int)nums.size());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="回溯：22-括号生成"><a href="#回溯：22-括号生成" class="headerlink" title="回溯：22. 括号生成"></a><a href="https://leetcode.com/problems/generate-parentheses/">回溯：22. 括号生成</a></h1><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><p>示例 1：</p><p>输入：n &#x3D; 3<br>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]<br>示例 2：</p><p>输入：n &#x3D; 1<br>输出：[“()”]</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 8</p><p><img src="https://files.mdnice.com/user/1489/892e94bc-1ad6-4b50-8aab-590affd655c2.png"></p><p><img src="https://files.mdnice.com/user/1489/f18021ba-0576-4c1b-9b86-f0ef68b32522.png"></p><p><img src="https://files.mdnice.com/user/1489/7e901ea4-a7d6-452a-beab-674122765685.png"></p><p><img src="https://files.mdnice.com/user/1489/3e32c7e8-7f40-431c-9d99-b1e1f7f829ca.png"></p><p><img src="https://files.mdnice.com/user/1489/b6203b58-422b-45b9-a11e-da067cdd12be.png"></p><p><img src="https://files.mdnice.com/user/1489/f59126b1-98b9-4e33-bc6c-d259cc0f55ab.png"></p><h2 id="Solution1-暴力-2"><a href="#Solution1-暴力-2" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><p><img src="https://files.mdnice.com/user/1489/9e16db80-4a17-41b8-9d9d-cdef5be73f58.png"></p><h2 id="Solution2-递归-剪枝"><a href="#Solution2-递归-剪枝" class="headerlink" title="Solution2 递归 + 剪枝"></a>Solution2 递归 + 剪枝</h2><p><img src="https://files.mdnice.com/user/1489/10427a40-975c-4b6b-85ff-d17cc899c623.png"></p><h1 id="回溯-17-电话号码的字母组合"><a href="#回溯-17-电话号码的字母组合" class="headerlink" title="回溯: 17. 电话号码的字母组合"></a><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/">回溯: 17. 电话号码的字母组合</a></h1><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p> </p><p>示例 1：</p><p>输入：digits &#x3D; “23”<br>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]<br>示例 2：</p><p>输入：digits &#x3D; “”<br>输出：[]<br>示例 3：</p><p>输入：digits &#x3D; “2”<br>输出：[“a”,”b”,”c”] </p><p>提示：</p><p>0 &lt;&#x3D; digits.length &lt;&#x3D; 4<br>digits[i] 是范围 [‘2’, ‘9’] 的一个数字。</p><h2 id="Solution-1-暴力"><a href="#Solution-1-暴力" class="headerlink" title="Solution 1  暴力"></a>Solution 1  暴力</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Simple and efficient iterative solution.</span><br><span class="line"></span><br><span class="line">Explanation with sample input &quot;123&quot;</span><br><span class="line"></span><br><span class="line">Initial state:</span><br><span class="line"></span><br><span class="line">result = &#123;&quot;&quot;&#125;</span><br><span class="line">Stage 1 for number &quot;1&quot;:</span><br><span class="line"></span><br><span class="line">result has &#123;&quot;&quot;&#125;</span><br><span class="line">candiate is &quot;abc&quot;</span><br><span class="line">generate three strings &quot;&quot; + &quot;a&quot;, &quot;&quot;+&quot;b&quot;, &quot;&quot;+&quot;c&quot; and put into tmp,</span><br><span class="line">tmp = &#123;&quot;a&quot;, &quot;b&quot;,&quot;c&quot;&#125;</span><br><span class="line">swap result and tmp (swap does not take memory copy)</span><br><span class="line">Now result has &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</span><br><span class="line">Stage 2 for number &quot;2&quot;:</span><br><span class="line"></span><br><span class="line">result has &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</span><br><span class="line">candidate is &quot;def&quot;</span><br><span class="line">generate nine strings and put into tmp,</span><br><span class="line">&quot;a&quot; + &quot;d&quot;, &quot;a&quot;+&quot;e&quot;, &quot;a&quot;+&quot;f&quot;,</span><br><span class="line">&quot;b&quot; + &quot;d&quot;, &quot;b&quot;+&quot;e&quot;, &quot;b&quot;+&quot;f&quot;,</span><br><span class="line">&quot;c&quot; + &quot;d&quot;, &quot;c&quot;+&quot;e&quot;, &quot;c&quot;+&quot;f&quot;</span><br><span class="line">so tmp has &#123;&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot; &#125;</span><br><span class="line">swap result and tmp</span><br><span class="line">Now result has &#123;&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot; &#125;</span><br><span class="line">Stage 3 for number &quot;3&quot;:</span><br><span class="line"></span><br><span class="line">result has &#123;&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot; &#125;</span><br><span class="line">candidate is &quot;ghi&quot;</span><br><span class="line">generate 27 strings and put into tmp,</span><br><span class="line">add &quot;g&quot; for each of &quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;</span><br><span class="line">add &quot;h&quot; for each of &quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;</span><br><span class="line">add &quot;h&quot; for each of &quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;</span><br><span class="line">so, tmp has</span><br><span class="line">&#123;&quot;adg&quot;, &quot;aeg&quot;, &quot;afg&quot;, &quot;bdg&quot;, &quot;beg&quot;, &quot;bfg&quot;, &quot;cdg&quot;, &quot;ceg&quot;, &quot;cfg&quot;</span><br><span class="line">&quot;adh&quot;, &quot;aeh&quot;, &quot;afh&quot;, &quot;bdh&quot;, &quot;beh&quot;, &quot;bfh&quot;, &quot;cdh&quot;, &quot;ceh&quot;, &quot;cfh&quot;</span><br><span class="line">&quot;adi&quot;, &quot;aei&quot;, &quot;afi&quot;, &quot;bdi&quot;, &quot;bei&quot;, &quot;bfi&quot;, &quot;cdi&quot;, &quot;cei&quot;, &quot;cfi&quot; &#125;</span><br><span class="line">swap result and tmp</span><br><span class="line">Now result has</span><br><span class="line">&#123;&quot;adg&quot;, &quot;aeg&quot;, &quot;afg&quot;, &quot;bdg&quot;, &quot;beg&quot;, &quot;bfg&quot;, &quot;cdg&quot;, &quot;ceg&quot;, &quot;cfg&quot;</span><br><span class="line">&quot;adh&quot;, &quot;aeh&quot;, &quot;afh&quot;, &quot;bdh&quot;, &quot;beh&quot;, &quot;bfh&quot;, &quot;cdh&quot;, &quot;ceh&quot;, &quot;cfh&quot;</span><br><span class="line">&quot;adi&quot;, &quot;aei&quot;, &quot;afi&quot;, &quot;bdi&quot;, &quot;bei&quot;, &quot;bfi&quot;, &quot;cdi&quot;, &quot;cei&quot;, &quot;cfi&quot; &#125;</span><br><span class="line">Finally, return result.</span><br></pre></td></tr></table></figure><h2 id="Soulution-2-回溯"><a href="#Soulution-2-回溯" class="headerlink" title="Soulution 2  回溯"></a>Soulution 2  回溯</h2><p><img src="https://files.mdnice.com/user/1489/eb7c965d-59c0-4b08-8d6a-6d3943f10cf5.png"><br><img src="https://files.mdnice.com/user/1489/7821e311-00aa-40b0-8ab9-57471419d97b.png"></p><h2 id="Solution-3-队列"><a href="#Solution-3-队列" class="headerlink" title="Solution 3  队列"></a>Solution 3  队列</h2><p><img src="https://files.mdnice.com/user/1489/cd61b224-e4ae-4271-bef4-076a650f65b3.png"></p><p><img src="https://files.mdnice.com/user/1489/e078bf30-d641-4c56-b4c9-8d1da707d807.png"></p><p><img src="https://files.mdnice.com/user/1489/e4fa6f50-22c9-41c7-8f6c-e43aab780585.png"></p><h1 id="二分：0-n-1中缺失的数字"><a href="#二分：0-n-1中缺失的数字" class="headerlink" title="二分：0~n-1中缺失的数字"></a><a href="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof">二分：0~n-1中缺失的数字</a></h1><p><img src="https://files.mdnice.com/user/1489/beeb899a-9927-4525-b0d1-3d241c00ccb4.jpg"><br><img src="https://files.mdnice.com/user/1489/e1be0f97-6680-4f55-a373-3a484128fe6a.jpg"></p><h1 id="二分：162-寻找峰值"><a href="#二分：162-寻找峰值" class="headerlink" title="二分：162. 寻找峰值"></a><a href="https://leetcode.com/problems/find-peak-element/">二分：162. 寻找峰值</a></h1><p>峰值元素是指其值严格大于左右相邻值的元素。</p><p>给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</p><p>你可以假设 nums[-1] &#x3D; nums[n] &#x3D; -∞ 。</p><p>你必须实现时间复杂度为 O(log n) 的算法来解决此问题。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3,1]<br>输出：2<br>解释：3 是峰值元素，你的函数应该返回其索引 2。<br>示例 2：</p><p>输入：nums &#x3D; [1,2,1,3,5,6,4]<br>输出：1 或 5<br>解释：你的函数可以返回索引 1，其峰值元素为 2；<br>     或者返回索引 5， 其峰值元素为 6。 </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 1000<br>-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1<br>对于所有有效的 i 都有 nums[i] !&#x3D; nums[i + 1]</p><p><img src="https://files.mdnice.com/user/1489/86d145b9-6845-402d-9358-b943bffcdebc.png"></p><p><img src="https://files.mdnice.com/user/1489/f8953b4b-43ee-4d3f-a31f-82cd8b633bce.png"></p><h2 id="Solution1-暴力-3"><a href="#Solution1-暴力-3" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><p><img src="https://files.mdnice.com/user/1489/423b6ac9-a7bd-4bd4-9840-3813d62617b5.png"></p><h2 id="Solution2-二分法"><a href="#Solution2-二分法" class="headerlink" title="Solution2 二分法"></a>Solution2 二分法</h2><p><img src="https://files.mdnice.com/user/1489/ec008965-da09-4c78-9ad1-83de91a31f4c.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int findPeakElement(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int left = 0, right = nums.size() - 1;</span><br><span class="line">    while (left &lt; right ) &#123;</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if (nums[mid] &lt; nums[mid + 1]) &#123;</span><br><span class="line">            left = mid+1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right = mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分-旋转数组的最小数字"><a href="#二分-旋转数组的最小数字" class="headerlink" title="二分: 旋转数组的最小数字"></a><a href="https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof">二分: 旋转数组的最小数字</a></h1><p><img src="https://files.mdnice.com/user/1489/ae78465c-a8c5-4cb3-9bc4-cc6a7f3f1498.jpg"><br><img src="https://files.mdnice.com/user/1489/e7e675f6-8b74-4492-a32d-b6c704015af1.jpg"></p><h1 id="二分：33-搜索旋转排序数组"><a href="#二分：33-搜索旋转排序数组" class="headerlink" title="二分：33. 搜索旋转排序数组"></a><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">二分：33. 搜索旋转排序数组</a></h1><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0<br>输出：4<br>示例 2：</p><p>输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3<br>输出：-1<br>示例 3：</p><p>输入：nums &#x3D; [1], target &#x3D; 0<br>输出：-1 </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 5000<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>nums 中的每个值都 独一无二<br>题目数据保证 nums 在预先未知的某个下标上进行了旋转<br>-104 &lt;&#x3D; target &lt;&#x3D; 104</p><h2 id="Solution1-暴力-4"><a href="#Solution1-暴力-4" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-二分查找"><a href="#Solution2-二分查找" class="headerlink" title="Solution2 二分查找"></a>Solution2 二分查找</h2><p><img src="https://files.mdnice.com/user/1489/60ec6cc2-9148-40df-ad8e-2969def89c43.png"></p><p><img src="https://files.mdnice.com/user/1489/a5922411-7a62-4a02-8d89-737ddad9f426.png"></p><h1 id="二分：34-在排序数组中查找元素的第一个和最后一个位置"><a href="#二分：34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="二分：34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">二分：34. 在排序数组中查找元素的第一个和最后一个位置</a></h1><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8<br>输出：[3,4]<br>示例 2：</p><p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6<br>输出：[-1,-1]<br>示例 3：</p><p>输入：nums &#x3D; [], target &#x3D; 0<br>输出：[-1,-1] </p><p>提示：</p><p>0 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>nums 是一个非递减数组<br>-109 &lt;&#x3D; target &lt;&#x3D; 109</p><h2 id="Solution1-暴力-5"><a href="#Solution1-暴力-5" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-二分"><a href="#Solution2-二分" class="headerlink" title="Solution2 二分"></a>Solution2 二分</h2><p><img src="https://files.mdnice.com/user/1489/d207a0eb-649a-47c3-94d2-ae381b200eaa.png"></p><p><img src="https://files.mdnice.com/user/1489/3a8da8b9-8e2a-4d67-9b85-61f5438d72f7.png"></p><p>二分搜索讲解<br><a href="https://www.bilibili.com/video/BV1fA4y1o715?spm_id_from=0.0.header_right.history_list.click">https://www.bilibili.com/video/BV1fA4y1o715?spm_id_from=0.0.header_right.history_list.click</a></p><p>寻找target在数组里的左右边界，有如下三种情况：</p><ul><li>情况一：target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1}</li><li>情况二：target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1}</li><li>情况三：target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{1, 1}</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int leftBorder = getLeftBorder(nums, target);</span><br><span class="line">        int rightBorder = getRightBorder(nums, target);</span><br><span class="line">        // 情况一</span><br><span class="line">        if (leftBorder == -2 || rightBorder == -2) return &#123;-1, -1&#125;;</span><br><span class="line">        // 情况三</span><br><span class="line">        if (rightBorder - leftBorder &gt; 1) return &#123;leftBorder + 1, rightBorder - 1&#125;;</span><br><span class="line">        // 情况二</span><br><span class="line">        return &#123;-1, -1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">     int getRightBorder(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.size() - 1;</span><br><span class="line">        int rightBorder = -2; // 记录一下rightBorder没有被赋值的情况</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int middle = left + ((right - left) / 2);</span><br><span class="line">            if (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - 1;</span><br><span class="line">            &#125; else &#123; // 寻找右边界，nums[middle] == target的时候更新left</span><br><span class="line">                left = middle + 1;</span><br><span class="line">                rightBorder = left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rightBorder;</span><br><span class="line">    &#125;</span><br><span class="line">    int getLeftBorder(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.size() - 1;</span><br><span class="line">        int leftBorder = -2; // 记录一下leftBorder没有被赋值的情况</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int middle = left + ((right - left) / 2);</span><br><span class="line">            if (nums[middle] &gt;= target) &#123; // 寻找左边界，nums[middle] == target的时候更新right</span><br><span class="line">                right = middle - 1;</span><br><span class="line">                leftBorder = right;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left = middle + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return leftBorder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二分：-35-搜索插入位置"><a href="#二分：-35-搜索插入位置" class="headerlink" title="二分： 35. 搜索插入位置"></a><a href="https://leetcode.cn/problems/search-insert-position/">二分： 35. 搜索插入位置</a></h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><p> </p><p>示例 1:</p><p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 5<br>输出: 2<br>示例 2:</p><p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 2<br>输出: 1<br>示例 3:</p><p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 7<br>输出: 4</p><h2 id="Solution1-暴力-6"><a href="#Solution1-暴力-6" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int searchInsert(int[] nums, int target) &#123;</span><br><span class="line">    for(int i = 0; i &lt; nums.length;i++)&#123;</span><br><span class="line">        if(nums[i] &gt;= target)&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Solution2-二分-1"><a href="#Solution2-二分-1" class="headerlink" title="Solution2 二分"></a>Solution2 二分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = n; // 定义target在左闭右开的区间里，[left, right)  target</span><br><span class="line">        while (left &lt; right) &#123; // 因为left == right的时候，在[left, right)是无效的空间</span><br><span class="line">            int middle = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">            if (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle; // target 在左区间，在[left, middle)中</span><br><span class="line">            &#125; else if (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + 1; // target 在右区间，在 [middle+1, right)中</span><br><span class="line">            &#125; else &#123; // nums[middle] == target</span><br><span class="line">                return middle; // 数组中找到目标值的情况，直接返回下标</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 分别处理如下四种情况</span><br><span class="line">        // 目标值在数组所有元素之前 [0,0)</span><br><span class="line">        // 目标值等于数组中某一个元素 return middle</span><br><span class="line">        // 目标值插入数组中的位置 [left, right) ，return right 即可</span><br><span class="line">        // 目标值在数组所有元素之后的情况 [left, right)，这是右开区间，return right 即可</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二分：69-x-的平方根"><a href="#二分：69-x-的平方根" class="headerlink" title="二分：69. x 的平方根 "></a><a href="https://leetcode.com/problems/sqrtx/">二分：69. x 的平方根 </a></h1><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p><p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p><p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p><p> </p><p>示例 1：</p><p>输入：x &#x3D; 4<br>输出：2<br>示例 2：</p><p>输入：x &#x3D; 8<br>输出：2<br>解释：8 的算术平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。 </p><p>提示：</p><p>0 &lt;&#x3D; x &lt;&#x3D; 231 - 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Time Complexity: O(logn) | due to binary search using while loop.</span><br><span class="line">Space Complexity: O(1) | as only 4 variables are initialized at the beginning. Which is constant irrespective of given input.</span><br><span class="line"></span><br><span class="line">long long s=0, e=x, ans, mid;   //long long due to some of test cases overflows integer limit.</span><br><span class="line">        while(s&lt;=e)&#123;             </span><br><span class="line">            mid=(s+e)/2;</span><br><span class="line">            if(mid*mid==x) return mid;     //if the &#x27;mid&#x27; value ever gives the result, we simply return it.</span><br><span class="line">            else if(mid*mid&lt;x)&#123;             </span><br><span class="line">                s=mid+1;        //if &#x27;mid&#x27; value encounterted gives lower result, we simply discard all the values lower than mid.</span><br><span class="line">                ans=mid;        //an extra pointer &#x27;ans&#x27; is maintained to keep track of only lowest &#x27;mid&#x27; value. </span><br><span class="line">            &#125;</span><br><span class="line">            else e=mid-1;       //if &#x27;mid&#x27; value encountered gives greater result, we simply discard all the values greater than mid. </span><br><span class="line">        &#125;</span><br><span class="line">        return ans;   </span><br></pre></td></tr></table></figure><h2 id="Solution1-暴力-7"><a href="#Solution1-暴力-7" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-二分搜索"><a href="#Solution2-二分搜索" class="headerlink" title="Solution2 二分搜索"></a>Solution2 二分搜索</h2><p><img src="https://files.mdnice.com/user/1489/19d7f700-92c7-4591-bef6-efe163c000f3.png"></p><h1 id="：287-寻找重复数"><a href="#：287-寻找重复数" class="headerlink" title="：287. 寻找重复数"></a><a href="https://leetcode.com/problems/find-the-duplicate-number/">：287. 寻找重复数</a></h1><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</p><p>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</p><p>你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [1,3,4,2,2]<br>输出：2<br>示例 2：</p><p>输入：nums &#x3D; [3,1,3,4,2]<br>输出：3 </p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 105<br>nums.length &#x3D;&#x3D; n + 1<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; n<br>nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次 </p><p>进阶：</p><p>如何证明 nums 中至少存在一个重复的数字?<br>你可以设计一个线性级时间复杂度 O(n) 的解决方案吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">Overview</span><br><span class="line">Finding the Duplicate Number is a classic problem, and as such there are many different ways to approach it; a total of 7 approaches are presented here. The first 4 approaches involve rearranging or modifying elements of the array, and hence do not meet the constraints specified in the problem statement. However, they are included here since they are more feasible to come up with as the first approach in an interview setting. Since each approach is independent of the other approaches, they can be read in any order.</span><br><span class="line"></span><br><span class="line">Proof</span><br><span class="line">Proving that at least one duplicate must exist in numsnums is an application of the pigeonhole principle. Here, each number in numsnums is a &quot;pigeon&quot; and each distinct number that can appear in numsnums is a &quot;pigeonhole.&quot; Because there are n+1n+1 numbers and nn distinct possible numbers, the pigeonhole principle implies that if you were to put each of the n + 1n+1 pigeons into nn pigeonholes, at least one of the pigeonholes would have 2 or more pigeons.</span><br><span class="line"></span><br><span class="line">Approach 1: Sort</span><br><span class="line">Note: This approach modifies individual elements and does not use constant space, and hence does not meet the problem constraints. However, it utilizes a fundamental concept that can help solve similar problems.</span><br><span class="line"></span><br><span class="line">Intuition</span><br><span class="line"></span><br><span class="line">In an unsorted array, duplicate elements may be scattered across the array. However, in a sorted array, duplicate numbers will be next to each other.</span><br><span class="line"></span><br><span class="line">Algorithm</span><br><span class="line"></span><br><span class="line">Sort the input array (numsnums).</span><br><span class="line"></span><br><span class="line">Iterate through the array, comparing the current number to the previous number (i.e. compare nums[i]nums[i] to nums[i - 1]nums[i−1] where i &gt; 0i&gt;0).</span><br><span class="line"></span><br><span class="line">Return the first number that is equal to its predecessor.</span><br><span class="line">Complexity Analysis</span><br><span class="line"></span><br><span class="line">Time Complexity: O(n \log n)O(nlogn)</span><br><span class="line"></span><br><span class="line">Sorting takes O(n \log n)O(nlogn) time. This is followed by a linear scan, resulting in a total of O(n \log n)O(nlogn) + O(n)O(n) = O(n \log n)O(nlogn) time.</span><br><span class="line"></span><br><span class="line">Space Complexity: O(\log n)O(logn) or O(n)O(n)</span><br><span class="line"></span><br><span class="line">The space complexity of the sorting algorithm depends on the implementation of each programming language:</span><br><span class="line"></span><br><span class="line">In Java, Arrays.sort() for primitives is implemented using a variant of the Quick Sort algorithm, which has a space complexity of O(\log n)O(logn)</span><br><span class="line">In C++, the sort() function provided by STL uses a hybrid of Quick Sort, Heap Sort and Insertion Sort, with a worst case space complexity of O(\log n)O(logn)</span><br><span class="line">In Python, the sort() function is implemented using the Timsort algorithm, which has a worst-case space complexity of O(n)O(n)</span><br><span class="line">Approach 2: Set</span><br><span class="line">Note: This approach does not use constant space, and hence does not meet the problem constraints. However, it utilizes a fundamental concept that can help solve similar problems.</span><br><span class="line"></span><br><span class="line">Intuition</span><br><span class="line"></span><br><span class="line">As we traverse the array, we need a way to &quot;remember&quot; values that we&#x27;ve seen. If we come across a number that we&#x27;ve seen before, we&#x27;ve found the duplicate. An efficient way to record the seen values is by adding each number to a set as we iterate over the numsnums array.</span><br><span class="line"></span><br><span class="line">Algorithm</span><br><span class="line"></span><br><span class="line">In order to achieve linear time complexity, we need to be able to insert elements into a data structure and look them up in constant time. A HashSet/unordered_set is well suited for this purpose. Initialize an empty hashset, seenseen.</span><br><span class="line"></span><br><span class="line">Iterate over the array and first check if the current element exists in the hashset (seenseen).</span><br><span class="line"></span><br><span class="line">If it does exist in the hashset, that number is the duplicate and can be returned right away.</span><br><span class="line">Otherwise, insert the current element into seenseen, move to the next element in the array and repeat step 2.</span><br><span class="line"></span><br><span class="line">Complexity Analysis</span><br><span class="line"></span><br><span class="line">Time Complexity: O(n)O(n)</span><br><span class="line"></span><br><span class="line">HashSet insertions and lookups have amortized constant time complexities. Hence, this algorithm requires linear time, since it consists of a single for loop that iterates over each element, looking up the element and inserting it into the set at most once.</span><br><span class="line"></span><br><span class="line">Space Complexity: O(n)O(n)</span><br><span class="line"></span><br><span class="line">We use a set that may need to store at most nn elements, leading to a linear space complexity of O(n)O(n).</span><br></pre></td></tr></table></figure><h2 id="Solution1-二分法"><a href="#Solution1-二分法" class="headerlink" title="Solution1 二分法"></a>Solution1 二分法</h2><p><img src="https://files.mdnice.com/user/1489/0c2f4579-0b43-40cb-9b3d-8acd25411140.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int l = 1, r = n - 1, ans = -1;</span><br><span class="line">        while (l &lt;= r) &#123;</span><br><span class="line">            int mid = (l + r) &gt;&gt; 1;</span><br><span class="line">            int cnt = 0;</span><br><span class="line">            for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">                cnt += nums[i] &lt;= mid;</span><br><span class="line">            &#125;</span><br><span class="line">            if (cnt &lt;= mid) &#123;</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                r = mid - 1;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution2-二进制"><a href="#Solution2-二进制" class="headerlink" title="Solution2 二进制"></a>Solution2 二进制</h2><p><img src="https://files.mdnice.com/user/1489/6a5118f3-ceff-4fd5-bed5-37e3eb1d1d63.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size(), ans = 0;</span><br><span class="line">        // 确定二进制下最高位是多少</span><br><span class="line">        int bit_max = 31;</span><br><span class="line">        while (!((n - 1) &gt;&gt; bit_max)) &#123;</span><br><span class="line">            bit_max -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int bit = 0; bit &lt;= bit_max; ++bit) &#123;</span><br><span class="line">            int x = 0, y = 0;</span><br><span class="line">            for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">                if (nums[i] &amp; (1 &lt;&lt; bit)) &#123;</span><br><span class="line">                    x += 1;</span><br><span class="line">                &#125;</span><br><span class="line">                if (i &gt;= 1 &amp;&amp; (i &amp; (1 &lt;&lt; bit))) &#123;</span><br><span class="line">                    y += 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (x &gt; y) &#123;</span><br><span class="line">                ans |= 1 &lt;&lt; bit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution3-快慢指针"><a href="#Solution3-快慢指针" class="headerlink" title="Solution3 快慢指针"></a>Solution3 快慢指针</h2><p><img src="https://files.mdnice.com/user/1489/403a3990-3546-4736-98f7-813c0e0093b9.png"></p><p><img src="https://files.mdnice.com/user/1489/684b77e1-27e3-43d2-9fd1-52958d131620.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findDuplicate(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int slow = 0, fast = 0;</span><br><span class="line">        do &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125; while (slow != fast);</span><br><span class="line">        slow = 0;</span><br><span class="line">        while (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="动态规划：53-最大子数组和"><a href="#动态规划：53-最大子数组和" class="headerlink" title="动态规划：53. 最大子数组和"></a><a href="https://leetcode.com/problems/maximum-subarray/">动态规划：53. 最大子数组和</a></h1><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组 是数组中的一个连续部分。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。<br>示例 2：</p><p>输入：nums &#x3D; [1]<br>输出：1<br>示例 3：</p><p>输入：nums &#x3D; [5,4,-1,7,8]<br>输出：23 </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104 </p><h2 id="Solution1-暴力-8"><a href="#Solution1-暴力-8" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-动态规划"><a href="#Solution2-动态规划" class="headerlink" title="Solution2 动态规划"></a>Solution2 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/5f787c97-ba90-4805-a6d6-b04d9f9c957c.png"></p><p><img src="https://files.mdnice.com/user/1489/8a4705a4-439c-4262-bdce-8186ee916289.png"></p><p><img src="https://files.mdnice.com/user/1489/5700074e-68cb-427a-9e58-a1858ab736e1.png"></p><h2 id="Solution3-分治"><a href="#Solution3-分治" class="headerlink" title="Solution3 分治"></a>Solution3 分治</h2><p><img src="https://files.mdnice.com/user/1489/82c123a3-94d3-4b42-8966-eeb5964b1047.png"></p><h1 id="动态规划：62-不同路径"><a href="#动态规划：62-不同路径" class="headerlink" title="动态规划：62. 不同路径"></a><a href="https://leetcode.com/problems/unique-paths/">动态规划：62. 不同路径</a></h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p> </p><p>示例 1：</p><p>输入：m &#x3D; 3, n &#x3D; 7<br>输出：28<br>示例 2：</p><p>输入：m &#x3D; 3, n &#x3D; 2<br>输出：3<br>解释：<br>从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li>向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向下<br>示例 3：</li></ol><p>输入：m &#x3D; 7, n &#x3D; 3<br>输出：28<br>示例 4：</p><p>输入：m &#x3D; 3, n &#x3D; 3<br>输出：6 </p><p>提示：</p><p>1 &lt;&#x3D; m, n &lt;&#x3D; 100<br>题目数据保证答案小于等于 2 * 109</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Since the robot can only move right and down, when it arrives at a point, it either arrives from left or above. If we use dp[i][j] for the number of unique paths to arrive at the point (i, j), then the state equation is dp[i][j] = dp[i][j - 1] + dp[i - 1][j]. Moreover, we have the base cases dp[0][j] = dp[i][0] = 1 for all valid i and j.</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 1));</span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">The above solution runs in O(m * n) time and costs O(m * n) space. However, you may have noticed that each time when we update dp[i][j], we only need dp[i - 1][j] (at the previous row) and dp[i][j - 1] (at the current row). So we can reduce the memory usage to just two rows (O(n)).</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        vector&lt;int&gt; pre(n, 1), cur(n, 1);</span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">                cur[j] = pre[j] + cur[j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">            swap(pre, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        return pre[n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Further inspecting the above code, pre[j] is just the cur[j] before the update. So we can further reduce the memory usage to one row.</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        vector&lt;int&gt; cur(n, 1);</span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">                cur[j] += cur[j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur[n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Now, you may wonder whether we can further reduce the memory usage to just O(1) space since the above code seems to use only two variables (cur[j] and cur[j - 1]). However, since the whole row cur needs to be updated for m - 1 times (the outer loop) based on old values, all of its values need to be saved and thus O(1)-space is impossible. However, if you are having a DP problem without the outer loop and just the inner one, then it will be possible.</span><br></pre></td></tr></table></figure><h2 id="Solution1-排列组合"><a href="#Solution1-排列组合" class="headerlink" title="Solution1 排列组合"></a>Solution1 排列组合</h2><p><img src="https://files.mdnice.com/user/1489/4a4d21b3-ff48-457a-a612-9723074e0647.png"></p><h2 id="Solution2-动态规划-1"><a href="#Solution2-动态规划-1" class="headerlink" title="Solution2 动态规划"></a>Solution2 动态规划</h2><p>我们令 dp[i][j] 是到达 i, j 最多路径</p><p>动态方程：dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1]</p><p>注意，对于第一行 dp[0][j]，或者第一列 dp[i][0]，由于都是在边界，所以只能为 1</p><p>时间复杂度：O(m*n)O(m∗n)</p><p>空间复杂度：O(m * n)O(m∗n)</p><p>优化：因为我们每次只需要 dp[i-1][j],dp[i][j-1]</p><p>所以我们只要记录这两个数，直接看代码吧！</p><p>思路二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[][] dp = new int[m][n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) dp[0][i] = 1;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) dp[i][0] = 1;</span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m - 1][n - 1];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化1：空间复杂度 O(2n)O(2n)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[] pre = new int[n];</span><br><span class="line">        int[] cur = new int[n];</span><br><span class="line">        Arrays.fill(pre, 1);</span><br><span class="line">        Arrays.fill(cur,1);</span><br><span class="line">        for (int i = 1; i &lt; m;i++)&#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++)&#123;</span><br><span class="line">                cur[j] = cur[j-1] + pre[j];</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        return pre[n-1]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化2：空间复杂度 O(n)O(n)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[] cur = new int[n];</span><br><span class="line">        Arrays.fill(cur,1);</span><br><span class="line">        for (int i = 1; i &lt; m;i++)&#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++)&#123;</span><br><span class="line">                cur[j] += cur[j-1] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur[n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态规划：64-最小路径和"><a href="#动态规划：64-最小路径和" class="headerlink" title="动态规划：64. 最小路径和"></a><a href="https://leetcode.com/problems/minimum-path-sum/">动态规划：64. 最小路径和</a></h1><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p> </p><p>示例 1：</p><p>输入：grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。<br>示例 2：</p><p>输入：grid &#x3D; [[1,2,3],[4,5,6]]<br>输出：12 </p><p>提示：</p><p>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 200<br>0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 100</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">his is a typical DP problem. Suppose the minimum path sum of arriving at point (i, j) is S[i][j], then the state equation is S[i][j] = min(S[i - 1][j], S[i][j - 1]) + grid[i][j].</span><br><span class="line"></span><br><span class="line">Well, some boundary conditions need to be handled. The boundary conditions happen on the topmost row (S[i - 1][j] does not exist) and the leftmost column (S[i][j - 1] does not exist). Suppose grid is like [1, 1, 1, 1], then the minimum sum to arrive at each point is simply an accumulation of previous points and the result is [1, 2, 3, 4].</span><br><span class="line"></span><br><span class="line">Now we can write down the following (unoptimized) code.</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int m = grid.size();</span><br><span class="line">        int n = grid[0].size(); </span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; sum(m, vector&lt;int&gt;(n, grid[0][0]));</span><br><span class="line">        for (int i = 1; i &lt; m; i++)</span><br><span class="line">            sum[i][0] = sum[i - 1][0] + grid[i][0];</span><br><span class="line">        for (int j = 1; j &lt; n; j++)</span><br><span class="line">            sum[0][j] = sum[0][j - 1] + grid[0][j];</span><br><span class="line">        for (int i = 1; i &lt; m; i++)</span><br><span class="line">            for (int j = 1; j &lt; n; j++)</span><br><span class="line">                sum[i][j]  = min(sum[i - 1][j], sum[i][j - 1]) + grid[i][j];</span><br><span class="line">        return sum[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">As can be seen, each time when we update sum[i][j], we only need sum[i - 1][j] (at the current column) and sum[i][j - 1] (at the left column). So we need not maintain the full m*n matrix. Maintaining two columns is enough and now we have the following code.</span><br></pre></td></tr></table></figure><h2 id="Solution0-暴力"><a href="#Solution0-暴力" class="headerlink" title="Solution0 暴力"></a>Solution0 暴力</h2><h2 id="Solution1-动态规划"><a href="#Solution1-动态规划" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/5984996e-8148-4ae1-8ed9-8198e3625d2f.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minPathSum(int[][] grid) &#123;</span><br><span class="line">        for(int i = 0; i &lt; grid.length; i++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; grid[0].length; j++) &#123;</span><br><span class="line">                if(i == 0 &amp;&amp; j == 0) continue;</span><br><span class="line">                else if(i == 0)  grid[i][j] = grid[i][j - 1] + grid[i][j];</span><br><span class="line">                else if(j == 0)  grid[i][j] = grid[i - 1][j] + grid[i][j];</span><br><span class="line">                else grid[i][j] = Math.min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return grid[grid.length - 1][grid[0].length - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="动态规划：70-爬楼梯"><a href="#动态规划：70-爬楼梯" class="headerlink" title="动态规划：70. 爬楼梯"></a><a href="https://leetcode.com/problems/climbing-stairs/">动态规划：70. 爬楼梯</a></h1><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p> </p><p>示例 1：</p><p>输入：n &#x3D; 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li>2 阶<br>示例 2：</li></ol><p>输入：n &#x3D; 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol><p> </p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 45</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">The problem seems to be a dynamic programming one. Hint: the tag also suggests that!</span><br><span class="line">Here are the steps to get the solution incrementally.</span><br><span class="line"></span><br><span class="line">Base cases:</span><br><span class="line">if n &lt;= 0, then the number of ways should be zero.</span><br><span class="line">if n == 1, then there is only way to climb the stair.</span><br><span class="line">if n == 2, then there are two ways to climb the stairs. One solution is one step by another; the other one is two steps at one time.</span><br><span class="line"></span><br><span class="line">The key intuition to solve the problem is that given a number of stairs n, if we know the number ways to get to the points [n-1] and [n-2] respectively, denoted as n1 and n2 , then the total ways to get to the point [n] is n1 + n2. Because from the [n-1] point, we can take one single step to reach [n]. And from the [n-2] point, we could take two steps to get there.</span><br><span class="line"></span><br><span class="line">The solutions calculated by the above approach are complete and non-redundant. The two solution sets (n1 and n2) cover all the possible cases on how the final step is taken. And there would be NO overlapping among the final solutions constructed from these two solution sets, because they differ in the final step.</span><br><span class="line"></span><br><span class="line">Now given the above intuition, one can construct an array where each node stores the solution for each number n. Or if we look at it closer, it is clear that this is basically a fibonacci number, with the starting numbers as 1 and 2, instead of 1 and 1.</span><br></pre></td></tr></table></figure><h2 id="Solution1-递归"><a href="#Solution1-递归" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">      int dp0=1;</span><br><span class="line">       int dp1=1;</span><br><span class="line">        for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">            int tmp=dp0;</span><br><span class="line">            dp0=dp1;</span><br><span class="line">            dp1=tmp+dp1;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp1;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="动态规划-91-解码方法"><a href="#动态规划-91-解码方法" class="headerlink" title="动态规划 91. 解码方法"></a><a href="https://leetcode.com/problems/decode-ways/">动态规划 91. 解码方法</a></h1><p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p><p>‘A’ -&gt; “1”<br>‘B’ -&gt; “2”<br>…<br>‘Z’ -&gt; “26”<br>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p><p>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)<br>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p><p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p><p>题目数据保证答案肯定是一个 32 位 的整数。</p><p> </p><p>示例 1：</p><p>输入：s &#x3D; “12”<br>输出：2<br>解释：它可以解码为 “AB”（1 2）或者 “L”（12）。<br>示例 2：</p><p>输入：s &#x3D; “226”<br>输出：3<br>解释：它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。<br>示例 3：</p><p>输入：s &#x3D; “0”<br>输出：0<br>解释：没有字符映射到以 0 开头的数字。<br>含有 0 的有效映射是 ‘J’ -&gt; “10” 和 ‘T’-&gt; “20” 。<br>由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。 </p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 100<br>s 只包含数字，并且可能包含前导零。<br>通过次数235,094提交次数721,617</p><p><img src="https://files.mdnice.com/user/1489/2a2a7ca4-66f7-4eb4-b733-68a3f4238ee1.png"></p><p><img src="https://files.mdnice.com/user/1489/7a667e7d-fb86-49d5-9c3a-bafcc9e7b164.png"></p><h2 id="Solution1-动态规划-1"><a href="#Solution1-动态规划-1" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/707aac6e-eec8-4f5a-8f0f-b7b45d344451.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numDecodings(string s) &#123;</span><br><span class="line">        if (s[0] == &#x27;0&#x27;) return 0;</span><br><span class="line">        vector&lt;int&gt; dp(s.size()+1);</span><br><span class="line">        dp[0]=1;dp[1]=1;</span><br><span class="line">        for (int i =1; i &lt; s.size(); i++) &#123;</span><br><span class="line">            if (s[i] == &#x27;0&#x27;)//1.s[i]为0的情况</span><br><span class="line">                if (s[i - 1] == &#x27;1&#x27; || s[i - 1] == &#x27;2&#x27;) //s[i - 1]等于1或2的情况</span><br><span class="line">                    dp[i+1] = dp[i-1];//由于s[1]指第二个下标，对应为dp[2],所以dp的下标要比s大1，故为dp[i+1]</span><br><span class="line">                else </span><br><span class="line">                    return 0;</span><br><span class="line">            else //2.s[i]不为0的情况</span><br><span class="line">                if (s[i - 1] == &#x27;1&#x27; || (s[i - 1] == &#x27;2&#x27; &amp;&amp; s[i] &lt;= &#x27;6&#x27;))//s[i-1]s[i]两位数要小于26的情况</span><br><span class="line">                    dp[i+1] = dp[i]+dp[i-1];</span><br><span class="line">                else//其他情况</span><br><span class="line">                    dp[i+1] = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution2-动态规划-空间复杂度优化为O-1"><a href="#Solution2-动态规划-空间复杂度优化为O-1" class="headerlink" title="Solution2 动态规划 空间复杂度优化为O(1)"></a>Solution2 动态规划 空间复杂度优化为O(1)</h2><p><img src="https://files.mdnice.com/user/1489/ebc2117f-b989-4c3d-b852-4b2b26c77453.png"></p><h1 id="树-x2F-动态规划：-96-不同的二叉搜索树"><a href="#树-x2F-动态规划：-96-不同的二叉搜索树" class="headerlink" title="树&#x2F;动态规划： 96. 不同的二叉搜索树"></a><a href="https://leetcode.com/problems/unique-binary-search-trees/">树&#x2F;动态规划： 96. 不同的二叉搜索树</a></h1><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p><p> </p><p>示例 1：</p><p>输入：n &#x3D; 3<br>输出：5<br>示例 2：</p><p>输入：n &#x3D; 1<br>输出：1 </p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 19</p><p><img src="https://files.mdnice.com/user/1489/e18c6e12-5f03-4540-b1ed-23f59e1d2c55.png"></p><p><img src="https://files.mdnice.com/user/1489/2d101957-45f0-493d-9bc6-ab743496916e.png"></p><p><img src="https://files.mdnice.com/user/1489/d775142c-564b-4176-a366-0baecb016c91.png"></p><h2 id="Solution1-动态规划-2"><a href="#Solution1-动态规划-2" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p>结题思路：假设n个节点存在二叉排序树的个数是G(n)，1为根节点，2为根节点，…，n为根节点，<br>当1为根节点时，其左子树节点个数为0，右子树节点个数为n-1，<br>同理当2为根节点时，其左子树节点个数为1，右子树节点为n-2，<br>所以可得G(n) &#x3D; G(0)<em>G(n-1)+G(1)</em>(n-2)+…+G(n-1)*G(0)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numTrees(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n + 1);</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j - 1] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="动态规划：121-买卖股票的最佳时机"><a href="#动态规划：121-买卖股票的最佳时机" class="headerlink" title="动态规划：121. 买卖股票的最佳时机"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">动态规划：121. 买卖股票的最佳时机</a></h1><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p> </p><p>示例 1：</p><p>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。<br>     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br>示例 2：</p><p>输入：prices &#x3D; [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 </p><p>提示：</p><p>1 &lt;&#x3D; prices.length &lt;&#x3D; 105<br>0 &lt;&#x3D; prices[i] &lt;&#x3D; 104</p><p><img src="https://files.mdnice.com/user/1489/69a37149-f011-4fef-9a55-272abfbc9b68.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">I hope now question, approach is absolute clear.</span><br><span class="line"></span><br><span class="line">code each line explained : Similar for C++, Java</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">        int lsf = Integer.MAX_VALUE; // least so far</span><br><span class="line">        int op = 0; // overall profit</span><br><span class="line">        int pist = 0; // profit if sold today</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; prices.length; i++)&#123;</span><br><span class="line">            if(prices[i] &lt; lsf)&#123; // if we found new buy value which is more smaller then previous one</span><br><span class="line">                lsf = prices[i]; // update our least so far</span><br><span class="line">            &#125;</span><br><span class="line">            pist = prices[i] - lsf; // calculating profit if sold today by, Buy - sell</span><br><span class="line">            if(op &lt; pist)&#123; // if pist is more then our previous overall profit</span><br><span class="line">                op = pist; // update overall profit</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return op; // return op </span><br></pre></td></tr></table></figure><h2 id="Solution0-暴力解法"><a href="#Solution0-暴力解法" class="headerlink" title="Solution0 暴力解法"></a>Solution0 暴力解法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int n = (int)prices.size(), ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            for (int j = i + 1; j &lt; n; ++j) &#123;</span><br><span class="line">                ans = max(ans, prices[j] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution1-动态规划-3"><a href="#Solution1-动态规划-3" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p>动态规划 前i天的最大收益 &#x3D; max{前i-1天的最大收益，第i天的价格-前i-1天中的最小价格}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        if(prices.length &lt;= 1)</span><br><span class="line">            return 0;</span><br><span class="line">        int min = prices[0], max = 0;</span><br><span class="line">        for(int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, prices[i] - min);</span><br><span class="line">            min = Math.min(min, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态规划：122-买卖股票的最佳时机-II"><a href="#动态规划：122-买卖股票的最佳时机-II" class="headerlink" title="动态规划：122. 买卖股票的最佳时机 II"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">动态规划：122. 买卖股票的最佳时机 II</a></h1><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p><p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p><p>返回 你能获得的 最大 利润 。</p><p> </p><p>示例 1：</p><p>输入：prices &#x3D; [7,1,5,3,6,4]<br>输出：7<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。<br>     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6 - 3 &#x3D; 3 。<br>     总利润为 4 + 3 &#x3D; 7 。<br>示例 2：</p><p>输入：prices &#x3D; [1,2,3,4,5]<br>输出：4<br>解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。<br>     总利润为 4 。<br>示例 3：</p><p>输入：prices &#x3D; [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。 </p><p>提示：</p><p>1 &lt;&#x3D; prices.length &lt;&#x3D; 3 * 104<br>0 &lt;&#x3D; prices[i] &lt;&#x3D; 104</p><p><img src="https://files.mdnice.com/user/1489/9ffae3b2-d6d0-4698-add8-49795aaafaf1.png"></p><h2 id="Solution1-贪心算法"><a href="#Solution1-贪心算法" class="headerlink" title="Solution1 贪心算法"></a>Solution1 贪心算法</h2><p><img src="https://files.mdnice.com/user/1489/5536a636-d181-42b9-a760-57aff155691a.png"></p><h2 id="Solution2-动态规划-2"><a href="#Solution2-动态规划-2" class="headerlink" title="Solution2 动态规划"></a>Solution2 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/9d910293-a6c0-4c4b-bfd8-c8e32fae01e8.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int [] dp = new int [prices.length+1];//这里从第0天开始，到底i天</span><br><span class="line">        dp[0] = 0;//第0天没有股票，最大利润为0</span><br><span class="line">        dp[1] = 0;//第一天只能买，不能买，因此最大利润也是0</span><br><span class="line">        for(int i = 1;i&lt;prices.length;i++)&#123;</span><br><span class="line">            int A =dp[i]+prices[i]-prices[i-1];//第一种选择</span><br><span class="line">            int B = dp[i];//第二种选择</span><br><span class="line">            dp[i+1] = A&gt;B ? A : B;//i从0开始，所以dp[I＋1]是当前天数 </span><br><span class="line">        &#125;</span><br><span class="line">        return dp[prices.length];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="动态规划：139-单词拆分"><a href="#动态规划：139-单词拆分" class="headerlink" title="动态规划：139. 单词拆分"></a><a href="https://leetcode.com/problems/word-break/">动态规划：139. 单词拆分</a></h1><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</p><p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p> </p><p>示例 1：</p><p>输入: s &#x3D; “leetcode”, wordDict &#x3D; [“leet”, “code”]<br>输出: true<br>解释: 返回 true 因为 “leetcode” 可以由 “leet” 和 “code” 拼接成。<br>示例 2：</p><p>输入: s &#x3D; “applepenapple”, wordDict &#x3D; [“apple”, “pen”]<br>输出: true<br>解释: 返回 true 因为 “applepenapple” 可以由 “apple” “pen” “apple” 拼接成。<br>     注意，你可以重复使用字典中的单词。<br>示例 3：</p><p>输入: s &#x3D; “catsandog”, wordDict &#x3D; [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出: false </p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 300<br>1 &lt;&#x3D; wordDict.length &lt;&#x3D; 1000<br>1 &lt;&#x3D; wordDict[i].length &lt;&#x3D; 20<br>s 和 wordDict[i] 仅有小写英文字母组成<br>wordDict 中的所有字符串 互不相同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">We use a boolean vector dp[]. dp[i] is set to true if a valid word (word sequence) ends there. The optimization is to look from current position i back and only substring and do dictionary look up in case the preceding position j with dp[j] == true is found.</span><br></pre></td></tr></table></figure><h2 id="Solution1-动态规划-4"><a href="#Solution1-动态规划-4" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</span><br><span class="line">    vector&lt;bool&gt; dp(s.size()+1, false);</span><br><span class="line">    unordered_set&lt;string&gt; m(wordDict.begin(), wordDict.end());</span><br><span class="line">    dp[0] = true;</span><br><span class="line">    for (int i = 1; i &lt;= s.size(); ++i)&#123;</span><br><span class="line">        for (int j = 0; j &lt; i; ++j)&#123;</span><br><span class="line">            if (dp[j] &amp;&amp; m.find(s.substr(j, i-j)) != m.end())&#123;</span><br><span class="line">                dp[i] = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[s.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Solution2-动态规划-优化版"><a href="#Solution2-动态规划-优化版" class="headerlink" title="Solution2 动态规划 优化版"></a>Solution2 动态规划 优化版</h2><p>【优化】对于以上代码可以优化。每次并不需要从s[0]开始搜索。因为wordDict中的字符串长度是有限的。只需要从i-maxWordLength开始搜索就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</span><br><span class="line">    vector&lt;bool&gt; dp(s.size()+1, false);</span><br><span class="line">    unordered_set&lt;string&gt; m(wordDict.begin(), wordDict.end());</span><br><span class="line">    dp[0] = true;</span><br><span class="line">    //获取最长字符串长度</span><br><span class="line">    int maxWordLength = 0;</span><br><span class="line">    for (int i = 0; i &lt; wordDict.size(); ++i)&#123;</span><br><span class="line">        maxWordLength = std::max(maxWordLength, (int)wordDict[i].size());</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= s.size(); ++i)&#123;</span><br><span class="line">        for (int j = std::max(i-maxWordLength, 0); j &lt; i; ++j)&#123;</span><br><span class="line">            if (dp[j] &amp;&amp; m.find(s.substr(j, i-j)) != m.end())&#123;</span><br><span class="line">                dp[i] = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[s.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态规划：152-乘积最大子数组"><a href="#动态规划：152-乘积最大子数组" class="headerlink" title="动态规划：152. 乘积最大子数组"></a><a href="https://leetcode.com/problems/maximum-product-subarray/">动态规划：152. 乘积最大子数组</a></h1><p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p>测试用例的答案是一个 32-位 整数。</p><p>子数组 是数组的连续子序列。</p><p> </p><p>示例 1:</p><p>输入: nums &#x3D; [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。<br>示例 2:</p><p>输入: nums &#x3D; [-2,0,-1]<br>输出: 0<br>解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 </p><p>提示:</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 104<br>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10<br>nums 的任何前缀或后缀的乘积都 保证 是一个 32-位 整数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">There can be Mutliple ways to frame the solution once we get the intuition right !! So, what should the intuition be ? Let&#x27;s discuss that out !</span><br><span class="line"></span><br><span class="line">Let&#x27;s consider array to have no 0s (for the moment)......</span><br><span class="line">So, on what factor does the answer depends now ?? It surely depends on the count of negative numbers in the array !!</span><br><span class="line"></span><br><span class="line">There are 2 possibilities - either the count of -ve numbers is even or odd.... ---&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line">If the count is even, then obviously we would want to include all of them(in fact the whole array) to maximise the product. As multiplying an even number of -ve numbers would make the result +ve.</span><br><span class="line"></span><br><span class="line">If the count is odd, then we would want to exclude one -ve number from our product, so that the product gets maximised. So, now the question is, which -ve number to exclude? Example ---&gt; arr=&#123;-2,-3,-1,-4,-5&#125; which number should be excluded ? On observing it , we should get one fact clear, that the number which is going to get ignored is either going to be the first one or the last one.</span><br><span class="line"></span><br><span class="line">Note that, we cannot exclude a -ve number that is not the first or the last, because, if we do so, we will need to exclude all(because you are breaking the product at this point) other -ve nums following that -ve number and then that needn&#x27;t result in the maximum product.</span><br><span class="line">Having said all that, now the question is whether to exclude the first -ve num or the last -ve num in the array. We can only know the answer by trying both.</span><br><span class="line">So, firstly we will take the product from the beginning of the array and we will include the first -ve number and will leave out the last one !!</span><br><span class="line">And will do the vice-versa for checking the other scenario !!</span><br><span class="line">So , in that example we would leave the first -ve number... (-2 and then total_product will be product of rest of the numbers in array) or we would leave the last number...(-5) ... And maximum of those 2 cases will be the answer !!</span><br><span class="line">Now, what if array has zeroes? Well, it changes nothing much to be honest, we can consider the part on both the side of 0 as the subarrays and the maximum product that way will be the max(subarray1_ans, subarray2_ans) .... And how to mark the division point ? How do we seperate the subarrays????...</span><br><span class="line">Thats pretty simple and we have done it in kadane&#x27;s algo, just make the curr_ongoing_prod=1 !! And maintain one maxm_prod variable seperately ....</span><br><span class="line"></span><br><span class="line">Example --&gt;&gt;&gt; arr=&#123;-2,1,4,5,0,-3,4,6,1,-2&#125; .... so we can consider subarray1=&#123;-2,1,4,5&#125; and subarray2=&#123;-3,4,6,-2&#125; and then the max_ans(subarray1,subarray2) will be our answer !!</span><br><span class="line"></span><br><span class="line">Let&#x27;s have a look on our code now ....</span><br></pre></td></tr></table></figure><h2 id="Solution0-暴力-1"><a href="#Solution0-暴力-1" class="headerlink" title="Solution0 暴力"></a>Solution0 暴力</h2><h2 id="Solution1-动态规划-5"><a href="#Solution1-动态规划-5" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/8079c50a-6dbe-4779-9b7d-ff76f481397d.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if(n == 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else if(n == 1) &#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        int p = nums[0];</span><br><span class="line">        int maxP = nums[0];</span><br><span class="line">        int minP = nums[0];</span><br><span class="line">        for(int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            int t = maxP;</span><br><span class="line">            maxP = max(max(maxP * nums[i], nums[i]), minP *nums[i]);</span><br><span class="line">            minP = min(min(t * nums[i], nums[i]), minP * nums[i]);</span><br><span class="line">            p = max(maxP, p);</span><br><span class="line">        &#125;</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="动态规划：198-打家劫舍"><a href="#动态规划：198-打家劫舍" class="headerlink" title="动态规划：198. 打家劫舍"></a><a href="https://leetcode.com/problems/house-robber/">动态规划：198. 打家劫舍</a></h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p> </p><p>示例 1：</p><p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。<br>     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。<br>示例 2：</p><p>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。<br>     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。 </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 400</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">This is a classic 1D-DP problem where at every step we have a choice to make ...</span><br><span class="line">So the first and foremost thing in any DP problem is to find the reccurence relation !!</span><br><span class="line">At every ith house robber has 2 options: a) rob current house i. b) don&#x27;t rob current house.</span><br><span class="line"></span><br><span class="line">In case he is robbing the (i)th house, the money he can get till the i-th house == money robbed till (i-2)th house + money robbed at (i)th house....let&#x27;s say total money robbed in this case equals to X.</span><br><span class="line">In case he is not robbing, money robbed till i-th house==money robbed till (i-1)th house...lets say total money robbed in this case equals to Y.</span><br><span class="line">So , the maxm money he gets till i-th house is the max(X,Y).</span><br><span class="line">Example of case (a) --&gt; nums=&#123;2,3,2&#125; ... Here, the robber will rob the house at index-2 as nums[index-2] + nums[index-0] &gt; nums[index-1]</span><br><span class="line">Example of case (b)--&gt; nums=&#123;2,7,3&#125; ... here maximum money robbed till index-2 will not be equal to nums[index-2] + nums[index-0]... as nums[index-1] is greater than the sum of money at both those houses ...</span><br><span class="line"></span><br><span class="line">We can achieve the desired solution to this problem via mutliple ways, let&#x27;s start with the simpler ones and then will look forward to optimize the Time and Space Complexities</span><br><span class="line"></span><br><span class="line">Simple Recursion</span><br><span class="line">Time Complexcity : O ( 2^n ) Gives us TLE</span><br><span class="line">Space Complexcity : O( 1 )</span><br></pre></td></tr></table></figure><h2 id="Solution1-动态规划-6"><a href="#Solution1-动态规划-6" class="headerlink" title="Solution1  动态规划"></a>Solution1  动态规划</h2><p>dp 方程 dp[i] &#x3D; max(dp[i-2]+nums[i], dp[i-1])</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.empty()) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        if (size == 1) &#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; dp = vector&lt;int&gt;(size, 0);</span><br><span class="line">        dp[0] = nums[0];</span><br><span class="line">        dp[1] = max(nums[0], nums[1]);</span><br><span class="line">        for (int i = 2; i &lt; size; i++) &#123;</span><br><span class="line">            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[size - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution2-动态规划-3"><a href="#Solution2-动态规划-3" class="headerlink" title="Solution2 动态规划"></a>Solution2 动态规划</h2><p>上述方法使用了数组存储结果。考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int rob(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if (nums.empty()) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int size = nums.size();</span><br><span class="line">        if (size == 1) &#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        int first = nums[0], second = max(nums[0], nums[1]);</span><br><span class="line">        for (int i = 2; i &lt; size; i++) &#123;</span><br><span class="line">            int temp = second;</span><br><span class="line">            second = max(first + nums[i], second);</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(n)O(n)，其中 nn 是数组长度。只需要对数组遍历一次。</p><p>空间复杂度：O(1)O(1)。使用滚动数组，可以只存储前两间房屋的最高总金额，而不需要存储整个数组的结果，因此空间复杂度是 O(1)O(1)。</p><h1 id="动态规划：221-最大正方形"><a href="#动态规划：221-最大正方形" class="headerlink" title="动态规划：221. 最大正方形"></a><a href="https://leetcode.com/problems/maximal-square/">动态规划：221. 最大正方形</a></h1><p><img src="https://files.mdnice.com/user/1489/317b8a93-0319-40c0-9273-c7d6ea72516a.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Approach 1: Brute Force</span><br><span class="line">The simplest approach consists of trying to find out every possible square of 1’s that can be formed from within the matrix. The question now is – how to go for it?</span><br><span class="line"></span><br><span class="line">We use a variable to contain the size of the largest square found so far and another variable to store the size of the current, both initialized to 0. Starting from the left uppermost point in the matrix, we search for a 1. No operation needs to be done for a 0. Whenever a 1 is found, we try to find out the largest square that can be formed including that 1. For this, we move diagonally (right and downwards), i.e. we increment the row index and column index temporarily and then check whether all the elements of that row and column are 1 or not. If all the elements happen to be 1, we move diagonally further as previously. If even one element turns out to be 0, we stop this diagonal movement and update the size of the largest square. Now we, continue the traversal of the matrix from the element next to the initial 1 found, till all the elements of the matrix have been traversed.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Complexity Analysis</span><br><span class="line"></span><br><span class="line">Time complexity : O((mn)^2）</span><br><span class="line">In worst case, we need to traverse the complete matrix for every 1.</span><br><span class="line">Space complexity : O(1)O(1). No extra space is used.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/73a115c9-da59-46f5-888c-2a70cd01953f.png"></p><h2 id="Solution0-暴力法"><a href="#Solution0-暴力法" class="headerlink" title="Solution0 暴力法"></a>Solution0 暴力法</h2><p><img src="https://files.mdnice.com/user/1489/19e5cf6f-0c41-4a7c-804d-9d81beac4123.png"></p><h2 id="Solution1-动态规划-7"><a href="#Solution1-动态规划-7" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p>class Solution {<br>    public int maximalSquare(char[][] matrix) {<br>        &#x2F;**<br>        dp[i][j]表示以第i行第j列为右下角所能构成的最大正方形边长, 则递推式为:<br>        dp[i][j] &#x3D; 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]);<br>        **&#x2F;<br>        int m &#x3D; matrix.length;<br>        if(m &lt; 1) return 0;<br>        int n &#x3D; matrix[0].length;<br>        int max &#x3D; 0;<br>        int[][] dp &#x3D; new int[m+1][n+1];</p><pre><code>    for(int i = 1; i &lt;= m; ++i) &#123;        for(int j = 1; j &lt;= n; ++j) &#123;            if(matrix[i-1][j-1] == &#39;1&#39;) &#123;                dp[i][j] = 1 + Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1]));                max = Math.max(max, dp[i][j]);             &#125;        &#125;    &#125;        return max*max;&#125;</code></pre><p>}</p><h1 id="动态规划：279-完全平方数"><a href="#动态规划：279-完全平方数" class="headerlink" title="动态规划：279. 完全平方数"></a><a href="https://leetcode.com/problems/perfect-squares/">动态规划：279. 完全平方数</a></h1><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p><p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><p> </p><p>示例 1：</p><p>输入：n &#x3D; 12<br>输出：3<br>解释：12 &#x3D; 4 + 4 + 4<br>示例 2：</p><p>输入：n &#x3D; 13<br>输出：2<br>解释：13 &#x3D; 4 + 9</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Idea:</span><br><span class="line">This question is very similar to coin change https://leetcode.com/problems/coin-change/discuss/1104203/C%2B%2B-Super-Simple-and-Short-Dynamic-Programming-Solution.</span><br><span class="line">The only difference is that in coin change we get a vector of coins and here we know that the coins are all the perfect squares.</span><br><span class="line">So our first step will be to construct a &quot;coin&quot; vector.</span><br><span class="line">Then, we do it the same way as coin change.</span><br></pre></td></tr></table></figure><h2 id="Solution1-动态规划-8"><a href="#Solution1-动态规划-8" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/8ef92a66-0286-4473-88b6-76fd2e9613ed.png"></p><h2 id="Solution2-数学"><a href="#Solution2-数学" class="headerlink" title="Solution2  数学"></a>Solution2  数学</h2><p><img src="https://files.mdnice.com/user/1489/3c123721-1909-4e2c-91e3-c2d357b57458.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    // 判断是否为完全平方数</span><br><span class="line">    bool isPerfectSquare(int x) &#123;</span><br><span class="line">        int y = sqrt(x);</span><br><span class="line">        return y * y == x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 判断是否能表示为 4^k*(8m+7)</span><br><span class="line">    bool checkAnswer4(int x) &#123;</span><br><span class="line">        while (x % 4 == 0) &#123;</span><br><span class="line">            x /= 4;</span><br><span class="line">        &#125;</span><br><span class="line">        return x % 8 == 7;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int numSquares(int n) &#123;</span><br><span class="line">        if (isPerfectSquare(n)) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (checkAnswer4(n)) &#123;</span><br><span class="line">            return 4;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i * i &lt;= n; i++) &#123;</span><br><span class="line">            int j = n - i * i;</span><br><span class="line">            if (isPerfectSquare(j)) &#123;</span><br><span class="line">                return 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="动态规划：300-最长递增子序列"><a href="#动态规划：300-最长递增子序列" class="headerlink" title="动态规划：300. 最长递增子序列"></a><a href="https://leetcode.com/problems/longest-increasing-subsequence/">动态规划：300. 最长递增子序列</a></h1><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p> <br>示例 1：</p><p>输入：nums &#x3D; [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。<br>示例 2：</p><p>输入：nums &#x3D; [0,1,0,3,2,3]<br>输出：4<br>示例 3：</p><p>输入：nums &#x3D; [7,7,7,7,7,7,7]<br>输出：1 </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 2500<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104 </p><p>进阶：</p><p>你能将算法的时间复杂度降低到 O(n log(n)) 吗?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">✔️ Solution 1: Dynamic Programming</span><br><span class="line"></span><br><span class="line">This is a classic Dynamic Programming problem.</span><br><span class="line">Let dp[i] is the longest increase subsequence of nums[0..i] which has nums[i] as the end element of the subsequence.</span><br><span class="line"></span><br><span class="line">Complexity</span><br><span class="line"></span><br><span class="line">Time: O(N^2), where N &lt;= 2500 is the number of elements in array nums.</span><br><span class="line">Space: O(N)</span><br><span class="line">✔️ Solution 2: Greedy with Binary Search</span><br><span class="line"></span><br><span class="line">Let&#x27;s construct the idea from following example.</span><br><span class="line">Consider the example nums = [2, 6, 8, 3, 4, 5, 1], let&#x27;s try to build the increasing subsequences starting with an empty one: sub1 = [].</span><br><span class="line">Let pick the first element, sub1 = [2].</span><br><span class="line">6 is greater than previous number, sub1 = [2, 6]</span><br><span class="line">8 is greater than previous number, sub1 = [2, 6, 8]</span><br><span class="line">3 is less than previous number, we can&#x27;t extend the subsequence sub1, but we must keep 3 because in the future there may have the longest subsequence start with [2, 3], sub1 = [2, 6, 8], sub2 = [2, 3].</span><br><span class="line">With 4, we can&#x27;t extend sub1, but we can extend sub2, so sub1 = [2, 6, 8], sub2 = [2, 3, 4].</span><br><span class="line">With 5, we can&#x27;t extend sub1, but we can extend sub2, so sub1 = [2, 6, 8], sub2 = [2, 3, 4, 5].</span><br><span class="line">With 1, we can&#x27;t extend neighter sub1 nor sub2, but we need to keep 1, so sub1 = [2, 6, 8], sub2 = [2, 3, 4, 5], sub3 = [1].</span><br><span class="line">Finally, length of longest increase subsequence = len(sub2) = 4.</span><br><span class="line">In the above steps, we need to keep different sub arrays (sub1, sub2..., subk) which causes poor performance. But we notice that we can just keep one sub array, when new number x is not greater than the last element of the subsequence sub, we do binary search to find the smallest element &gt;= x in sub, and replace with number x.</span><br><span class="line">Let&#x27;s run that example nums = [2, 6, 8, 3, 4, 5, 1] again:</span><br><span class="line">Let pick the first element, sub = [2].</span><br><span class="line">6 is greater than previous number, sub = [2, 6]</span><br><span class="line">8 is greater than previous number, sub = [2, 6, 8]</span><br><span class="line">3 is less than previous number, so we can&#x27;t extend the subsequence sub. We need to find the smallest number &gt;= 3 in sub, it&#x27;s 6. Then we overwrite it, now sub = [2, 3, 8].</span><br><span class="line">4 is less than previous number, so we can&#x27;t extend the subsequence sub. We overwrite 8 by 4, so sub = [2, 3, 4].</span><br><span class="line">5 is greater than previous number, sub = [2, 3, 4, 5].</span><br><span class="line">1 is less than previous number, so we can&#x27;t extend the subsequence sub. We overwrite 2 by 1, so sub = [1, 3, 4, 5].</span><br><span class="line">Finally, length of longest increase subsequence = len(sub) = 4.</span><br><span class="line"></span><br><span class="line">Complexity</span><br><span class="line"></span><br><span class="line">Time: O(N * logN), where N &lt;= 2500 is the number of elements in array nums.</span><br><span class="line">Space: O(N), we can achieve O(1) in space by overwriting values of sub into original nums array.</span><br><span class="line"></span><br><span class="line">Complexity:</span><br><span class="line"></span><br><span class="line">Time: O(N * logN)</span><br><span class="line">Space: O(N)</span><br></pre></td></tr></table></figure><h2 id="Solution1-动态规划-9"><a href="#Solution1-动态规划-9" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/2f69c7c1-c466-4ba5-aeb7-ee8d57b4bc1c.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = (int)nums.size();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; dp(n, 0);</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = 1;</span><br><span class="line">            for (int j = 0; j &lt; i; ++j) &#123;</span><br><span class="line">                if (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return *max_element(dp.begin(), dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/1082c59b-c9b3-44b1-a291-78fb192b9ea4.png"></p><h2 id="Solution2-贪心"><a href="#Solution2-贪心" class="headerlink" title="Solution2  贪心"></a>Solution2  贪心</h2><p><img src="https://files.mdnice.com/user/1489/ce693fb0-6d34-4939-93b2-58af527f3ab4.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len = 1, n = (int)nums.size();</span><br><span class="line">        if (n == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; d(n + 1, 0);</span><br><span class="line">        d[len] = nums[0];</span><br><span class="line">        for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">            if (nums[i] &gt; d[len]) &#123;</span><br><span class="line">                d[++len] = nums[i];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int l = 1, r = len, pos = 0; // 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0</span><br><span class="line">                while (l &lt;= r) &#123;</span><br><span class="line">                    int mid = (l + r) &gt;&gt; 1;</span><br><span class="line">                    if (d[mid] &lt; nums[i]) &#123;</span><br><span class="line">                        pos = mid;</span><br><span class="line">                        l = mid + 1;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        r = mid - 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d[pos + 1] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="动态规划：313-超级丑数"><a href="#动态规划：313-超级丑数" class="headerlink" title="动态规划：313. 超级丑数"></a><a href="https://leetcode.com/problems/super-ugly-number/">动态规划：313. 超级丑数</a></h1><p>超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。</p><p>给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。</p><p>题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。</p><p> </p><p>示例 1：</p><p>输入：n &#x3D; 12, primes &#x3D; [2,7,13,19]<br>输出：32<br>解释：给定长度为 4 的质数数组 primes &#x3D; [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。<br>示例 2：</p><p>输入：n &#x3D; 1, primes &#x3D; [2,3,5]<br>输出：1<br>解释：1 不含质因数，因此它的所有质因数都在质数数组 primes &#x3D; [2,3,5] 中。<br> <br>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 105<br>1 &lt;&#x3D; primes.length &lt;&#x3D; 100<br>2 &lt;&#x3D; primes[i] &lt;&#x3D; 1000<br>题目数据 保证 primes[i] 是一个质数<br>primes 中的所有值都 互不相同 ，且按 递增顺序 排列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">It is actually like how we merge k sorted list:</span><br><span class="line"></span><br><span class="line">ugly number                       k sorted list</span><br><span class="line">    1                            2     7    13   19     1 * [2,7,13,19]</span><br><span class="line">    |                            |     |    |    |</span><br><span class="line">    2                            4     14   26   38     2 * [2,7,13,19]</span><br><span class="line">    |                            |     |    |    |</span><br><span class="line">    4                            8     28   52   76     4 * [2,7,13,19]</span><br><span class="line">    |                            |     |    |    |              </span><br><span class="line">    7                            14    49   91   133    7 * [2,7,13,19]</span><br><span class="line">    |                            |     |    |    |</span><br><span class="line">    8                            16    56   ...   ...   8 * [2,7,13,19]</span><br><span class="line">    |                            |     |    |     |</span><br><span class="line">    .                            .     .     .    .</span><br><span class="line">    .                            .     .     .    .</span><br><span class="line">    .                            .     .     .    .</span><br><span class="line">We can see that each prime number in primes[] form a sorted list, and now our job is to merge them and find the nth minimum.</span><br><span class="line"></span><br><span class="line">Here we don&#x27;t have the next pointer for each node to trace the next potential candidate. But as we can see in the graph, we can make use of the ugly number we have produced so far!</span><br></pre></td></tr></table></figure><h2 id="Solution1-最小堆"><a href="#Solution1-最小堆" class="headerlink" title="Solution1 最小堆"></a>Solution1 最小堆</h2><p><img src="https://files.mdnice.com/user/1489/836dc250-a4b3-4acd-80a8-5202dbd8266b.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int nthSuperUglyNumber(int n, int[] primes) &#123;</span><br><span class="line">      PriorityQueue&lt;Long&gt;queue=new PriorityQueue&lt;&gt;();</span><br><span class="line">        long res=1;</span><br><span class="line">        for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">            for(int prime:primes)&#123;</span><br><span class="line">                queue.add(prime*res);</span><br><span class="line">            &#125;</span><br><span class="line">            res=queue.poll();</span><br><span class="line">            while(!queue.isEmpty()&amp;&amp;res==queue.peek()) queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        return (int)res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Solution2-动态规划-4"><a href="#Solution2-动态规划-4" class="headerlink" title="Solution2 动态规划"></a>Solution2 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/144ef974-6b43-473c-9b4e-76efb177144a.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int nthSuperUglyNumber(int n, vector&lt;int&gt;&amp; primes) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n + 1);  //用来存储丑数序列</span><br><span class="line">        dp[1] = 1;          //第一个丑数是1</span><br><span class="line">        int m = primes.size();</span><br><span class="line">        vector&lt;int&gt; nums(m);     //记录新丑数序列</span><br><span class="line">        vector&lt;int&gt; pointers(m, 1); //记录质数该与哪一位丑数做乘积</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            int minn = INT_MAX;</span><br><span class="line">            for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                nums[j] = dp[pointers[j]] * primes[j]; //旧丑数 * 质数序列 = 新丑数序列</span><br><span class="line">                minn = min(minn, nums[j]);  //寻找所有新丑数中最小的丑数</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = minn;</span><br><span class="line">            for (int j = 0; j &lt; m; j++)</span><br><span class="line">                if (minn == nums[j])        //如果此位置已经诞生过最小丑数</span><br><span class="line">                    pointers[j]++;          //让此位置所取旧丑数向后推一位</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="动态规划-x2F-递归：322-零钱兑换"><a href="#动态规划-x2F-递归：322-零钱兑换" class="headerlink" title="动态规划&#x2F;递归：322. 零钱兑换"></a><a href="https://leetcode.com/problems/coin-change/">动态规划&#x2F;递归：322. 零钱兑换</a></h1><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的。</p><p> </p><p>示例 1：</p><p>输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11<br>输出：3<br>解释：11 &#x3D; 5 + 5 + 1<br>示例 2：</p><p>输入：coins &#x3D; [2], amount &#x3D; 3<br>输出：-1<br>示例 3：</p><p>输入：coins &#x3D; [1], amount &#x3D; 0<br>输出：0 </p><p>提示：</p><p>1 &lt;&#x3D; coins.length &lt;&#x3D; 12<br>1 &lt;&#x3D; coins[i] &lt;&#x3D; 231 - 1<br>0 &lt;&#x3D; amount &lt;&#x3D; 104</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">If you carefully observe the below 3 codes. You will see that the DP Memoization is dervied from the Recursion code just by changing 3 lines and the DP Tabulation is derived from the DP Memoization.</span><br><span class="line"></span><br><span class="line">Recursion</span><br><span class="line">Time: O(2^n)</span><br><span class="line">Space: O(n)</span><br><span class="line"></span><br><span class="line">Writing a recursive function is all about find two things:</span><br><span class="line"></span><br><span class="line">The base case: Just calculate the output for the smallest possible input</span><br><span class="line">The choice diagram: For any given input, just see what all choices do we have.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DP Memoization</span><br><span class="line">Time: O(n.m)</span><br><span class="line">Space: O(n.m)</span><br><span class="line"></span><br><span class="line">In the above recursive case, we were doing repeated work in the form of subproblems. Hence we store the results of those subproblems in a table to reduce the number of recursive calls.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DP Tabulation</span><br><span class="line">Time: O(n.m)</span><br><span class="line">Space: O(n.m)</span><br><span class="line"></span><br><span class="line">We have reached the best conceivable run time for this question but since we have recursive calls in the previous algorithm. It might lead to stackoverflow error in the worst case when recursive calls are a lot. Hence we want to totally emit the notion of recursions. To do that, we simply convert the recursion into iterative code.</span><br><span class="line"></span><br><span class="line">The below code is bottom up dynamic programming because we are starting from the first element in the 2D array and filling the DP from this first element till the last element. And eventually, the last cell stores our final result.</span><br></pre></td></tr></table></figure><h2 id="Solution1-动态规划-10"><a href="#Solution1-动态规划-10" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/b2f8f7dd-d476-4624-bed2-09ed94cd6f74.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</span><br><span class="line">        int Max = amount + 1;</span><br><span class="line">        vector&lt;int&gt; dp(amount + 1, Max);</span><br><span class="line">        dp[0] = 0;</span><br><span class="line">        for (int i = 1; i &lt;= amount; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; (int)coins.size(); ++j) &#123;</span><br><span class="line">                if (coins[j] &lt;= i) &#123;</span><br><span class="line">                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[amount] &gt; amount ? -1 : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution2-贪心-回溯-剪枝"><a href="#Solution2-贪心-回溯-剪枝" class="headerlink" title="Solution2 贪心+回溯+剪枝"></a>Solution2 贪心+回溯+剪枝</h2><p><img src="https://files.mdnice.com/user/1489/bc43d48c-bd11-4ebe-816d-8df25edec96b.png"></p><p><img src="https://files.mdnice.com/user/1489/be81cb56-2d21-4267-81ff-c1fe308261cd.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void coinChange(vector&lt;int&gt;&amp; coins, int amount, int c_index, int count, int&amp; ans) &#123;</span><br><span class="line">    if (amount == 0) &#123;</span><br><span class="line">        ans = min(ans, count);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (c_index == coins.size()) return;</span><br><span class="line"></span><br><span class="line">    for (int k = amount / coins[c_index]; k &gt;= 0 &amp;&amp; k + count &lt; ans; k--) &#123;</span><br><span class="line">        coinChange(coins, amount - k * coins[c_index], c_index + 1, count + k, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123;</span><br><span class="line">    if (amount == 0) return 0;</span><br><span class="line">    sort(coins.rbegin(), coins.rend());</span><br><span class="line">    int ans = INT_MAX;</span><br><span class="line">    coinChange(coins, amount, 0, 0, ans);</span><br><span class="line">    return ans == INT_MAX ? -1 : ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="树-x2F-动态规划-337-打家劫舍-III"><a href="#树-x2F-动态规划-337-打家劫舍-III" class="headerlink" title="树&#x2F;动态规划: 337. 打家劫舍 III"></a><a href="https://leetcode.com/problems/house-robber-iii/">树&#x2F;动态规划: 337. 打家劫舍 III</a></h1><p><img src="https://files.mdnice.com/user/1489/863165d0-8403-42e8-abcb-4387abc6f8d3.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Step I -- Think naively</span><br><span class="line"></span><br><span class="line">At first glance, the problem exhibits the feature of &quot;optimal substructure&quot;: if we want to rob maximum amount of money from current binary tree (rooted at root), we surely hope that we can do the same to its left and right subtrees.</span><br><span class="line"></span><br><span class="line">So going along this line, let&#x27;s define the function rob(root) which will return the maximum amount of money that we can rob for the binary tree rooted at root; the key now is to construct the solution to the original problem from solutions to its subproblems, i.e., how to get rob(root) from rob(root.left), rob(root.right), ... etc.</span><br><span class="line"></span><br><span class="line">Apparently the analyses above suggest a recursive solution. And for recursion, it&#x27;s always worthwhile figuring out the following two properties:</span><br><span class="line"></span><br><span class="line">Termination condition: when do we know the answer to rob(root) without any calculation? Of course when the tree is empty ---- we&#x27;ve got nothing to rob so the amount of money is zero.</span><br><span class="line"></span><br><span class="line">Recurrence relation: i.e., how to get rob(root) from rob(root.left), rob(root.right), ... etc. From the point of view of the tree root, there are only two scenarios at the end: root is robbed or is not. If it is, due to the constraint that &quot;we cannot rob any two directly-linked houses&quot;, the next level of subtrees that are available would be the four &quot;grandchild-subtrees&quot; (root.left.left, root.left.right, root.right.left, root.right.right). However if root is not robbed, the next level of available subtrees would just be the two &quot;child-subtrees&quot; (root.left, root.right). We only need to choose the scenario which yields the larger amount of money.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">However the solution runs very slowly (1186 ms) and barely got accepted (the time complexity turns out to be exponential, see my comments below).</span><br><span class="line"></span><br><span class="line">Step II -- Think one step further</span><br><span class="line"></span><br><span class="line">In step I, we only considered the aspect of &quot;optimal substructure&quot;, but think little about the possibilities of overlapping of the subproblems. For example, to obtain rob(root), we need rob(root.left), rob(root.right), rob(root.left.left), rob(root.left.right), rob(root.right.left), rob(root.right.right); but to get rob(root.left), we also need rob(root.left.left), rob(root.left.right), similarly for rob(root.right). The naive solution above computed these subproblems repeatedly, which resulted in bad time performance. Now if you recall the two conditions for dynamic programming (DP): &quot;optimal substructure&quot; + &quot;overlapping of subproblems&quot;, we actually have a DP problem. A naive way to implement DP here is to use a hash map to record the results for visited subtrees.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Step III -- Think one step back</span><br><span class="line"></span><br><span class="line">In step I, we defined our problem as rob(root), which will yield the maximum amount of money that can be robbed of the binary tree rooted at root. This leads to the DP problem summarized in step II.</span><br><span class="line"></span><br><span class="line">Now let&#x27;s take one step back and ask why we have overlapping subproblems. If you trace all the way back to the beginning, you&#x27;ll find the answer lies in the way how we have defined rob(root). As I mentioned, for each tree root, there are two scenarios: it is robbed or is not. rob(root) does not distinguish between these two cases, so &quot;information is lost as the recursion goes deeper and deeper&quot;, which results in repeated subproblems.</span><br><span class="line"></span><br><span class="line">If we were able to maintain the information about the two scenarios for each tree root, let&#x27;s see how it plays out. Redefine rob(root) as a new function which will return an array of two elements, the first element of which denotes the maximum amount of money that can be robbed if root is not robbed, while the second element signifies the maximum amount of money robbed if it is robbed.</span><br><span class="line"></span><br><span class="line">Let&#x27;s relate rob(root) to rob(root.left) and rob(root.right)..., etc. For the 1st element of rob(root), we only need to sum up the larger elements of rob(root.left) and rob(root.right), respectively, since root is not robbed and we are free to rob its left and right subtrees. For the 2nd element of rob(root), however, we only need to add up the 1st elements of rob(root.left) and rob(root.right), respectively, plus the value robbed from root itself, since in this case it&#x27;s guaranteed that we cannot rob the nodes of root.left and root.right.</span><br><span class="line"></span><br><span class="line">As you can see, by keeping track of the information of both scenarios, we decoupled the subproblems and the solution essentially boiled down to a greedy one. Here is the program:</span><br></pre></td></tr></table></figure><h2 id="Solution1-动态规划-11"><a href="#Solution1-动态规划-11" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/f05af832-f82d-4a9a-85c8-880b56b213a8.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    unordered_map &lt;TreeNode*, int&gt; f, g;</span><br><span class="line"></span><br><span class="line">    void dfs(TreeNode* node) &#123;</span><br><span class="line">        if (!node) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node-&gt;left);</span><br><span class="line">        dfs(node-&gt;right);</span><br><span class="line">        f[node] = node-&gt;val + g[node-&gt;left] + g[node-&gt;right];</span><br><span class="line">        g[node] = max(f[node-&gt;left], g[node-&gt;left]) + max(f[node-&gt;right], g[node-&gt;right]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int rob(TreeNode* root) &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        return max(f[root], g[root]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="动态规划-x2F-背包：分割等和子集"><a href="#动态规划-x2F-背包：分割等和子集" class="headerlink" title="动态规划&#x2F;背包：分割等和子集"></a><a href="https://leetcode.com/problems/partition-equal-subset-sum/">动态规划&#x2F;背包：分割等和子集</a></h1><p>背包问题 后面和回溯问题一起搞定</p><p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [1,5,11,5]<br>输出：true<br>解释：数组可以分割成 [1, 5, 5] 和 [11] 。<br>示例 2：</p><p>输入：nums &#x3D; [1,2,3,5]<br>输出：false<br>解释：数组不能分割成两个元素和相等的子集。 </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">❌ Solution - I (Brute-Force)</span><br><span class="line"></span><br><span class="line">Let&#x27;s try solving it using brute-force approach. We need to partition the array into two subsets. This means that for each element of the array, we can either place it in 1st subset, or place it in 2nd subset.</span><br><span class="line"></span><br><span class="line">Since we are only concerned with the sums of subset being equal, we will maintain 1st subset&#x27;s sum: sum1 &amp; 2nd subset&#x27;s sum: sum2. For each element, we try both possible options of either placing it in 1st subset and increasing sum1 or placing it in 2nd subset &amp; increasing sum2. Finally, once we reach the end of array, we can check if the current placements gave equal sum. If none of the possible placements give equal sum, we will return false.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">We can slightly optimize the above approach by observing that equal partion are only possible when the total sum of array can be equally split, i.e, it is even. This effectively allows us to directly return false if the sum is odd. When the sum is even, we only need to check if we can construct one subset with its sum equal to total_sum / 2 (the other will automatically have the same sum, so we dont need to care about it). Thus the above can be optimized to -</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Time Complexity : O(2N), where N is the number of elements in nums. For each element, we try both choices of including or excluding an element from subset leading to recursive branches 2*2*2..N times which give time complexity of O(2N)</span><br><span class="line">Space Complexity : O(N), required by recursive stack</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">✔️ Solution - II (Dynamic Programming - Memoization)</span><br><span class="line"></span><br><span class="line">The above solution times out because we were performing repeated calculations over and over unnecessarily. The result for a given parameters sum, i (can we achieve subset sum = sum starting from i index?) will always be the same. So once we have calculated it, we dont need to repea the whole calculation again when it is called from another recursive branch. Instead we can save the result for this state and return it whenever we called again.</span><br><span class="line"></span><br><span class="line">Thus, we can use dynamic programming here. We use a dp array where dp[i][sum] denotes whether subset-sum = sum can be achieved or not starting from the ith index.</span><br><span class="line"></span><br><span class="line">Initially all elements in dp are initialized to -1 denoting that we have not computed that state</span><br><span class="line">If dp[i][sum] == 1 means that we can achieve sum starting from ith index</span><br><span class="line">If dp[i][sum] == 0 means we cant achieve that sum starting from the ith index</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Time Complexity : O(N*sum), where N is the number of elements in nums &amp; sum is the sum of all elements in nums.</span><br><span class="line">Space Complexity : O(N*sum), required by dp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">✔️ Solution - III (Optimized Dynamic Programming - Memoization)</span><br><span class="line"></span><br><span class="line">I am not sure if my reasoning is correct for this approach or it passes due to weak test cases. All other solutions I have seen are 2D memo. I initially thought this approach would fail but seems like it passes (tried on other OJs too).</span><br><span class="line"></span><br><span class="line">We can further optimize the above memoization approach by reducing the state that we memoize. We used dp[i][sum] in the above approach to denote if sum can be achieved starting from ith element in nums. But we dont really care if we achieve the sum starting from i index or not. We are only concerned with whether we can achieve it or not. Thus, we can reduce the state down to 1D dp where dp[sum] denotes whether sum is possible to be achived from nums or not.</span><br><span class="line"></span><br><span class="line">It is essential that we 1st recurse by choosing the current element and only then try the branch of not choosing. This prevents the recursive function from going all the way down the recursion tree by not choosing any elements and incorrectly marking sums as not achievable which could have been achievable if we had chosen earlier elements that we skipped.</span><br><span class="line"></span><br><span class="line">I am not sure if this is best explanation but if someone can better explain or provide some kind of proof/reasoning as to why recursing by 1st picking the element &amp; then not picking will guarantee correct answer, do comment below.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Time Complexity : O(N*sum)</span><br><span class="line"></span><br><span class="line">Check the below image for illustration (Credits: @SanjayMarreddi)</span><br><span class="line">Space Complexity : O(sum), required by dp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">✔️ Solution - IV (Dynamic Programming - Tabulation)</span><br><span class="line"></span><br><span class="line">We can convert the dp approach to iterative version. Here we will again use dp array, where dp[sum] will denote whether sum is achievable or not. Initially, we have dp[0] = true since a 0 sum is always achievable. Then for each element num, we will iterate &amp; find if it is possible to form a sum j by adding num to some previously formable sum.</span><br><span class="line"></span><br><span class="line">One thing to note that it is essential to iterate from right to left in the below inner loop to avoid marking multiple sum, say j1 as achievable and then again using that result to mark another bigger sum j2 (j2=j1+num) as achievable. This would be wrong since it would mean choosing num multiple times. So we start from right to left to avoid overwriting previous results updated in the current loop.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Time Complexity : O(N*sum)</span><br><span class="line">Space Complexity : O(sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">✔️ Solution - V (Dynamic Programming using bitmask)</span><br><span class="line"></span><br><span class="line">We can use bitmasking to condense the inner loop of previous approach into a single bit-shift operation. Here we will use bitset in C++ consisting of sum number of bits (other language can use bigInt or whatever support is provided for such operations).</span><br><span class="line"></span><br><span class="line">Each bit in bitset (dp[i]) will denote whether sum i is possible or not. Now, when we get a new number num, it can be added to every sum already possible, i.e, every dp[i] bit which is already 1. This operation can be performed using bit shift as dp &lt;&lt; num. How? See the following example</span><br><span class="line"></span><br><span class="line">Suppose current dp = 1011</span><br><span class="line">This means sums 0, 1 and 3 are possible to achieve.</span><br><span class="line">Let the next number we get: num = 5. </span><br><span class="line">Now we can achieve (0, 1 &amp; 3) which were already possible and (5, 6, 8) which are new sum after adding &#x27;num=5&#x27; to previous sums</span><br><span class="line"></span><br><span class="line">1. &#x27;dp &lt;&lt; num&#x27;: This operation will add num to every bit .</span><br><span class="line">                         3 2 1 0                                8 7 6 5 4 3 2 1 0                     </span><br><span class="line">                So, dp = 1 0 1 1 will be transformed to  dp  =  1 0 1 1 0 0 0 0 0   (after 5 shifts to left)</span><br><span class="line">    Note that new dp now denotes 5, 6, 8 which are the new sums possible.</span><br><span class="line">    We will combine it with previous sums using &#x27;|&#x27; operation</span><br><span class="line"></span><br><span class="line">                      8 7 6 5 4 3 2 1 0</span><br><span class="line">2. &#x27;dp | dp &lt;&lt; num&#x27; = 1 0 1 1 0 1 0 1 1</span><br><span class="line"></span><br><span class="line">And now we have every possible sum after combining new num with previous possible sums.</span><br><span class="line">Finally, we will return dp[halfSum] denoting whether half sum is achievable or not.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Time Complexity : O(N*sum)</span><br><span class="line">Space Complexity : O(sum)</span><br></pre></td></tr></table></figure><h1 id="动态规划-礼物的最大价值"><a href="#动态规划-礼物的最大价值" class="headerlink" title="动态规划:礼物的最大价值"></a><a href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof">动态规划:礼物的最大价值</a></h1><p><img src="https://files.mdnice.com/user/1489/0db9683d-96ad-462b-9c2f-e80cb835f227.jpg"></p><h1 id="动态规划-连续子数组的最大和"><a href="#动态规划-连续子数组的最大和" class="headerlink" title="动态规划: 连续子数组的最大和"></a><a href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof">动态规划: 连续子数组的最大和</a></h1><p><img src="https://files.mdnice.com/user/1489/828bd8c8-3c46-49e2-8d18-ae06aa6d3582.jpg"></p><h1 id="动态规划-剪绳子"><a href="#动态规划-剪绳子" class="headerlink" title="动态规划:剪绳子"></a><a href="https://leetcode.cn/problems/jian-sheng-zi-ii-lcof">动态规划:剪绳子</a></h1><p><img src="https://files.mdnice.com/user/1489/03a1de17-c22e-4c59-9494-1f0b2d174b29.jpg"></p><p><img src="https://files.mdnice.com/user/1489/9522e217-e06b-4346-84a0-eb8263b04f93.jpg"></p><p><img src="https://files.mdnice.com/user/1489/7b12d053-d366-4765-bfe4-75826f938e07.jpg"></p><p><img src="https://files.mdnice.com/user/1489/ca057ccb-65b9-48c8-9fee-a4024d76d47c.jpg"></p><p><img src="https://files.mdnice.com/user/1489/4ac49557-f581-4661-a123-af48b849ece1.jpg"></p><p><img src="https://files.mdnice.com/user/1489/9056d59a-86ef-4471-b065-a0a89df02627.jpg"></p><p><img src="https://files.mdnice.com/user/1489/19b73a26-c4e0-4af9-b278-52185b8bc40c.jpg"></p><h1 id="动态规划-青蛙跳台阶"><a href="#动态规划-青蛙跳台阶" class="headerlink" title="动态规划: 青蛙跳台阶"></a><a href="https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof">动态规划: 青蛙跳台阶</a></h1><p><img src="https://files.mdnice.com/user/1489/e0b97aff-77d6-44a0-905d-ddf01528b962.jpg"><br><img src="https://files.mdnice.com/user/1489/6fb39538-c320-49bd-b472-3e6dc981eb4d.jpg"></p><p><img src="https://files.mdnice.com/user/1489/2fe78d28-cb51-4119-a5e7-2d289ee647c7.jpg"></p><p><img src="https://files.mdnice.com/user/1489/5587729c-faa6-4969-9c44-33c350aac1a6.jpg"></p><h1 id="动态规划-最长重复子数组"><a href="#动态规划-最长重复子数组" class="headerlink" title="动态规划: 最长重复子数组"></a><a href="https://leetcode.com/problems/maximum-length-of-repeated-subarray">动态规划: 最长重复子数组</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Approach #1: Brute Force with Initial Character Map [Time Limit Exceeded]</span><br><span class="line">Intuition and Algorithm</span><br><span class="line"></span><br><span class="line">In a typical brute force, for all starting indices i of A and j of B, we will check for the longest matching subarray A[i:i+k] == B[j:j+k] of length k. This would look roughly like the following psuedocode:</span><br><span class="line"></span><br><span class="line">ans = 0</span><br><span class="line">for i in [0 .. A.length - 1]:</span><br><span class="line">    for j in [0 .. B.length - 1]:</span><br><span class="line">        k = 0</span><br><span class="line">        while (A[i+k] == B[j+k]): k += 1 #and i+k &lt; A.length etc.</span><br><span class="line">        ans = max(ans, k)</span><br><span class="line">Our insight is that in typical cases, most of the time A[i] != B[j]. We could instead keep a hashmap Bstarts[A[i]] = all j such that B[j] == A[i], and only loop through those in our j loop.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Approach #2: Binary Search with Naive Check [Time Limit Exceeded]</span><br><span class="line">Intuition</span><br><span class="line"></span><br><span class="line">If there is a length k subarray common to A and B, then there is a length j &lt;= k subarray as well.</span><br><span class="line"></span><br><span class="line">Let check(length) be the answer to the question &quot;Is there a subarray with length length, common to A and B?&quot; This is a function with range that must take the form [True, True, ..., True, False, False, ..., False] with at least one True. We can binary search on this function.</span><br><span class="line"></span><br><span class="line">Algorithm</span><br><span class="line"></span><br><span class="line">Focusing on the binary search, our invariant is that check(hi) will always be False. We&#x27;ll start with hi = min(len(A), len(B)) + 1; clearly check(hi) is False.</span><br><span class="line"></span><br><span class="line">Now we perform our check in the midpoint mi of lo and hi. When it is possible, then lo = mi + 1, and when it isn&#x27;t, hi = mi. This maintains the invariant. At the end of our binary search, hi == lo and lo is the lowest value such that check(lo) is False, so we want lo - 1.</span><br><span class="line"></span><br><span class="line">As for the check itself, we can naively check whether any A[i:i+k] == B[j:j+k] using set structures.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Approach #3: Dynamic Programming [Accepted]</span><br><span class="line">Intuition and Algorithm</span><br><span class="line"></span><br><span class="line">Since a common subarray of A and B must start at some A[i] and B[j], let dp[i][j] be the longest common prefix of A[i:] and B[j:]. Whenever A[i] == B[j], we know dp[i][j] = dp[i+1][j+1] + 1. Also, the answer is max(dp[i][j]) over all i, j.</span><br><span class="line"></span><br><span class="line">We can perform bottom-up dynamic programming to find the answer based on this recurrence. Our loop invariant is that the answer is already calculated correctly and stored in dp for any larger i, j.</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/7bc821d7-1447-46ae-899c-cd1196d3e8fe.jpg"></p><p><img src="https://files.mdnice.com/user/1489/c2a7b9ac-91b4-4ecd-ac11-9c6f89d76202.jpg"></p><p><img src="https://files.mdnice.com/user/1489/83c47edf-7580-482f-9d47-83717761349c.jpg"></p><p><img src="https://files.mdnice.com/user/1489/623c9607-ca24-41cb-a43c-64e5a071ed00.jpg"></p><p><img src="https://files.mdnice.com/user/1489/3d092f02-d8a2-49fe-9ae9-a89efccf9907.jpg"><br><img src="https://files.mdnice.com/user/1489/fcfc655c-34c8-49b5-8ab9-09d72d74a3cb.jpg"></p><h1 id="动态规划：和为K的子数组"><a href="#动态规划：和为K的子数组" class="headerlink" title="动态规划：和为K的子数组"></a><a href="https://leetcode.com/problems/subarray-sum-equals-k/">动态规划：和为K的子数组</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Brief note about Question-</span><br><span class="line"></span><br><span class="line">We have to return the total number of continuous subarrays whose sum equals to k.</span><br><span class="line">Let&#x27;s take an example not given in the question by taking negative numbers</span><br><span class="line">Suppose our arr is arr[]: [-1, -1, 1]  &amp;&amp; k = 0</span><br><span class="line"></span><br><span class="line">So, the answer should be &#x27;1&#x27; as their is only one subarray whose sum is 0 i.e (-1 + 1)</span><br><span class="line">Solution - I (Brute force, TLE)-</span><br><span class="line"></span><br><span class="line">Since we are very obedient person and don&#x27;t want to do anything extra from our side.</span><br><span class="line">So, we will try to generate the sum of each subarray and if matches withk , then increment our answer.</span><br><span class="line">Like, this is the most basic thing we can do.</span><br><span class="line">Time Complexity --&gt; O(n ^ 2) // where n is the size of the array</span><br><span class="line">Space Complexity --&gt; O(1) // we are not using anything extra from our side</span><br><span class="line">It paases [ 85 / 89 ] in built test cases</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/05eda67c-4389-4973-9617-02aefee2129f.jpg"></p><p><img src="https://files.mdnice.com/user/1489/f5cbc2d0-8659-47c7-b189-9da1f9840224.jpg"><br><img src="https://files.mdnice.com/user/1489/2345cdfb-b295-4124-83a5-4cf212022be0.jpg"></p><p><img src="https://files.mdnice.com/user/1489/58a66c05-9434-4a32-89b8-ec1b10ba4c88.jpg"></p><h1 id="动态规划-最长回文子串"><a href="#动态规划-最长回文子串" class="headerlink" title="动态规划:最长回文子串"></a><a href="https://leetcode.com/problems/longest-palindromic-substring">动态规划:最长回文子串</a></h1><p><img src="https://files.mdnice.com/user/1489/d57e3684-a3f8-4baa-a8e1-0909a9b5c969.png"></p><p><img src="https://files.mdnice.com/user/1489/5c8a5c07-af35-4430-8d91-b7a975b4ba33.png"></p><p><img src="https://files.mdnice.com/user/1489/e7b49339-91b4-4ada-a0b5-14ec5d3cb9d9.jpg"></p><p><img src="https://files.mdnice.com/user/1489/77577f23-520d-480a-b4d1-94f1e25aeed7.jpg"><br><img src="https://files.mdnice.com/user/1489/c6f390b2-c832-408a-ab8e-587085f4faf8.jpg"></p><p><img src="https://files.mdnice.com/user/1489/bb53951f-2e43-453c-b6f6-0383e670e50f.jpg"></p><h1 id="位运算-268-丢失的数字"><a href="#位运算-268-丢失的数字" class="headerlink" title="位运算:268. 丢失的数字"></a><a href="https://leetcode.com/problems/missing-number/">位运算:268. 丢失的数字</a></h1><p>给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [3,0,1]<br>输出：2<br>解释：n &#x3D; 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。<br>示例 2：</p><p>输入：nums &#x3D; [0,1]<br>输出：2<br>解释：n &#x3D; 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。<br>示例 3：</p><p>输入：nums &#x3D; [9,6,4,2,3,5,7,0,1]<br>输出：8<br>解释：n &#x3D; 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。<br>示例 4：</p><p>输入：nums &#x3D; [0]<br>输出：1<br>解释：n &#x3D; 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。 </p><p>提示：</p><p>n &#x3D;&#x3D; nums.length<br>1 &lt;&#x3D; n &lt;&#x3D; 104<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; n<br>nums 中的所有数字都 独一无二</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The basic idea is to use XOR operation. We all know that a^b^b =a, which means two xor operations with the same number will eliminate the number and reveal the original number.</span><br><span class="line">In this solution, I apply XOR operation to both the index and value of the array. In a complete array with no missing numbers, the index and value should be perfectly corresponding( nums[index] = index), so in a missing array, what left finally is the missing number.</span><br></pre></td></tr></table></figure><h2 id="Solution1-排序"><a href="#Solution1-排序" class="headerlink" title="Solution1 排序"></a>Solution1 排序</h2><p><img src="https://files.mdnice.com/user/1489/76ff413d-adba-4dd6-a6f7-14af4914335c.png"></p><h2 id="Solution2-求和"><a href="#Solution2-求和" class="headerlink" title="Solution2 求和"></a>Solution2 求和</h2><p><img src="https://files.mdnice.com/user/1489/4c7ba032-9897-4231-bb99-98f8ecdcc362.png"></p><h2 id="Solution3-位运算"><a href="#Solution3-位运算" class="headerlink" title="Solution3 位运算"></a>Solution3 位运算</h2><p><img src="https://files.mdnice.com/user/1489/c5e2d5e5-ba77-4e29-9aa1-9e78c0599f01.png"></p><h2 id="Solution4-哈希"><a href="#Solution4-哈希" class="headerlink" title="Solution4 哈希"></a>Solution4 哈希</h2><p><img src="https://files.mdnice.com/user/1489/d8bbcdd3-9968-4deb-b8db-b0c7f87e0856.png"></p><h1 id="位运算：338-比特位计数"><a href="#位运算：338-比特位计数" class="headerlink" title="位运算：338. 比特位计数\"></a><a href="https://leetcode.com/problems/counting-bits/">位运算：338. 比特位计数</a>\</h1><p>给你一个整数 n ，对于 0 &lt;&#x3D; i &lt;&#x3D; n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。</p><p> </p><p>示例 1：</p><p>输入：n &#x3D; 2<br>输出：[0,1,1]<br>解释：<br>0 –&gt; 0<br>1 –&gt; 1<br>2 –&gt; 10<br>示例 2：</p><p>输入：n &#x3D; 5<br>输出：[0,1,1,2,1,2]<br>解释：<br>0 –&gt; 0<br>1 –&gt; 1<br>2 –&gt; 10<br>3 –&gt; 11<br>4 –&gt; 100<br>5 –&gt; 101 </p><p>提示：</p><p>0 &lt;&#x3D; n &lt;&#x3D; 105 </p><p>进阶：</p><p>很容易就能实现时间复杂度为 O(n log n) 的解决方案，你可以在线性时间复杂度 O(n) 内用一趟扫描解决此问题吗？<br>你能不使用任何内置函数解决此问题吗？（如，C++ 中的 __builtin_popcount ）</p><p><img src="https://files.mdnice.com/user/1489/34b15e82-e8e8-4a37-8eb6-89773c3e5b12.png"></p><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><p>方法一：i &amp; (i - 1)可以去掉i最右边的一个1（如果有），因此 i &amp; (i - 1）是比 i 小的，而且i &amp; (i - 1)的1的个数已经在前面算过了，所以i的1的个数就是 i &amp; (i - 1)的1的个数加上1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">public int[] countBits(int num) &#123;</span><br><span class="line">    int[] res = new int[num + 1];</span><br><span class="line">    for(int i = 1;i&lt;= num;i++)&#123;  //注意要从1开始，0不满足</span><br><span class="line">        res[i] = res[i &amp; (i - 1)] + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p>方法二：i &gt;&gt; 1会把最低位去掉，因此i &gt;&gt; 1 也是比i小的，同样也是在前面的数组里算过。当 i 的最低位是0，则 i 中1的个数和i &gt;&gt; 1中1的个数相同；当i的最低位是1，i 中1的个数是 i &gt;&gt; 1中1的个数再加1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int[] countBits(int num) &#123;</span><br><span class="line">    int[] res = new int[num + 1];</span><br><span class="line">    for(int i = 0;i&lt;= num;i++)&#123;</span><br><span class="line">        res[i] = res[i &gt;&gt; 1] + (i &amp; 1);  //注意i&amp;1需要加括号</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution3"><a href="#Solution3" class="headerlink" title="Solution3"></a>Solution3</h2><p>分奇数和偶数：</p><p>偶数的二进制1个数超级简单，因为偶数是相当于被某个更小的数乘2，乘2怎么来的？在二进制运算中，就是左移一位，也就是在低位多加1个0，那样就说明dp[i] &#x3D; dp[i &#x2F; 2]<br>奇数稍微难想到一点，奇数由不大于该数的偶数+1得到，偶数+1在二进制位上会发生什么？会在低位多加1个1，那样就说明dp[i] &#x3D; dp[i-1] + 1，当然也可以写成dp[i] &#x3D; dp[i &#x2F; 2] + 1<br>就这么简单！！！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; countBits(int num) &#123;</span><br><span class="line">        int i = 1;</span><br><span class="line">        vector&lt;int&gt; ans(num + 1);</span><br><span class="line">        for (int i = 0; i &lt;= num; i++) &#123;</span><br><span class="line">            if (i % 2 == 0) </span><br><span class="line">                ans[i] = ans[i / 2];</span><br><span class="line">            else </span><br><span class="line">                ans[i] = ans[i / 2] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="位运算-371-两整数之和"><a href="#位运算-371-两整数之和" class="headerlink" title="位运算:371. 两整数之和"></a><a href="https://leetcode.com/problems/sum-of-two-integers/">位运算:371. 两整数之和</a></h1><p>给你两个整数 a 和 b ，不使用 运算符 + 和 - ​​​​​​​，计算并返回两整数之和。</p><p> </p><p>示例 1：</p><p>输入：a &#x3D; 1, b &#x3D; 2<br>输出：3<br>示例 2：</p><p>输入：a &#x3D; 2, b &#x3D; 3<br>输出：5 </p><p>提示：</p><p>-1000 &lt;&#x3D; a, b &lt;&#x3D; 1000</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">Now we can not use the + operator, which means it is obvious that we have to use some sort of bit manupulation. But the real question is how?</span><br><span class="line">The ans lies within the procedure of the addition, which I am going to show you below.</span><br><span class="line"></span><br><span class="line">from binary level, how do we exactly add two numbers, let us see --&gt;</span><br><span class="line"></span><br><span class="line">         _</span><br><span class="line">a = 2 = 010</span><br><span class="line">b = 3 = 011</span><br><span class="line">------------</span><br><span class="line">c = 5 = 101</span><br><span class="line">In the position, where we have a dash above, there we are generating a carry, which will be carried over to the next bit, and added to that next bit. So, the addition pattern goes like -</span><br><span class="line"></span><br><span class="line">  0         0         1         1</span><br><span class="line">+ 0        +1       + 0       + 1</span><br><span class="line">----      ----      ----      ----</span><br><span class="line">  0         1         1         0 (with a carry 1)</span><br><span class="line">Is this pattern similar to you? Have you seen this in the XOR table? Let&#x27;s see the XOR table quickly -</span><br><span class="line"></span><br><span class="line">a b | XOR</span><br><span class="line">- - | - -</span><br><span class="line">0 0 | 0</span><br><span class="line">0 1 | 1</span><br><span class="line">1 0 | 1</span><br><span class="line">1 1 | 0</span><br><span class="line">These are the exact same, hence for addition, we need to use the XOR operator. But what to do with the carry? Hey, we need to add that carry to the next bit, right? That is what we have seen in the implementation of the addition as well. We will do that only, but we can NOT use addition anyway.</span><br><span class="line">But, before that, let&#x27;s do the XOR for 2 and 3 example.</span><br><span class="line"></span><br><span class="line">-- Doing only XOR --</span><br><span class="line">a = 2 = 010</span><br><span class="line">b = 3 = 011</span><br><span class="line">------------</span><br><span class="line">c = 1 = 001</span><br><span class="line">1 is NOT our answer, and in this procedure, we have left the carry out, which is 100. Now what&#x27;s the pattern for finding the carry? It is after we AND the two numbers, we will LEFT-SHIFT the result by 1. Didn&#x27;t get it?</span><br><span class="line"></span><br><span class="line">-- Doing only AND --</span><br><span class="line">a = 2 = 010</span><br><span class="line">b = 3 = 011</span><br><span class="line">------------</span><br><span class="line">c = 2 = 010</span><br><span class="line">-----------</span><br><span class="line">Doing Left-Shift by 1 (&lt;&lt;1)</span><br><span class="line">-----------</span><br><span class="line">c = 4 = 100</span><br><span class="line">So, we found out the carry as well, and believe me or not, but it is the entire Algorithm. You have to repeat the steps of 1. XOR and 2. AND with Left-Shift, until the step no 2. becomes 0, and you will have your answer.</span><br><span class="line"></span><br><span class="line">Example -</span><br><span class="line"></span><br><span class="line">a = 2 = 010</span><br><span class="line">b = 3 = 011</span><br><span class="line">-----------</span><br><span class="line">x = 1 = 001 = a</span><br><span class="line">c = 4 = 100 = b</span><br><span class="line">-----------</span><br><span class="line">x = 5 = 101</span><br><span class="line">c = 0 = 000</span><br><span class="line"></span><br><span class="line">x = XOR &amp; c = AND with Left-Shift</span><br><span class="line">Since carry becomes 0, hence our answer is the XOR result = 5.</span><br><span class="line"></span><br><span class="line">Below is the working code for the same, and you can run this code to find the desired answer.</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int getSum(int a, int b) &#123;</span><br><span class="line">        while(b != 0)&#123;</span><br><span class="line">            int temp = (a&amp;b)&lt;&lt;1;</span><br><span class="line">            a = a ^ b;</span><br><span class="line">            b = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Time Complexity: O(1)</span><br><span class="line">Space Complexity: O(1)</span><br><span class="line"></span><br><span class="line">Time is O(1), because the max and min bounds are 1000 and -1000 respectively, which means the input will NOT be arbitrarily large, and it will be in the limits, hence the time will be constant.</span><br><span class="line"></span><br><span class="line">The code for c and c++ will be very similar, and python will be a little different. If you like this approach, then please give me a thumbs up.</span><br><span class="line"></span><br><span class="line">Thanks &amp; Happy Coding :)</span><br></pre></td></tr></table></figure><h2 id="Solution1-位运算"><a href="#Solution1-位运算" class="headerlink" title="Solution1 位运算"></a>Solution1 位运算</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int getSum(int a, int b) </span><br><span class="line">&#123;</span><br><span class="line">    int sum, carry; </span><br><span class="line">    sum = a ^ b;  //异或这里可看做是相加但是不显现进位，比如5 ^ 3</span><br><span class="line">                 /*0 1 0 1</span><br><span class="line">                   0 0 1 1</span><br><span class="line">                 ------------</span><br><span class="line">                   0 1 1 0      </span><br><span class="line">              上面的如果看成传统的加法，不就是1+1=2，进1得0，但是这里没有显示进位出来，仅是相加，0+1或者是1+0都不用进位*/</span><br><span class="line">    </span><br><span class="line">    carry = (a &amp; b) &lt;&lt; 1;</span><br><span class="line">    </span><br><span class="line">                //相与为了让进位显现出来，比如5 &amp; 3</span><br><span class="line">                /* 0 1 0 1</span><br><span class="line">                   0 0 1 1</span><br><span class="line">                 ------------</span><br><span class="line">                   0 0 0 1</span><br><span class="line">              上面的最低位1和1相与得1，而在二进制加法中，这里1+1也应该是要进位的，所以刚好吻合，但是这个进位1应该要再往前一位，所以左移一位*/</span><br><span class="line">    </span><br><span class="line">    if(carry != 0)  //经过上面这两步，如果进位不等于0，那么就是说还要把进位给加上去，所以用了尾递归，一直递归到进位是0。</span><br><span class="line">    &#123;</span><br><span class="line">        return getSum(sum, carry);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="位运算：数组中数字出现的次数"><a href="#位运算：数组中数字出现的次数" class="headerlink" title="位运算：数组中数字出现的次数"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof">位运算：数组中数字出现的次数</a></h1><p><img src="https://files.mdnice.com/user/1489/7d866548-cf10-4e94-b709-7f71ef98a483.jpg"></p><p><img src="https://files.mdnice.com/user/1489/3b246e5f-80a9-4142-afcc-f87821e72388.jpg"></p><p><img src="https://files.mdnice.com/user/1489/40509b75-a36f-4c79-88d3-5bfc2084e109.jpg"></p><p><img src="https://files.mdnice.com/user/1489/a871d490-3098-4744-acd1-27faa3facd1e.jpg"></p><h1 id="位运算：不用加减乘除做加法"><a href="#位运算：不用加减乘除做加法" class="headerlink" title="位运算：不用加减乘除做加法"></a><a href="https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof">位运算：不用加减乘除做加法</a></h1><p><img src="https://files.mdnice.com/user/1489/861c46f5-40c1-4452-bae1-d1fe40b46687.jpg"></p><h1 id="位运算-汉明距离"><a href="#位运算-汉明距离" class="headerlink" title="位运算:汉明距离"></a><a href="https://leetcode.com/problems/hamming-distance">位运算:汉明距离</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Solution I:</span><br><span class="line">We use XOR bitwise operatoin to get all the bits that are set either in x or in y, not both.</span><br><span class="line">Then we count the number of such bits and we&#x27;re done!</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hammingDistance(int x, int y) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        int num = x^y;</span><br><span class="line">        while (num) &#123;</span><br><span class="line">            res += num % 2;</span><br><span class="line">            num &gt;&gt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Solution II - Without XOR:</span><br><span class="line">We iterate x and y in parallel.</span><br><span class="line">If (x % 2 != y % 2) - only one of the rightmost bits are set - we add one to res.</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int hammingDistance(int x, int y) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        while (x || y) &#123;</span><br><span class="line">            res += (x % 2 != y % 2);</span><br><span class="line">            x &gt;&gt;= 1, y &gt;&gt;= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/65b0b068-a855-410f-833f-0cd18b42c057.jpg"></p><p><img src="https://files.mdnice.com/user/1489/127549f9-fa4e-440b-9f58-7e2ec00d19dc.jpg"></p><h1 id="位运算-二进制中1的个数"><a href="#位运算-二进制中1的个数" class="headerlink" title="位运算:二进制中1的个数"></a><a href="https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof">位运算:二进制中1的个数</a></h1><p><img src="https://files.mdnice.com/user/1489/1da2c2bf-57a1-4e47-87f9-613dbee436fb.jpg"></p><p><img src="https://files.mdnice.com/user/1489/7d2f2092-3b35-4543-806a-3426630f698d.jpg"></p><h1 id="位运算：数字的补数"><a href="#位运算：数字的补数" class="headerlink" title="位运算：数字的补数"></a><a href="https://leetcode-cn.com/problems/number-complement/">位运算：数字的补数</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">✔️ Solution - I (Brute-Force)</span><br><span class="line"></span><br><span class="line">We can simply iterate and find the leftmost bit (MSB) that is set. From that point onwards, we flip every bit till we reach the rightmost bit (LSB). To flip a bit, we can use ^ 1 (XOR 1) operation. This will flip a bit to 0 if it is set and flip to 1 if it is unset.</span><br><span class="line"></span><br><span class="line">C++</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findComplement(int num) &#123;</span><br><span class="line">        int i = 31;</span><br><span class="line">        while((num &amp; 1 &lt;&lt; i) == 0) i--;   // skip the left 0 bits till we reach the 1st set bit from left</span><br><span class="line">        while(i &gt;= 0)</span><br><span class="line">            num ^= 1 &lt;&lt; i--;              // flip all bits by XORing with 1</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Python</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def findComplement(self, num):</span><br><span class="line">        i = 31</span><br><span class="line">        while (num &amp; 1 &lt;&lt; i) == 0: </span><br><span class="line">            i -= 1</span><br><span class="line">        while i &gt;= 0:</span><br><span class="line">            num ^= 1 &lt;&lt; i</span><br><span class="line">            i -= 1</span><br><span class="line">        return num</span><br><span class="line">Time Complexity : O(N), where N is the number of bits. In this case, since we are starting from i=31, it should be constant but I am denoting time complexity of this approach as generalized O(N)</span><br><span class="line">Space Complexity : O(1)</span><br><span class="line"></span><br><span class="line">✔️ Solution - II (Bit-Manipulation Tricks)</span><br><span class="line"></span><br><span class="line">The above method basically finds the leftmost set bit and XORs the remaining bits with 1. A more efficient way to do the same would be to simply XOR num with another number having all bits to the right of nums&#x27;s 1st set bit as 1 and rest bit to left as 0. This would achieve the same thing as above.</span><br><span class="line"></span><br><span class="line">For eg. num = 13</span><br><span class="line">=&gt;  num  = 13  (1101)</span><br><span class="line">=&gt;  mask = 15  (1111)</span><br><span class="line">--------------------</span><br><span class="line">   ^       2   (0010)    We got all the bits flipped</span><br><span class="line">But how to get mask?</span><br><span class="line"></span><br><span class="line">A simple way would be to initialize mask = 0 and keep flipping bits of it to 1 starting from the rightmost bit (LSB) till we reach the leftmost set bit of num.</span><br><span class="line">Now, how do we know that we reached the leftmost set bit in num?</span><br><span class="line"></span><br><span class="line">We use another variable tmp = num. Each time, we will rightshift tmp essentially removing the rightmost bit. When we remove the leftmost set bit from it, it will become 0. Thus, we loop till tmp is not 0.</span><br><span class="line">C++</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findComplement(int num) &#123;</span><br><span class="line">        int mask = 0;                                 // all bits in mask are initially 0</span><br><span class="line">        for(int tmp = num; tmp; tmp &gt;&gt;= 1)            // set bits in mask to 1 till we reach leftmost set bit in num</span><br><span class="line">            mask = (mask &lt;&lt; 1) | 1;                   // leftshifts and sets the rightmost bit to 1</span><br><span class="line"></span><br><span class="line">        return mask ^ num;                            // finally XORing with mask will flip all bits in num</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Python</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def findComplement(self, num):</span><br><span class="line">        mask, tmp = 0, num</span><br><span class="line">        while tmp:</span><br><span class="line">            mask = (mask &lt;&lt; 1) | 1</span><br><span class="line">            tmp &gt;&gt;= 1</span><br><span class="line">        return mask ^ num</span><br><span class="line">Another way to do the same would be to the other way around and start with mask with all bits as 1. Then we keep setting rightmost bits in mask to 0 one by one till there are no common set bits left in num and mask (num &amp; mask == 0 when no common set bits are present).</span><br><span class="line"></span><br><span class="line">For eg. num = 13 (1101)  and  mask = -1 (111...1111)  [all 32 set bits are set in -1 binary representation]</span><br><span class="line"> </span><br><span class="line">1. num =  000...1101 </span><br><span class="line">   mask = 111...1110   =&gt; we still have common set bits</span><br><span class="line">   </span><br><span class="line">2. num =  000...1101 </span><br><span class="line">   mask = 111...1100   =&gt; we still have common set bits   </span><br><span class="line">  </span><br><span class="line">3. num =  000...1101</span><br><span class="line">   mask = 111...1000   =&gt; we still have common set bits  </span><br><span class="line">   </span><br><span class="line">4. num =  000...1101 </span><br><span class="line">   mask = 111...0000   =&gt; no more common bits left</span><br><span class="line">Now what?</span><br><span class="line"></span><br><span class="line">Now we can simply flip all bits in mask (using ~ operator). It will now have all rightmost bits set to one starting from leftmost set bit in num, i.e, we now have the same mask that we had in previous approach.</span><br><span class="line">Now, we can XOR it with num and we get the flipped result</span><br><span class="line">C++</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findComplement(int num) &#123;</span><br><span class="line">        uint mask = -1;                             // -1 is represented in binary as all bits set to 1</span><br><span class="line">        while(mask &amp; num) mask &lt;&lt;= 1;               // remove rightmost bits 1 by 1 till no common bits are left</span><br><span class="line">        return ~mask ^ num;                         // XORs with 1 &amp; flips all bits in num starting from the leftmost set bit </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Python</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def findComplement(self, num):</span><br><span class="line">        mask = -1</span><br><span class="line">        while mask &amp; num: mask &lt;&lt;= 1</span><br><span class="line">        return ~mask ^ num</span><br><span class="line">This approach used 1 less operation inside loop (1st approach used 3 operations: right-shift &gt;&gt; on tmp, left-shift &lt;&lt; on mask and | with 1 to set rightmost bit. This one uses 2: &amp; to check if there are common bits in mask and num and left-shift &lt;&lt; to remove the right set bits one by one)</span><br><span class="line"></span><br><span class="line">Time Complexity : O(P) / O(log num), where P is the position of leftmost set bit in num. O(P) ~ O(log2(num))</span><br><span class="line">Space Complexity : O(1)</span><br><span class="line"></span><br><span class="line">✔️ Solution - III (Flip Bits from Right to Left)</span><br><span class="line"></span><br><span class="line">We can start from the right-end and flip bits one by one. This is somewhat similar to 1st solution in above appraoch. But here we will not use mask but rather a bit starting with i=1 and just directly XOR it with num, then left-shift it &amp; repeat thus flipping the bits in num one by one.</span><br><span class="line"></span><br><span class="line">So, how do we know when to stop? We stop as soon i &gt; num. This denotes that we have passed the leftmost set bit in num and thus we have flipped all the bits that needed to be flipped.</span><br><span class="line"></span><br><span class="line">C++</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findComplement(int num) &#123;</span><br><span class="line">        int i = 1;</span><br><span class="line">        while(i &lt;= num)</span><br><span class="line">            num ^= i,</span><br><span class="line">            i &lt;&lt;= 1;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Python</span><br><span class="line"></span><br><span class="line">class Solution():</span><br><span class="line">    def findComplement(self, num):</span><br><span class="line">        i = 1</span><br><span class="line">        while i &lt;= num:</span><br><span class="line">            num ^= i</span><br><span class="line">            i &lt;&lt;= 1</span><br><span class="line">        return num    </span><br><span class="line">Time Complexity : O(P) / O(log num)</span><br><span class="line">Space Complexity : O(1)</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/c27eca08-3f9b-4813-b858-da16881adde7.jpg"></p><p><img src="https://files.mdnice.com/user/1489/5d0202cd-9252-47fc-bb24-c44a7962fc24.jpg"></p><h1 id="递归：-24-两两交换链表中的节点"><a href="#递归：-24-两两交换链表中的节点" class="headerlink" title="递归： 24. 两两交换链表中的节点"></a><a href="https://leetcode.com/problems/swap-nodes-in-pairs/">递归： 24. 两两交换链表中的节点</a></h1><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p> </p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4]<br>输出：[2,1,4,3]<br>示例 2：</p><p>输入：head &#x3D; []<br>输出：[]<br>示例 3：</p><p>输入：head &#x3D; [1]<br>输出：[1]</p><h2 id="Solution1-递归-1"><a href="#Solution1-递归-1" class="headerlink" title="Solution1  递归"></a>Solution1  递归</h2><p><img src="https://files.mdnice.com/user/1489/c072ce6a-4174-41b0-b176-459494233b1e.png"></p><p><img src="https://files.mdnice.com/user/1489/01f7eaa0-e02c-4bf6-9dbb-4efcf67513b5.png"></p><p><img src="https://files.mdnice.com/user/1489/34777dfe-25ba-4a81-883e-b66110b1a8c9.png"></p><h2 id="Solution2-迭代"><a href="#Solution2-迭代" class="headerlink" title="Solution2 迭代"></a>Solution2 迭代</h2><p><img src="https://files.mdnice.com/user/1489/8b223432-03ba-43a5-8968-584c7c8d8068.png"></p><p><img src="https://files.mdnice.com/user/1489/36ee0f58-1bce-411c-b3fc-308d769ad869.png"></p><h1 id="树-x2F-递归：95-不同的二叉搜索树-II"><a href="#树-x2F-递归：95-不同的二叉搜索树-II" class="headerlink" title="树&#x2F;递归：95. 不同的二叉搜索树 II"></a><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/">树&#x2F;递归：95. 不同的二叉搜索树 II</a></h1><p>给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。</p><p> </p><p>示例 1：</p><p>输入：n &#x3D; 3<br>输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]<br>示例 2：</p><p>输入：n &#x3D; 1<br>输出：[[1]] </p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 8</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The basic idea is that we can construct the result of n node tree just from the result of n-1 node tree.</span><br><span class="line">Here&#x27;s how we do it: only 2 conditions: 1) The nth node is the new root, so newroot-&gt;left = oldroot;</span><br><span class="line">2) the nth node is not root, we traverse the old tree, every time the node in the old tree has a right child, we can perform: old node-&gt;right = nth node, nth node -&gt;left = right child; and when we reach the end of the tree, don&#x27;t forget we can also add the nth node here.</span><br><span class="line">One thing to notice is that every time we push a TreeNode in our result, I push the clone version of the root, and I recover what I do to the old node immediately. This is because you may use the old tree for several times.</span><br></pre></td></tr></table></figure><h2 id="Solution1-回溯-2"><a href="#Solution1-回溯-2" class="headerlink" title="Solution1 回溯"></a>Solution1 回溯</h2><p><img src="https://files.mdnice.com/user/1489/a150914f-1207-4dc6-8091-639f11405933.png"></p><p><img src="https://files.mdnice.com/user/1489/d66220b0-0d89-479e-9313-6adce6816e8c.png"></p><h1 id="树-x2F-递归：98-验证二叉搜索树"><a href="#树-x2F-递归：98-验证二叉搜索树" class="headerlink" title="树&#x2F;递归：98. 验证二叉搜索树"></a><a href="https://leetcode.com/problems/validate-binary-search-tree/">树&#x2F;递归：98. 验证二叉搜索树</a></h1><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。 </p><p>示例 1：</p><p>输入：root &#x3D; [2,1,3]<br>输出：true<br>示例 2：</p><p>输入：root &#x3D; [5,1,4,null,null,3,6]<br>输出：false<br>解释：根节点的值是 5 ，但是右子节点的值是 4 。 </p><p>提示：</p><p>树中节点数目范围在[1, 104] 内<br>-231 &lt;&#x3D; Node.val &lt;&#x3D; 231 - 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">For the recursive solution, we set a lower bound and a upper bound for the tree. When we recurse on the left subtree, the upper bound becomes the value of its root. When we recurse on the right subtree, the lower bound becomes the value of its root.</span><br></pre></td></tr></table></figure><h2 id="Solution1-递归-2"><a href="#Solution1-递归-2" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><p>方法一: 递归<br>思路和算法</p><p>要解决这道题首先我们要了解二叉搜索树有什么性质可以给我们利用，由题目给出的信息我们可以知道：如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。</p><p>这启示我们设计一个递归函数 helper(root, lower, upper) 来递归判断，函数表示考虑以 root 为根的子树，判断子树中所有节点的值是否都在 (l,r)(l,r) 的范围内（注意是开区间）。如果 root 节点的值 val 不在 (l,r)(l,r) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。</p><p>那么根据二叉搜索树的性质，在递归调用左子树时，我们需要把上界 upper 改为 root.val，即调用 helper(root.left, lower, root.val)，因为左子树里所有节点的值均小于它的根节点的值。同理递归调用右子树时，我们需要把下界 lower 改为 root.val，即调用 helper(root.right, root.val, upper)。</p><p>函数递归调用的入口为 helper(root, -inf, +inf)， inf 表示一个无穷大的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool helper(TreeNode* root, long long lower, long long upper) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root -&gt; val &lt;= lower || root -&gt; val &gt;= upper) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return helper(root -&gt; left, lower, root -&gt; val) &amp;&amp; helper(root -&gt; right, root -&gt; val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        return helper(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(n)O(n)，其中 nn 为二叉树的节点个数。在递归调用的时候二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)O(n)。</p><p>空间复杂度：O(n)O(n)，其中 nn 为二叉树的节点个数。递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，即二叉树的高度。最坏情况下二叉树为一条链，树的高度为 nn ，递归最深达到 nn 层，故最坏情况下空间复杂度为 O(n)O(n) 。</p><h2 id="Solution2-中序遍历为升序"><a href="#Solution2-中序遍历为升序" class="headerlink" title="Solution2 中序遍历为升序"></a>Solution2 中序遍历为升序</h2><p>基于方法一中提及的性质，我们可以进一步知道二叉搜索树「中序遍历」得到的值构成的序列一定是升序的，这启示我们在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。如果均大于说明这个序列是升序的，整棵树是二叉搜索树，否则不是，下面的代码我们使用栈来模拟中序遍历的过程。</p><p>可能有读者不知道中序遍历是什么，我们这里简单提及。中序遍历是二叉树的一种遍历方式，它先遍历左子树，再遍历根节点，最后遍历右子树。而我们二叉搜索树保证了左子树的节点的值均小于根节点的值，根节点的值均小于右子树的值，因此中序遍历以后得到的序列一定是升序序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stack;</span><br><span class="line">        long long inorder = (long long)INT_MIN - 1;</span><br><span class="line"></span><br><span class="line">        while (!stack.empty() || root != nullptr) &#123;</span><br><span class="line">            while (root != nullptr) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root -&gt; left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.top();</span><br><span class="line">            stack.pop();</span><br><span class="line">            // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树</span><br><span class="line">            if (root -&gt; val &lt;= inorder) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            inorder = root -&gt; val;</span><br><span class="line">            root = root -&gt; right;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(n)O(n)，其中 nn 为二叉树的节点个数。二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)O(n)。</p><p>空间复杂度：O(n)O(n)，其中 nn 为二叉树的节点个数。栈最多存储 nn 个节点，因此需要额外的 O(n)O(n) 的空间。</p><h1 id="树-x2F-递归：101-对称二叉树"><a href="#树-x2F-递归：101-对称二叉树" class="headerlink" title="树&#x2F;递归：101. 对称二叉树"></a><a href="https://leetcode.com/problems/symmetric-tree/">树&#x2F;递归：101. 对称二叉树</a></h1><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p><p> </p><p>示例 1：</p><p>输入：root &#x3D; [1,2,2,3,4,4,3]<br>输出：true<br>示例 2：</p><p>输入：root &#x3D; [1,2,2,null,3,null,3]<br>输出：false </p><p>提示：</p><p>树中节点数目在范围 [1, 1000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100 </p><p>进阶：你可以运用递归和迭代两种方法解决这个问题吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Explanation :</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool solve(TreeNode * r1, TreeNode * r2)</span><br><span class="line">    &#123;</span><br><span class="line">        // See the tree diagram are r1 and r2 null ? No, so this line dont execute</span><br><span class="line">        if(r1 == NULL &amp;&amp; r2 == NULL)</span><br><span class="line">            return true; </span><br><span class="line"></span><br><span class="line">        // Is any one of r1 or r2 null ? Or are these values different ? No. Both values are</span><br><span class="line">        // same so this else if wont execute either</span><br><span class="line">        else if(r1 == NULL || r2 == NULL || r1-&gt;val != r2-&gt;val)</span><br><span class="line">            return false; </span><br><span class="line">        </span><br><span class="line">        // Now comes the main part, we are calling 2 seperate function calls </span><br><span class="line">        return solve(r1-&gt;left, r2-&gt;right) &amp;&amp; solve(r1-&gt;right, r2-&gt;left);</span><br><span class="line">        // First solve() before &amp;&amp; will execute</span><br><span class="line">        // r1-&gt;left is 3 and r2-&gt;right = 3</span><br><span class="line">        // Both values are same , they will by pass both if and else if statement</span><br><span class="line">        // Now again r1-&gt;left is null and r2-&gt;right is null</span><br><span class="line">        // So they will return true from first if condtion</span><br><span class="line">        // Now the scene is : we have executed first solve() before &amp;&amp; and it has</span><br><span class="line">        // returned us True so expression becomes &#x27; return true &amp;&amp; solve() &#x27;</span><br><span class="line">        // Now solve after &amp;&amp; will execute </span><br><span class="line">        // Similarly it will check for 4 and 4 , it will by pass if else statements</span><br><span class="line">        // next time both will become null, so will return true</span><br><span class="line">        // Thus 2nd solve() at the end will also hold true</span><br><span class="line">        // and we know &#x27;true &amp;&amp; true&#x27; is true</span><br><span class="line">        // so true will be returned to caller, and thus tree is mirror of itself.</span><br><span class="line">        // Similarly you can check for any testcase, flow of execution will remain same.</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool isSymmetric(TreeNode* root) </span><br><span class="line">    &#123;</span><br><span class="line">        // Imagine a tree:    1</span><br><span class="line">        //                 2     2</span><br><span class="line">        //               3   4 4   3</span><br><span class="line">        // We are standing on root that is 1, function begins</span><br><span class="line">        // and now r1 and r2 points to 2 and 2 respectively.                      </span><br><span class="line">        return solve(root-&gt;left, root-&gt;right);     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution1-递归-3"><a href="#Solution1-递归-3" class="headerlink" title="Solution1  递归"></a>Solution1  递归</h2><p><img src="https://files.mdnice.com/user/1489/17bcb971-2dd2-4659-a84f-24493a37c88e.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">if(root==null) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">//调用递归函数，比较左节点，右节点</span><br><span class="line">return dfs(root.left,root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean dfs(TreeNode left, TreeNode right) &#123;</span><br><span class="line">//递归的终止条件是两个节点都为空</span><br><span class="line">//或者两个节点中有一个为空</span><br><span class="line">//或者两个节点的值不相等</span><br><span class="line">if(left==null &amp;&amp; right==null) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">if(left==null || right==null) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">if(left.val!=right.val) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">//再递归的比较 左节点的左孩子 和 右节点的右孩子</span><br><span class="line">//以及比较  左节点的右孩子 和 右节点的左孩子</span><br><span class="line">return dfs(left.left,right.right) &amp;&amp; dfs(left.right,right.left);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution2-队列"><a href="#Solution2-队列" class="headerlink" title="Solution2 队列"></a>Solution2 队列</h2><p>回想下递归的实现：<br>当两个子树的根节点相等时，就比较:<br>左子树的 left 和 右子树的 right，这个比较是用递归实现的。<br>现在我们改用队列来实现，思路如下：<br>首先从队列中拿出两个节点(left 和 right)比较<br>将 left 的 left 节点和 right 的 right 节点放入队列<br>将 left 的 right 节点和 right 的 left 节点放入队列<br>时间复杂度是 O(n)O(n)，空间复杂度是 O(n)O(n)<br>动画演示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">if(root==null || (root.left==null &amp;&amp; root.right==null)) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">//用队列保存节点</span><br><span class="line">LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">//将根节点的左右孩子放到队列中</span><br><span class="line">queue.add(root.left);</span><br><span class="line">queue.add(root.right);</span><br><span class="line">while(queue.size()&gt;0) &#123;</span><br><span class="line">//从队列中取出两个节点，再比较这两个节点</span><br><span class="line">TreeNode left = queue.removeFirst();</span><br><span class="line">TreeNode right = queue.removeFirst();</span><br><span class="line">//如果两个节点都为空就继续循环，两者有一个为空就返回false</span><br><span class="line">if(left==null &amp;&amp; right==null) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">if(left==null || right==null) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">if(left.val!=right.val) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">//将左节点的左孩子， 右节点的右孩子放入队列</span><br><span class="line">queue.add(left.left);</span><br><span class="line">queue.add(right.right);</span><br><span class="line">//将左节点的右孩子，右节点的左孩子放入队列</span><br><span class="line">queue.add(left.right);</span><br><span class="line">queue.add(right.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="递归：200-岛屿数量"><a href="#递归：200-岛屿数量" class="headerlink" title="递归：200. 岛屿数量"></a><a href="https://leetcode.com/problems/number-of-islands/">递归：200. 岛屿数量</a></h1><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p> </p><p>示例 1：</p><p>输入：grid &#x3D; [<br>  [“1”,”1”,”1”,”1”,”0”],<br>  [“1”,”1”,”0”,”1”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”0”,”0”,”0”]<br>]<br>输出：1<br>示例 2：</p><p>输入：grid &#x3D; [<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”1”,”0”,”0”],<br>  [“0”,”0”,”0”,”1”,”1”]<br>]<br>输出：3 </p><p>提示：</p><p>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 300<br>grid[i][j] 的值为 ‘0’ 或 ‘1’</p><p><img src="https://files.mdnice.com/user/1489/6128b483-caa2-4730-a94c-7b53e02cb7b0.png"></p><h2 id="Solution1-DFS"><a href="#Solution1-DFS" class="headerlink" title="Solution1  DFS"></a>Solution1  DFS</h2><p>思路：遍历岛这个二维数组，如果当前数为1，则进入感染函数并将岛个数+1<br>感染函数：其实就是一个递归标注的过程，它会将所有相连的1都标注成2。为什么要标注？这样就避免了遍历过程中的重复计数的情况，一个岛所有的1都变成了2后，遍历的时候就不会重复遍历了。建议没想明白的同学画个图看看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numIslands(char[][] grid) &#123;</span><br><span class="line">        int islandNum = 0;</span><br><span class="line">        for(int i = 0; i &lt; grid.length; i++)&#123;</span><br><span class="line">            for(int j = 0; j &lt; grid[0].length; j++)&#123;</span><br><span class="line">                if(grid[i][j] == &#x27;1&#x27;)&#123;</span><br><span class="line">                    infect(grid, i, j);</span><br><span class="line">                    islandNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return islandNum;</span><br><span class="line">    &#125;</span><br><span class="line">    //感染函数</span><br><span class="line">    public void infect(char[][] grid, int i, int j)&#123;</span><br><span class="line">        if(i &lt; 0 || i &gt;= grid.length ||</span><br><span class="line">           j &lt; 0 || j &gt;= grid[0].length || grid[i][j] != &#x27;1&#x27;)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = &#x27;2&#x27;;</span><br><span class="line">        infect(grid, i + 1, j);</span><br><span class="line">        infect(grid, i - 1, j);</span><br><span class="line">        infect(grid, i, j + 1);</span><br><span class="line">        infect(grid, i, j - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Solution2-BFS"><a href="#Solution2-BFS" class="headerlink" title="Solution2 BFS"></a>Solution2 BFS</h2><p>主循环和思路一类似，不同点是在于搜索某岛屿边界的方法不同。<br>bfs 方法：<br>借用一个队列 queue，判断队列首部节点 (i, j) 是否未越界且为 1：<br>若是则置零（删除岛屿节点），并将此节点上下左右节点 (i+1,j),(i-1,j),(i,j+1),(i,j-1) 加入队列；<br>若不是则跳过此节点；<br>循环 pop 队列首节点，直到整个队列为空，此时已经遍历完此岛屿。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numIslands(char[][] grid) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for(int i = 0; i &lt; grid.length; i++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; grid[0].length; j++) &#123;</span><br><span class="line">                if(grid[i][j] == &#x27;1&#x27;)&#123;</span><br><span class="line">                    bfs(grid, i, j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">    private void bfs(char[][] grid, int i, int j)&#123;</span><br><span class="line">        Queue&lt;int[]&gt; list = new LinkedList&lt;&gt;();</span><br><span class="line">        list.add(new int[] &#123; i, j &#125;);</span><br><span class="line">        while(!list.isEmpty())&#123;</span><br><span class="line">            int[] cur = list.remove();</span><br><span class="line">            i = cur[0]; j = cur[1];</span><br><span class="line">            if(0 &lt;= i &amp;&amp; i &lt; grid.length &amp;&amp; 0 &lt;= j &amp;&amp; j &lt; grid[0].length &amp;&amp; grid[i][j] == &#x27;1&#x27;) &#123;</span><br><span class="line">                grid[i][j] = &#x27;0&#x27;;</span><br><span class="line">                list.add(new int[] &#123; i + 1, j &#125;);</span><br><span class="line">                list.add(new int[] &#123; i - 1, j &#125;);</span><br><span class="line">                list.add(new int[] &#123; i, j + 1 &#125;);</span><br><span class="line">                list.add(new int[] &#123; i, j - 1 &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="递归：206-反转链表"><a href="#递归：206-反转链表" class="headerlink" title="递归：206. 反转链表"></a><a href="https://leetcode.com/problems/reverse-linked-list/">递归：206. 反转链表</a></h1><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 </p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4,5]<br>输出：[5,4,3,2,1]<br>示例 2：</p><p>输入：head &#x3D; [1,2]<br>输出：[2,1]<br>示例 3：</p><p>输入：head &#x3D; []<br>输出：[] </p><p>提示：</p><p>链表中节点的数目范围是 [0, 5000]<br>-5000 &lt;&#x3D; Node.val &lt;&#x3D; 5000 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Well, since the head pointer may also be modified, we create a pre that points to it to facilitate the reverse process.</span><br><span class="line"></span><br><span class="line">For the example list 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 in the problem statement, it will become 0 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 (we init pre -&gt; val to be 0). We also set a pointer cur to head. Then we keep inserting cur -&gt; next after pre until cur becomes the last node. This idea uses three pointers (pre, cur and temp). You may implement it as follows.</span><br></pre></td></tr></table></figure><h2 id="Solution1-迭代"><a href="#Solution1-迭代" class="headerlink" title="Solution1 迭代"></a>Solution1 迭代</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/迭代法</span><br><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">    ListNode pre = null;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    while(cur!=null) &#123;</span><br><span class="line">        ListNode next = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    return pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Solution2-递归"><a href="#Solution2-递归" class="headerlink" title="Solution2 递归"></a>Solution2 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//尾递归</span><br><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">    return reverse(null,head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static ListNode reverse(ListNode pre,ListNode cur)&#123;</span><br><span class="line">    if(cur==null) return pre;</span><br><span class="line">    ListNode next = cur.next;</span><br><span class="line">    cur.next = pre;</span><br><span class="line">    return reverse(cur,next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树-x2F-递归：235-二叉搜索树的最近公共祖先"><a href="#树-x2F-递归：235-二叉搜索树的最近公共祖先" class="headerlink" title="树&#x2F;递归：235. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">树&#x2F;递归：235. 二叉搜索树的最近公共祖先</a></h1><p><img src="https://files.mdnice.com/user/1489/183fb47d-cb82-4909-bfae-8f78c632e7ea.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Well, remember to take advantage of the property of binary search trees, which is, node -&gt; left -&gt; val &lt; node -&gt; val &lt; node -&gt; right -&gt; val. Moreover, both p and q will be the descendants of the root of the subtree that contains both of them. And the root with the largest depth is just the lowest common ancestor. This idea can be turned into the following simple recursive code.</span><br></pre></td></tr></table></figure><h2 id="Solution1-非递归"><a href="#Solution1-非递归" class="headerlink" title="Solution1  非递归"></a>Solution1  非递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">      //如果根节点和p,q的差相乘是正数，说明这两个差值要么都是正数要么都是负数，也就是说</span><br><span class="line">      //他们肯定都位于根节点的同一侧，就继续往下找</span><br><span class="line">      while ((root.val - p.val) * (root.val - q.val) &gt; 0)</span><br><span class="line">          root = p.val &lt; root.val ? root.left : root.right;</span><br><span class="line">      //如果相乘的结果是负数，说明p和q位于根节点的两侧，如果等于0，说明至少有一个就是根节点</span><br><span class="line">      return root;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution2-递归-1"><a href="#Solution2-递归-1" class="headerlink" title="Solution2 递归"></a>Solution2 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">    //如果小于等于0，说明p和q位于root的两侧，直接返回即可</span><br><span class="line">    if ((root.val - p.val) * (root.val - q.val) &lt;= 0)</span><br><span class="line">        return root;</span><br><span class="line">    //否则，p和q位于root的同一侧，就继续往下找</span><br><span class="line">    return lowestCommonAncestor(p.val &lt; root.val ? root.left : root.right, p, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="树-x2F-递归：236-二叉树的最近公共祖先"><a href="#树-x2F-递归：236-二叉树的最近公共祖先" class="headerlink" title="树&#x2F;递归：236. 二叉树的最近公共祖先"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">树&#x2F;递归：236. 二叉树的最近公共祖先</a></h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p> </p><p>示例 1：</p><p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。<br>示例 2：</p><p>输入：root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4<br>输出：5<br>解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。<br>示例 3：</p><p>输入：root &#x3D; [1,2], p &#x3D; 1, q &#x3D; 2<br>输出：1 </p><p>提示：</p><p>树中节点数目在范围 [2, 105] 内。<br>-109 &lt;&#x3D; Node.val &lt;&#x3D; 109<br>所有 Node.val 互不相同 。<br>p !&#x3D; q<br>p 和 q 均存在于给定的二叉树中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Approach 1: Recursive Approach</span><br><span class="line">Intuition</span><br><span class="line"></span><br><span class="line">The approach is pretty intuitive. Traverse the tree in a depth first manner. The moment you encounter either of the nodes p or q, return some boolean flag. The flag helps to determine if we found the required nodes in any of the paths. The least common ancestor would then be the node for which both the subtree recursions return a True flag. It can also be the node which itself is one of p or q and for which one of the subtree recursions returns a True flag.</span><br><span class="line"></span><br><span class="line">Let us look at the formal algorithm based on this idea.</span><br><span class="line"></span><br><span class="line">Algorithm</span><br><span class="line"></span><br><span class="line">Start traversing the tree from the root node.</span><br><span class="line">If the current node itself is one of p or q, we would mark a variable mid as True and continue the search for the other node in the left and right branches.</span><br><span class="line">If either of the left or the right branch returns True, this means one of the two nodes was found below.</span><br><span class="line">If at any point in the traversal, any two of the three flags left, right or mid become True, this means we have found the lowest common ancestor for the nodes p and q.</span><br><span class="line"></span><br><span class="line">Complexity Analysis</span><br><span class="line"></span><br><span class="line">Time Complexity: O(N)O(N), where NN is the number of nodes in the binary tree. In the worst case we might be visiting all the nodes of the binary tree.</span><br><span class="line"></span><br><span class="line">Space Complexity: O(N)O(N). This is because the maximum amount of space utilized by the recursion stack would be NN since the height of a skewed binary tree could be NN.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Approach 2: Iterative using parent pointers</span><br><span class="line">Intuition</span><br><span class="line"></span><br><span class="line">If we have parent pointers for each node we can traverse back from p and q to get their ancestors. The first common node we get during this traversal would be the LCA node. We can save the parent pointers in a dictionary as we traverse the tree.</span><br><span class="line"></span><br><span class="line">Algorithm</span><br><span class="line"></span><br><span class="line">Start from the root node and traverse the tree.</span><br><span class="line">Until we find p and q both, keep storing the parent pointers in a dictionary.</span><br><span class="line">Once we have found both p and q, we get all the ancestors for p using the parent dictionary and add to a set called ancestors.</span><br><span class="line">Similarly, we traverse through ancestors for node q. If the ancestor is present in the ancestors set for p, this means this is the first ancestor common between p and q (while traversing upwards) and hence this is the LCA node.</span><br><span class="line"></span><br><span class="line">Complexity Analysis</span><br><span class="line"></span><br><span class="line">Time Complexity : O(N)O(N), where NN is the number of nodes in the binary tree. In the worst case we might be visiting all the nodes of the binary tree.</span><br><span class="line"></span><br><span class="line">Space Complexity : O(N)O(N). In the worst case space utilized by the stack, the parent pointer dictionary and the ancestor set, would be NN each, since the height of a skewed binary tree could be NN.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution1-递归-4"><a href="#Solution1-递归-4" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if (root == null) return null;</span><br><span class="line">        // 如果p,q为根节点，则公共祖先为根节点</span><br><span class="line">        if (root.val == p.val || root.val == q.val) return root;</span><br><span class="line">        // 如果p,q在左子树，则公共祖先在左子树查找</span><br><span class="line">        if (find(root.left, p) &amp;&amp; find(root.left, q)) &#123;</span><br><span class="line">            return lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果p,q在右子树，则公共祖先在右子树查找</span><br><span class="line">        if (find(root.right, p) &amp;&amp; find(root.right, q)) &#123;</span><br><span class="line">            return lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果p,q分属两侧，则公共祖先为根节点</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private boolean find(TreeNode root, TreeNode c) &#123;</span><br><span class="line">        if (root == null) return false;</span><br><span class="line">        if (root.val == c.val) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return find(root.left, c) || find(root.right, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="递归：最小的K个数"><a href="#递归：最小的K个数" class="headerlink" title="递归：最小的K个数"></a><a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof">递归：最小的K个数</a></h1><p><img src="https://files.mdnice.com/user/1489/c9037420-1a61-4305-bad1-b4227ec9707f.jpg"></p><p><img src="https://files.mdnice.com/user/1489/f5098755-cba5-4145-9804-8e4cbff4dd48.jpg"></p><p><img src="https://files.mdnice.com/user/1489/e3138c17-60bb-411d-9843-f6639bd0abd7.jpg"></p><p><img src="https://files.mdnice.com/user/1489/2c2e1f87-d654-46f1-a83f-c36c34189b47.jpg"></p><h1 id="树-x2F-递归：二叉搜索树与双向链表"><a href="#树-x2F-递归：二叉搜索树与双向链表" class="headerlink" title="树&#x2F;递归：二叉搜索树与双向链表"></a><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof">树&#x2F;递归：二叉搜索树与双向链表</a></h1><p><img src="https://files.mdnice.com/user/1489/d51c2fab-43eb-470b-8d20-9408f94774ed.jpg"></p><p><img src="https://files.mdnice.com/user/1489/c672b522-c4ab-424a-b872-59264a5bd13e.jpg"></p><p><img src="https://files.mdnice.com/user/1489/77a88286-4f3b-40a2-8aa5-6513bef59e05.jpg"></p><h1 id="树-x2F-递归-二叉树的镜像"><a href="#树-x2F-递归-二叉树的镜像" class="headerlink" title="树&#x2F;递归: 二叉树的镜像"></a><a href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof">树&#x2F;递归: 二叉树的镜像</a></h1><p><img src="https://files.mdnice.com/user/1489/64dedead-67bc-48c3-b39b-b7eefdecdbf3.jpg"></p><p><img src="https://files.mdnice.com/user/1489/c5329093-56fd-4e91-8ee1-7c045e22310f.jpg"></p><p><img src="https://files.mdnice.com/user/1489/a89ccc07-d81b-4c4c-9430-b0c3096d59c0.jpg"></p><p><img src="https://files.mdnice.com/user/1489/f23d7252-0e97-4d3c-890a-434c8b5803d5.jpg"></p><h1 id="树-x2F-递归-对称的二叉树"><a href="#树-x2F-递归-对称的二叉树" class="headerlink" title="树&#x2F;递归: 对称的二叉树"></a><a href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof">树&#x2F;递归: 对称的二叉树</a></h1><p><img src="https://files.mdnice.com/user/1489/a2d7a7ea-4135-46f9-9ce9-0601312f2e95.jpg"></p><h1 id="树-x2F-递归-树的子结构"><a href="#树-x2F-递归-树的子结构" class="headerlink" title="树&#x2F;递归: 树的子结构"></a><a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof">树&#x2F;递归: 树的子结构</a></h1><p><img src="https://files.mdnice.com/user/1489/2c27e439-fff2-4f5e-a3e7-d35da3dd0250.jpg"><br><img src="https://files.mdnice.com/user/1489/ddadda37-15c0-4593-9817-db62669441a3.jpg"></p><h1 id="树-x2F-递归-二叉树中和为某一个值的路径"><a href="#树-x2F-递归-二叉树中和为某一个值的路径" class="headerlink" title="树&#x2F;递归: 二叉树中和为某一个值的路径"></a><a href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof">树&#x2F;递归: 二叉树中和为某一个值的路径</a></h1><p><img src="https://files.mdnice.com/user/1489/aefe8796-fac3-4849-a19c-fce0f029ba08.jpg"></p><h1 id="递归-x2F-树：105-从前序与中序遍历序列构造二叉树"><a href="#递归-x2F-树：105-从前序与中序遍历序列构造二叉树" class="headerlink" title="递归&#x2F;树：105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">递归&#x2F;树：105. 从前序与中序遍历序列构造二叉树</a></h1><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><p> </p><p>示例 1:</p><p>输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]<br>输出: [3,9,20,null,null,15,7]<br>示例 2:</p><p>输入: preorder &#x3D; [-1], inorder &#x3D; [-1]<br>输出: [-1] </p><p>提示:</p><p>1 &lt;&#x3D; preorder.length &lt;&#x3D; 3000<br>inorder.length &#x3D;&#x3D; preorder.length<br>-3000 &lt;&#x3D; preorder[i], inorder[i] &lt;&#x3D; 3000<br>preorder 和 inorder 均 无重复 元素<br>inorder 均出现在 preorder<br>preorder 保证 为二叉树的前序遍历序列<br>inorder 保证 为二叉树的中序遍历序列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Solution</span><br><span class="line">You need to understand preorder and postorder traversal first, and then go ahead.</span><br><span class="line"></span><br><span class="line">Basic idea is:</span><br><span class="line"></span><br><span class="line">preorder[0] is the root node of the tree</span><br><span class="line">preorder[x] is a root node of a sub tree</span><br><span class="line">In in-order traversal</span><br><span class="line">When inorder[index] is an item in the in-order traversal</span><br><span class="line">inorder[0]-inorder[index-1] are on the left branch</span><br><span class="line">inorder[index+1]-inorder[size()-1] are on the right branch</span><br><span class="line">if there is nothing on the left, that means the left child of the node is NULL</span><br><span class="line">if there is nothing on the right, that means the right child of the node is NULL</span><br><span class="line">Algorithm:</span><br><span class="line"></span><br><span class="line">Start from rootIdx 0</span><br><span class="line">Find preorder[rootIdx] from inorder, let&#x27;s call the index pivot</span><br><span class="line">Create a new node with inorder[pivot]</span><br><span class="line">Create its left child recursively</span><br><span class="line">Create its right child recursively</span><br><span class="line">Return the created node.</span><br><span class="line">The implementation is self explanatory. Have a look :)</span><br></pre></td></tr></table></figure><h2 id="Solution1-递归-5"><a href="#Solution1-递归-5" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">        // preorder: [root, [left], [right]]</span><br><span class="line">        // inorder:  [[left], root, [right]]</span><br><span class="line">        return buildTree(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, int lo1, int hi1, vector&lt;int&gt;&amp; inorder, int lo2, int hi2) &#123;</span><br><span class="line">        if (lo1 &gt; hi1 || lo2 &gt; hi2) return nullptr;</span><br><span class="line">        int root = preorder[lo1];</span><br><span class="line">        int mid = lo2;</span><br><span class="line">        // 在 inorder 中查找 root 位置</span><br><span class="line">        for (int i = lo2; i &lt;= hi2; ++i) &#123;</span><br><span class="line">            if (inorder[i] == root) &#123;</span><br><span class="line">                mid = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        auto s = new TreeNode(root);</span><br><span class="line">        // 下面的数组表示分割长度</span><br><span class="line">        // inorder: [mid-lo2, mid, hi2-mid]</span><br><span class="line">        // preorder:[root, mid-lo2, hi2-mid]</span><br><span class="line">        s-&gt;left = buildTree(preorder, lo1+1, lo1+mid-lo2, inorder, lo2, mid-1);</span><br><span class="line">        s-&gt;right = buildTree(preorder, lo1+mid-lo2+1, hi1, inorder, mid+1, hi2);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution2-1"><a href="#Solution2-1" class="headerlink" title="Solution2"></a>Solution2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int getLength(ListNode* head) &#123;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (; head != nullptr; ++ret, head = head-&gt;next);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* buildTree(ListNode*&amp; head, int left, int right) &#123;</span><br><span class="line">        if (left &gt; right) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = (left + right + 1) / 2;</span><br><span class="line">        TreeNode* root = new TreeNode();</span><br><span class="line">        root-&gt;left = buildTree(head, left, mid - 1);</span><br><span class="line">        root-&gt;val = head-&gt;val;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        root-&gt;right = buildTree(head, mid + 1, right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* sortedListToBST(ListNode* head) &#123;</span><br><span class="line">        int length = getLength(head);</span><br><span class="line">        return buildTree(head, 0, length - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="递归-x2F-树：109-有序链表转换二叉搜索树"><a href="#递归-x2F-树：109-有序链表转换二叉搜索树" class="headerlink" title="递归&#x2F;树：109. 有序链表转换二叉搜索树"></a><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/">递归&#x2F;树：109. 有序链表转换二叉搜索树</a></h1><p>给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。</p><p> </p><p>示例 1:</p><p>输入: head &#x3D; [-10,-3,0,5,9]<br>输出: [0,-3,9,-10,null,5]<br>解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。<br>示例 2:</p><p>输入: head &#x3D; []<br>输出: [] </p><p>提示:</p><p>head 中的节点数在[0, 2 * 104] 范围内<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Recursively build tree.</span><br><span class="line"></span><br><span class="line">find midpoint by fast/slow method, use middle node as root.</span><br><span class="line">build left child by first half of the list</span><br><span class="line">build right child by second half of the list (head is midpoint-&gt;next)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution1-先找中点-然后再左右分别构造"><a href="#Solution1-先找中点-然后再左右分别构造" class="headerlink" title="Solution1 先找中点 然后再左右分别构造"></a>Solution1 先找中点 然后再左右分别构造</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode sortedListToBST(ListNode head) &#123;</span><br><span class="line">        if(head == null) return null;</span><br><span class="line">        else if(head.next == null) return new TreeNode(head.val);</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        ListNode p = pre.next;</span><br><span class="line">        ListNode q = p.next;</span><br><span class="line">        //找到链表的中点p</span><br><span class="line">        while(q!=null &amp;&amp; q.next!=null)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            p = pre.next;</span><br><span class="line">            q = q.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //将中点左边的链表分开</span><br><span class="line">        pre.next = null;</span><br><span class="line">        TreeNode root = new TreeNode(p.val);</span><br><span class="line">        root.left = sortedListToBST(head);</span><br><span class="line">        root.right = sortedListToBST(p.next);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="递归-x2F-树：113-路径总和-II"><a href="#递归-x2F-树：113-路径总和-II" class="headerlink" title="递归&#x2F;树：113. 路径总和 II"></a><a href="https://leetcode.com/problems/path-sum-ii/">递归&#x2F;树：113. 路径总和 II</a></h1><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p> </p><p>示例 1：</p><p>输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22<br>输出：[[5,4,11,2],[5,8,4,5]]<br>示例 2：</p><p>输入：root &#x3D; [1,2,3], targetSum &#x3D; 5<br>输出：[]<br>示例 3：</p><p>输入：root &#x3D; [1,2], targetSum &#x3D; 0<br>输出：[] </p><p>提示：</p><p>树中节点总数在范围 [0, 5000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000<br>-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Idea</span><br><span class="line"></span><br><span class="line">DFS from the root down to it&#x27;s descendants:</span><br><span class="line">We need to keep current path (which stores elements in the path) so far.</span><br><span class="line">We need to keep the remain targetSum so far (after minus value of elements in the path).</span><br><span class="line">If we already reach into leaf node</span><br><span class="line">Check if targetSum == 0 then we found a valid path from root to leaf node which sum equal to targetSum, so add current path to the answer.</span><br><span class="line">Else dfs on left node and on the right node.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Complexity</span><br><span class="line"></span><br><span class="line">Time: O(N^2), where N &lt;= 5000 is the number of elements in the binary tree.</span><br><span class="line"></span><br><span class="line">First, we think the time complexity is O(N) because we only visit each node once.</span><br><span class="line">But we forgot to calculate the cost to copy the current path when we found a valid path, which in the worst case can cost O(N^2), let see the following example for more clear.</span><br><span class="line"></span><br><span class="line">Extra Space (without counting output as space): O(H), where H is height of the binary tree. This is the space for stack recursion or keeping path so far.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution1-DFS-1"><a href="#Solution1-DFS-1" class="headerlink" title="Solution1 DFS"></a>Solution1 DFS</h2><p>我们可以采用深度优先搜索的方式，枚举每一条从根节点到叶子节点的路径。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p><p>复杂度分析</p><p><img src="https://files.mdnice.com/user/1489/070d05a3-3ee3-4b0a-90da-bed5c1c2b9a8.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ret;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line"></span><br><span class="line">    void dfs(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        path.emplace_back(root-&gt;val);</span><br><span class="line">        targetSum -= root-&gt;val;</span><br><span class="line">        if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr &amp;&amp; targetSum == 0) &#123;</span><br><span class="line">            ret.emplace_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left, targetSum);</span><br><span class="line">        dfs(root-&gt;right, targetSum);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        dfs(root, targetSum);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution2-BFS-1"><a href="#Solution2-BFS-1" class="headerlink" title="Solution2 BFS"></a>Solution2 BFS</h2><p>方法二：广度优先搜索<br>思路及算法</p><p>我们也可以采用广度优先搜索的方式，遍历这棵树。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p><p>为了节省空间，我们使用哈希表记录树中的每一个节点的父节点。每次找到一个满足条件的节点，我们就从该节点出发不断向父节点迭代，即可还原出从根节点到当前节点的路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ret;</span><br><span class="line">    unordered_map&lt;TreeNode*, TreeNode*&gt; parent;</span><br><span class="line"></span><br><span class="line">    void getPath(TreeNode* node) &#123;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        while (node != nullptr) &#123;</span><br><span class="line">            tmp.emplace_back(node-&gt;val);</span><br><span class="line">            node = parent[node];</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(tmp.begin(), tmp.end());</span><br><span class="line">        ret.emplace_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; que_node;</span><br><span class="line">        queue&lt;int&gt; que_sum;</span><br><span class="line">        que_node.emplace(root);</span><br><span class="line">        que_sum.emplace(0);</span><br><span class="line"></span><br><span class="line">        while (!que_node.empty()) &#123;</span><br><span class="line">            TreeNode* node = que_node.front();</span><br><span class="line">            que_node.pop();</span><br><span class="line">            int rec = que_sum.front() + node-&gt;val;</span><br><span class="line">            que_sum.pop();</span><br><span class="line"></span><br><span class="line">            if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr) &#123;</span><br><span class="line">                if (rec == targetSum) &#123;</span><br><span class="line">                    getPath(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (node-&gt;left != nullptr) &#123;</span><br><span class="line">                    parent[node-&gt;left] = node;</span><br><span class="line">                    que_node.emplace(node-&gt;left);</span><br><span class="line">                    que_sum.emplace(rec);</span><br><span class="line">                &#125;</span><br><span class="line">                if (node-&gt;right != nullptr) &#123;</span><br><span class="line">                    parent[node-&gt;right] = node;</span><br><span class="line">                    que_node.emplace(node-&gt;right);</span><br><span class="line">                    que_sum.emplace(rec);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="树：从上到下打印二叉树"><a href="#树：从上到下打印二叉树" class="headerlink" title="树：从上到下打印二叉树|||"></a><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof">树：从上到下打印二叉树|||</a></h1><p><img src="https://files.mdnice.com/user/1489/a730fbab-4997-4af9-a608-85ffe0bcac07.jpg"></p><p><img src="https://files.mdnice.com/user/1489/442400a3-6855-4a90-a088-8d14c10099fd.jpg"></p><h1 id="树-x2F-分治-重建二叉树"><a href="#树-x2F-分治-重建二叉树" class="headerlink" title="树&#x2F;分治: 重建二叉树"></a><a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof">树&#x2F;分治: 重建二叉树</a></h1><p><img src="https://files.mdnice.com/user/1489/f3d44400-5e6a-4005-be47-2a20e288383f.jpg"><br><img src="https://files.mdnice.com/user/1489/c1843e98-f7e0-4e0b-b053-3bdb40abb586.jpg"></p><h1 id="树：最大二叉树"><a href="#树：最大二叉树" class="headerlink" title="树：最大二叉树"></a><a href="https://leetcode.com/problems/maximum-binary-tree">树：最大二叉树</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Approach 1: Recursive Solution</span><br><span class="line">The current solution is very simple. We make use of a function construct(nums, l, r), which returns the maximum binary tree consisting of numbers within the indices ll and rr in the given numsnums array(excluding the r^&#123;th&#125;r </span><br><span class="line">th</span><br><span class="line">  element).</span><br><span class="line"></span><br><span class="line">The algorithm consists of the following steps:</span><br><span class="line"></span><br><span class="line">Start with the function call construct(nums, 0, n). Here, nn refers to the number of elements in the given numsnums array.</span><br><span class="line"></span><br><span class="line">Find the index, max_imax </span><br><span class="line">i</span><br><span class="line">​</span><br><span class="line"> , of the largest element in the current range of indices (l:r-1)(l:r−1). Make this largest element, nums[max\_i]nums[max_i] as the local root node.</span><br><span class="line"></span><br><span class="line">Determine the left child using construct(nums, l, max_i). Doing this recursively finds the largest element in the subarray left to the current largest element.</span><br><span class="line"></span><br><span class="line">Similarly, determine the right child using construct(nums, max_i + 1, r).</span><br><span class="line"></span><br><span class="line">Return the root node to the calling function.</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/7cb88611-e8e0-4de4-a0e0-c34d8a78df3d.jpg"></p><h1 id="树-把二叉搜索树转换成为累加树"><a href="#树-把二叉搜索树转换成为累加树" class="headerlink" title="树: 把二叉搜索树转换成为累加树"></a><a href="https://leetcode.com/problems/convert-bst-to-greater-tree">树: 把二叉搜索树转换成为累加树</a></h1><p><img src="https://files.mdnice.com/user/1489/f9a6f9ba-1a2e-4ef2-8799-6b93c635519c.jpg"></p><h1 id="树-二叉树的直径"><a href="#树-二叉树的直径" class="headerlink" title="树:二叉树的直径"></a><a href="https://leetcode.com/problems/diameter-of-binary-tree">树:二叉树的直径</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">int dia=0;</span><br><span class="line"></span><br><span class="line">int diameterOfBinaryTree(TreeNode* root) &#123;</span><br><span class="line">    </span><br><span class="line">    //base case 1:</span><br><span class="line">    if(!root)</span><br><span class="line">        return 0;</span><br><span class="line">    </span><br><span class="line">    //recursively, call the helper function with the root</span><br><span class="line">    helper(root);</span><br><span class="line">    </span><br><span class="line">    //return the diameter value</span><br><span class="line">    return dia;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int helper(TreeNode* node)&#123;</span><br><span class="line">    </span><br><span class="line">    //base case 2</span><br><span class="line">    if(!node)</span><br><span class="line">        return 0;</span><br><span class="line">    </span><br><span class="line">    //initialize two pointers, left &amp; right ones</span><br><span class="line">    int leftNode=helper(node-&gt;left);</span><br><span class="line">    int rightNode=helper(node-&gt;right);</span><br><span class="line">    </span><br><span class="line">    //updated diameter value is the max path between two nodes-&gt; path between two leaves</span><br><span class="line">    dia=max(dia, leftNode+rightNode);</span><br><span class="line">    </span><br><span class="line">    //for each node-&gt; add the diameter by one, as you pass an edge</span><br><span class="line">    return 1+max(leftNode, rightNode);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/a8df6972-ea60-4073-a9ed-c607c5017b21.jpg"></p><p><img src="https://files.mdnice.com/user/1489/ba15565c-2189-4cda-b8eb-92ada72b826f.jpg"></p><h1 id="树：94-二叉树的中序遍历"><a href="#树：94-二叉树的中序遍历" class="headerlink" title="树：94. 二叉树的中序遍历"></a><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/">树：94. 二叉树的中序遍历</a></h1><p>给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。</p><p> </p><p>示例 1：</p><p>输入：root &#x3D; [1,null,2,3]<br>输出：[1,3,2]<br>示例 2：</p><p>输入：root &#x3D; []<br>输出：[]<br>示例 3：</p><p>输入：root &#x3D; [1]<br>输出：[1] </p><p>提示：</p><p>树中节点数目在范围 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100 </p><h2 id="Solution1-递归-6"><a href="#Solution1-递归-6" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><p><img src="https://files.mdnice.com/user/1489/166bca4c-bcc2-4718-b6f4-1576acf3ff36.png"></p><h2 id="Solution2-迭代-1"><a href="#Solution2-迭代-1" class="headerlink" title="Solution2 迭代"></a>Solution2 迭代</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        while (root != nullptr || !stk.empty()) &#123;</span><br><span class="line">            while (root != nullptr) &#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="树：102-二叉树的层序遍历"><a href="#树：102-二叉树的层序遍历" class="headerlink" title="树：102. 二叉树的层序遍历"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">树：102. 二叉树的层序遍历</a></h1><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p><p> </p><p>示例 1：</p><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]<br>示例 2：</p><p>输入：root &#x3D; [1]<br>输出：[[1]]<br>示例 3：</p><p>输入：root &#x3D; []<br>输出：[] </p><p>提示：</p><p>树中节点数目在范围 [0, 2000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">What is level in our binary tree? It is set of nodes, for which distance between root and these nodes are constant. And if we talk about distances, it can be a good idea to use bfs.</span><br><span class="line"></span><br><span class="line">We put our root into queue, now we have level 0 in our queue.</span><br><span class="line">On each step extract all nodes from queue and put their children to to opposite end of queue. In this way we will have full level in the end of each step and our queue will be filled with nodes from the next level.</span><br><span class="line">In the end we just return result.</span><br><span class="line">Complexity</span><br><span class="line">Time complexity is O(n): we perform one bfs on our tree. Space complexity is also O(n), because we have answer of this size.</span><br><span class="line"></span><br><span class="line">Code</span><br></pre></td></tr></table></figure><h2 id="Solution1-队列实现"><a href="#Solution1-队列实现" class="headerlink" title="Solution1 队列实现"></a>Solution1 队列实现</h2><p><img src="https://files.mdnice.com/user/1489/35a4e4dc-eb76-4d87-ba29-735a5042bfe1.png"></p><p><img src="https://files.mdnice.com/user/1489/3f09955d-d39b-41e9-8495-445cf9b35418.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector &lt;vector &lt;int&gt;&gt; ret;</span><br><span class="line">        if (!root) &#123;</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue &lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            int currentLevelSize = q.size();</span><br><span class="line">            ret.push_back(vector &lt;int&gt; ());</span><br><span class="line">            for (int i = 1; i &lt;= currentLevelSize; ++i) &#123;</span><br><span class="line">                auto node = q.front(); q.pop();</span><br><span class="line">                ret.back().push_back(node-&gt;val);</span><br><span class="line">                if (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                if (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution2-递归实现"><a href="#Solution2-递归实现" class="headerlink" title="Solution2 递归实现"></a>Solution2 递归实现</h2><p>层序遍历一般来说确实是用队列实现的，但是这里很明显用递归前序遍历就能实现呀，而且复杂度O(n)。。。</p><p>要点有几个：</p><p>利用depth变量记录当前在第几层（从0开始），进入下层时depth + 1；<br>如果depth &gt;&#x3D; vector.size()说明这一层还没来过，这是第一次来，所以得扩容咯；<br>因为是前序遍历，中-左-右，对于每一层来说，左边的肯定比右边先被遍历到，实际上后序中序都是一样的。。。<br>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        pre(root, 0, ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void pre(TreeNode *root, int depth, vector&lt;vector&lt;int&gt;&gt; &amp;ans) &#123;</span><br><span class="line">        if (!root) return ;</span><br><span class="line">        if (depth &gt;= ans.size())</span><br><span class="line">            ans.push_back(vector&lt;int&gt; &#123;&#125;);</span><br><span class="line">        ans[depth].push_back(root-&gt;val);</span><br><span class="line">        pre(root-&gt;left, depth + 1, ans);</span><br><span class="line">        pre(root-&gt;right, depth + 1, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="树：103-二叉树的锯齿形层序遍历"><a href="#树：103-二叉树的锯齿形层序遍历" class="headerlink" title="树：103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">树：103. 二叉树的锯齿形层序遍历</a></h1><p>给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p> </p><p>示例 1：</p><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[3],[20,9],[15,7]]<br>示例 2：</p><p>输入：root &#x3D; [1]<br>输出：[[1]]<br>示例 3：</p><p>输入：root &#x3D; []<br>输出：[] </p><p>提示：</p><p>树中节点数目在范围 [0, 2000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Assuming after traversing the 1st level, nodes in queue are &#123;9, 20, 8&#125;, And we are going to traverse 2nd level, which is even line and should print value from right to left [8, 20, 9].</span><br><span class="line"></span><br><span class="line">We know there are 3 nodes in current queue, so the vector for this level in final result should be of size 3.</span><br><span class="line">Then, queue [i] -&gt; goes to -&gt; vector[queue.size() - 1 - i]</span><br><span class="line">i.e. the ith node in current queue should be placed in (queue.size() - 1 - i) position in vector for that line.</span><br><span class="line"></span><br><span class="line">For example, for node(9), it&#x27;s index in queue is 0, so its index in vector should be (3-1-0) = 2.</span><br></pre></td></tr></table></figure><h2 id="Solution1-层序遍历"><a href="#Solution1-层序遍历" class="headerlink" title="Solution1 层序遍历"></a>Solution1 层序遍历</h2><p>层序遍历，然后在奇数时逆序一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">        if(!root) return res;</span><br><span class="line">        </span><br><span class="line">        queue&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        int flag = 0;</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; out;</span><br><span class="line">            int size = q.size(); //取得每一层的长度</span><br><span class="line">            for(int i = 0; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                auto temp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                out.push_back(temp-&gt;val);</span><br><span class="line">                if(temp-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag%2==1)</span><br><span class="line">            &#123;</span><br><span class="line">                reverse(out.begin(),out.end());</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(out);</span><br><span class="line">            flag++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="树：104-二叉树的最大深度"><a href="#树：104-二叉树的最大深度" class="headerlink" title="树：104. 二叉树的最大深度"></a><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">树：104. 二叉树的最大深度</a></h1><p><img src="https://files.mdnice.com/user/1489/bdcd019a-a049-4e57-ac75-c491a552e1e0.png"></p><p><img src="https://files.mdnice.com/user/1489/6aa612fa-c6de-4c45-bcb7-0ed123b1a063.png"></p><h2 id="Solution1-DFS-2"><a href="#Solution1-DFS-2" class="headerlink" title="Solution1 DFS"></a>Solution1 DFS</h2><p><img src="https://files.mdnice.com/user/1489/f28b6ed7-01b5-4a89-952f-d626edf15d9e.png"></p><p><img src="https://files.mdnice.com/user/1489/988437b9-f65e-4111-8cde-79a687333027.png"></p><h2 id="Slution2-BFS"><a href="#Slution2-BFS" class="headerlink" title="Slution2 BFS"></a>Slution2 BFS</h2><p><img src="https://files.mdnice.com/user/1489/c915e202-251b-48cd-816b-cfcabdbf2214.png"></p><h1 id="树：105-从前序与中序遍历序列构造二叉树"><a href="#树：105-从前序与中序遍历序列构造二叉树" class="headerlink" title="树：105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">树：105. 从前序与中序遍历序列构造二叉树</a></h1><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><p> </p><p>示例 1:</p><p>输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]<br>输出: [3,9,20,null,null,15,7]<br>示例 2:</p><p>输入: preorder &#x3D; [-1], inorder &#x3D; [-1]<br>输出: [-1] </p><p>提示:</p><p>1 &lt;&#x3D; preorder.length &lt;&#x3D; 3000<br>inorder.length &#x3D;&#x3D; preorder.length<br>-3000 &lt;&#x3D; preorder[i], inorder[i] &lt;&#x3D; 3000<br>preorder 和 inorder 均 无重复 元素<br>inorder 均出现在 preorder<br>preorder 保证 为二叉树的前序遍历序列<br>inorder 保证 为二叉树的中序遍历序列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">olution</span><br><span class="line">You need to understand preorder and postorder traversal first, and then go ahead.</span><br><span class="line"></span><br><span class="line">Basic idea is:</span><br><span class="line"></span><br><span class="line">preorder[0] is the root node of the tree</span><br><span class="line">preorder[x] is a root node of a sub tree</span><br><span class="line">In in-order traversal</span><br><span class="line">When inorder[index] is an item in the in-order traversal</span><br><span class="line">inorder[0]-inorder[index-1] are on the left branch</span><br><span class="line">inorder[index+1]-inorder[size()-1] are on the right branch</span><br><span class="line">if there is nothing on the left, that means the left child of the node is NULL</span><br><span class="line">if there is nothing on the right, that means the right child of the node is NULL</span><br><span class="line">Algorithm:</span><br><span class="line"></span><br><span class="line">Start from rootIdx 0</span><br><span class="line">Find preorder[rootIdx] from inorder, let&#x27;s call the index pivot</span><br><span class="line">Create a new node with inorder[pivot]</span><br><span class="line">Create its left child recursively</span><br><span class="line">Create its right child recursively</span><br><span class="line">Return the created node.</span><br><span class="line">The implementation is self explanatory. Have a look :)</span><br></pre></td></tr></table></figure><h1 id="树：144-二叉树的前序遍历"><a href="#树：144-二叉树的前序遍历" class="headerlink" title="树：144. 二叉树的前序遍历"></a><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/">树：144. 二叉树的前序遍历</a></h1><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p><p> </p><p>示例 1：</p><p>输入：root &#x3D; [1,null,2,3]<br>输出：[1,2,3]<br>示例 2：</p><p>输入：root &#x3D; []<br>输出：[]<br>示例 3：</p><p>输入：root &#x3D; [1]<br>输出：[1]<br>示例 4：</p><p>输入：root &#x3D; [1,2]<br>输出：[1,2]<br>示例 5：</p><p>输入：root &#x3D; [1,null,2]<br>输出：[1,2] </p><p>提示：</p><p>树中节点数目在范围 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">There are three solutions to this problem.</span><br><span class="line"></span><br><span class="line">Iterative solution using stack --- O(n) time and O(n) space;</span><br><span class="line">Recursive solution --- O(n) time and O(n) space (function call stack);</span><br><span class="line">Morris traversal --- O(n) time and O(1) space.</span><br></pre></td></tr></table></figure><h2 id="Solution1-递归-7"><a href="#Solution1-递归-7" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><p><img src="https://files.mdnice.com/user/1489/04aefe28-f537-4f0f-a96c-e08abbe1030f.png"></p><h2 id="Solution2-迭代-2"><a href="#Solution2-迭代-2" class="headerlink" title="Solution2 迭代"></a>Solution2 迭代</h2><p><img src="https://files.mdnice.com/user/1489/de302c02-3172-4795-81bf-b52f9a497fcf.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        while (!stk.empty() || node != nullptr) &#123;</span><br><span class="line">            while (node != nullptr) &#123;</span><br><span class="line">                res.emplace_back(node-&gt;val);</span><br><span class="line">                stk.emplace(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(n)O(n)，其中 nn 是二叉树的节点数。每一个节点恰好被遍历一次。</p><p>空间复杂度：O(n)O(n)，为迭代过程中显式栈的开销，平均情况下为 O(\log n)O(logn)，最坏情况下树呈现链状，为 O(n)O(n)。</p><h1 id="树：199-二叉树的右视图"><a href="#树：199-二叉树的右视图" class="headerlink" title="树：199. 二叉树的右视图"></a><a href="https://leetcode.com/problems/binary-tree-right-side-view/">树：199. 二叉树的右视图</a></h1><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p> </p><p>示例 1:</p><p>输入: [1,2,3,null,5,null,4]<br>输出: [1,3,4]<br>示例 2:</p><p>输入: [1,null,3]<br>输出: [1,3]<br>示例 3:</p><p>输入: []<br>输出: [] </p><p>提示:</p><p>二叉树的节点个数的范围是 [0,100]<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100 </p><p><img src="https://files.mdnice.com/user/1489/48c2dc78-d14d-4a7d-b5fd-0ca2431b377a.png"></p><h2 id="Solution1-层序遍历-1"><a href="#Solution1-层序遍历-1" class="headerlink" title="Solution1 层序遍历"></a>Solution1 层序遍历</h2><p>使用层序遍历，并只保留每层最后一个节点的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; rightSideView(TreeNode* root) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; rightmostValueAtDepth;</span><br><span class="line">        int max_depth = -1;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; nodeQueue;</span><br><span class="line">        queue&lt;int&gt; depthQueue;</span><br><span class="line">        nodeQueue.push(root);</span><br><span class="line">        depthQueue.push(0);</span><br><span class="line"></span><br><span class="line">        while (!nodeQueue.empty()) &#123;</span><br><span class="line">            TreeNode* node = nodeQueue.front();nodeQueue.pop();</span><br><span class="line">            int depth = depthQueue.front();depthQueue.pop();</span><br><span class="line"></span><br><span class="line">            if (node != NULL) &#123;</span><br><span class="line">            // 维护二叉树的最大深度</span><br><span class="line">                max_depth = max(max_depth, depth);</span><br><span class="line"></span><br><span class="line">                // 由于每一层最后一个访问到的节点才是我们要的答案，因此不断更新对应深度的信息即可</span><br><span class="line">                rightmostValueAtDepth[depth] =  node -&gt; val;</span><br><span class="line"></span><br><span class="line">                nodeQueue.push(node -&gt; left);</span><br><span class="line">                nodeQueue.push(node -&gt; right);</span><br><span class="line">                depthQueue.push(depth + 1);</span><br><span class="line">                depthQueue.push(depth + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; rightView;</span><br><span class="line">        for (int depth = 0; depth &lt;= max_depth; ++depth) &#123;</span><br><span class="line">            rightView.push_back(rightmostValueAtDepth[depth]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return rightView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/fb683879-39db-4823-890b-e02d5deeb48c.png"></p><p>这里可以通过维护两个node queue来实现</p><h1 id="树：226-翻转二叉树"><a href="#树：226-翻转二叉树" class="headerlink" title="树：226. 翻转二叉树"></a><a href="https://leetcode.com/problems/invert-binary-tree/">树：226. 翻转二叉树</a></h1><p><img src="https://files.mdnice.com/user/1489/69e49a83-545c-483f-8a37-ec3b834d2e93.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">To invert a binary tree, we swap the left and right subtrees and invert them recursively/iteratively.</span><br></pre></td></tr></table></figure><h2 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1"></a>Solution1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">利用前序遍历</span><br><span class="line">class Solution &#123;</span><br><span class="line">        // 先序遍历--从顶向下交换</span><br><span class="line">        public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">            if (root == null) return null;</span><br><span class="line">            // 保存右子树</span><br><span class="line">            TreeNode rightTree = root.right;</span><br><span class="line">            // 交换左右子树的位置</span><br><span class="line">            root.right = invertTree(root.left);</span><br><span class="line">            root.left = invertTree(rightTree);</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">利用中序遍历</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">            if (root == null) return null;</span><br><span class="line">            invertTree(root.left); // 递归找到左节点</span><br><span class="line">            TreeNode rightNode= root.right; // 保存右节点</span><br><span class="line">            root.right = root.left;</span><br><span class="line">            root.left = rightNode;</span><br><span class="line">            // 递归找到右节点 继续交换 : 因为此时左右节点已经交换了,所以此时的右节点为root.left</span><br><span class="line">            invertTree(root.left); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">利用后序遍历</span><br><span class="line"> class Solution &#123;</span><br><span class="line">        public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">            // 后序遍历-- 从下向上交换</span><br><span class="line">            if (root == null) return null;</span><br><span class="line">            TreeNode leftNode = invertTree(root.left);</span><br><span class="line">            TreeNode rightNode = invertTree(root.right);</span><br><span class="line">            root.right = leftNode;</span><br><span class="line">            root.left = rightNode;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">利用层次遍历</span><br><span class="line">   class Solution &#123;</span><br><span class="line">        public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">            // 层次遍历--直接左右交换即可</span><br><span class="line">            if (root == null) return null;</span><br><span class="line">            Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">            queue.offer(root);</span><br><span class="line">            while (!queue.isEmpty())&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                TreeNode rightTree = node.right;</span><br><span class="line">                node.right = node.left;</span><br><span class="line">                node.left = rightTree;</span><br><span class="line">                if (node.left != null)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if (node.right != null)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="树：230-二叉搜索树中第K小的元素"><a href="#树：230-二叉搜索树中第K小的元素" class="headerlink" title="树：230. 二叉搜索树中第K小的元素"></a><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">树：230. 二叉搜索树中第K小的元素</a></h1><p>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。</p><p><img src="https://files.mdnice.com/user/1489/b09171cd-4ad6-4049-bd68-cb3ac6236510.png"></p><h2 id="Solution1-非递归-1"><a href="#Solution1-非递归-1" class="headerlink" title="Solution1  非递归"></a>Solution1  非递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int kthSmallest(TreeNode* root, int k) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        int num=0;</span><br><span class="line">        TreeNode *cur=root;</span><br><span class="line">        while(!s.empty() || cur)</span><br><span class="line">        &#123;</span><br><span class="line">            if(cur)</span><br><span class="line">            &#123;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur=cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                cur=s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                num++;</span><br><span class="line">                if(num==k)</span><br><span class="line">                    return cur-&gt;val;</span><br><span class="line">                cur=cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution2-记录子节点数目"><a href="#Solution2-记录子节点数目" class="headerlink" title="Solution2 记录子节点数目"></a>Solution2 记录子节点数目</h2><p><img src="https://files.mdnice.com/user/1489/e65a5f5c-4e4e-4bb7-857a-f5fd4309020f.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class MyBst &#123;</span><br><span class="line">public:</span><br><span class="line">    MyBst(TreeNode *root) &#123;</span><br><span class="line">        this-&gt;root = root;</span><br><span class="line">        countNodeNum(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 返回二叉搜索树中第k小的元素</span><br><span class="line">    int kthSmallest(int k) &#123;</span><br><span class="line">        TreeNode *node = root;</span><br><span class="line">        while (node != nullptr) &#123;</span><br><span class="line">            int left = getNodeNum(node-&gt;left);</span><br><span class="line">            if (left &lt; k - 1) &#123;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">                k -= left + 1;</span><br><span class="line">            &#125; else if (left == k - 1) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return node-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    TreeNode *root;</span><br><span class="line">    unordered_map&lt;TreeNode *, int&gt; nodeNum;</span><br><span class="line"></span><br><span class="line">    // 统计以node为根结点的子树的结点数</span><br><span class="line">    int countNodeNum(TreeNode * node) &#123;</span><br><span class="line">        if (node == nullptr) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        nodeNum[node] = 1 + countNodeNum(node-&gt;left) + countNodeNum(node-&gt;right);</span><br><span class="line">        return nodeNum[node];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取以node为根结点的子树的结点数</span><br><span class="line">    int getNodeNum(TreeNode * node) &#123;</span><br><span class="line">        if (node != nullptr &amp;&amp; nodeNum.count(node)) &#123;</span><br><span class="line">            return nodeNum[node];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int kthSmallest(TreeNode* root, int k) &#123;</span><br><span class="line">        MyBst bst(root);</span><br><span class="line">        return bst.kthSmallest(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="树：二叉搜索树的第K大节点"><a href="#树：二叉搜索树的第K大节点" class="headerlink" title="树：二叉搜索树的第K大节点"></a><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof">树：二叉搜索树的第K大节点</a></h1><p><img src="https://files.mdnice.com/user/1489/815f7215-0047-455e-8cc3-fa211fc82157.jpg"></p><h1 id="树：114-二叉树展开为链表"><a href="#树：114-二叉树展开为链表" class="headerlink" title="树：114. 二叉树展开为链表"></a><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/">树：114. 二叉树展开为链表</a></h1><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p><p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。 </p><p>示例 1：</p><p>输入：root &#x3D; [1,2,5,3,4,null,6]<br>输出：[1,null,2,null,3,null,4,null,5,null,6]<br>示例 2：</p><p>输入：root &#x3D; []<br>输出：[]<br>示例 3：</p><p>输入：root &#x3D; [0]<br>输出：[0] </p><p>提示：</p><p>树中结点数在范围 [0, 2000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><p><img src="https://files.mdnice.com/user/1489/eb69f29d-548d-4414-bd1f-27b9944ac200.png"></p><p> </p><h2 id="Solution1-递归-8"><a href="#Solution1-递归-8" class="headerlink" title="Solution1  递归"></a>Solution1  递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* last = nullptr;</span><br><span class="line">void flatten(TreeNode* root) &#123;</span><br><span class="line">    if (root == nullptr) return;</span><br><span class="line">    flatten(root-&gt;right);</span><br><span class="line">    flatten(root-&gt;left);</span><br><span class="line">    root-&gt;right = last;</span><br><span class="line">    root-&gt;left = nullptr;</span><br><span class="line">    last = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Solution2-迭代-3"><a href="#Solution2-迭代-3" class="headerlink" title="Solution2   迭代"></a>Solution2   迭代</h2><p><img src="https://files.mdnice.com/user/1489/5f3de36e-929d-4f22-adcb-a8070f305409.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        while(root)&#123;</span><br><span class="line">            TreeNode* p = root-&gt;left;</span><br><span class="line">            if(p)&#123;</span><br><span class="line">                while(p-&gt;right) p = p-&gt;right; </span><br><span class="line">                p-&gt;right = root-&gt;right;</span><br><span class="line">                root-&gt;right = root-&gt;left;</span><br><span class="line">                root-&gt;left = nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a><a href="https://leetcode.com/problems/two-sum/">1. Two Sum</a></h1><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。<br>示例 2：</p><p>输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]<br>示例 3：</p><p>输入：nums &#x3D; [3,3], target &#x3D; 6<br>输出：[0,1] </p><p>提示：</p><p>2 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>-109 &lt;&#x3D; target &lt;&#x3D; 109<br>只会存在一个有效答案<br>进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>双层遍历</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>哈希表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The basic idea is to maintain a hash table for each element num in nums, </span><br><span class="line">using num as key and its index (0-based) as value. For each num,</span><br><span class="line"> search for target - num in the hash table.</span><br><span class="line"> If it is found and is not the same element as num, then we are done.</span><br><span class="line"></span><br><span class="line">The code is as follows. Note that each time before we add num to mp,</span><br><span class="line"> we search for target - num first and so we will not hit the same element.</span><br></pre></td></tr></table></figure><h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode.com/problems/4sum/">18. 四数之和</a></h1><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p><p>0 &lt;&#x3D; a, b, c, d &lt; n<br>a、b、c 和 d 互不相同<br>nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target<br>你可以按 任意顺序 返回答案 。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0<br>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]<br>示例 2：</p><p>输入：nums &#x3D; [2,2,2,2,2], target &#x3D; 8<br>输出：[[2,2,2,2]] </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>-109 &lt;&#x3D; target &lt;&#x3D; 109</p><h2 id="Solution-1-暴力枚举"><a href="#Solution-1-暴力枚举" class="headerlink" title="Solution 1  暴力枚举"></a>Solution 1  暴力枚举</h2><h2 id="Solution-2-双指针法"><a href="#Solution-2-双指针法" class="headerlink" title="Solution 2  双指针法"></a>Solution 2  双指针法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The two pointers pattern requires the array to be sorted, so we do that first. Also, it&#x27;s easier to deal with duplicates if the array is sorted: repeated values are next to each other and easy to skip.</span><br><span class="line"></span><br><span class="line">For 3Sum, we enumerate each value in a single loop, and use the two pointers pattern for the rest of the array. For kSum, we will have k - 2 nested loops to enumerate all combinations of k - 2 values.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/1ab57d58-3c53-4974-885c-d0b997487df7.png"></p><p><img src="https://files.mdnice.com/user/1489/9abc4082-7aba-4bf2-95ab-8151841c8777.png"></p><p><img src="https://files.mdnice.com/user/1489/dbda7684-ec6b-4517-89ef-8415d7f95a32.png"></p><p><img src="https://files.mdnice.com/user/1489/5cd09d98-bd6d-413f-a699-5d03755f5802.png"></p><h1 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list">19. 删除链表的倒数第 N 个结点</a></h1><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p> </p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>输出：[1,2,3,5]<br>示例 2：</p><p>输入：head &#x3D; [1], n &#x3D; 1<br>输出：[]<br>示例 3：</p><p>输入：head &#x3D; [1,2], n &#x3D; 1<br>输出：[1] </p><p>提示：</p><p>链表中结点的数目为 sz<br>1 &lt;&#x3D; sz &lt;&#x3D; 30<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>1 &lt;&#x3D; n &lt;&#x3D; sz</p><p><img src="https://files.mdnice.com/user/1489/66e5f430-7a71-4480-8d2b-930a4ea9a2df.png"></p><p> </p><h2 id="Solution1-计算链表长度"><a href="#Solution1-计算链表长度" class="headerlink" title="Solution1 计算链表长度"></a>Solution1 计算链表长度</h2><p><img src="https://files.mdnice.com/user/1489/5bfffdd4-470d-482c-849d-e4e82e2b40d8.png"></p><h2 id="Solution2-栈"><a href="#Solution2-栈" class="headerlink" title="Solution2 栈"></a>Solution2 栈</h2><p><img src="https://files.mdnice.com/user/1489/f6e5ea9e-b6b4-4545-97c5-2ef86e5fbd08.png"></p><p><img src="https://files.mdnice.com/user/1489/b3fb36fb-92e9-417d-9c00-60756ed04c17.png"></p><h2 id="Solution3-快慢指针-1"><a href="#Solution3-快慢指针-1" class="headerlink" title="Solution3 快慢指针"></a>Solution3 快慢指针</h2><p><img src="https://files.mdnice.com/user/1489/1d658e59-2c76-4ade-a9c5-39a2ff20161f.png"></p><p><img src="https://files.mdnice.com/user/1489/7fc31992-dc5b-4e11-bb5e-7c61942e6e57.png"></p><h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.com/problems/valid-parentheses/">20. 有效的括号</a></h1><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。 </p><p>示例 1：</p><p>输入：s &#x3D; “()”<br>输出：true<br>示例 2：</p><p>输入：s &#x3D; “()[]{}”<br>输出：true<br>示例 3：</p><p>输入：s &#x3D; “(]”<br>输出：false<br>示例 4：</p><p>输入：s &#x3D; “([)]”<br>输出：false<br>示例 5：</p><p>输入：s &#x3D; “{[]}”<br>输出：true</p><h2 id="Solution1-栈"><a href="#Solution1-栈" class="headerlink" title="Solution1 栈"></a>Solution1 栈</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValid(string s) &#123;</span><br><span class="line">        stack&lt;char&gt; st;  //taking stack for keep tracking the order of the brackets..</span><br><span class="line">        for(auto i:s)  //iterate over each and every elements</span><br><span class="line">        &#123;</span><br><span class="line">            if(i==&#x27;(&#x27; or i==&#x27;&#123;&#x27; or i==&#x27;[&#x27;) st.push(i);  //if current element of the string will be opening bracket then we will just simply push it into the stack</span><br><span class="line">            else  //if control comes to else part, it means that current element is a closing bracket, so check two conditions  current element matches with top of the stack and the stack must not be empty...</span><br><span class="line">            &#123;</span><br><span class="line">                if(st.empty() or (st.top()==&#x27;(&#x27; and i!=&#x27;)&#x27;) or (st.top()==&#x27;&#123;&#x27; and i!=&#x27;&#125;&#x27;) or (st.top()==&#x27;[&#x27; and i!=&#x27;]&#x27;)) return false;</span><br><span class="line">                st.pop();  //if control reaches to that line, it means we have got the right pair of brackets, so just pop it.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return st.empty();  //at last, it may possible that we left something into the stack unpair so return checking stack is empty or not..</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/4097f955-844e-4ceb-a4c1-513342bc6e37.png"></p><h1 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h1><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p><p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p><p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>判题标准:</p><p>系统会用下面的代码来测试你的题解:</p><p>int[] nums &#x3D; […]; &#x2F;&#x2F; 输入数组<br>int[] expectedNums &#x3D; […]; &#x2F;&#x2F; 长度正确的期望答案</p><p>int k &#x3D; removeDuplicates(nums); &#x2F;&#x2F; 调用</p><p>assert k &#x3D;&#x3D; expectedNums.length;<br>for (int i &#x3D; 0; i &lt; k; i++) {<br>    assert nums[i] &#x3D;&#x3D; expectedNums[i];<br>}<br>如果所有断言都通过，那么您的题解将被 通过。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [1,1,2]<br>输出：2, nums &#x3D; [1,2,_]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。<br>示例 2：</p><p>输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums &#x3D; [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>nums 已按 升序 排列</p><h2 id="Solution1-暴力-9"><a href="#Solution1-暴力-9" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-双指针"><a href="#Solution2-双指针" class="headerlink" title="Solution2 双指针"></a>Solution2 双指针</h2><p><img src="https://files.mdnice.com/user/1489/4bab35d7-99bc-45ab-9bc4-cccdbe223a0c.png"></p><p><img src="https://files.mdnice.com/user/1489/731a9af6-7a21-42e7-9a1b-f4b2d9cfddba.png"></p><p><img src="https://files.mdnice.com/user/1489/97cb5a3b-6aaa-4be9-9b17-dde9d86f17ab.png"></p><h2 id="Solution3-双指针-优化"><a href="#Solution3-双指针-优化" class="headerlink" title="Solution3 双指针 优化"></a>Solution3 双指针 优化</h2><p><img src="https://files.mdnice.com/user/1489/80714af6-4b56-4b6d-965a-6d0e396c1b63.png"></p><h1 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode.com/problems/next-permutation/">31. 下一个排列</a></h1><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p><p>例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><p>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。</p><p>必须 原地 修改，只允许使用额外常数空间。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3]<br>输出：[1,3,2]<br>示例 2：</p><p>输入：nums &#x3D; [3,2,1]<br>输出：[1,2,3]<br>示例 3：</p><p>输入：nums &#x3D; [1,1,5]<br>输出：[1,5,1] </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p><h2 id="Solution1-暴力-10"><a href="#Solution1-暴力-10" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><p><img src="https://files.mdnice.com/user/1489/6225fcf0-251b-4649-92fa-65307499a714.png"></p><h2 id="Solution2-2"><a href="#Solution2-2" class="headerlink" title="Solution2"></a>Solution2</h2><p><img src="https://files.mdnice.com/user/1489/3b831fba-7be3-423c-87d3-d1f5f499cd9c.png"></p><p><img src="https://files.mdnice.com/user/1489/7e984502-8307-4144-85fa-134adc4a304f.png"></p><p><img src="https://files.mdnice.com/user/1489/997007a2-0e00-49d3-88fc-6865a7578af8.png"></p><h1 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode.com/problems/rotate-image/">48. 旋转图像</a></h1><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><p> </p><p>示例 1：</p><p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[[7,4,1],[8,5,2],[9,6,3]]<br>示例 2：</p><p>输入：matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]<br>输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] </p><p>提示：</p><p>n &#x3D;&#x3D; matrix.length &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; n &lt;&#x3D; 20<br>-1000 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 1000 </p><h2 id="Solution1-原地查找"><a href="#Solution1-原地查找" class="headerlink" title="Solution1 原地查找"></a>Solution1 原地查找</h2><p><img src="https://files.mdnice.com/user/1489/21a7a3a3-e652-45a8-99cb-f56b22227301.png"></p><h2 id="Solution2-先转置再竖直对称反转"><a href="#Solution2-先转置再竖直对称反转" class="headerlink" title="Solution2 先转置再竖直对称反转"></a>Solution2 先转置再竖直对称反转</h2><p><img src="https://files.mdnice.com/user/1489/bd454bbc-41fb-4383-8f76-57b770d4b60d.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        //先转置</span><br><span class="line">        for(int row=0;row&lt;=matrix.size()-1;row++)&#123;</span><br><span class="line"></span><br><span class="line">            for(int col=row;col&lt;=matrix[0].size()-1;col++)&#123;</span><br><span class="line">                swap(matrix[row][col],matrix[col][row]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //在竖直对称翻转</span><br><span class="line">        for(int row=0;row&lt;=matrix.size()-1;row++)&#123;</span><br><span class="line">            for(int col = 0;col&lt;=(matrix.size()-1)/2;col++)&#123;</span><br><span class="line">                swap(matrix[row][col],matrix[row][matrix.size()-1-col]);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a href="https://leetcode.com/problems/group-anagrams/">49. 字母异位词分组</a></h1><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p><p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><p> </p><p>示例 1:</p><p>输入: strs &#x3D; [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]<br>示例 2:</p><p>输入: strs &#x3D; [“”]<br>输出: [[“”]]<br>示例 3:</p><p>输入: strs &#x3D; [“a”]<br>输出: [[“a”]] </p><p>提示：</p><p>1 &lt;&#x3D; strs.length &lt;&#x3D; 104<br>0 &lt;&#x3D; strs[i].length &lt;&#x3D; 100<br>strs[i] 仅包含小写字母</p><h2 id="Solution1-Map"><a href="#Solution1-Map" class="headerlink" title="Solution1 Map"></a>Solution1 Map</h2><p>Use an unordered_map to group the strings by their sorted counterparts. Use the sorted string as the key and all anagram strings as the value.</p><p>Moreover, since the string only contains lower-case alphabets, we can sort them using counting sort to improve the time complexity.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        </span><br><span class="line">        map&lt;string,vector&lt;string&gt;&gt;res;</span><br><span class="line">        //遍历 </span><br><span class="line">        for(auto val:strs)&#123;</span><br><span class="line">            string tmp=val;</span><br><span class="line">               //以排序后的str作为key  vector&lt;string&gt;作为value 放进map</span><br><span class="line">            sort(val.begin(),val.end());</span><br><span class="line">            if(res.find(val)==res.end())&#123;</span><br><span class="line">                vector&lt;string&gt; t=&#123;tmp&#125;;</span><br><span class="line">                res.insert(&#123;val,t&#125;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res[val].push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历输出结果</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">        for(auto p:res)&#123;</span><br><span class="line">            result.push_back(p.second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode.com/problems/spiral-matrix/">54. 螺旋矩阵</a></h1><p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p><p> </p><p>示例 1：</p><p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br>示例 2：</p><p>输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7] </p><p>提示：</p><p>m &#x3D;&#x3D; matrix.length<br>n &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 10<br>-100 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 100</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spiral-matrix</span><br><span class="line"></span><br><span class="line">Algorithm:</span><br><span class="line"></span><br><span class="line">First we will iterate in to first row from left to right push back all the elements into a vector. After iterating, we change the top to second row (top++).</span><br><span class="line">Then we will iterate from new top to bottom and push back only right most elements of each row. After iterating, we change the right to second last column (right--).</span><br><span class="line">Then we will iterate in bottom row from right to left and pushback all the elements from new right to left. After iterating, we change the bottom to second last row (bottom--).</span><br><span class="line">Then we will iterate from new bottom to new top and push back only left most element. After iterating, we change the left to second column (left++).</span><br><span class="line">Repeat all these steps until left = right and top = bottom.</span><br></pre></td></tr></table></figure><h2 id="Solution1-原地遍历"><a href="#Solution1-原地遍历" class="headerlink" title="Solution1 原地遍历"></a>Solution1 原地遍历</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">          if(matrix.empty())&#123;return res;&#125;</span><br><span class="line">        int s=0,x=matrix.size()-1,z=0,y=matrix[0].size()-1;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">        while(true)&#123;</span><br><span class="line">            //在上边沿</span><br><span class="line">            for(int i=s,j=z;j&lt;=y;j++)&#123;</span><br><span class="line">                res.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(++s&gt;x)   break;</span><br><span class="line">            //在右边沿</span><br><span class="line">            for(int i=s,j=y;i&lt;=x;i++)&#123;</span><br><span class="line">                  res.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(--y&lt;z) break;</span><br><span class="line">            //在下边沿</span><br><span class="line">           for(int i=x,j=y;j&gt;=z;j--)&#123;</span><br><span class="line">                  res.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(--x&lt;s) break;</span><br><span class="line">            //在左边沿</span><br><span class="line">           for(int i=x,j=z;i&gt;=s;i--)&#123;</span><br><span class="line">                  res.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(++z&gt;y) break;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution2-按层遍历"><a href="#Solution2-按层遍历" class="headerlink" title="Solution2 按层遍历"></a>Solution2 按层遍历</h2><p><img src="https://files.mdnice.com/user/1489/6fc73b94-e500-4182-a9f9-e1d8a4e29a32.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        if (matrix.size() == 0 || matrix[0].size() == 0) &#123;</span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int rows = matrix.size(), columns = matrix[0].size();</span><br><span class="line">        vector&lt;int&gt; order;</span><br><span class="line">        int left = 0, right = columns - 1, top = 0, bottom = rows - 1;</span><br><span class="line">        while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">            for (int column = left; column &lt;= right; column++) &#123;</span><br><span class="line">                order.push_back(matrix[top][column]);</span><br><span class="line">            &#125;</span><br><span class="line">            for (int row = top + 1; row &lt;= bottom; row++) &#123;</span><br><span class="line">                order.push_back(matrix[row][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            if (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">                for (int column = right - 1; column &gt; left; column--) &#123;</span><br><span class="line">                    order.push_back(matrix[bottom][column]);</span><br><span class="line">                &#125;</span><br><span class="line">                for (int row = bottom; row &gt; top; row--) &#123;</span><br><span class="line">                    order.push_back(matrix[row][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        return order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.com/problems/merge-intervals/">56. 合并区间</a></h1><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><p> </p><p>示例 1：</p><p>输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<br>示例 2：</p><p>输入：intervals &#x3D; [[1,4],[4,5]]<br>输出：[[1,5]]<br>解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。 </p><p>提示：</p><p>1 &lt;&#x3D; intervals.length &lt;&#x3D; 104<br>intervals[i].length &#x3D;&#x3D; 2<br>0 &lt;&#x3D; starti &lt;&#x3D; endi &lt;&#x3D; 104</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">nitially sort the array and then push the first element into the answer for speculation.</span><br><span class="line">We have two condition if the first elements second part of ans array is greater than or equal to the second element first part of the </span><br><span class="line">interval array.</span><br><span class="line">The other condition we have to tackle is what if its not? then we push the particular element into the ans array which will be then be under speculation.</span><br><span class="line">interval: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">             i</span><br><span class="line">We initally push the 1st element into the ans array:</span><br><span class="line">ans=[[1,3]]</span><br><span class="line">      j        j points to the latest pushed element</span><br><span class="line">Then we i is incremented.</span><br><span class="line">[[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">         i</span><br><span class="line">Now the ans[j][1]&gt;interval[i][0] this means there is a possiblity of merging so we merger them</span><br><span class="line">Remember the way we merge is to take the second element as max(ans[j][1],interval[i][1])</span><br><span class="line">cuz imagine we have this</span><br><span class="line">[1,7][2,4] ---&gt;merge should be ----&gt;[1,7]</span><br><span class="line"></span><br><span class="line">ans=[[1,6]]</span><br><span class="line"></span><br><span class="line">then we move i forward</span><br><span class="line"></span><br><span class="line">[[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">               i</span><br><span class="line">Since ans[j][1]&lt;interval[i][0] thus not contributing to the merge.</span><br><span class="line">Thus we will push this into the ans array and speculate.</span><br><span class="line"></span><br><span class="line">ans=[[1,6][8,10]]</span><br><span class="line">            j   &lt;----j is moved forward</span><br><span class="line">i is moved forward </span><br><span class="line">[[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">                       i</span><br><span class="line">Since ans[j][1]&lt;interval[i][0] thus not contributing to the merge.</span><br><span class="line">ans=[[1,6][8,10][15,18]]</span><br><span class="line">                  j</span><br><span class="line"></span><br><span class="line">Thus yielding our final answer.</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; interval) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        if(interval.size()==0)return ans;</span><br><span class="line">        sort(interval.begin(),interval.end());</span><br><span class="line">        ans.push_back(interval[0]);</span><br><span class="line">        int j=0;</span><br><span class="line">        for(int i=1;i&lt;interval.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(ans[j][1]&gt;=interval[i][0])</span><br><span class="line">                ans[j][1]=max(ans[j][1],interval[i][1]);</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">                ans.push_back(interval[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Solution1-排序-1"><a href="#Solution1-排序-1" class="headerlink" title="Solution1 排序"></a>Solution1 排序</h2><p><img src="https://files.mdnice.com/user/1489/e8db6a23-fe74-4f65-b6a6-6cafbddff0bc.png"></p><p>复杂度分析</p><p>时间复杂度：O(n\log n)O(nlogn)，其中 nn 为区间的数量。除去排序的开销，我们只需要一次线性扫描，所以主要的时间开销是排序的 O(n\log n)O(nlogn)。</p><p>空间复杂度：O(\log n)O(logn)，其中 nn 为区间的数量。这里计算的是存储答案之外，使用的额外空间。O(\log n)O(logn) 即为排序所需要的空间复杂度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        if (intervals.size() == 0) &#123;</span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(intervals.begin(), intervals.end());</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; merged;</span><br><span class="line">        for (int i = 0; i &lt; intervals.size(); ++i) &#123;</span><br><span class="line">            int L = intervals[i][0], R = intervals[i][1];</span><br><span class="line">            if (!merged.size() || merged.back()[1] &lt; L) &#123;</span><br><span class="line">                merged.push_back(&#123;L, R&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                merged.back()[1] = max(merged.back()[1], R);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a><a href="https://leetcode.com/problems/rotate-list/">61. 旋转链表</a></h1><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p><p> </p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2<br>输出：[4,5,1,2,3]<br>示例 2：</p><p>输入：head &#x3D; [0,1,2], k &#x3D; 4<br>输出：[2,0,1] </p><p>提示：</p><p>链表中节点的数目在范围 [0, 500] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>0 &lt;&#x3D; k &lt;&#x3D; 2 * 109</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">There is no trick for this problem. Some people used slow/fast pointers to find the tail node but I don&#x27;t see the benefit (in the sense that it doesn&#x27;t reduce the pointer move op) to do so. So I just used one loop to find the length first.</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* rotateRight(ListNode* head, int k) &#123;</span><br><span class="line">        if(!head) return head;</span><br><span class="line">        </span><br><span class="line">        int len=1; // number of nodes</span><br><span class="line">        ListNode *newH, *tail;</span><br><span class="line">        newH=tail=head;</span><br><span class="line">        </span><br><span class="line">        while(tail-&gt;next)  // get the number of nodes in the list</span><br><span class="line">        &#123;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        tail-&gt;next = head; // circle the link</span><br><span class="line"></span><br><span class="line">        if(k %= len) </span><br><span class="line">        &#123;</span><br><span class="line">            for(auto i=0; i&lt;len-k; i++) tail = tail-&gt;next; // the tail node is the (len-k)-th node (1st node is head)</span><br><span class="line">        &#125;</span><br><span class="line">        newH = tail-&gt;next; </span><br><span class="line">        tail-&gt;next = NULL;</span><br><span class="line">        return newH;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution1-暴力-11"><a href="#Solution1-暴力-11" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Soluion2-闭环"><a href="#Soluion2-闭环" class="headerlink" title="Soluion2  闭环"></a>Soluion2  闭环</h2><p><img src="https://files.mdnice.com/user/1489/319c806f-a568-403a-9a39-c4ac50f30308.png"></p><h1 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a><a href="https://leetcode.com/problems/plus-one/">66. 加一</a></h1><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p> </p><p>示例 1：</p><p>输入：digits &#x3D; [1,2,3]<br>输出：[1,2,4]<br>解释：输入数组表示数字 123。<br>示例 2：</p><p>输入：digits &#x3D; [4,3,2,1]<br>输出：[4,3,2,2]<br>解释：输入数组表示数字 4321。<br>示例 3：</p><p>输入：digits &#x3D; [0]<br>输出：[1] </p><p>提示：</p><p>1 &lt;&#x3D; digits.length &lt;&#x3D; 100<br>0 &lt;&#x3D; digits[i] &lt;&#x3D; 9</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">My solution is nothing special and isn&#x27;t clever at all. I decided to post it since I thought the &quot;official&quot; solution article from leetcode was very poorly written and confused me more, even after I solved it on my own.</span><br><span class="line"></span><br><span class="line">So, I believe my comments below should explain the idea, but I want to add that it helps to test the more obscure test cases for this problem to understand the algorithm. For example:</span><br><span class="line"></span><br><span class="line">[9]</span><br><span class="line">[9090]</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123;</span><br><span class="line">      int n = digits.size() - 1;</span><br><span class="line">      </span><br><span class="line">      for (int i = n; i &gt;= 0; --i) &#123; // traverse digits from the last element (least significant)</span><br><span class="line">        // since we begin with the last digit, increasing that digit by one</span><br><span class="line">        // results in overflow.  Therefore, all elements PRIOR to digits[0]</span><br><span class="line">        // need to be considered since there may be additional nines between</span><br><span class="line">        // digits[0], ... , digits[n].</span><br><span class="line">        if (digits[i] == 9) &#123;  </span><br><span class="line">          digits[i] = 0;</span><br><span class="line">        &#125; else &#123;  // current digit is not 9 so we can safely increment by one</span><br><span class="line">          digits[i] += 1;</span><br><span class="line">          return digits;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // if the program runs to this point, each 9 is now a 0.</span><br><span class="line">      // to get a correct solution, we need to add one more element with </span><br><span class="line">      // a value of zero AND set digits[0] to 1 (in the most significant position)</span><br><span class="line">      // to account for the carry digit.</span><br><span class="line">      digits.push_back(0);</span><br><span class="line">      digits[0] = 1;</span><br><span class="line">      return digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution-0-暴力"><a href="#Solution-0-暴力" class="headerlink" title="Solution 0  暴力"></a>Solution 0  暴力</h2><h2 id="Solution-1-逆序遍历-找到9"><a href="#Solution-1-逆序遍历-找到9" class="headerlink" title="Solution 1 逆序遍历 找到9"></a>Solution 1 逆序遍历 找到9</h2><p><img src="https://files.mdnice.com/user/1489/846120fb-5574-4fde-bd23-c798e938fa6e.png"></p><h1 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a href="https://leetcode.com/problems/sort-colors/">75. 颜色分类</a></h1><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>必须在不使用库的sort函数的情况下解决这个问题。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [2,0,2,1,1,0]<br>输出：[0,0,1,1,2,2]<br>示例 2：</p><p>输入：nums &#x3D; [2,0,1]<br>输出：[0,1,2] </p><p>提示：</p><p>n &#x3D;&#x3D; nums.length<br>1 &lt;&#x3D; n &lt;&#x3D; 300<br>nums[i] 为 0、1 或 2 </p><p>进阶：</p><p>你可以不使用代码库中的排序函数来解决这道题吗？<br>你能想出一个仅使用常数空间的一趟扫描算法吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">The solution requires the use of tracking 3 positions, the Low, Mid and High.</span><br><span class="line"></span><br><span class="line">We assume that the mid is the &quot;Unknown&quot; area that we must evaluate.</span><br><span class="line"></span><br><span class="line">If we encounter a 0, we know that it will be on the low end of the array, and if we encounter a 2, we know it will be on the high end of the array.</span><br><span class="line"></span><br><span class="line">To achieve this in one pass without preprocessing (counting), we simply traverse the unknown will generating the low and high ends.</span><br><span class="line"></span><br><span class="line">Take this example:</span><br><span class="line"></span><br><span class="line">Assume our input is: 1 0 2 2 1 0 (short for simplicity).</span><br><span class="line"></span><br><span class="line">Running the algorithm by hand would look something like:</span><br><span class="line"></span><br><span class="line">    1 0 2 2 1 0</span><br><span class="line">    ^         ^</span><br><span class="line">    L         H</span><br><span class="line">    M</span><br><span class="line"></span><br><span class="line">    Mid != 0 || 2</span><br><span class="line">    Mid++</span><br><span class="line"></span><br><span class="line">    1 0 2 2 1 0</span><br><span class="line">    ^ ^       ^</span><br><span class="line">    L M       H</span><br><span class="line"></span><br><span class="line">    Mid == 0</span><br><span class="line">    Swap Low and Mid</span><br><span class="line">    Mid++</span><br><span class="line">    Low++</span><br><span class="line"></span><br><span class="line">    0 1 2 2 1 0</span><br><span class="line">      ^ ^     ^</span><br><span class="line">      L M     H</span><br><span class="line"></span><br><span class="line">    Mid == 2</span><br><span class="line">    Swap High and Mid</span><br><span class="line">    High--</span><br><span class="line"></span><br><span class="line">    0 1 0 2 1 2</span><br><span class="line">      ^ ^   ^</span><br><span class="line">      L M   H</span><br><span class="line"></span><br><span class="line">    Mid == 0</span><br><span class="line">    Swap Low and Mid</span><br><span class="line">    Mid++</span><br><span class="line">    Low++</span><br><span class="line"></span><br><span class="line">    0 0 1 2 1 2</span><br><span class="line">        ^ ^ ^</span><br><span class="line">        L M H</span><br><span class="line"></span><br><span class="line">    Mid == 2</span><br><span class="line">    Swap High and Mid</span><br><span class="line">    High--</span><br><span class="line"></span><br><span class="line">    0 0 1 1 2 2</span><br><span class="line">        ^ ^</span><br><span class="line">        L M</span><br><span class="line">          H</span><br><span class="line"></span><br><span class="line">    Mid &lt;= High is our exit case</span><br></pre></td></tr></table></figure><h2 id="Solution1-暴力-12"><a href="#Solution1-暴力-12" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><p>根据题目中的提示，我们可以统计出数组中 0, 1, 20,1,2 的个数，再根据它们的数量，重写整个数组。这种方法较为简单，也很容易想到，而本题解中会介绍两种基于指针进行交换的方法。</p><h2 id="Solution2-单指针"><a href="#Solution2-单指针" class="headerlink" title="Solution2 单指针"></a>Solution2 单指针</h2><p>我们可以考虑对数组进行两次遍历。在第一次遍历中，我们将数组中所有的 00 交换到数组的头部。在第二次遍历中，我们将数组中所有的 11 交换到头部的 00 之后。此时，所有的 22 都出现在数组的尾部，这样我们就完成了排序。</p><p>具体地，我们使用一个指针 \textit{ptr}ptr 表示「头部」的范围，\textit{ptr}ptr 中存储了一个整数，表示数组 \textit{nums}nums 从位置 00 到位置 \textit{ptr}-1ptr−1 都属于「头部」。\textit{ptr}ptr 的初始值为 00，表示还没有数处于「头部」。</p><p>在第一次遍历中，我们从左向右遍历整个数组，如果找到了 00，那么就需要将 00 与「头部」位置的元素进行交换，并将「头部」向后扩充一个位置。在遍历结束之后，所有的 00 都被交换到「头部」的范围，并且「头部」只包含 00。</p><p>在第二次遍历中，我们从「头部」开始，从左向右遍历整个数组，如果找到了 11，那么就需要将 11 与「头部」位置的元素进行交换，并将「头部」向后扩充一个位置。在遍历结束之后，所有的 11 都被交换到「头部」的范围，并且都在 00 之后，此时 22 只出现在「头部」之外的位置，因此排序完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void sortColors(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int ptr = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (nums[i] == 0) &#123;</span><br><span class="line">                swap(nums[i], nums[ptr]);</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = ptr; i &lt; n; ++i) &#123;</span><br><span class="line">            if (nums[i] == 1) &#123;</span><br><span class="line">                swap(nums[i], nums[ptr]);</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution3-双指针"><a href="#Solution3-双指针" class="headerlink" title="Solution3 双指针"></a>Solution3 双指针</h2><p><img src="https://files.mdnice.com/user/1489/d99bbb87-979c-426b-b6e5-647acf2cad20.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void sortColors(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int p0 = 0, p2 = n - 1;</span><br><span class="line">        for (int i = 0; i &lt;= p2; ++i) &#123;</span><br><span class="line">            while (i &lt;= p2 &amp;&amp; nums[i] == 2) &#123;</span><br><span class="line">                swap(nums[i], nums[p2]);</span><br><span class="line">                --p2;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums[i] == 0) &#123;</span><br><span class="line">                swap(nums[i], nums[p0]);</span><br><span class="line">                ++p0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h1><p>给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</p><p> </p><p>示例 1：</p><p>输入：head &#x3D; [1,1,2]<br>输出：[1,2]<br>示例 2：</p><p>输入：head &#x3D; [1,1,2,3,3]<br>输出：[1,2,3] </p><p>提示：</p><p>链表中节点数目在范围 [0, 300] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>题目数据保证链表已经按升序 排列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> noticed that the solutions posted here are too long and complicated. They use unnecessary variables and/or checks etc.</span><br><span class="line">The solution can be much more concise. Here is my solution:</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *deleteDuplicates(ListNode *head) &#123;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        while (cur) &#123;</span><br><span class="line">            while (cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val)</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Note about freeing memory. We need to free memory when we delete a node. But don&#x27;t use delete node; construct on an interview without discussing it with the interviewer. A list node can be allocated in many different ways and we can use delete node; only if we are sure that the nodes were allocated with new TreeNode(...);.</span><br></pre></td></tr></table></figure><h2 id="Solution1-一次遍历"><a href="#Solution1-一次遍历" class="headerlink" title="Solution1 一次遍历"></a>Solution1 一次遍历</h2><p>方法一：一次遍历<br>思路与算法</p><p>由于给定的链表是排好序的，因此重复的元素在链表中出现的位置是连续的，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。</p><p>具体地，我们从指针 \textit{cur}cur 指向链表的头节点，随后开始对链表进行遍历。如果当前 \textit{cur}cur 与 \textit{cur.next}cur.next 对应的元素相同，那么我们就将 \textit{cur.next}cur.next 从链表中移除；否则说明链表中已经不存在其它与 \textit{cur}cur 对应的元素相同的节点，因此可以将 \textit{cur}cur 指向 \textit{cur.next}cur.next。</p><p>当遍历完整个链表之后，我们返回链表的头节点即可。</p><p>细节</p><p>当我们遍历到链表的最后一个节点时，\textit{cur.next}cur.next 为空节点，如果不加以判断，访问 \textit{cur.next}cur.next 对应的元素会产生运行错误。因此我们只需要遍历到链表的最后一个节点，而不需要遍历完整个链表。</p><p>复杂度分析</p><p>时间复杂度：O(n)O(n)，其中 nn 是链表的长度。</p><p>空间复杂度：O(1)O(1)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">        if (!head) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        while (cur-&gt;next) &#123;</span><br><span class="line">            if (cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a><a href="https://leetcode.com/problems/partition-list/">86. 分隔链表</a></h1><p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p><p>你应当 保留 两个分区中每个节点的初始相对位置。</p><p> </p><p>示例 1：</p><p>输入：head &#x3D; [1,4,3,2,5,2], x &#x3D; 3<br>输出：[1,2,2,4,3,5]<br>示例 2：</p><p>输入：head &#x3D; [2,1], x &#x3D; 2<br>输出：[1,2] </p><p>提示：</p><p>链表中节点的数目在范围 [0, 200] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>-200 &lt;&#x3D; x &lt;&#x3D; 200</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Approach 1: Two Pointer Approach</span><br><span class="line">Intuition</span><br><span class="line"></span><br><span class="line">We can take two pointers before and after to keep track of the two linked lists as described above. These two pointers could be used two create two separate lists and then these lists could be combined to form the desired reformed list.</span><br><span class="line"></span><br><span class="line">Algorithm</span><br><span class="line"></span><br><span class="line">Initialize two pointers before and after. In the implementation we have initialized these two with a dummy ListNode. This helps to reduce the number of conditional checks we would need otherwise. You can try an implementation where you don&#x27;t initialize with a dummy node and see it yourself!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dummy Node Initialization</span><br><span class="line"></span><br><span class="line">Iterate the original linked list, using the head pointer.</span><br><span class="line"></span><br><span class="line">If the node&#x27;s value pointed by head is lesser than x, the node should be part of the before list. So we move it to before list.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Else, the node should be part of after list. So we move it to after list.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Once we are done with all the nodes in the original linked list, we would have two list before and after. The original list nodes are either part of before list or after list, depending on its value.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Note: Since we traverse the original linked list from left to right, at no point would the order of nodes change relatively in the two lists. Another important thing to note here is that we show the original linked list intact in the above diagrams. However, in the implementation, we remove the nodes from the original linked list and attach them in the before or after list. We don&#x27;t utilize any additional space. We simply move the nodes from the original list around.</span><br><span class="line"></span><br><span class="line">Now, these two lists before and after can be combined to form the reformed list.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">We did a dummy node initialization at the start to make implementation easier, you don&#x27;t want that to be part of the returned list, hence just move ahead one node in both the lists while combining the two list. Since both before and after have an extra node at the front.</span><br></pre></td></tr></table></figure><h2 id="Solution1-双指针"><a href="#Solution1-双指针" class="headerlink" title="Solution1  双指针"></a>Solution1  双指针</h2><p><img src="https://files.mdnice.com/user/1489/1a1aae99-5b02-4641-9e50-5bd0913d1e4d.png"></p><h1 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a href="https://leetcode.com/problems/merge-sorted-array/">88. 合并两个有序数组</a></h1><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><p> </p><p>示例 1：</p><p>输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3<br>输出：[1,2,2,3,5,6]<br>解释：需要合并 [1,2,3] 和 [2,5,6] 。<br>合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。<br>示例 2：</p><p>输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0<br>输出：[1]<br>解释：需要合并 [1] 和 [] 。<br>合并结果是 [1] 。<br>示例 3：</p><p>输入：nums1 &#x3D; [0], m &#x3D; 0, nums2 &#x3D; [1], n &#x3D; 1<br>输出：[1]<br>解释：需要合并的数组是 [] 和 [1] 。<br>合并结果是 [1] 。<br>注意，因为 m &#x3D; 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。 </p><p>提示：</p><p>nums1.length &#x3D;&#x3D; m + n<br>nums2.length &#x3D;&#x3D; n<br>0 &lt;&#x3D; m, n &lt;&#x3D; 200<br>1 &lt;&#x3D; m + n &lt;&#x3D; 200<br>-109 &lt;&#x3D; nums1[i], nums2[j] &lt;&#x3D; 109 </p><p>进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？</p><p>This code relies on the simple observation that once all of the numbers from nums2 have been merged into nums1, the rest of the numbers in nums1 that were not moved are already in the correct place.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">The way to think about the solution is that we will have to do a reverse sorting.</span><br><span class="line">We initialize k=m+n-1 as that will be the last location of nums1.</span><br><span class="line">We will keep checking for the greater element of the two arrays(i=m-1,j=n-1) and insert the values.</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">nums1 = [1,2,3,0,0,0]</span><br><span class="line">             |     |</span><br><span class="line">             i     k</span><br><span class="line"></span><br><span class="line">nums2 = [2,5,6]</span><br><span class="line">             |</span><br><span class="line">             j</span><br><span class="line">nums2[j]&gt;nums1[i] thus nums1[k]=6</span><br><span class="line">k and j are decremented.</span><br><span class="line"></span><br><span class="line">nums1 = [1,2,3,0,0,6]</span><br><span class="line">             |     |</span><br><span class="line">             i     k</span><br><span class="line"></span><br><span class="line">nums2 = [2,5,6]</span><br><span class="line">           |</span><br><span class="line">           j</span><br><span class="line">nums2[j]&gt;nums1[i] thus nums1[k]=5</span><br><span class="line">k and j are decremented.</span><br><span class="line"></span><br><span class="line">nums1 = [1,2,3,0,5,6]</span><br><span class="line">             |   |</span><br><span class="line">             i   k</span><br><span class="line"></span><br><span class="line">nums2 = [2,5,6]</span><br><span class="line">         |</span><br><span class="line">         j</span><br><span class="line">We keep following up this procedure and we get the desired reult.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        int i=m-1,j=n-1,k=m+n-1;</span><br><span class="line">        while(i&gt;=0&amp;&amp;j&gt;=0)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums1[i]&gt;nums2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                nums1[k]=nums1[i];</span><br><span class="line">                i--;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                nums1[k]=nums2[j];</span><br><span class="line">                j--;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(i&gt;=0)</span><br><span class="line">            nums1[k--]=nums1[i--];</span><br><span class="line">        while(j&gt;=0)</span><br><span class="line">            nums1[k--]=nums2[j--];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Solution1-暴力直接合并后排序"><a href="#Solution1-暴力直接合并后排序" class="headerlink" title="Solution1 暴力直接合并后排序"></a>Solution1 暴力直接合并后排序</h2><p><img src="https://files.mdnice.com/user/1489/8aeff7af-53ed-467e-aebc-7835db5b52f5.png"></p><h2 id="Solution2-双指针-1"><a href="#Solution2-双指针-1" class="headerlink" title="Solution2 双指针"></a>Solution2 双指针</h2><p><img src="https://files.mdnice.com/user/1489/5be86979-df7c-4994-a29c-088dc60e24e6.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        int p1 = 0, p2 = 0;</span><br><span class="line">        int sorted[m + n];</span><br><span class="line">        int cur;</span><br><span class="line">        while (p1 &lt; m || p2 &lt; n) &#123;</span><br><span class="line">            if (p1 == m) &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125; else if (p2 == n) &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125; else if (nums1[p1] &lt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">            sorted[p1 + p2 - 1] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i != m + n; ++i) &#123;</span><br><span class="line">            nums1[i] = sorted[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(m+n)O(m+n)。<br>指针移动单调递增，最多移动 m+nm+n 次，因此时间复杂度为 O(m+n)O(m+n)。</p><p>空间复杂度：O(m+n)O(m+n)。<br>需要建立长度为 m+nm+n 的中间数组 \textit{sorted}sorted。</p><h2 id="Solution3-逆向双指针"><a href="#Solution3-逆向双指针" class="headerlink" title="Solution3 逆向双指针"></a>Solution3 逆向双指针</h2><p><img src="https://files.mdnice.com/user/1489/a825eedd-e311-4153-bc5b-ed31be497911.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        int p1 = m - 1, p2 = n - 1;</span><br><span class="line">        int tail = m + n - 1;</span><br><span class="line">        int cur;</span><br><span class="line">        while (p1 &gt;= 0 || p2 &gt;= 0) &#123;</span><br><span class="line">            if (p1 == -1) &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125; else if (p2 == -1) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; else if (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">            nums1[tail--] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h1><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。 </p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4,5], left &#x3D; 2, right &#x3D; 4<br>输出：[1,4,3,2,5]<br>示例 2：</p><p>输入：head &#x3D; [5], left &#x3D; 1, right &#x3D; 1<br>输出：[5] </p><p>提示：</p><p>链表中节点数目为 n<br>1 &lt;&#x3D; n &lt;&#x3D; 500<br>-500 &lt;&#x3D; Node.val &lt;&#x3D; 500<br>1 &lt;&#x3D; left &lt;&#x3D; right &lt;&#x3D; n </p><p>进阶： 你可以使用一趟扫描完成反转吗？</p><h2 id="Solution1-原地反转"><a href="#Solution1-原地反转" class="headerlink" title="Solution1 原地反转"></a>Solution1 原地反转</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Algorithm</span><br><span class="line"></span><br><span class="line">We define a recursion function that will do the job of reversing a portion of the linked list.</span><br><span class="line">Let&#x27;s call this function recurse. The function takes in 3 parameters: m being the starting point of the reversal, n being the ending point for the reversal, and a pointer right which will start at the n^&#123;th&#125;n </span><br><span class="line">th</span><br><span class="line">  node in the linked list and move backwards with the backtracking of the recursion. If this is not clear at the moment, the diagrams that follow will help.</span><br><span class="line">Additionally, we have a pointer called left which starts from the m^&#123;th&#125;m </span><br><span class="line">th</span><br><span class="line">  node in the linked list and moves forward. In Python, we have to take a global variable for this which get&#x27;s changed with recursion. In other languages, where changes made in function calls persist, we can consider this pointer as an additional variable for the function recurse.</span><br><span class="line">In a recursion call, given m, n, and right, we check if n == 1. If this is the case, we don&#x27;t need to go any further.</span><br><span class="line">Until we reach n = 1, we keep moving the right pointer one step forward and after doing that, we make a recursive call with the value of n decreased by 1. At the same time, we keep on moving the left pointer forward until m == 1. When we refer to a pointer being moved forward, it essentially means pointer.next.</span><br><span class="line">So we backtrack as soon as n reaches 1. At that point of time, the right pointer is at the last node of the sublist we want to reverse and the left has already reached the first node of this sublist. So, we swap out the data and move the left pointer one step forward using left = left.next. We need this change to persist across the backtracking process.</span><br><span class="line">From there on, every time we backtrack, the right pointer moves one step backwards. This is the simulation we&#x27;ve been mentioning all along. The backward movement is simulated by backtracking.</span><br><span class="line">We stop the swaps when either right == left, which happens if the sublist size is odd, or, right.next == left which happens when during the backtracking process for an even sized sublist, the right pointer crosses left. We use a global boolean flag for stopping the swaps once these conditions are met.</span><br><span class="line">Let&#x27;s look at a series of diagrams explaining the process on a sample linked list. Hopefully, things would be clearer after this.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">This is the first step in the recursion process. We have a list given to us and the left and the right pointers start off from the head of the linked list. The first step makes a recursive call with updated values of m and n i.e. their values each reduced by 1. Also, the left and the right pointers move one step forward in the linked list.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The next two steps show the movement of the left and the right pointers in the list. Notice that after the second step, the left pointer reaches it&#x27;s designated spot. So, we don&#x27;t move it any further. Only the right pointer progresses from here on out until it reaches node 6.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">As we can see, after the step 5, both the pointers are in their designated spots in the list and we can start the backtracking process. We don&#x27;t recurse further. The operation performed during the backtracking is swapping of data between the left and right nodes.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The right pointer crosses the left pointer after step 3 (backtracking) as can be seen above and by that point, we have already reversed the required portion of the linked list. We needed the output list to be [7 → 9 → 8 → 1 → 10 → 2 → 6] and that&#x27;s what we have. So, we don&#x27;t perform any more swaps and in the code, we can use a global boolean flag to stop the swapping after a point. We can&#x27;t really break out of recursion per say.</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/1d9b3377-72f8-4c1b-8451-a2e484bfdc1c.png"></p><h1 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a><a href="https://leetcode.com/problems/pascals-triangle/">118. 杨辉三角</a></h1><p>给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p> </p><p>示例 1:</p><p>输入: numRows &#x3D; 5<br>输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]<br>示例 2:</p><p>输入: numRows &#x3D; 1<br>输出: [[1]]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The pascal triangle problem has a very simple and intuitive dynamic programming approach. As the definition states, every element of a row is formed by the sum of the two numbers directly above. So, we can just apply DP and use the previously stored rows of trianlge to calculate the new rows.</span><br><span class="line"></span><br><span class="line">We can just initialize the start and end elements of each row as 1 and update only the elements between them. This will make the code simpler and avoid the need of having extra checks for edge elements of each row.</span><br></pre></td></tr></table></figure><h2 id="Solution1-直接求解"><a href="#Solution1-直接求解" class="headerlink" title="Solution1 直接求解"></a>Solution1 直接求解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; yanghui;</span><br><span class="line">        for (int i = 0; i &lt; numRows; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; data(i + 1);</span><br><span class="line">            yanghui.push_back(data);</span><br><span class="line">            for (int j = 0; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                if(j == 0) yanghui[i][j] = 1;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    yanghui[i][j] = yanghui[i - 1][j - 1] + yanghui[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            yanghui[i][yanghui[i].size() - 1] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return yanghui;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a><a href="https://leetcode.com/problems/valid-palindrome/">125. 验证回文串</a></h1><p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个回文串。</p><p>字母和数字都属于字母数字字符。</p><p>给你一个字符串 s，如果它是回文串，返回 true ；否则，返回 false 。</p><p> </p><p>示例 1：</p><p>输入: “A man, a plan, a canal: Panama”<br>输出：true<br>解释：”amanaplanacanalpanama” 是回文串。<br>示例 2：</p><p>输入：”race a car”<br>输出：false<br>解释：”raceacar” 不是回文串。<br>示例 3：</p><p>输入：s &#x3D; “ “<br>输出：true<br>解释：在移除非字母数字字符之后，s 是一个空字符串 “” 。<br>由于空字符串正着反着读都一样，所以是回文串。 </p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 2 * 105<br>s 仅由可打印的 ASCII 字符组成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool isPalindrome(string s) &#123;</span><br><span class="line">    for (int i = 0, j = s.size() - 1; i &lt; j; i++, j--) &#123; // Move 2 pointers from each end until they collide</span><br><span class="line">        while (isalnum(s[i]) == false &amp;&amp; i &lt; j) i++; // Increment left pointer if not alphanumeric</span><br><span class="line">        while (isalnum(s[j]) == false &amp;&amp; i &lt; j) j--; // Decrement right pointer if no alphanumeric</span><br><span class="line">        if (toupper(s[i]) != toupper(s[j])) return false; // Exit and return error if not match</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Solution1-筛选-判断"><a href="#Solution1-筛选-判断" class="headerlink" title="Solution1 筛选 + 判断"></a>Solution1 筛选 + 判断</h2><p><img src="https://files.mdnice.com/user/1489/fb453ee9-27d8-4bad-86ea-346219e70b18.png"></p><h2 id="Solution2-筛选-判断-02"><a href="#Solution2-筛选-判断-02" class="headerlink" title="Solution2 筛选 + 判断 02"></a>Solution2 筛选 + 判断 02</h2><p><img src="https://files.mdnice.com/user/1489/bd915655-54ae-4387-8d94-22cabd830f19.png"></p><h2 id="Solution03-在原字符串上直接判断"><a href="#Solution03-在原字符串上直接判断" class="headerlink" title="Solution03 在原字符串上直接判断"></a>Solution03 在原字符串上直接判断</h2><p><img src="https://files.mdnice.com/user/1489/4391ada0-91de-488d-a3a9-23fa346ea804.png"></p><h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.com/problems/linked-list-cycle/">141. 环形链表</a></h1><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><p> </p><p>示例 1：</p><p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p><p>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p><p>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：false<br>解释：链表中没有环。 </p><p>提示：</p><p>链表中节点的数目范围是 [0, 104]<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>pos 为 -1 或者链表中的一个 有效索引 。 </p><p>进阶：你能用 O(1)（即，常量）内存解决此问题吗？</p><h2 id="Solution1-哈希表"><a href="#Solution1-哈希表" class="headerlink" title="Solution1 哈希表"></a>Solution1 哈希表</h2><p><img src="https://files.mdnice.com/user/1489/f65c3a6a-debe-4c68-ac3b-171b07af7262.png"></p><h2 id="Solution2-3"><a href="#Solution2-3" class="headerlink" title="Solution2"></a>Solution2</h2><p><img src="https://files.mdnice.com/user/1489/9add3a1c-b13f-4277-a2b6-e511bf914864.png"></p><p><img src="https://files.mdnice.com/user/1489/1411c0a9-8a0f-452f-8fc6-ff371d70d1d0.png"></p><p><img src="https://files.mdnice.com/user/1489/fc7adb50-508e-4b31-b28e-f3f11eea8217.png"></p><h1 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h1><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改 链表。</p><p> </p><p>示例 1：</p><p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p><p>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p><p>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：返回 null<br>解释：链表中没有环。 </p><p>提示：</p><p>链表中节点的数目范围在范围 [0, 104] 内<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>pos 的值为 -1 或者链表中的一个有效索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Alogrithm Description:</span><br><span class="line">Step 1: Determine whether there is a cycle</span><br><span class="line"></span><br><span class="line">1.1) Using a slow pointer that move forward 1 step each time</span><br><span class="line"></span><br><span class="line">1.2) Using a fast pointer that move forward 2 steps each time</span><br><span class="line"></span><br><span class="line">1.3) If the slow pointer and fast pointer both point to the same location after several moving steps, there is a cycle;</span><br><span class="line"></span><br><span class="line">1.4) Otherwise, if (fast-&gt;next == NULL || fast-&gt;next-&gt;next == NULL), there has no cycle.</span><br><span class="line"></span><br><span class="line">Step 2: If there is a cycle, return the entry location of the cycle</span><br><span class="line"></span><br><span class="line">2.1) L1 is defined as the distance between the head point and entry point</span><br><span class="line"></span><br><span class="line">2.2) L2 is defined as the distance between the entry point and the meeting point</span><br><span class="line"></span><br><span class="line">2.3) C is defined as the length of the cycle</span><br><span class="line"></span><br><span class="line">2.4) n is defined as the travel times of the fast pointer around the cycle When the first encounter of the slow pointer and the fast pointer</span><br><span class="line"></span><br><span class="line">According to the definition of L1, L2 and C, we can obtain:</span><br><span class="line"></span><br><span class="line">the total distance of the slow pointer traveled when encounter is L1 + L2</span><br><span class="line"></span><br><span class="line">the total distance of the fast pointer traveled when encounter is L1 + L2 + n * C</span><br><span class="line"></span><br><span class="line">Because the total distance the fast pointer traveled is twice as the slow pointer, Thus:</span><br><span class="line"></span><br><span class="line">2 * (L1+L2) = L1 + L2 + n * C =&gt; L1 + L2 = n * C =&gt; L1 = (n - 1) C + (C - L2)*</span><br><span class="line"></span><br><span class="line">It can be concluded that the distance between the head location and entry location is equal to the distance between the meeting location and the entry location along the direction of forward movement.</span><br><span class="line"></span><br><span class="line">So, when the slow pointer and the fast pointer encounter in the cycle, we can define a pointer &quot;entry&quot; that point to the head, this &quot;entry&quot; pointer moves one step each time so as the slow pointer. When this &quot;entry&quot; pointer and the slow pointer both point to the same location, this location is the node where the cycle begins.</span><br></pre></td></tr></table></figure><h2 id="Solution1-哈希表-1"><a href="#Solution1-哈希表-1" class="headerlink" title="Solution1 哈希表"></a>Solution1 哈希表</h2><p><img src="https://files.mdnice.com/user/1489/335701cf-1815-4ee0-a266-d54c6c35669b.png"></p><h2 id="Solution2-双指针-2"><a href="#Solution2-双指针-2" class="headerlink" title="Solution2 双指针"></a>Solution2 双指针</h2><p><img src="https://files.mdnice.com/user/1489/725fc0e8-c8e6-4660-b971-9c47beb3c888.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        while (fast != nullptr) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            if (fast-&gt;next == nullptr) &#123;</span><br><span class="line">                return nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            if (fast == slow) &#123;</span><br><span class="line">                ListNode *ptr = head;</span><br><span class="line">                while (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                return ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/7323d75f-2b46-4b8a-9908-4f5c654281f5.png"></p><h1 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a href="https://leetcode.com/problems/reorder-list/">143. 重排链表</a></h1><p>给定一个单链表 L 的头节点 head ，单链表 L 表示为：</p><p>L0 → L1 → … → Ln - 1 → Ln<br>请将其重新排列后变为：</p><p>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …<br>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p> </p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4]<br>输出：[1,4,2,3]<br>示例 2：</p><p>输入：head &#x3D; [1,2,3,4,5]<br>输出：[1,5,2,4,3] </p><p>提示：</p><p>链表的长度范围为 [1, 5 * 104]<br>1 &lt;&#x3D; node.val &lt;&#x3D; 1000</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">If you never solved singly linked lists problems before, or you do not have a lot of experience, this problem can be quite difficult. However if you already know all the tricks, it is not difficult at all. Let us first try to understand what we need to do. For list [1,2,3,4,5,6,7] we need to return [1,7,2,6,3,5,4]. We can note, that it is actually two lists [1,2,3,4] and [7,6,5], where elements are interchange. So, to succeed we need to do the following steps:</span><br><span class="line"></span><br><span class="line">Find the middle of or list - be careful, it needs to work properly both for even and for odd number of nodes. For this we can either just count number of elements and then divide it by to, and do two traversals of list. Or we can use slow/fast iterators trick, where slow moves with speed 1 and fast moves with speed 2. Then when fast reches the end, slow will be in the middle, as we need.</span><br><span class="line">Reverse the second part of linked list. Again, if you never done it before, it can be quite painful, please read oficial solution to problem 206. Reverse Linked List. The idea is to keep three pointers: prev, curr, nextt stand for previous, current and next and change connections in place. Do not forget to use slow.next = None, in opposite case you will have list with loop.</span><br><span class="line">Finally, we need to merge two lists, given its heads. These heads are denoted by head and prev, so for simplisity I created head1 and head2 variables. What we need to do now is to interchange nodes: we put head2 as next element of head1 and then say that head1 is now head2 and head2 is previous head1.next. In this way we do one step for one of the lists and rename lists, so next time we will take element from head2, then rename again and so on.</span><br><span class="line">Complexity: Time complexity is O(n), because we first do O(n) iterations to find middle, then we do O(n) iterations to reverse second half and finally we do O(n) iterations to merge lists. Space complexity is O(1).</span><br></pre></td></tr></table></figure><h2 id="Solution0-暴力-2"><a href="#Solution0-暴力-2" class="headerlink" title="Solution0 暴力"></a>Solution0 暴力</h2><h2 id="Solution1-双指针-1"><a href="#Solution1-双指针-1" class="headerlink" title="Solution1 双指针"></a>Solution1 双指针</h2><p>1.快慢指针找到中点 2.拆成两个链表 3.遍历两个链表，后面的塞到前面的“缝隙里”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">void reorderList(ListNode* head) &#123;</span><br><span class="line">    </span><br><span class="line">    if(head==NULL || head-&gt;next == NULL)</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line">    //快慢指针分出两段</span><br><span class="line">    ListNode *slow = head,*fast = head;</span><br><span class="line">    </span><br><span class="line">    while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123;</span><br><span class="line">        </span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //后端反转</span><br><span class="line">    ListNode *needReverser = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = NULL;</span><br><span class="line">    needReverser = reverse(needReverser);</span><br><span class="line">    </span><br><span class="line">    //插入前端缝隙</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    while(cur &amp;&amp; needReverser)&#123;</span><br><span class="line">        ListNode *curSecond = needReverser;</span><br><span class="line">        needReverser = needReverser-&gt;next;</span><br><span class="line">        ListNode *nextCur = cur-&gt;next;</span><br><span class="line">        curSecond-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = curSecond;</span><br><span class="line">        </span><br><span class="line">        cur = nextCur;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode *reverse(ListNode *head)&#123;</span><br><span class="line">    </span><br><span class="line">    ListNode *p1 = NULL;</span><br><span class="line">    ListNode *p2 = head;</span><br><span class="line">    ListNode *p3 = p2;</span><br><span class="line">    </span><br><span class="line">    while(p2)&#123;</span><br><span class="line">        p3 = p2-&gt;next;</span><br><span class="line">        p2-&gt;next = p1;</span><br><span class="line">        p1 = p2;</span><br><span class="line">        p2 = p3;            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return p1;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a href="https://leetcode.com/problems/lru-cache/">146. LRU 缓存</a></h1><p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：<br>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。<br>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p><p> </p><p>示例：</p><p>输入<br>[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”]<br>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]<br>输出<br>[null, null, null, 1, null, -1, null, -1, 3, 4]</p><p>解释<br>LRUCache lRUCache &#x3D; new LRUCache(2);<br>lRUCache.put(1, 1); &#x2F;&#x2F; 缓存是 {1&#x3D;1}<br>lRUCache.put(2, 2); &#x2F;&#x2F; 缓存是 {1&#x3D;1, 2&#x3D;2}<br>lRUCache.get(1);    &#x2F;&#x2F; 返回 1<br>lRUCache.put(3, 3); &#x2F;&#x2F; 该操作会使得关键字 2 作废，缓存是 {1&#x3D;1, 3&#x3D;3}<br>lRUCache.get(2);    &#x2F;&#x2F; 返回 -1 (未找到)<br>lRUCache.put(4, 4); &#x2F;&#x2F; 该操作会使得关键字 1 作废，缓存是 {4&#x3D;4, 3&#x3D;3}<br>lRUCache.get(1);    &#x2F;&#x2F; 返回 -1 (未找到)<br>lRUCache.get(3);    &#x2F;&#x2F; 返回 3<br>lRUCache.get(4);    &#x2F;&#x2F; 返回 4 </p><p>提示：</p><p>1 &lt;&#x3D; capacity &lt;&#x3D; 3000<br>0 &lt;&#x3D; key &lt;&#x3D; 10000<br>0 &lt;&#x3D; value &lt;&#x3D; 105<br>最多调用 2 * 105 次 get 和 put</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n this question we have to keep track of the most least recently used item in the cache. I have designed the cache using list and map in C++.</span><br><span class="line">We do it by following the steps below :-</span><br><span class="line"></span><br><span class="line">When we access an item in the cache it moves to the front of the list as it is the most recently used item.</span><br><span class="line">When we want to remove an item we remove it from the last of the list as it is the least recently used item in the cache.</span><br><span class="line">When we insert an item we insert it into the front of the list as it is the most recently used item.</span><br><span class="line">The idea is to store the keys in the map and its corrosponding values into the list...</span><br><span class="line">Note : splice() function here takes the element at the m[key] and places it at the beginning of the list...</span><br></pre></td></tr></table></figure><h2 id="Solution1-哈希表-双向链表"><a href="#Solution1-哈希表-双向链表" class="headerlink" title="Solution1 哈希表 + 双向链表"></a>Solution1 哈希表 + 双向链表</h2><p>方法一：哈希表 + 双向链表<br>算法</p><p>LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。</p><p>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</p><p>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。</p><p>这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1)O(1) 的时间内完成 get 或者 put 操作。具体的方法如下：</p><p>对于 get 操作，首先判断 key 是否存在：</p><p>如果 key 不存在，则返回 -1−1；</p><p>如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。</p><p>对于 put 操作，首先判断 key 是否存在：</p><p>如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；</p><p>如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。</p><p>上述各项操作中，访问哈希表的时间复杂度为 O(1)O(1)，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 O(1)O(1)。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 O(1)O(1) 时间内完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">struct DLinkedNode &#123;</span><br><span class="line">    int key, value;</span><br><span class="line">    DLinkedNode* prev;</span><br><span class="line">    DLinkedNode* next;</span><br><span class="line">    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) &#123;&#125;</span><br><span class="line">    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LRUCache &#123;</span><br><span class="line">private:</span><br><span class="line">    unordered_map&lt;int, DLinkedNode*&gt; cache;</span><br><span class="line">    DLinkedNode* head;</span><br><span class="line">    DLinkedNode* tail;</span><br><span class="line">    int size;</span><br><span class="line">    int capacity;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    LRUCache(int _capacity): capacity(_capacity), size(0) &#123;</span><br><span class="line">        // 使用伪头部和伪尾部节点</span><br><span class="line">        head = new DLinkedNode();</span><br><span class="line">        tail = new DLinkedNode();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int get(int key) &#123;</span><br><span class="line">        if (!cache.count(key)) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果 key 存在，先通过哈希表定位，再移到头部</span><br><span class="line">        DLinkedNode* node = cache[key];</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        return node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void put(int key, int value) &#123;</span><br><span class="line">        if (!cache.count(key)) &#123;</span><br><span class="line">            // 如果 key 不存在，创建一个新的节点</span><br><span class="line">            DLinkedNode* node = new DLinkedNode(key, value);</span><br><span class="line">            // 添加进哈希表</span><br><span class="line">            cache[key] = node;</span><br><span class="line">            // 添加至双向链表的头部</span><br><span class="line">            addToHead(node);</span><br><span class="line">            ++size;</span><br><span class="line">            if (size &gt; capacity) &#123;</span><br><span class="line">                // 如果超出容量，删除双向链表的尾部节点</span><br><span class="line">                DLinkedNode* removed = removeTail();</span><br><span class="line">                // 删除哈希表中对应的项</span><br><span class="line">                cache.erase(removed-&gt;key);</span><br><span class="line">                // 防止内存泄漏</span><br><span class="line">                delete removed;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span><br><span class="line">            DLinkedNode* node = cache[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void addToHead(DLinkedNode* node) &#123;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void removeNode(DLinkedNode* node) &#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void moveToHead(DLinkedNode* node) &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DLinkedNode* removeTail() &#123;</span><br><span class="line">        DLinkedNode* node = tail-&gt;prev;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="分治：148-排序链表"><a href="#分治：148-排序链表" class="headerlink" title="分治：148. 排序链表"></a><a href="https://leetcode.com/problems/sort-list/">分治：148. 排序链表</a></h1><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p><p> </p><p>示例 1：</p><p>输入：head &#x3D; [4,2,1,3]<br>输出：[1,2,3,4]<br>示例 2：</p><p>输入：head &#x3D; [-1,5,3,4,0]<br>输出：[-1,0,3,4,5]<br>示例 3：</p><p>输入：head &#x3D; []<br>输出：[] </p><p>提示：</p><p>链表中节点的数目在范围 [0, 5 * 104] 内<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Brief note about Question-</span><br><span class="line"></span><br><span class="line">We have to return the linked list after sorting it in ascending order.</span><br><span class="line">Let&#x27;s take an example not given in question -</span><br><span class="line">Suppose head of linked list given to us is like, head: [3,-9,8,67,9]</span><br><span class="line"></span><br><span class="line">then answer should like [-9,3,8,9,67] after sorting it in ascending order.</span><br><span class="line">Solution - I (Using Merge sort, Accepted)-</span><br><span class="line"></span><br><span class="line">We want to sort a linked list, then we may able to use any of the sorting algorithm and then apply on it.</span><br><span class="line">We will use merge sort here, because I find it easy to implement in linked list.</span><br><span class="line">Whole implementation totally based on the merge sort, so i strongly suggest you to read a article on the merge sort.</span><br><span class="line">Some basic thing that we will do in applying merge sort on our linked list are-</span><br><span class="line">We divide our linked liist into two equal parts until when only one element is left.</span><br><span class="line">After that we start merge them on the basis of value.</span><br><span class="line">Now, if we divide them into two equal parts then then how we will find mid in linked list.</span><br><span class="line">We find mid of linked list using tortise and hare method or say using fast and slow pointer.</span><br><span class="line">See commented code for more explanation.</span><br></pre></td></tr></table></figure><h2 id="Solution1-自顶向下归并排序"><a href="#Solution1-自顶向下归并排序" class="headerlink" title="Solution1 自顶向下归并排序"></a>Solution1 自顶向下归并排序</h2><p><img src="https://files.mdnice.com/user/1489/d5233fdc-b942-4252-b385-aeaa32428270.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* sortList(ListNode* head) &#123;</span><br><span class="line">        return sortList(head, nullptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* sortList(ListNode* head, ListNode* tail) &#123;</span><br><span class="line">        if (head == nullptr) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        if (head-&gt;next == tail) &#123;</span><br><span class="line">            head-&gt;next = nullptr;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow = head, *fast = head;</span><br><span class="line">        while (fast != tail) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            if (fast != tail) &#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* mid = slow;</span><br><span class="line">        return merge(sortList(head, mid), sortList(mid, tail));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* merge(ListNode* head1, ListNode* head2) &#123;</span><br><span class="line">        ListNode* dummyHead = new ListNode(0);</span><br><span class="line">        ListNode* temp = dummyHead, *temp1 = head1, *temp2 = head2;</span><br><span class="line">        while (temp1 != nullptr &amp;&amp; temp2 != nullptr) &#123;</span><br><span class="line">            if (temp1-&gt;val &lt;= temp2-&gt;val) &#123;</span><br><span class="line">                temp-&gt;next = temp1;</span><br><span class="line">                temp1 = temp1-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                temp-&gt;next = temp2;</span><br><span class="line">                temp2 = temp2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (temp1 != nullptr) &#123;</span><br><span class="line">            temp-&gt;next = temp1;</span><br><span class="line">        &#125; else if (temp2 != nullptr) &#123;</span><br><span class="line">            temp-&gt;next = temp2;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution2-自底向上归并排序"><a href="#Solution2-自底向上归并排序" class="headerlink" title="Solution2 自底向上归并排序"></a>Solution2 自底向上归并排序</h2><p><img src="https://files.mdnice.com/user/1489/76432652-12d7-4385-8ea8-6dae686cd490.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* sortList(ListNode* head) &#123;</span><br><span class="line">        if (head == nullptr) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        int length = 0;</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        while (node != nullptr) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* dummyHead = new ListNode(0, head);</span><br><span class="line">        for (int subLength = 1; subLength &lt; length; subLength &lt;&lt;= 1) &#123;</span><br><span class="line">            ListNode* prev = dummyHead, *curr = dummyHead-&gt;next;</span><br><span class="line">            while (curr != nullptr) &#123;</span><br><span class="line">                ListNode* head1 = curr;</span><br><span class="line">                for (int i = 1; i &lt; subLength &amp;&amp; curr-&gt;next != nullptr; i++) &#123;</span><br><span class="line">                    curr = curr-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode* head2 = curr-&gt;next;</span><br><span class="line">                curr-&gt;next = nullptr;</span><br><span class="line">                curr = head2;</span><br><span class="line">                for (int i = 1; i &lt; subLength &amp;&amp; curr != nullptr &amp;&amp; curr-&gt;next != nullptr; i++) &#123;</span><br><span class="line">                    curr = curr-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode* next = nullptr;</span><br><span class="line">                if (curr != nullptr) &#123;</span><br><span class="line">                    next = curr-&gt;next;</span><br><span class="line">                    curr-&gt;next = nullptr;</span><br><span class="line">                &#125;</span><br><span class="line">                ListNode* merged = merge(head1, head2);</span><br><span class="line">                prev-&gt;next = merged;</span><br><span class="line">                while (prev-&gt;next != nullptr) &#123;</span><br><span class="line">                    prev = prev-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* merge(ListNode* head1, ListNode* head2) &#123;</span><br><span class="line">        ListNode* dummyHead = new ListNode(0);</span><br><span class="line">        ListNode* temp = dummyHead, *temp1 = head1, *temp2 = head2;</span><br><span class="line">        while (temp1 != nullptr &amp;&amp; temp2 != nullptr) &#123;</span><br><span class="line">            if (temp1-&gt;val &lt;= temp2-&gt;val) &#123;</span><br><span class="line">                temp-&gt;next = temp1;</span><br><span class="line">                temp1 = temp1-&gt;next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                temp-&gt;next = temp2;</span><br><span class="line">                temp2 = temp2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (temp1 != nullptr) &#123;</span><br><span class="line">            temp-&gt;next = temp1;</span><br><span class="line">        &#125; else if (temp2 != nullptr) &#123;</span><br><span class="line">            temp-&gt;next = temp2;</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h1><p>根据 逆波兰表示法，求表达式的值。</p><p>有效的算符包括 +、-、*、&#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p>注意 两个整数之间的除法只保留整数部分。</p><p>可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</p><p> </p><p>示例 1：</p><p>输入：tokens &#x3D; [“2”,”1”,”+”,”3”,”*”]<br>输出：9<br>解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) &#x3D; 9<br>示例 2：</p><p>输入：tokens &#x3D; [“4”,”13”,”5”,”&#x2F;“,”+”]<br>输出：6<br>解释：该算式转化为常见的中缀算术表达式为：(4 + (13 &#x2F; 5)) &#x3D; 6<br>示例 3：</p><p>输入：tokens &#x3D; [“10”,”6”,”9”,”3”,”+”,”-11”,”<em>“,”&#x2F;“,”</em>“,”17”,”+”,”5”,”+”]<br>输出：22<br>解释：该算式转化为常见的中缀算术表达式为：<br>  ((10 * (6 &#x2F; ((9 + 3) * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; (12 * -11))) + 17) + 5<br>&#x3D; ((10 * (6 &#x2F; -132)) + 17) + 5<br>&#x3D; ((10 * 0) + 17) + 5<br>&#x3D; (0 + 17) + 5<br>&#x3D; 17 + 5<br>&#x3D; 22 </p><p>提示：</p><p>1 &lt;&#x3D; tokens.length &lt;&#x3D; 104<br>tokens[i] 是一个算符（”+”、”-“、”*” 或 “&#x2F;“），或是在范围 [-200, 200] 内的一个整数 </p><p>逆波兰表达式：</p><p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p><p>平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。<br>该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。<br>逆波兰表达式主要有以下两个优点：</p><p>去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。<br>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Idea:</span><br><span class="line">Reverse Polish Notation was designed specifically to make computing easier with the more efficient use of a stack. So we can use a stack here to store numbers until they&#x27;re used, and then each operand will use the top two values of the stack.</span><br><span class="line"></span><br><span class="line">Since the order of the numbers is still important for subtraction and division, we&#x27;ll have to make sure that the two numbers are processed in their original order, which is the opposite order of the stack.</span><br><span class="line"></span><br><span class="line">After each successful operation, the result should be pushed back onto the stack until it&#x27;s used. After iteration is complete, the remaining value in the stack will be our answer, so we should return stack[0].</span><br><span class="line"></span><br><span class="line">Time Complexity: O(N) where N is the length of tokens</span><br><span class="line">Space Complexity: O(N) for the length of the stack, up to N / 2 + 1 values</span><br></pre></td></tr></table></figure><h2 id="Solution1-栈-1"><a href="#Solution1-栈-1" class="headerlink" title="Solution1  栈"></a>Solution1  栈</h2><p><img src="https://files.mdnice.com/user/1489/e7ac0fe5-7797-4094-a619-f13588081fd5.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">        stack&lt;int&gt; stk;</span><br><span class="line">        int n = tokens.size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            string&amp; token = tokens[i];</span><br><span class="line">            if (isNumber(token)) &#123;</span><br><span class="line">                stk.push(atoi(token.c_str()));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                int num2 = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                int num1 = stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">                switch (token[0]) &#123;</span><br><span class="line">                    case &#x27;+&#x27;:</span><br><span class="line">                        stk.push(num1 + num2);</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;-&#x27;:</span><br><span class="line">                        stk.push(num1 - num2);</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;*&#x27;:</span><br><span class="line">                        stk.push(num1 * num2);</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;/&#x27;:</span><br><span class="line">                        stk.push(num1 / num2);</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stk.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool isNumber(string&amp; token) &#123;</span><br><span class="line">        return !(token == &quot;+&quot; || token == &quot;-&quot; || token == &quot;*&quot; || token == &quot;/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(n)O(n)，其中 nn 是数组 \textit{tokens}tokens 的长度。需要遍历数组 \textit{tokens}tokens 一次，计算逆波兰表达式的值。</p><p>空间复杂度：O(n)O(n)，其中 nn 是数组 \textit{tokens}tokens 的长度。使用栈存储计算过程中的数，栈内元素个数不会超过逆波兰表达式的长度。</p><h2 id="Solution2-数组模拟栈"><a href="#Solution2-数组模拟栈" class="headerlink" title="Solution2 数组模拟栈"></a>Solution2 数组模拟栈</h2><p><img src="https://files.mdnice.com/user/1489/f40bfb53-0680-426d-b458-8de6820f7bae.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;</span><br><span class="line">        int n = tokens.size();</span><br><span class="line">        vector&lt;int&gt; stk((n + 1) / 2);</span><br><span class="line">        int index = -1;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            string&amp; token = tokens[i];</span><br><span class="line">            if (token.length() &gt; 1 || isdigit(token[0])) &#123;</span><br><span class="line">                index++;</span><br><span class="line">                stk[index] = atoi(token.c_str());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                switch (token[0]) &#123;</span><br><span class="line">                    case &#x27;+&#x27;:</span><br><span class="line">                        index--;</span><br><span class="line">                        stk[index] += stk[index + 1];</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;-&#x27;:</span><br><span class="line">                        index--;</span><br><span class="line">                        stk[index] -= stk[index + 1];</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;*&#x27;:</span><br><span class="line">                        index--;</span><br><span class="line">                        stk[index] *= stk[index + 1];</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;/&#x27;:</span><br><span class="line">                        index--;</span><br><span class="line">                        stk[index] /= stk[index + 1];</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stk[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="171-Excel-表列序号"><a href="#171-Excel-表列序号" class="headerlink" title="171. Excel 表列序号"></a><a href="https://leetcode.com/problems/excel-sheet-column-number/">171. Excel 表列序号</a></h1><p>给你一个字符串 columnTitle ，表示 Excel 表格中的列名称。返回 该列名称对应的列序号 。</p><p>例如：</p><p>A -&gt; 1<br>B -&gt; 2<br>C -&gt; 3<br>…<br>Z -&gt; 26<br>AA -&gt; 27<br>AB -&gt; 28<br>… </p><p>示例 1:</p><p>输入: columnTitle &#x3D; “A”<br>输出: 1<br>示例 2:</p><p>输入: columnTitle &#x3D; “AB”<br>输出: 28<br>示例 3:</p><p>输入: columnTitle &#x3D; “ZY”<br>输出: 701 </p><p>提示：</p><p>1 &lt;&#x3D; columnTitle.length &lt;&#x3D; 7<br>columnTitle 仅由大写英文组成<br>columnTitle 在范围 [“A”, “FXSHRXW”] 内</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1. There are 26 letters in our alphabet and we start counting from 1, not zero.</span><br><span class="line">   So &#x27;Z&#x27; is 26.</span><br><span class="line">2. The rest of the combinations start from a base 26</span><br><span class="line"></span><br><span class="line">AA --&gt; 26*1+ 1 = 27 (A == 1)</span><br><span class="line">AB --&gt; 26*1+ 2 = 28 (B == 2)</span><br><span class="line">AC --&gt;26*1 + 3 = 29 (C == 3)</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">So we can write like this:</span><br><span class="line"></span><br><span class="line">result = 0</span><br><span class="line">d = s[i](char) - &#x27;A&#x27; + 1 (we used  s[i] -  &#x27;A&#x27; to convert the letter to a number like it&#x27;s going to be C)</span><br><span class="line">result = result* 26 + d</span><br><span class="line"></span><br><span class="line">If the given input is only one letter, it will automatically take the value s[i] - &#x27;A&#x27; + 1 as the first result is 0.</span><br><span class="line">Some More Explanation</span><br><span class="line">1. For every additional digit of the string, we multiply the value of the digit by 26^n</span><br><span class="line">2. here n is the number of digits it is away from the one&#x27;s place.</span><br><span class="line">3. This is similar to how the number 254 could be broken down as this:</span><br><span class="line"> (2 x 10 x 10) + (5 x 10) + (4).</span><br><span class="line">4. The reason we use 26 instead of 10 is because 26 is our base.</span><br><span class="line"></span><br><span class="line">For s = &quot;BCM&quot; the final solution would be (2 x 26 x 26) + (3 x 26) + (13)</span><br><span class="line"></span><br><span class="line">We could do this process iteratively. Start at looking at the first digit &quot;B&quot;. Add the int equivalent of &quot;B&quot; to the running sum and continue. </span><br><span class="line">Every time we look at the following digit multiply our running sum by 26 before adding the next digit to signify we are changing places. Example below:</span><br><span class="line"></span><br><span class="line">&quot;B&quot; = 2</span><br><span class="line">&quot;BC&quot; = (2)26 + 3</span><br><span class="line">&quot;BCM&quot; = (2(26) + 3)26 + 13</span><br><span class="line">Time Complexity : O(n) one scan of string , n is number of characters in the string</span><br><span class="line"></span><br><span class="line">CODE WITH EXPLANATION</span><br></pre></td></tr></table></figure><h2 id="Solution1-26进制"><a href="#Solution1-26进制" class="headerlink" title="Solution1  26进制"></a>Solution1  26进制</h2><p><img src="https://files.mdnice.com/user/1489/ca4fbbe4-2cea-43f3-ac48-3d192c40bacf.png"></p><h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode.com/problems/min-stack/comments/">155. 最小栈</a></h1><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 MinStack 类:</p><p>MinStack() 初始化堆栈对象。<br>void push(int val) 将元素val推入堆栈。<br>void pop() 删除堆栈顶部的元素。<br>int top() 获取堆栈顶部的元素。<br>int getMin() 获取堆栈中的最小元素。 </p><p>示例 1:</p><p>输入：<br>[“MinStack”,”push”,”push”,”push”,”getMin”,”pop”,”top”,”getMin”]<br>[[],[-2],[0],[-3],[],[],[],[]]</p><p>输出：<br>[null,null,null,null,-3,null,0,-2]</p><p>解释：<br>MinStack minStack &#x3D; new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2. </p><p>提示：</p><p>-231 &lt;&#x3D; val &lt;&#x3D; 231 - 1<br>pop、top 和 getMin 操作总是在 非空栈 上调用<br>push, pop, top, and getMin最多被调用 3 * 104 次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">I came up with this simple solution using just a single stack.</span><br><span class="line">Here I am using Stack of Pair of Int. The first value of the pair would store the element of the normal stack and the second value would store the minimum up to that point in the stack.</span><br><span class="line">So even if the minimum element of the stack is removed from the top, we still have a backup of the next minimum element in the pair. So for every element pushed in the stack, it stores its corresponding minimum value.</span><br><span class="line"></span><br><span class="line">For example, let&#x27;s do a Dry Run of an example.</span><br><span class="line"></span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;push&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[5],[-2],[3],[-10],[20],[],[],[],[],[30],[]]</span><br><span class="line">We push 5,-2,3,-10,20 in the stack.</span><br><span class="line">If the stack is empty we push &#123;val,val&#125; in the stack</span><br><span class="line">else we push &#123;val,min(s.top().second,val)&#125; which is basically minimum upto that point.</span><br><span class="line">Hence &#123;5,5&#125;,&#123;-2,-2&#125;,&#123;3,-2&#125;,&#123;-10,-10&#125;,&#123;20,-10&#125; are pushed in the stack.</span><br><span class="line">To pop simply do stack.pop()</span><br><span class="line">To get the top return stack.top().first;</span><br><span class="line">Now we pop 20 and -10 from the stack</span><br><span class="line">The elements in the stack would be &#123;5,5&#125;,&#123;-2,-2&#125;,&#123;3,-2&#125;</span><br><span class="line">On pushing 30 to the stack</span><br><span class="line">The elements in the stack would be &#123;5,5&#125;,&#123;-2,-2&#125;,&#123;3,-2&#125;,&#123;30,-2&#125;.</span><br><span class="line">The Output of the code would be:</span><br><span class="line"></span><br><span class="line">[null,null,null,null,null,null,-10,null,null,3,null,-2]</span><br><span class="line">All the operations are one liners expect the Push operation which is a 2 liner.</span><br><span class="line"></span><br><span class="line">class MinStack &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt; pair&lt;int,int&gt; &gt; s;</span><br><span class="line"></span><br><span class="line">    MinStack() &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    void push(int val) &#123;</span><br><span class="line">        if(s.empty())</span><br><span class="line">            s.push_back(&#123;val,val&#125;);</span><br><span class="line">        else</span><br><span class="line">            s.push_back(&#123;val,min(s.back().second,val)&#125;);    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void pop() &#123; s.pop_back(); &#125;</span><br><span class="line">    </span><br><span class="line">    int top() &#123; return s.back().first; &#125;</span><br><span class="line">    </span><br><span class="line">    int getMin() &#123; return s.back().second; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">The Time complexity of each operation is O(1)</span><br><span class="line">The Space complexity is O(N)</span><br></pre></td></tr></table></figure><h2 id="Solution1-辅助栈"><a href="#Solution1-辅助栈" class="headerlink" title="Solution1 辅助栈"></a>Solution1 辅助栈</h2><p><img src="https://files.mdnice.com/user/1489/0b64394f-ee13-447f-835a-965086697e94.png"></p><p><img src="https://files.mdnice.com/user/1489/a01bf43a-aa9c-45e4-8e02-e38f1a09bba3.png"></p><h2 id="Solution2-不用辅助栈"><a href="#Solution2-不用辅助栈" class="headerlink" title="Solution2 不用辅助栈"></a>Solution2 不用辅助栈</h2><p><img src="https://files.mdnice.com/user/1489/5f397d41-0fd5-406a-befb-20bb996d6862.png"></p><h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h1><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p><p>自定义评测：</p><p>评测系统 的输入如下（你设计的程序 不适用 此输入）：</p><p>intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0<br>listA - 第一个链表<br>listB - 第二个链表<br>skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数<br>skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数<br>评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。</p><p> </p><p>示例 1：</p><p>输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3<br>输出：Intersected at ‘8’<br>解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。<br>在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。<br>示例 2：</p><p>输入：intersectVal &#x3D; 2, listA &#x3D; [1,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1<br>输出：Intersected at ‘2’<br>解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。<br>从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。<br>在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。<br>示例 3：</p><p>输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2<br>输出：null<br>解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。<br>由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 null 。 </p><p>提示：</p><p>listA 中节点数目为 m<br>listB 中节点数目为 n<br>1 &lt;&#x3D; m, n &lt;&#x3D; 3 * 104<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>0 &lt;&#x3D; skipA &lt;&#x3D; m<br>0 &lt;&#x3D; skipB &lt;&#x3D; n<br>如果 listA 和 listB 没有交点，intersectVal 为 0<br>如果 listA 和 listB 有交点，intersectVal &#x3D;&#x3D; listA[skipA] &#x3D;&#x3D; listB[skipB] </p><p>进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">O ( 1 ) SPACE SOLUTION</span><br><span class="line"></span><br><span class="line">First using constant space check for last element of both lists.</span><br><span class="line">If tails of both lists are different then return NULL</span><br><span class="line"></span><br><span class="line">Now we know that intersection length will be same for both lists. So we want to make length prior to the intersection also equal.</span><br><span class="line">Head pointer of the longer list is moved to next till length of both lists become equal</span><br><span class="line"></span><br><span class="line">NOW we will have intersetion point at the same distance from head for both the lists.</span><br><span class="line"></span><br><span class="line">Now keep comparing heads till match found.</span><br></pre></td></tr></table></figure><h2 id="Solution1-哈希集合"><a href="#Solution1-哈希集合" class="headerlink" title="Solution1 哈希集合"></a>Solution1 哈希集合</h2><p><img src="https://files.mdnice.com/user/1489/6ed11899-abbb-4316-b5f5-0905cc477414.png"></p><h2 id="Solution2-双指针-3"><a href="#Solution2-双指针-3" class="headerlink" title="Solution2 双指针"></a>Solution2 双指针</h2><p><img src="https://files.mdnice.com/user/1489/eef3c25b-9218-4dd9-83d7-392ec8df5f36.png"></p><p><img src="https://files.mdnice.com/user/1489/a181f628-892e-4ab3-9509-236d9b01c497.png"></p><p><img src="https://files.mdnice.com/user/1489/a1ffabf9-420e-46a6-a2e1-ae5db89d9a6e.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        if (headA == nullptr || headB == nullptr) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *pA = headA, *pB = headB;</span><br><span class="line">        while (pA != pB) &#123;</span><br><span class="line">            pA = pA == nullptr ? headB : pA-&gt;next;</span><br><span class="line">            pB = pB == nullptr ? headA : pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a href="https://leetcode.com/problems/majority-element/">169. 多数元素</a></h1><p><img src="https://files.mdnice.com/user/1489/edd0b34a-aae0-4667-8e36-645c0c1fbd04.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Approach 1: Brute Force</span><br><span class="line">Intuition</span><br><span class="line">We can exhaust the search space in quadratic time by checking whether each element is the majority element.</span><br><span class="line"></span><br><span class="line">Algorithm</span><br><span class="line">The brute force algorithm iterates over the array, and then iterates again for each number to count its occurrences. As soon as a number is found to have appeared more than any other can possibly have appeared, return it.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Complexity Analysis</span><br><span class="line">Time complexity : O(n^2)</span><br><span class="line"></span><br><span class="line">The brute force algorithm contains two nested for loops that each run for nn iterations, adding up to quadratic time complexity.</span><br><span class="line"></span><br><span class="line">Space complexity : O(1)</span><br><span class="line"></span><br><span class="line">The brute force solution does not allocate additional space proportional to the input size.</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/4f33e6e4-017a-4f41-81a0-7f60d1d578f0.png"></p><h2 id="Solution-1-哈希表"><a href="#Solution-1-哈希表" class="headerlink" title="Solution 1 哈希表"></a>Solution 1 哈希表</h2><p><img src="https://files.mdnice.com/user/1489/eb446da9-85b1-4898-b238-ee7548e16cc1.png"></p><p><img src="https://files.mdnice.com/user/1489/d6347f35-ca4c-425c-b8ca-6b7e2ae2ab07.png"></p><h2 id="Solution-2-排序"><a href="#Solution-2-排序" class="headerlink" title="Solution 2  排序"></a>Solution 2  排序</h2><p><img src="https://files.mdnice.com/user/1489/a8de2fa0-7abe-474d-a113-bca524a5c19d.png"></p><h2 id="Solution-3-Boyer-Moore-投票法"><a href="#Solution-3-Boyer-Moore-投票法" class="headerlink" title="Solution 3  Boyer-Moore 投票法"></a>Solution 3  Boyer-Moore 投票法</h2><p><img src="https://files.mdnice.com/user/1489/f451fbd9-f97d-4b05-9a25-92f9f405369b.png"></p><h1 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172. 阶乘后的零"></a><a href="https://leetcode.com/problems/factorial-trailing-zeroes/">172. 阶乘后的零</a></h1><p>给定一个整数 n ，返回 n! 结果中尾随零的数量。</p><p>提示 n! &#x3D; n * (n - 1) * (n - 2) * … * 3 * 2 * 1</p><p> </p><p>示例 1：</p><p>输入：n &#x3D; 3<br>输出：0<br>解释：3! &#x3D; 6 ，不含尾随 0<br>示例 2：</p><p>输入：n &#x3D; 5<br>输出：1<br>解释：5! &#x3D; 120 ，有一个尾随 0<br>示例 3：</p><p>输入：n &#x3D; 0<br>输出：0 </p><p>提示：</p><p>0 &lt;&#x3D; n &lt;&#x3D; 104 </p><p><img src="https://files.mdnice.com/user/1489/90ee8419-0d4e-4f4f-9e93-06007789a613.png"></p><h2 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1"></a>Solution1</h2><p>首先题目的意思是末尾有几个0<br> 比如6! &#x3D; 【1* 2* 3* 4* 5* 6】<br>    其中只有2<em>5末尾才有0，所以就可以抛去其他数据 专门看2 5 以及其倍数 毕竟 4 * 25末尾也是0<br>    比如10！ &#x3D; 【2</em>4<em>5</em>6<em>8</em>10】<br>    其中 4能拆成2<em>2  10能拆成2</em>5<br>    所以10！ &#x3D; 【2<em>（2</em>2）<em>5</em>（2<em>3）</em>（2<em>2</em>2）<em>（2</em>5）】<br>    一个2和一个5配对 就产生一个0 所以10！末尾2个0</p><pre><code>转头一想 2肯定比5多 所以只数5的个数就行了假若N=31 31里能凑10的5为[5, 2*5, 3*5, 4*5, 25, 6*5] </code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int trailingZeroes(int n) &#123;</span><br><span class="line">        int res=0;</span><br><span class="line">    for(int i=n;i&gt;0;i/=5)&#123;</span><br><span class="line">    res+=i/5;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="179-最大数"><a href="#179-最大数" class="headerlink" title="179. 最大数"></a><a href="https://leetcode.com/problems/largest-number/">179. 最大数</a></h1><p>给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p><p>注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [10,2]<br>输出：”210”<br>示例 2：</p><p>输入：nums &#x3D; [3,30,34,5,9]<br>输出：”9534330” </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Intuition</span><br><span class="line"></span><br><span class="line">To construct the largest number, we want to ensure that the most significant digits are occupied by the largest digits.</span><br><span class="line"></span><br><span class="line">Algorithm</span><br><span class="line"></span><br><span class="line">First, we convert each integer to a string. Then, we sort the array of strings.</span><br><span class="line"></span><br><span class="line">While it might be tempting to simply sort the numbers in descending order, this causes problems for sets of numbers with the same leading digit. For example, sorting the problem example in descending order would produce the number 95343039534303, while the correct answer can be achieved by transposing the 33 and the 3030. Therefore, for each pairwise comparison during the sort, we compare the numbers achieved by concatenating the pair in both orders. We can prove that this sorts into the proper order as follows:</span><br><span class="line"></span><br><span class="line">Assume that (without loss of generality), for some pair of integers aa and bb, our comparator dictates that aa should precede bb in sorted order. This means that a\frown b &gt; b\frown aa⌢b&gt;b⌢a (where \frown⌢ represents concatenation). For the sort to produce an incorrect ordering, there must be some cc for which bb precedes cc and cc precedes aa. This is a contradiction because a\frown b &gt; b\frown aa⌢b&gt;b⌢a and b\frown c &gt; c\frown bb⌢c&gt;c⌢b implies a\frown c &gt; c\frown aa⌢c&gt;c⌢a. In other words, our custom comparator preserves transitivity, so the sort is correct.</span><br><span class="line"></span><br><span class="line">Once the array is sorted, the most &quot;signficant&quot; number will be at the front. There is a minor edge case that comes up when the array consists of only zeroes, so if the most significant number is 00, we can simply return 00. Otherwise, we build a string out of the sorted array and return it.</span><br></pre></td></tr></table></figure><h2 id="Solution0-暴力-3"><a href="#Solution0-暴力-3" class="headerlink" title="Solution0 暴力"></a>Solution0 暴力</h2><h2 id="Solution1-排序-2"><a href="#Solution1-排序-2" class="headerlink" title="Solution1 排序"></a>Solution1 排序</h2><p>自定义一种排序方式 比较 s1 + s2 和 s2 + s1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    static bool cmp(int a,int b)&#123;</span><br><span class="line">        string sa = to_string(a);</span><br><span class="line">        string sb = to_string(b);</span><br><span class="line">        return sa+sb&gt;sb+sa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string largestNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(),nums.end(),cmp);</span><br><span class="line">        string ret;</span><br><span class="line">        for(auto num:nums)&#123;</span><br><span class="line">            if(!(num==0&amp;&amp;ret[0]==&#x27;0&#x27;)) ret+=to_string(num);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/724583f7-e9bf-46be-a2e9-235ba7e2d358.png"></p><h1 id="187-重复的DNA序列"><a href="#187-重复的DNA序列" class="headerlink" title="187. 重复的DNA序列"></a><a href="https://leetcode.com/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></h1><p>DNA序列 由一系列核苷酸组成，缩写为 ‘A’, ‘C’, ‘G’ 和 ‘T’.。</p><p>例如，”ACGAATTCCG” 是一个 DNA序列 。<br>在研究 DNA 时，识别 DNA 中的重复序列非常有用。</p><p>给定一个表示 DNA序列 的字符串 s ，返回所有在 DNA 分子中出现不止一次的 长度为 10 的序列(子字符串)。你可以按 任意顺序 返回答案。</p><p> </p><p>示例 1：</p><p>输入：s &#x3D; “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT”<br>输出：[“AAAAACCCCC”,”CCCCCAAAAA”]<br>示例 2：</p><p>输入：s &#x3D; “AAAAAAAAAAAAA”<br>输出：[“AAAAAAAAAA”] </p><p>提示：</p><p>0 &lt;&#x3D; s.length &lt;&#x3D; 105<br>s[i]&#x3D;&#x3D;’A’、’C’、’G’ or ‘T’</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Simple sliding window solution.</span><br><span class="line">comments added for better explanation.</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123;</span><br><span class="line">         vector&lt;string&gt; ans;</span><br><span class="line">         map&lt;string,int&gt; mmap;</span><br><span class="line">        //storing the first 10 size substring(dna sequence) </span><br><span class="line">        //in temp</span><br><span class="line">         string temp=s.substr(0,10);</span><br><span class="line">       //adding first dna sequence to map</span><br><span class="line">        mmap[temp]++;</span><br><span class="line">        //now the sliding window.</span><br><span class="line">        for(int i=10;i&lt;s.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            //remove first character from exsisting substring</span><br><span class="line">            temp=temp.substr(1);</span><br><span class="line">            </span><br><span class="line">            //add the next character in substring.</span><br><span class="line">            temp=temp+s[i];</span><br><span class="line">            </span><br><span class="line">            //add the new dna sequence to map.</span><br><span class="line">            mmap[temp]++;</span><br><span class="line">            </span><br><span class="line">            //if the count of given sequence is greater than 2</span><br><span class="line">            //and it is not present in out ans vector push it in</span><br><span class="line">            //it</span><br><span class="line">            </span><br><span class="line">            //we have done the find operation to keep the elements in answer vector</span><br><span class="line">            //unique.</span><br><span class="line">            //for example if aa...a sequence is present 4 times, it will adding 4 times</span><br><span class="line">            //in ans according to our sliding window logic. but we want it only one time.</span><br><span class="line">            //therefore we check in our vector if the given dna sequence is already present or not/</span><br><span class="line">            if(mmap[temp]&gt;1 and find(ans.begin(),ans.end(),temp)==ans.end())</span><br><span class="line">            &#123;</span><br><span class="line">                ans.push_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution1-哈希表-2"><a href="#Solution1-哈希表-2" class="headerlink" title="Solution1 哈希表"></a>Solution1 哈希表</h2><p>我们可以用一个哈希表统计 ss 所有长度为 1010 的子串的出现次数，返回所有出现次数超过 1010 的子串。</p><p>代码实现时，可以一边遍历子串一边记录答案，为了不重复记录答案，我们只统计当前出现次数为 22 的子串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    const int L = 10;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        unordered_map&lt;string, int&gt; cnt;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        for (int i = 0; i &lt;= n - L; ++i) &#123;</span><br><span class="line">            string sub = s.substr(i, L);</span><br><span class="line">            if (++cnt[sub] == 2) &#123;</span><br><span class="line">                ans.push_back(sub);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution2-哈希表-滑动窗口-二进制"><a href="#Solution2-哈希表-滑动窗口-二进制" class="headerlink" title="Solution2 哈希表 滑动窗口 二进制"></a>Solution2 哈希表 滑动窗口 二进制</h2><p><img src="https://files.mdnice.com/user/1489/971e09e6-1b22-4c78-a3bc-956a6d4f1827.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    const int L = 10;</span><br><span class="line">    unordered_map&lt;char, int&gt; bin = &#123;&#123;&#x27;A&#x27;, 0&#125;, &#123;&#x27;C&#x27;, 1&#125;, &#123;&#x27;G&#x27;, 2&#125;, &#123;&#x27;T&#x27;, 3&#125;&#125;;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; findRepeatedDnaSequences(string s) &#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        if (n &lt;= L) &#123;</span><br><span class="line">            return ans;</span><br><span class="line">        &#125;</span><br><span class="line">        int x = 0;</span><br><span class="line">        for (int i = 0; i &lt; L - 1; ++i) &#123;</span><br><span class="line">            x = (x &lt;&lt; 2) | bin[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;int, int&gt; cnt;</span><br><span class="line">        for (int i = 0; i &lt;= n - L; ++i) &#123;</span><br><span class="line">            x = ((x &lt;&lt; 2) | bin[s[i + L - 1]]) &amp; ((1 &lt;&lt; (L * 2)) - 1);</span><br><span class="line">            if (++cnt[x] == 2) &#123;</span><br><span class="line">                ans.push_back(s.substr(i, L));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a><a href="https://leetcode.com/problems/rotate-array/">189. 轮转数组</a></h1><p>给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p><p> </p><p>示例 1:</p><p>输入: nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3<br>输出: [5,6,7,1,2,3,4]<br>解释:<br>向右轮转 1 步: [7,1,2,3,4,5,6]<br>向右轮转 2 步: [6,7,1,2,3,4,5]<br>向右轮转 3 步: [5,6,7,1,2,3,4]<br>示例 2:</p><p>输入：nums &#x3D; [-1,-100,3,99], k &#x3D; 2<br>输出：[3,99,-1,-100]<br>解释:<br>向右轮转 1 步: [99,-1,-100,3]<br>向右轮转 2 步: [3,99,-1,-100] </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1<br>0 &lt;&#x3D; k &lt;&#x3D; 105</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// o(n) This solution is simply reversing the array and the reversing array from 0 to k-1 and then from k to n-1. Do a dry run by taking an example on copy and you will usndersand it. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// o(n) Using extra space approach we simply store the last k elemets in same order from n-k to n-1 in a temp vector and we then pushback the reaining elements in the temp vector from index 0 to n-k-1; </span><br><span class="line"></span><br><span class="line">/ o(n*k) we roatate elements of the vector one by one for k times and achieve k roatations.</span><br></pre></td></tr></table></figure><h2 id="Solution1-使用额外的数组"><a href="#Solution1-使用额外的数组" class="headerlink" title="Solution1 使用额外的数组"></a>Solution1 使用额外的数组</h2><p><img src="https://files.mdnice.com/user/1489/df37bbbe-bbbb-4e52-b5ae-5ba6fd84cd30.png"></p><h2 id="Solution2-数组翻转"><a href="#Solution2-数组翻转" class="headerlink" title="Solution2  数组翻转"></a>Solution2  数组翻转</h2><p><img src="https://files.mdnice.com/user/1489/cd09a3b7-fdbb-469a-8609-f64f592fda01.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reverse(vector&lt;int&gt;&amp; nums, int start, int end) &#123;</span><br><span class="line">        while (start &lt; end) &#123;</span><br><span class="line">            swap(nums[start], nums[end]);</span><br><span class="line">            start += 1;</span><br><span class="line">            end -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        k %= nums.size();</span><br><span class="line">        reverse(nums, 0, nums.size() - 1);</span><br><span class="line">        reverse(nums, 0, k - 1);</span><br><span class="line">        reverse(nums, k, nums.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a><a href="https://leetcode.com/problems/happy-number/">202. 快乐数</a></h1><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」 定义为：</p><p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<br>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。<br>如果这个过程 结果为 1，那么这个数就是快乐数。<br>如果 n 是 快乐数 就返回 true ；不是，则返回 false 。</p><p> </p><p>示例 1：</p><p>输入：n &#x3D; 19<br>输出：true<br>解释：<br>12 + 92 &#x3D; 82<br>82 + 22 &#x3D; 68<br>62 + 82 &#x3D; 100<br>12 + 02 + 02 &#x3D; 1<br>示例 2：</p><p>输入：n &#x3D; 2<br>输出：false </p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 231 - 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1.hash-set</span><br><span class="line"></span><br><span class="line">The hash-set solution is very straightforward. For every new data, we check whether it is already in the set. If no, we insert it into the set. If yes, we detect the loop. Only when the node in the loop is &quot;1&quot;, the number is happy number.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.hash-map</span><br><span class="line"></span><br><span class="line">The idea is similar as hase-set. We check the node value to check whether it is in the loop.</span><br><span class="line"></span><br><span class="line">The code is as follow. The time complexity usually is O(1) (the worst may be O(n) due to conflict)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.Floyd&#x27;s Cycle detection algorithm</span><br><span class="line"></span><br><span class="line">Floyd&#x27;s cycle detection algorithm is a pointer algorithm that uses only two pointers, which move through the sequence at different speeds. Obviously, if there is a loop, they will meet in the loop. It is also called the &quot;tortoise and the hare algorithm&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.Brent&#x27;s Cycle detection algorithm</span><br><span class="line"></span><br><span class="line">Brent&#x27;s algorithm features a moving rabbit and a stationary, then teleporting, turtle. Both turtle and rabbit start at the top of the list. The rabbit takes one step per iteration. Every once in a while, we teleport the turtle to the rabbit&#x27;s position, and let the rabbit continue moving. We start out waiting just 2 steps before teleportation, and we double that each time we move the turtle. If there is a loop, they will meet in the loop.</span><br><span class="line"></span><br><span class="line">The code is as follows. The time complexity is O(λ + μ)*. However you&#x27;re doing less stepping than with Floyd&#x27;s (in fact the upper bound for steps is the number you would do with Floyd&#x27;s algorithm). According to Brent&#x27;s research, his algorithm is 24-36% faster on average for implicit linked list algorithms.(However, it cost same time as the Floyd&#x27;s in the OJ ;) )</span><br></pre></td></tr></table></figure><h2 id="Solution1-快慢指针"><a href="#Solution1-快慢指针" class="headerlink" title="Solution1 快慢指针"></a>Solution1 快慢指针</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//参考英文网站热评第一。这题可以用快慢指针的思想去做，有点类似于检测是否为环形链表那道题</span><br><span class="line">//如果给定的数字最后会一直循环重复，那么快的指针（值）一定会追上慢的指针（值），也就是</span><br><span class="line">//两者一定会相等。如果没有循环重复，那么最后快慢指针也会相等，且都等于1。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isHappy(int n) &#123;</span><br><span class="line">        int fast=n;</span><br><span class="line">        int slow=n;</span><br><span class="line">        do&#123;</span><br><span class="line">            slow=squareSum(slow);</span><br><span class="line">            fast=squareSum(fast);</span><br><span class="line">            fast=squareSum(fast);</span><br><span class="line">        &#125;while(slow!=fast);</span><br><span class="line">        if(fast==1)</span><br><span class="line">            return true;</span><br><span class="line">        else return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private int squareSum(int m)&#123;</span><br><span class="line">        int squaresum=0;</span><br><span class="line">        while(m!=0)&#123;</span><br><span class="line">           squaresum+=(m%10)*(m%10);</span><br><span class="line">            m/=10;</span><br><span class="line">        &#125;</span><br><span class="line">        return squaresum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Solution2-暴力"><a href="#Solution2-暴力" class="headerlink" title="Solution2 暴力"></a>Solution2 暴力</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isHappy(int n) &#123;</span><br><span class="line">        int ans=0;</span><br><span class="line">        for(int i = 0 ; i&lt; 100;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            while(n&gt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                ans += (n%10)*(n%10);</span><br><span class="line">                n = n /10;</span><br><span class="line">            &#125;</span><br><span class="line">            n = ans;</span><br><span class="line">            if(n==1)</span><br><span class="line">                return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><a href="https://leetcode.com/problems/remove-linked-list-elements/">203. 移除链表元素</a></h1><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。 </p><p>示例 1：</p><p>输入：head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6<br>输出：[1,2,3,4,5]<br>示例 2：</p><p>输入：head &#x3D; [], val &#x3D; 1<br>输出：[]<br>示例 3：</p><p>输入：head &#x3D; [7,7,7,7], val &#x3D; 7<br>输出：[] </p><p>提示：</p><p>列表中的节点数目在范围 [0, 104] 内<br>1 &lt;&#x3D; Node.val &lt;&#x3D; 50<br>0 &lt;&#x3D; val &lt;&#x3D; 50</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">✔️ Solution - I (Iterative using Dummy node)</span><br><span class="line"></span><br><span class="line">A simple solution to delete the nodes having value T is to traverse over the linked list and just remove the next pointers to the node having value as T. Now, usually in deletion problem of linked list, there can be multiple cases where node to be deleted is either a head node or other node in rest of list. We usually make use of a dummy node at the start or sentinel node to avoid handling multiple edge cases and write a clean uniform solution.</span><br><span class="line"></span><br><span class="line">So, the algorithm we are using can be summarised as -</span><br><span class="line"></span><br><span class="line">Initialize a dummy/sentinel node having its next pointer pointing to the head of linked list and another node pointer prev pointing to this dummy node.</span><br><span class="line">Start iterating over head of linked list</span><br><span class="line">If current node&#x27;s value is not equal to T, we can just move to next node without deleting current node. In this case,</span><br><span class="line">We first update prev pointer and point it to current head</span><br><span class="line">Then move head to next node.</span><br><span class="line">Otherwise, if head -&gt; val == T, we know that this node needs to be deleted. In this case,</span><br><span class="line">We can just update the next pointer of previous node to the next pointer of current node. This will basically remove the current node from list.</span><br><span class="line">Then, we update head to its next node just as in previous case.</span><br><span class="line">Finally, ignore the dummy node created at start and return its next node.</span><br></pre></td></tr></table></figure><h2 id="Solution1-迭代-1"><a href="#Solution1-迭代-1" class="headerlink" title="Solution1 迭代"></a>Solution1 迭代</h2><p><img src="https://files.mdnice.com/user/1489/b2e898e8-a1bf-4e57-88b2-00546145e9d0.png"></p><h2 id="Solution2-递归-2"><a href="#Solution2-递归-2" class="headerlink" title="Solution2 递归"></a>Solution2 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListNode *removeElements(ListNode *head, int val)</span><br><span class="line">&#123;</span><br><span class="line">    if (!head)</span><br><span class="line">        return head;</span><br><span class="line">    head-&gt;next = removeElements(head-&gt;next, val);</span><br><span class="line">    return head-&gt;val == val ? head-&gt;next : head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析<br>时间复杂度：O(n)O(n)，其中 nn 是链表的长度。需要遍历链表一次。<br>空间复杂度：O(1)O(1)。</p><h1 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h1><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><p> </p><p>示例 1:</p><p>输入: [3,2,1,5,6,4], k &#x3D; 2<br>输出: 5<br>示例 2:</p><p>输入: [3,2,3,1,2,4,5,5,6], k &#x3D; 4<br>输出: 4 </p><p>提示：</p><p>1 &lt;&#x3D; k &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">This problem is well known and quite often can be found in various text books.</span><br><span class="line"></span><br><span class="line">You can take a couple of approaches to actually solve it:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">O(N lg K) running time + O(K) memory</span><br><span class="line">Other possibility is to use a min oriented priority queue that will store the K-th largest values. The algorithm iterates over the whole input and maintains the size of priority queue.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">O(N) best case / O(N^2) worst case running time + O(1) memory</span><br><span class="line">The smart approach for this problem is to use the selection algorithm (based on the partion method - the same one as used in quicksort).</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">O(N) guaranteed running time + O(1) space</span><br><span class="line"></span><br><span class="line">So how can we improve the above solution and make it O(N) guaranteed? The answer is quite simple, we can randomize the input, so that even when the worst case input would be provided the algorithm wouldn&#x27;t be affected. So all what it is needed to be done is to shuffle the input.</span><br></pre></td></tr></table></figure><h2 id="Solution1-堆排序"><a href="#Solution1-堆排序" class="headerlink" title="Solution1  堆排序"></a>Solution1  堆排序</h2><p><img src="https://files.mdnice.com/user/1489/bb70337e-337f-4525-9b82-628e0ababa73.png"></p><p>复杂度分析</p><p>时间复杂度：O(n \log n)O(nlogn)，建堆的时间代价是 O(n)O(n)，删除的总代价是 O(k \log n)O(klogn)，因为 k &lt; nk&lt;n，故渐进时间复杂为 O(n + k \log n) &#x3D; O(n \log n)O(n+klogn)&#x3D;O(nlogn)。<br>空间复杂度：O(\log n)O(logn)，即递归使用栈空间的空间代价。</p><p><img src="https://files.mdnice.com/user/1489/6b0ad4c7-d06d-477f-a7be-fc2e043a0db5.png"></p><h1 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a><a href="https://leetcode.com/problems/contains-duplicate/">217. 存在重复元素</a></h1><p>给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。 </p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3,1]<br>输出：true<br>示例 2：</p><p>输入：nums &#x3D; [1,2,3,4]<br>输出：false<br>示例 3：</p><p>输入：nums &#x3D; [1,1,1,3,3,4,3,2,4,2]<br>输出：true </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">This problem seems trivial, so lets try different approaches to solve it:</span><br><span class="line"></span><br><span class="line">Starting from worst time complexity to the best one:</span><br><span class="line"></span><br><span class="line">Time complexity: O(N^2), memory: O(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The naive approach would be to run a iteration for each element and see whether a duplicate value can be found: this results in O(N^2) time complexity.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Time complexity: O(N lg N), memory: O(1) - not counting the memory used by sort</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Since it is trivial task to find duplicates in sorted array, we can sort it as the first step of the algorithm and then search for consecutive duplicates.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Time complexity: O(N), memory: O(N)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Finally we can used a well known data structure hash table that will help us to identify whether an element has been previously encountered in the array.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">This is trivial but quite nice example of space-time tradeoff.</span><br></pre></td></tr></table></figure><h2 id="Solution1-排序-3"><a href="#Solution1-排序-3" class="headerlink" title="Solution1  排序"></a>Solution1  排序</h2><p><img src="https://files.mdnice.com/user/1489/30ba428f-42b6-472b-8b8b-23aaef1c23b6.png"></p><h2 id="Solution2-4"><a href="#Solution2-4" class="headerlink" title="Solution2"></a>Solution2</h2><p><img src="https://files.mdnice.com/user/1489/f14525cf-e0bb-44a5-a385-54ae95316f9b.png"></p><h1 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225. 用队列实现栈"></a><a href="https://leetcode.com/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h1><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p><p>实现 MyStack 类：</p><p>void push(int x) 将元素 x 压入栈顶。<br>int pop() 移除并返回栈顶元素。<br>int top() 返回栈顶元素。<br>boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。 </p><p>注意：</p><p>你只能使用队列的基本操作 —— 也就是 push to back、peek&#x2F;pop from front、size 和 is empty 这些操作。<br>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 </p><p>示例：</p><p>输入：<br>[“MyStack”, “push”, “push”, “top”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>输出：<br>[null, null, null, 2, 2, false]</p><p>解释：<br>MyStack myStack &#x3D; new MyStack();<br>myStack.push(1);<br>myStack.push(2);<br>myStack.top(); &#x2F;&#x2F; 返回 2<br>myStack.pop(); &#x2F;&#x2F; 返回 2<br>myStack.empty(); &#x2F;&#x2F; 返回 False </p><p>提示：</p><p>1 &lt;&#x3D; x &lt;&#x3D; 9<br>最多调用100 次 push、pop、top 和 empty<br>每次调用 pop 和 top 都保证栈不为空</p><p><img src="https://files.mdnice.com/user/1489/75306b0a-0beb-4576-a53e-49b2835d09c8.png"></p><p><img src="https://files.mdnice.com/user/1489/04e73830-74d3-4ebe-9b91-a8058dd5f0d8.png"></p><p><img src="https://files.mdnice.com/user/1489/37f7ba54-f044-48a7-a5fc-c2d9a82f7b3c.png"></p><h2 id="Solution1-两个队列"><a href="#Solution1-两个队列" class="headerlink" title="Solution1  两个队列"></a>Solution1  两个队列</h2><p><img src="https://files.mdnice.com/user/1489/44e2b2c5-3a86-4e20-97d1-45502d4bfc29.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class MyStack &#123;</span><br><span class="line">public:</span><br><span class="line">    queue&lt;int&gt; queue1;</span><br><span class="line">    queue&lt;int&gt; queue2;</span><br><span class="line"></span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    MyStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Push element x onto stack. */</span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        queue2.push(x);</span><br><span class="line">        while (!queue1.empty()) &#123;</span><br><span class="line">            queue2.push(queue1.front());</span><br><span class="line">            queue1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        swap(queue1, queue2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Removes the element on top of the stack and returns that element. */</span><br><span class="line">    int pop() &#123;</span><br><span class="line">        int r = queue1.front();</span><br><span class="line">        queue1.pop();</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Get the top element. */</span><br><span class="line">    int top() &#123;</span><br><span class="line">        int r = queue1.front();</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** Returns whether the stack is empty. */</span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return queue1.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution2-单个队列"><a href="#Solution2-单个队列" class="headerlink" title="Solution2 单个队列"></a>Solution2 单个队列</h2><p><img src="https://files.mdnice.com/user/1489/aa634f7b-decf-4a6c-8e21-80efe413f3c1.png"></p><h1 id="227-基本计算器-II"><a href="#227-基本计算器-II" class="headerlink" title="227. 基本计算器 II"></a><a href="https://leetcode.com/problems/basic-calculator-ii/">227. 基本计算器 II</a></h1><p>给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。</p><p>整数除法仅保留整数部分。</p><p>你可以假设给定的表达式总是有效的。所有中间结果将在 [-231, 231 - 1] 的范围内。</p><p>注意：不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。</p><p> </p><p>示例 1：</p><p>输入：s &#x3D; “3+2*2”<br>输出：7<br>示例 2：</p><p>输入：s &#x3D; “ 3&#x2F;2 “<br>输出：1<br>示例 3：</p><p>输入：s &#x3D; “ 3+5 &#x2F; 2 “<br>输出：5 </p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 3 * 105<br>s 由整数和算符 (‘+’, ‘-‘, ‘*’, ‘&#x2F;‘) 组成，中间由一些空格隔开<br>s 表示一个 有效表达式<br>表达式中的所有整数都是非负整数，且在范围 [0, 231 - 1] 内<br>题目数据保证答案是一个 32-bit 整数</p><p><img src="https://files.mdnice.com/user/1489/9f8c8e11-c866-4407-8346-5dee64d57879.png"></p><p><img src="https://files.mdnice.com/user/1489/ad0cf225-2160-4223-8147-528ce599990c.png"></p><h2 id="Solution1-栈-2"><a href="#Solution1-栈-2" class="headerlink" title="Solution1 栈"></a>Solution1 栈</h2><p>方法一：栈<br>思路</p><p>由于乘除优先于加减计算，因此不妨考虑先进行所有乘除运算，并将这些乘除运算后的整数值放回原表达式的相应位置，则随后整个表达式的值，就等于一系列整数加减后的值。</p><p>基于此，我们可以用一个栈，保存这些（进行乘除运算后的）整数的值。对于加减号后的数字，将其直接压入栈中；对于乘除号后的数字，可以直接与栈顶元素计算，并替换栈顶元素为计算后的结果。</p><p>具体来说，遍历字符串 ss，并用变量 \textit{preSign}preSign 记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。每次遍历到数字末尾时，根据 \textit{preSign}preSign 来决定计算方式：</p><p>加号：将数字压入栈；<br>减号：将数字的相反数压入栈；<br>乘除号：计算数字与栈顶元素，并将栈顶元素替换为计算结果。<br>代码实现中，若读到一个运算符，或者遍历到字符串末尾，即认为是遍历到了数字末尾。处理完该数字后，更新 \textit{preSign}preSign 为当前遍历的字符。</p><p>遍历完字符串 ss 后，将栈中元素累加，即为该字符串表达式的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int calculate(string s) &#123;</span><br><span class="line">        vector&lt;int&gt; stk;</span><br><span class="line">        char preSign = &#x27;+&#x27;;</span><br><span class="line">        int num = 0;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (isdigit(s[i])) &#123;</span><br><span class="line">                num = num * 10 + int(s[i] - &#x27;0&#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!isdigit(s[i]) &amp;&amp; s[i] != &#x27; &#x27; || i == n - 1) &#123;</span><br><span class="line">                switch (preSign) &#123;</span><br><span class="line">                    case &#x27;+&#x27;:</span><br><span class="line">                        stk.push_back(num);</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;-&#x27;:</span><br><span class="line">                        stk.push_back(-num);</span><br><span class="line">                        break;</span><br><span class="line">                    case &#x27;*&#x27;:</span><br><span class="line">                        stk.back() *= num;</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        stk.back() /= num;</span><br><span class="line">                &#125;</span><br><span class="line">                preSign = s[i];</span><br><span class="line">                num = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return accumulate(stk.begin(), stk.end(), 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(n)O(n)，其中 nn 为字符串 ss 的长度。需要遍历字符串 ss 一次，计算表达式的值。</p><p>空间复杂度：O(n)O(n)，其中 nn 为字符串 ss 的长度。空间复杂度主要取决于栈的空间，栈的元素个数不超过 nn。</p><h1 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode.com/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h1><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p><p>实现 MyQueue 类：</p><p>void push(int x) 将元素 x 推到队列的末尾<br>int pop() 从队列的开头移除并返回元素<br>int peek() 返回队列开头的元素<br>boolean empty() 如果队列为空，返回 true ；否则，返回 false<br>说明：</p><p>你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek&#x2F;pop from top, size, 和 is empty 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 </p><p>示例 1：</p><p>输入：<br>[“MyQueue”, “push”, “push”, “peek”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>输出：<br>[null, null, null, 1, 1, false]</p><p>解释：<br>MyQueue myQueue &#x3D; new MyQueue();<br>myQueue.push(1); &#x2F;&#x2F; queue is: [1]<br>myQueue.push(2); &#x2F;&#x2F; queue is: [1, 2] (leftmost is front of the queue)<br>myQueue.peek(); &#x2F;&#x2F; return 1<br>myQueue.pop(); &#x2F;&#x2F; return 1, queue is [2]<br>myQueue.empty(); &#x2F;&#x2F; return false</p><p><img src="https://files.mdnice.com/user/1489/feb1c7fb-24cf-4081-a9db-574dc3b46711.png"></p><p><img src="https://files.mdnice.com/user/1489/7a9ccbf5-4ed2-4bdd-aaeb-5b91d2e4c7a1.png"></p><h2 id="Solution1-3"><a href="#Solution1-3" class="headerlink" title="Solution1"></a>Solution1</h2><p><img src="https://files.mdnice.com/user/1489/3cd35f16-15b6-4698-8053-935ffdd85349.png"><br>思路</p><p>将一个栈当作输入栈，用于压入 \texttt{push}push 传入的数据；另一个栈当作输出栈，用于 \texttt{pop}pop 和 \texttt{peek}peek 操作。</p><p>每次 \texttt{pop}pop 或 \texttt{peek}peek 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class MyQueue &#123;</span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; inStack, outStack;</span><br><span class="line"></span><br><span class="line">    void in2out() &#123;</span><br><span class="line">        while (!inStack.empty()) &#123;</span><br><span class="line">            outStack.push(inStack.top());</span><br><span class="line">            inStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    MyQueue() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">        if (outStack.empty()) &#123;</span><br><span class="line">            in2out();</span><br><span class="line">        &#125;</span><br><span class="line">        int x = outStack.top();</span><br><span class="line">        outStack.pop();</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int peek() &#123;</span><br><span class="line">        if (outStack.empty()) &#123;</span><br><span class="line">            in2out();</span><br><span class="line">        &#125;</span><br><span class="line">        return outStack.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return inStack.empty() &amp;&amp; outStack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/7ee6b978-400a-44f6-8197-a9507c8e058b.png"></p><h1 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode.com/problems/palindrome-linked-list/">234. 回文链表</a></h1><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。</p><p> </p><p>示例 1：</p><p>输入：head &#x3D; [1,2,2,1]<br>输出：true<br>示例 2：</p><p>输入：head &#x3D; [1,2]<br>输出：false </p><p>提示：</p><p>链表中节点数目在范围[1, 105] 内<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 9 </p><p>进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Functions used below are HEART n SOUL of linkedlist questions. Usually, any LinkedList question can be broken down to these functions:-</span><br><span class="line"></span><br><span class="line">Reverse ===&gt; Used for space optimization</span><br><span class="line">Find Mid ===&gt; Slow-Fast Pointer</span><br><span class="line">Iteration : normal iter, recursive iter, adjacent node 2-vars, slow-fast</span><br><span class="line">Insert : start , mid, last</span><br><span class="line">delete : start, mid, last</span><br><span class="line">THIS QUESTION:</span><br><span class="line">find Mid of linkedlist --------&gt; do see cases of even/odd length on paper</span><br><span class="line">reverse second half from mid pointer ----&gt; see how prev gets changed</span><br><span class="line">Now compare first and second half Easy huh! 😜</span><br><span class="line">EdgeCase:</span><br><span class="line">linkedlist size =0,1</span><br></pre></td></tr></table></figure><h2 id="Solution0-将链表复制到数组"><a href="#Solution0-将链表复制到数组" class="headerlink" title="Solution0 将链表复制到数组"></a>Solution0 将链表复制到数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(ListNode* head) &#123;</span><br><span class="line">        vector&lt;int&gt; vals;</span><br><span class="line">        while (head != nullptr) &#123;</span><br><span class="line">            vals.emplace_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0, j = (int)vals.size() - 1; i &lt; j; ++i, --j) &#123;</span><br><span class="line">            if (vals[i] != vals[j]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution1-中点开始比较"><a href="#Solution1-中点开始比较" class="headerlink" title="Solution1 中点开始比较"></a>Solution1 中点开始比较</h2><p><img src="https://files.mdnice.com/user/1489/86154c4e-b8da-4890-ab23-b2612d4c5777.png"></p><h1 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237. 删除链表中的节点"></a><a href="https://leetcode.com/problems/delete-node-in-a-linked-list/">237. 删除链表中的节点</a></h1><p>有一个单链表的 head，我们想删除它其中的一个节点 node。</p><p>给你一个需要删除的节点 node 。你将 无法访问 第一个节点  head。</p><p>链表的所有值都是 唯一的，并且保证给定的节点 node 不是链表中的最后一个节点。</p><p>删除给定的节点。注意，删除节点并不是指从内存中删除它。这里的意思是：</p><p>给定节点的值不应该存在于链表中。<br>链表中的节点数应该减少 1。<br>node 前面的所有值顺序相同。<br>node 后面的所有值顺序相同。<br>自定义测试：</p><p>对于输入，你应该提供整个链表 head 和要给出的节点 node。node 不应该是链表的最后一个节点，而应该是链表中的一个实际节点。<br>我们将构建链表，并将节点传递给你的函数。<br>输出将是调用你函数后的整个链表。 </p><p>示例 1：</p><p>输入：head &#x3D; [4,5,1,9], node &#x3D; 5<br>输出：[4,1,9]<br>解释：指定链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9<br>示例 2：</p><p>输入：head &#x3D; [4,5,1,9], node &#x3D; 1<br>输出：[4,5,9]<br>解释：指定链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9 </p><p>提示：</p><p>链表中节点的数目范围是 [2, 1000]<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000<br>链表中每个节点的值都是 唯一 的<br>需要删除的节点 node 是 链表中的节点 ，且 不是末尾节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void deleteNode(ListNode node) &#123;</span><br><span class="line">        node.val=node.next.val;</span><br><span class="line">        node.next=node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">So, this is our code.</span><br><span class="line">We don&#x27;t have the access to the previous node of the to be deleted node.</span><br><span class="line">But we have the access to the next node, which makes deletion of next node possible.</span><br><span class="line">So, we copy the value of the next node to this node and delete the next node (i.e connecting our current node to the next node&#x27;s next)</span><br><span class="line"></span><br><span class="line">Hopefully you understood, Thank you 😀</span><br></pre></td></tr></table></figure><h2 id="Solution1-4"><a href="#Solution1-4" class="headerlink" title="Solution1"></a>Solution1</h2><p><img src="https://files.mdnice.com/user/1489/f6a63c36-aafb-4e9c-a5c7-3eac3a044410.png"></p><h1 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a href="https://leetcode.com/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h1><p>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。</p><p>题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内。</p><p>请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p><p> </p><p>示例 1:</p><p>输入: nums &#x3D; [1,2,3,4]<br>输出: [24,12,8,6]<br>示例 2:</p><p>输入: nums &#x3D; [-1,1,0,-3,3]<br>输出: [0,0,9,0,0] </p><p>提示：</p><p>2 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-30 &lt;&#x3D; nums[i] &lt;&#x3D; 30<br>保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">✔️ Solution - I (Calculate product &amp; divide by self)</span><br><span class="line"></span><br><span class="line">We can simply calculate product of the whole array and for each element in nums, divide the product by nums[i]. This effectively leaves us with product of whole array except self at each index. We need to take care of zeros that may occur in the array -</span><br><span class="line"></span><br><span class="line">1. If there are more than one 0s in nums, the result is an array consisting of all 0.</span><br><span class="line">2. If there is a single 0 in nums, then the result is an array consisting of all 0 except at the index where there was 0 in nums, which will contain product of rest of array.</span><br><span class="line">3. If there&#x27;s no 0 in nums, then the result is an array ans where ans[i] = prod / nums[i] (prod = product of all elements in nums).</span><br></pre></td></tr></table></figure><h2 id="Solution1-累乘列表"><a href="#Solution1-累乘列表" class="headerlink" title="Solution1 累乘列表"></a>Solution1 累乘列表</h2><p><img src="https://files.mdnice.com/user/1489/4484458a-b006-4fe8-a7a8-ea586342ca22.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int length = nums.size();</span><br><span class="line"></span><br><span class="line">        // L 和 R 分别表示左右两侧的乘积列表</span><br><span class="line">        vector&lt;int&gt; L(length, 0), R(length, 0);</span><br><span class="line"></span><br><span class="line">        vector&lt;int&gt; answer(length);</span><br><span class="line"></span><br><span class="line">        // L[i] 为索引 i 左侧所有元素的乘积</span><br><span class="line">        // 对于索引为 &#x27;0&#x27; 的元素，因为左侧没有元素，所以 L[0] = 1</span><br><span class="line">        L[0] = 1;</span><br><span class="line">        for (int i = 1; i &lt; length; i++) &#123;</span><br><span class="line">            L[i] = nums[i - 1] * L[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // R[i] 为索引 i 右侧所有元素的乘积</span><br><span class="line">        // 对于索引为 &#x27;length-1&#x27; 的元素，因为右侧没有元素，所以 R[length-1] = 1</span><br><span class="line">        R[length - 1] = 1;</span><br><span class="line">        for (int i = length - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">            R[i] = nums[i + 1] * R[i + 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积</span><br><span class="line">        for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">            answer[i] = L[i] * R[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution2-空间复杂度为O-1-的方法"><a href="#Solution2-空间复杂度为O-1-的方法" class="headerlink" title="Solution2 空间复杂度为O(1)的方法"></a>Solution2 空间复杂度为O(1)的方法</h2><p><img src="https://files.mdnice.com/user/1489/448bc91c-0af2-4a4b-af89-c01fa606a5b7.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int length = nums.size();</span><br><span class="line">        vector&lt;int&gt; answer(length);</span><br><span class="line"></span><br><span class="line">        // answer[i] 表示索引 i 左侧所有元素的乘积</span><br><span class="line">        // 因为索引为 &#x27;0&#x27; 的元素左侧没有元素， 所以 answer[0] = 1</span><br><span class="line">        answer[0] = 1;</span><br><span class="line">        for (int i = 1; i &lt; length; i++) &#123;</span><br><span class="line">            answer[i] = nums[i - 1] * answer[i - 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // R 为右侧所有元素的乘积</span><br><span class="line">        // 刚开始右边没有元素，所以 R = 1</span><br><span class="line">        int R = 1;</span><br><span class="line">        for (int i = length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            // 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span><br><span class="line">            answer[i] = answer[i] * R;</span><br><span class="line">            // R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span><br><span class="line">            R *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a href="https://leetcode.com/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h1><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p><p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。 </p><p>示例 1：</p><p>输入：matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 5<br>输出：true<br>示例 2：</p><p>输入：matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 20<br>输出：false<br> <br><img src="https://files.mdnice.com/user/1489/00e1d4fd-e285-4863-8b0b-3060766bb525.png"></p><p>提示：</p><p>m &#x3D;&#x3D; matrix.length<br>n &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; n, m &lt;&#x3D; 300<br>-109 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 109<br>每行的所有元素从左到右升序排列<br>每列的所有元素从上到下升序排列<br>-109 &lt;&#x3D; target &lt;&#x3D; 109</p><p><img src="https://files.mdnice.com/user/1489/cc8a492c-a4e6-4df7-a90d-320f17769205.png"></p><h2 id="Solution0-暴力-4"><a href="#Solution0-暴力-4" class="headerlink" title="Solution0 暴力"></a>Solution0 暴力</h2><h2 id="Solution1-从右上角看是一颗二叉搜索树"><a href="#Solution1-从右上角看是一颗二叉搜索树" class="headerlink" title="Solution1 从右上角看是一颗二叉搜索树"></a>Solution1 从右上角看是一颗二叉搜索树</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;</span><br><span class="line">        if(matrix.size() == 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int i = 0;</span><br><span class="line">        int j = matrix[0].size()-1;</span><br><span class="line">        while(i &lt; matrix.size() &amp;&amp; j &gt;= 0) &#123;</span><br><span class="line">            if(matrix[i][j] == target) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            if(matrix[i][j] &lt; target) &#123;</span><br><span class="line">                ++ i;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                -- j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a href="https://leetcode.com/problems/valid-anagram/">242. 有效的字母异位词</a></h1><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p><p> </p><p>示例 1:</p><p>输入: s &#x3D; “anagram”, t &#x3D; “nagaram”<br>输出: true<br>示例 2:</p><p>输入: s &#x3D; “rat”, t &#x3D; “car”<br>输出: false </p><p>提示:</p><p>1 &lt;&#x3D; s.length, t.length &lt;&#x3D; 5 * 104<br>s 和 t 仅包含小写字母</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Hash Table</span><br><span class="line"></span><br><span class="line">This idea uses a hash table to record the times of appearances of each letter in the two strings s and t. For each letter in s, it increases the counter by 1 while for each letter in t, it decreases the counter by 1. Finally, all the counters will be 0 if they two are anagrams of each other.</span><br><span class="line"></span><br><span class="line">The first implementation uses the built-in unordered_map and takes 36 ms.</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isAnagram(string s, string t) &#123;</span><br><span class="line">        if (s.length() != t.length()) return false;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        unordered_map&lt;char, int&gt; counts;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            counts[s[i]]++;</span><br><span class="line">            counts[t[i]]--;</span><br><span class="line">        &#125;</span><br><span class="line">        for (auto count : counts)</span><br><span class="line">            if (count.second) return false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Since the problem statement says that &quot;the string contains only lowercase alphabets&quot;, we can simply use an array to simulate the unordered_map and speed up the code. The following implementation takes 12 ms.</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isAnagram(string s, string t) &#123;</span><br><span class="line">        if (s.length() != t.length()) return false;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        int counts[26] = &#123;0&#125;;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123; </span><br><span class="line">            counts[s[i] - &#x27;a&#x27;]++;</span><br><span class="line">            counts[t[i] - &#x27;a&#x27;]--;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; 26; i++)</span><br><span class="line">            if (counts[i]) return false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Sorting</span><br><span class="line"></span><br><span class="line">For two anagrams, once they are sorted in a fixed order, they will become the same. This code is much shorter (this idea can be done in just 1 line using Python as here). However, it takes much longer time --- 76 ms in C++.</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isAnagram(string s, string t) &#123; </span><br><span class="line">        sort(s.begin(), s.end());</span><br><span class="line">        sort(t.begin(), t.end());</span><br><span class="line">        return s == t; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>C++ 三种方法：</p><h2 id="Solution1-1-直接用sort函数"><a href="#Solution1-1-直接用sort函数" class="headerlink" title="Solution1  1.直接用sort函数"></a>Solution1  1.直接用sort函数</h2><p>class Solution {<br>public:<br>    bool isAnagram(string s, string t) {<br>        sort(s.begin(),s.end());<br>        sort(t.begin(),t.end());<br>        if(s&#x3D;&#x3D;t)<br>            return true;<br>        else<br>            return false;<br>    }<br>};</p><h2 id="Solution2-2-map计数"><a href="#Solution2-2-map计数" class="headerlink" title="Solution2  2.map计数"></a>Solution2  2.map计数</h2><p>class Solution {<br>public:<br>    bool isAnagram(string s, string t) {<br>        unordered_map&lt;char,int&gt; map;<br>        if (s.size() !&#x3D; t.size())<br>            return false;<br>        for(int i&#x3D;0;i&lt;s.size();i++){<br>            ++map[s[i]];<br>            –map[t[i]];<br>        }<br>        for(unordered_map&lt;char,int&gt;::iterator it&#x3D;map.begin();it!&#x3D;map.end();it++){<br>            if(it-&gt;second!&#x3D;0)<br>                return false;<br>        }<br>        return true;</p><pre><code>&#125;</code></pre><p>};</p><h2 id="Solution3-3-效率最高"><a href="#Solution3-3-效率最高" class="headerlink" title="Solution3  3.效率最高"></a>Solution3  3.效率最高</h2><p>class Solution {<br>public:<br>    bool isAnagram(string s, string t) {<br>        int num[26]&#x3D;{0};<br>        if(s.length()!&#x3D;t.length())<br>            return false;<br>        for(int i&#x3D;0;s[i]!&#x3D;’\0’;i++){<br>            num[s[i]-‘a’]++;<br>            num[t[i]-‘a’]–;</p><pre><code>    &#125;    for(int i=0;i&lt;26;i++)        if(num[i]!=0)            return false;    return true;&#125;</code></pre><p>};</p><h1 id="258-各位相加"><a href="#258-各位相加" class="headerlink" title="258. 各位相加"></a><a href="https://leetcode.com/problems/add-digits/">258. 各位相加</a></h1><p>给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。</p><p> </p><p>示例 1:</p><p>输入: num &#x3D; 38<br>输出: 2<br>解释: 各位相加的过程为：<br>38 –&gt; 3 + 8 –&gt; 11<br>11 –&gt; 1 + 1 –&gt; 2<br>由于 2 是一位数，所以返回 2。<br>示例 1:</p><p>输入: num &#x3D; 0<br>输出: 0 </p><p>提示：</p><p>0 &lt;&#x3D; num &lt;&#x3D; 231 - 1 </p><p>进阶：你可以不使用循环或者递归，在 O(1) 时间复杂度内解决这个问题吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Math&#x27;s Explained :-</span><br><span class="line">Any number where it&#x27;s digits add to 9 is always divisible by 9. (18, 27, 36, 45, 54, 63, 72, 81, 90, etc.) Therefore the &#x27;digital root&#x27; for any number divisible by 9 is always 9. You can see this even in larger numbers like 99 because 9 + 9 = 18, and then 1 + 8 = 9 still, so the root always becomes 9 for any numbers divisible by 9.</span><br><span class="line"></span><br><span class="line">Additionally, 0 always has a digital root of 0 obviously.</span><br><span class="line"></span><br><span class="line">The only other cases you need to worry about to find the digital root are when it isn&#x27;t 0 or 9.</span><br><span class="line"></span><br><span class="line">So for any number that isn&#x27;t 0 and isn&#x27;t divisible by 9, the root will always n % 9 for a given number n. (AKA the difference between given number n and the nearest number that is divisible by 9, since numbers divisible by 9 always have a digital root of 9).</span><br><span class="line">For examples: 100 % 9 = 1 (one greater than 99, which is divisible by 9).</span><br><span class="line">101 % 9 = 2</span><br><span class="line">102 % 9 = 3 and so on.</span><br><span class="line"></span><br><span class="line">This explanation/algorithm skips the whole &quot;add digits until there is only 1 remaining&quot;, so the description of this problem seems pretty misleading to me since it makes you think the solution will be something unrelated to the optimal one. I guess the point of Leetcode is to learn all of these tricks though.</span><br></pre></td></tr></table></figure><h2 id="Solution1-找规律"><a href="#Solution1-找规律" class="headerlink" title="Solution1 : 找规律"></a>Solution1 : 找规律</h2><p>除了传统的单纯循环，还可以找规律。假如一个三位数’abc’，其值大小为s1 &#x3D; 100 * a + 10 * b + 1 * c，经过一次各位相加后，变为s2 &#x3D; a + b + c，减小的差值为(s1 -s2) &#x3D; 99 * a + 9 * b，差值可以被9整除，每一个循环都这样，缩小了9的倍数。当num小于9，即只有一位时，直接返回num，大于9时，如果能被9整除，则返回9（因为不可能返回0也不可能返回两位数及以上的值），如果不能被整除，就返回被9除的余数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addDigits(self, num: int) -&gt; int:</span><br><span class="line">        if num &gt; 9:</span><br><span class="line">            num = num % 9</span><br><span class="line">            if num == 0:</span><br><span class="line">                return 9</span><br><span class="line">        return num</span><br></pre></td></tr></table></figure><h2 id="Solution2-循环"><a href="#Solution2-循环" class="headerlink" title="Solution2 :循环"></a>Solution2 :循环</h2><p><img src="https://files.mdnice.com/user/1489/f5955143-7685-4b34-b5dd-9b24fa5290ce.png"></p><h1 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode.com/problems/move-zeroes/">283. 移动零</a></h1><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>请注意 ，必须在不复制数组的情况下原地对数组进行操作。</p><p> </p><p>示例 1:</p><p>输入: nums &#x3D; [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>示例 2:</p><p>输入: nums &#x3D; [0]<br>输出: [0] </p><p>提示:</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">Solution</span><br><span class="line">This question comes under a broad category of &quot;Array Transformation&quot;. This category is the meat of tech interviews. Mostly because arrays are such a simple and easy to use data structure. Traversal or representation doesn&#x27;t require any boilerplate code and most of your code will look like the Pseudocode itself.</span><br><span class="line"></span><br><span class="line">The 2 requirements of the question are:</span><br><span class="line"></span><br><span class="line">Move all the 0&#x27;s to the end of array.</span><br><span class="line"></span><br><span class="line">All the non-zero elements must retain their original order.</span><br><span class="line"></span><br><span class="line">It&#x27;s good to realize here that both the requirements are mutually exclusive, i.e., you can solve the individual sub-problems and then combine them for the final solution.</span><br><span class="line"></span><br><span class="line">Approach #1 (Space Sub-Optimal) [Accepted]</span><br><span class="line">C++</span><br><span class="line"></span><br><span class="line">void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n = nums.size();</span><br><span class="line"></span><br><span class="line">    // Count the zeroes</span><br><span class="line">    int numZeroes = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        numZeroes += (nums[i] == 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Make all the non-zero elements retain their original order.</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (nums[i] != 0) &#123;</span><br><span class="line">            ans.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Move all zeroes to the end</span><br><span class="line">    while (numZeroes--) &#123;</span><br><span class="line">        ans.push_back(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Combine the result</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        nums[i] = ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Complexity Analysis</span><br><span class="line"></span><br><span class="line">Space Complexity : O(n)O(n). Since we are creating the &quot;ans&quot; array to store results.</span><br><span class="line"></span><br><span class="line">Time Complexity: O(n)O(n). However, the total number of operations are sub-optimal. We can achieve the same result in less number of operations.</span><br><span class="line"></span><br><span class="line">If asked in an interview, the above solution would be a good start. You can explain the interviewer(not code) the above and build your base for the next Optimal Solution.</span><br><span class="line"></span><br><span class="line">Approach #2 (Space Optimal, Operation Sub-Optimal) [Accepted]</span><br><span class="line">This approach works the same way as above, i.e. , first fulfills one requirement and then another. The catch? It does it in a clever way. The above problem can also be stated in alternate way, &quot; Bring all the non 0 elements to the front of array keeping their relative order same&quot;.</span><br><span class="line"></span><br><span class="line">This is a 2 pointer approach. The fast pointer which is denoted by variable &quot;cur&quot; does the job of processing new elements. If the newly found element is not a 0, we record it just after the last found non-0 element. The position of last found non-0 element is denoted by the slow pointer &quot;lastNonZeroFoundAt&quot; variable. As we keep finding new non-0 elements, we just overwrite them at the &quot;lastNonZeroFoundAt + 1&quot; &#x27;th index. This overwrite will not result in any loss of data because we already processed what was there(if it were non-0,it already is now written at it&#x27;s corresponding index,or if it were 0 it will be handled later in time).</span><br><span class="line"></span><br><span class="line">After the &quot;cur&quot; index reaches the end of array, we now know that all the non-0 elements have been moved to beginning of array in their original order. Now comes the time to fulfil other requirement, &quot;Move all 0&#x27;s to the end&quot;. We now simply need to fill all the indexes after the &quot;lastNonZeroFoundAt&quot; index with 0.</span><br><span class="line"></span><br><span class="line">C++</span><br><span class="line"></span><br><span class="line">void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int lastNonZeroFoundAt = 0;</span><br><span class="line">    // If the current element is not 0, then we need to</span><br><span class="line">    // append it just in front of last non 0 element we found. </span><br><span class="line">    for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        if (nums[i] != 0) &#123;</span><br><span class="line">            nums[lastNonZeroFoundAt++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> // After we have finished processing new elements,</span><br><span class="line"> // all the non-zero elements are already at beginning of array.</span><br><span class="line"> // We just need to fill remaining array with 0&#x27;s.</span><br><span class="line">    for (int i = lastNonZeroFoundAt; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        nums[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Complexity Analysis</span><br><span class="line"></span><br><span class="line">Space Complexity : O(1)O(1). Only constant space is used.</span><br><span class="line"></span><br><span class="line">Time Complexity: O(n)O(n). However, the total number of operations are still sub-optimal. The total operations (array writes) that code does is nn (Total number of elements).</span><br><span class="line"></span><br><span class="line">Approach #3 (Optimal) [Accepted]</span><br><span class="line">The total number of operations of the previous approach is sub-optimal. For example, the array which has all (except last) leading zeroes: [0, 0, 0, ..., 0, 1].How many write operations to the array? For the previous approach, it writes 0&#x27;s n-1n−1 times, which is not necessary. We could have instead written just once. How? ..... By only fixing the non-0 element,i.e., 1.</span><br><span class="line"></span><br><span class="line">The optimal approach is again a subtle extension of above solution. A simple realization is if the current element is non-0, its&#x27; correct position can at best be it&#x27;s current position or a position earlier. If it&#x27;s the latter one, the current position will be eventually occupied by a non-0 ,or a 0, which lies at a index greater than &#x27;cur&#x27; index. We fill the current position by 0 right away,so that unlike the previous solution, we don&#x27;t need to come back here in next iteration.</span><br><span class="line"></span><br><span class="line">In other words, the code will maintain the following invariant:</span><br><span class="line"></span><br><span class="line">All elements before the slow pointer (lastNonZeroFoundAt) are non-zeroes.</span><br><span class="line"></span><br><span class="line">All elements between the current and slow pointer are zeroes.</span><br><span class="line"></span><br><span class="line">Therefore, when we encounter a non-zero element, we need to swap elements pointed by current and slow pointer, then advance both pointers. If it&#x27;s zero element, we just advance current pointer.</span><br><span class="line"></span><br><span class="line">With this invariant in-place, it&#x27;s easy to see that the algorithm will work.</span><br><span class="line"></span><br><span class="line">C++</span><br><span class="line"></span><br><span class="line">void moveZeroes(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    for (int lastNonZeroFoundAt = 0, cur = 0; cur &lt; nums.size(); cur++) &#123;</span><br><span class="line">        if (nums[cur] != 0) &#123;</span><br><span class="line">            swap(nums[lastNonZeroFoundAt++], nums[cur]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Complexity Analysis</span><br><span class="line"></span><br><span class="line">Space Complexity : O(1)O(1). Only constant space is used.</span><br><span class="line"></span><br><span class="line">Time Complexity: O(n)O(n). However, the total number of operations are optimal. The total operations (array writes) that code does is Number of non-0 elements.This gives us a much better best-case (when most of the elements are 0) complexity than last solution. However, the worst-case (when all elements are non-0) complexity for both the algorithms is same.</span><br></pre></td></tr></table></figure><h2 id="Solution1-5"><a href="#Solution1-5" class="headerlink" title="Solution1"></a>Solution1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void moveZeroes(int* nums, int numsSize) &#123;</span><br><span class="line">    int i = 0,j = 0;</span><br><span class="line">    for(i = 0 ; i &lt; numsSize; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(nums[i] != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[j++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(j &lt; numsSize)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[j++] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="292-Nim-游戏"><a href="#292-Nim-游戏" class="headerlink" title="292. Nim 游戏"></a><a href="https://leetcode.com/problems/nim-game/">292. Nim 游戏</a></h1><p><img src="https://files.mdnice.com/user/1489/8faa0b82-6c1d-4433-abc3-8bb1ef5df8b6.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Solution</span><br><span class="line">You can always win a Nim game if the number of stones nn in the pile is not divisible by 44.</span><br><span class="line"></span><br><span class="line">Reasoning</span><br><span class="line"></span><br><span class="line">Let us think of the small cases. It is clear that if there are only one, two, or three stones in the pile, and it is your turn, you can win the game by taking all of them. Like the problem description says, if there are exactly four stones in the pile, you will lose. Because no matter how many you take, you will leave some stones behind for your opponent to take and win the game. So in order to win, you have to ensure that you never reach the situation where there are exactly four stones on the pile on your turn.</span><br><span class="line"></span><br><span class="line">Similarly, if there are five, six, or seven stones you can win by taking just enough to leave four stones for your opponent so that they lose. But if there are eight stones on the pile, you will inevitably lose, because regardless whether you pick one, two or three stones from the pile, your opponent can pick three, two or one stone to ensure that, again, four stones will be left to you on your turn.</span><br><span class="line"></span><br><span class="line">It is obvious that the same pattern repeats itself for n=4,8,12,16,\dotsn=4,8,12,16,…, basically all multiples of 44.</span><br><span class="line"></span><br><span class="line">Complexity Analysis</span><br><span class="line"></span><br><span class="line">Time complexity: O(1)O(1)</span><br><span class="line"></span><br><span class="line">Only one check is performed.</span><br><span class="line">Space complexity: O(1)O(1)</span><br><span class="line"></span><br><span class="line">No additional space is used, so space complexity is also O(1)O(1).</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution1-数学推理"><a href="#Solution1-数学推理" class="headerlink" title="Solution1 数学推理"></a>Solution1 数学推理</h2><p><img src="https://files.mdnice.com/user/1489/8c0e907f-f383-48da-98e6-ed531d6bd93a.png"></p><h1 id="326-3的幂"><a href="#326-3的幂" class="headerlink" title="326.3的幂"></a><a href="https://leetcode.com/problems/power-of-three/">326.3的幂</a></h1><p><img src="https://files.mdnice.com/user/1489/c13f7729-4dce-428f-8f31-b5f9317a5ce2.png"></p><p><img src="https://files.mdnice.com/user/1489/a9da96c8-01ef-4845-9aae-aa779466e765.png"></p><p><img src="https://files.mdnice.com/user/1489/802538d5-95df-4c84-9c65-31ac4b52eff3.png"></p><h2 id="Solution1-试除法"><a href="#Solution1-试除法" class="headerlink" title="Solution1 试除法"></a>Solution1 试除法</h2><p><img src="https://files.mdnice.com/user/1489/bc9e3a37-edc5-498a-b026-882a06a64125.png"></p><h2 id="Solution2-约数法"><a href="#Solution2-约数法" class="headerlink" title="Solution2 约数法"></a>Solution2 约数法</h2><p><img src="https://files.mdnice.com/user/1489/654af93a-97e3-4f83-88fb-c27a32ac905a.png"></p><h1 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a><a href="https://leetcode.com/problems/odd-even-linked-list/">328. 奇偶链表</a></h1><p><img src="https://files.mdnice.com/user/1489/201501bf-a7cf-4604-9d0c-860c89a8eeb9.png"></p><p><img src="https://files.mdnice.com/user/1489/9aed981d-b202-4bc8-b0a1-1e9080dc85c1.png"></p><h2 id="Solution1-双链法"><a href="#Solution1-双链法" class="headerlink" title="Solution1 双链法"></a>Solution1 双链法</h2><p>结点1作为奇数链的头 结点2作为偶数链的头<br>从第3个点开始遍历，依次轮流附在奇、偶链的后面<br>遍历完后，奇数链的尾连向偶链的头，偶链的尾为空， 返回奇数链的头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* oddEvenList(ListNode* head) &#123;</span><br><span class="line">        if (head == nullptr) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* evenHead = head-&gt;next;</span><br><span class="line">        ListNode* odd = head;</span><br><span class="line">        ListNode* even = evenHead;</span><br><span class="line">        while (even != nullptr &amp;&amp; even-&gt;next != nullptr) &#123;</span><br><span class="line">            odd-&gt;next = even-&gt;next;</span><br><span class="line">            odd = odd-&gt;next;</span><br><span class="line">            even-&gt;next = odd-&gt;next;</span><br><span class="line">            even = even-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd-&gt;next = evenHead;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(n)O(n)，其中 nn 是链表的节点数。需要遍历链表中的每个节点，并更新指针。</p><p>空间复杂度：O(1)O(1)。只需要维护有限的指针。</p><h1 id="334-递增的三元子序列"><a href="#334-递增的三元子序列" class="headerlink" title="334. 递增的三元子序列"></a><a href="https://leetcode.com/problems/increasing-triplet-subsequence/">334. 递增的三元子序列</a></h1><p>给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。</p><p>如果存在这样的三元组下标 (i, j, k) 且满足 i &lt; j &lt; k ，使得 nums[i] &lt; nums[j] &lt; nums[k] ，返回 true ；否则，返回 false 。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3,4,5]<br>输出：true<br>解释：任何 i &lt; j &lt; k 的三元组都满足题意<br>示例 2：</p><p>输入：nums &#x3D; [5,4,3,2,1]<br>输出：false<br>解释：不存在满足题意的三元组<br>示例 3：</p><p>输入：nums &#x3D; [2,1,5,0,4,6]<br>输出：true<br>解释：三元组 (3, 4, 5) 满足题意，因为 nums[3] &#x3D;&#x3D; 0 &lt; nums[4] &#x3D;&#x3D; 4 &lt; nums[5] &#x3D;&#x3D; 6 </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 5 * 105<br>-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool increasingTriplet(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int c1 = INT_MAX, c2 = INT_MAX;</span><br><span class="line">    for (int x : nums) &#123;</span><br><span class="line">        if (x &lt;= c1) &#123;</span><br><span class="line">            c1 = x;           // c1 is min seen so far (it&#x27;s a candidate for 1st element)</span><br><span class="line">        &#125; else if (x &lt;= c2) &#123; // here when x &gt; c1, i.e. x might be either c2 or c3</span><br><span class="line">            c2 = x;           // x is better than the current c2, store it</span><br><span class="line">        &#125; else &#123;              // here when we have/had c1 &lt; c2 already and x &gt; c2</span><br><span class="line">            return true;      // the increasing subsequence of 3 elements exists</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Solution1-贪心"><a href="#Solution1-贪心" class="headerlink" title="Solution1  贪心"></a>Solution1  贪心</h2><p><img src="https://files.mdnice.com/user/1489/61447011-c76d-459e-be76-ed35d1d0edeb.png"></p><h2 id="Solution2-双向遍历"><a href="#Solution2-双向遍历" class="headerlink" title="Solution2 双向遍历"></a>Solution2 双向遍历</h2><p><img src="https://files.mdnice.com/user/1489/32ee1091-199d-4e97-be7e-8c82cd1a5660.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool increasingTriplet(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        if (n &lt; 3) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; leftMin(n);</span><br><span class="line">        leftMin[0] = nums[0];</span><br><span class="line">        for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">            leftMin[i] = min(leftMin[i - 1], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; rightMax(n);</span><br><span class="line">        rightMax[n - 1] = nums[n - 1];</span><br><span class="line">        for (int i = n - 2; i &gt;= 0; i--) &#123;</span><br><span class="line">            rightMax[i] = max(rightMax[i + 1], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; n - 1; i++) &#123;</span><br><span class="line">            if (nums[i] &gt; leftMin[i - 1] &amp;&amp; nums[i] &lt; rightMax[i + 1]) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(n)，其中 nn 是数组 \textit{nums}nums 的长度。需要遍历数组三次。</p><p>空间复杂度：O(n)，其中 nn 是数组 \textit{nums}nums 的长度。需要创建两个长度为 nn 的数组 \textit{leftMin}leftMin 和 \textit{rightMax}rightMax。</p><h1 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode.com/problems/reverse-string/">344. 反转字符串</a></h1><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p> </p><p>示例 1：</p><p>输入：s &#x3D; [“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]<br>示例 2：</p><p>输入：s &#x3D; [“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">We use here two pointers that gives us access to characters for swapping in left and right side of the string. For swapping we use a convinient C++ method swap. We just iterate over characters and swap them.</span><br><span class="line"></span><br><span class="line">Time: O(n)</span><br><span class="line">Space: O(1)</span><br></pre></td></tr></table></figure><h2 id="Solution1-双指针交换"><a href="#Solution1-双指针交换" class="headerlink" title="Solution1 双指针交换"></a>Solution1 双指针交换</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void reverseString(vector&lt;char&gt;&amp; s) &#123;</span><br><span class="line">        for (int i = 0, j = s.size() - 1; i &lt; s.size()/2; i++, j--) &#123;</span><br><span class="line">            swap(s[i],s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="堆：347-前-K-个高频元素"><a href="#堆：347-前-K-个高频元素" class="headerlink" title="堆：347. 前 K 个高频元素"></a><a href="https://leetcode.com/problems/top-k-frequent-elements/">堆：347. 前 K 个高频元素</a></h1><p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。</p><p> </p><p>示例 1:</p><p>输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2<br>输出: [1,2]<br>示例 2:</p><p>输入: nums &#x3D; [1], k &#x3D; 1<br>输出: [1] </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>k 的取值范围是 [1, 数组中不相同的元素的个数]<br>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的 </p><p>进阶：你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">How&#x27;s going Ladies - n - Gentlemen, today we are going to solve another coolest problem i.e. Top K Frequent Elements</span><br><span class="line"></span><br><span class="line">Okay, so in order to solve this problem, first of all let&#x27;s understand what the problem statement is:</span><br><span class="line"></span><br><span class="line">Given an integer array nums, </span><br><span class="line">and an integer k, return the k most frequent elements. You may return the answer in any order.</span><br><span class="line">Okay, so wait wait listen just looking at this if you know the HashMap, you&#x27;ll simply gonna say we can solve this problem easily using HashMap. And I&#x27;ll say yes, exactly we gonna do the exact same thing but we will use Heap as well with HashMap, if you got the idea by listening heap. Then you had just solve the brute force approach</span><br><span class="line"></span><br><span class="line">So, let&#x27;s talk about it&#x27;s</span><br><span class="line"></span><br><span class="line">Brute Force Approach :-</span><br><span class="line">Let&#x27;s take an example,</span><br><span class="line"></span><br><span class="line">Input: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">Output: [1,2]</span><br><span class="line"></span><br><span class="line">So, we have 2 step&#x27;s to perform in this problem:-</span><br><span class="line"></span><br><span class="line">HashMap</span><br><span class="line"></span><br><span class="line">Heap</span><br><span class="line"></span><br><span class="line">Step -1 :- Make an Frequency map &amp; fill it with the given elements</span><br><span class="line"></span><br><span class="line">[1,1,1,2,2,3]</span><br><span class="line"></span><br><span class="line">------------------------------------------------</span><br><span class="line">|        1    ---&gt; |       3         |</span><br><span class="line">|                  |                 |</span><br><span class="line">|        2    ---&gt; |       2         |                         HashMap of Integer, Integer</span><br><span class="line">|                  |                 |</span><br><span class="line">|        3    ---&gt; |       1         |</span><br><span class="line">------------------------------------------------</span><br><span class="line">Okay, so we just had completed our step no.1 now, it;s time to move to next step</span><br><span class="line"></span><br><span class="line">Step -2 :- Make an MaxHeap &amp; fill it with keys &amp; on the peek of our Heap we will be having most frequent elements</span><br><span class="line"></span><br><span class="line">HashMap :-</span><br><span class="line">Key     Value</span><br><span class="line">1 ----&gt; 3</span><br><span class="line">2 ----&gt; 2</span><br><span class="line">3 ----&gt; 1</span><br><span class="line"></span><br><span class="line">Heap :-</span><br><span class="line"></span><br><span class="line">|    1   |             from the top of the heap we&#x27;ll pop that no. of element requires in our array of k size</span><br><span class="line">|    2   |</span><br><span class="line">|    3   |</span><br><span class="line">   ------------</span><br><span class="line">Create result array res &amp; store K frequent elements in it.</span><br><span class="line"></span><br><span class="line">Heap :-</span><br><span class="line"></span><br><span class="line">|        |             res : [1]</span><br><span class="line">|    2   |</span><br><span class="line">|    3   |</span><br><span class="line">   ------------</span><br><span class="line">Heap :-</span><br><span class="line"></span><br><span class="line">|        |             res : [1, 2]</span><br><span class="line">|        |</span><br><span class="line">|    3   |</span><br><span class="line">   ------------</span><br><span class="line">As, our K is 2 we gonna only store Most frequent K elements in our array, therefore in the result we get:- [1, 2]</span><br><span class="line"></span><br><span class="line">I hope so, ladies - n - gentlemen, this approach is absolute clear, Let&#x27;s code it, up</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int[] topKFrequent(int[] nums, int k) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        for(int i : nums)&#123;</span><br><span class="line">            map.put(i, map.getOrDefault(i, 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((a,b) -&gt; map.get(b) - map.get(a));</span><br><span class="line">        </span><br><span class="line">        for(int key : map.keySet())&#123;</span><br><span class="line">            maxHeap.add(key);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int res[] = new int[k];</span><br><span class="line">        for(int i = 0; i &lt; k; i++)&#123;</span><br><span class="line">            res[i] = maxHeap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ANALYSIS :-</span><br><span class="line"></span><br><span class="line">Time Complexity :- BigO(K log D) as we are Poll K distinct elements from the Heap &amp; here D is no. of distinct (unique) elements in the input array</span><br><span class="line"></span><br><span class="line">Space Complexity :- BigO(D), this is the size of the heap.</span><br><span class="line"></span><br><span class="line">Well, this is not a super efficient Approach,</span><br><span class="line">We can solve this more efficiently as well, now some of you&#x27;ll ask but how!!</span><br><span class="line"></span><br><span class="line">Well, for that we have Bucket Sorting</span><br><span class="line"></span><br><span class="line">Optimize Approach :-</span><br><span class="line">Let&#x27;s understand what bucket sort is,</span><br><span class="line"></span><br><span class="line">Bucket sort, or bin sort, is a sorting algorithm that works by distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm, or by recursively applying the bucket sorting algorithm.</span><br><span class="line"></span><br><span class="line">In this process we gonna follow 3 major steps :-</span><br><span class="line"></span><br><span class="line">Step - 1 :</span><br><span class="line">Create Frequency map:</span><br><span class="line">1.1 Iterate thru the given nums[] array</span><br><span class="line">1.2. With each iteration - check if map already contains current key</span><br><span class="line">If current key is already in the map just increase the value for this key</span><br><span class="line">Else add key value pair.</span><br><span class="line">Where key is current int and value is 1 (1 -&gt; we encounter given key for the first time)</span><br><span class="line"></span><br><span class="line">image</span><br><span class="line"></span><br><span class="line">Step - 2 :</span><br><span class="line">Create Bucket List[]:</span><br><span class="line">index of bucket[] arr will represent the value from our map</span><br><span class="line">Why not use int[] arr? Multiple values can have the same frequency that&#x27;s why we use List[] array of lists instead of regular array</span><br><span class="line">Iterate thrue the map and for each value add key at the index of that value</span><br><span class="line"></span><br><span class="line">image</span><br><span class="line"></span><br><span class="line">Step - 3 :</span><br><span class="line">If we look at bucket arr we can see that most frequent elements are located at the end of arr</span><br><span class="line">and leat frequent elemnts at the begining</span><br><span class="line">Last step is to iterate from the end to the begining of the arr and add elements to result List</span><br><span class="line"></span><br><span class="line">image</span><br><span class="line"></span><br><span class="line">I hope so ladies - n - gentlemen Approach is absolute clear, Let&#x27;s code it up</span><br></pre></td></tr></table></figure><h2 id="Solution1-排序法"><a href="#Solution1-排序法" class="headerlink" title="Solution1 排序法"></a>Solution1 排序法</h2><p><img src="https://files.mdnice.com/user/1489/9d0654e6-75ac-4ef1-9309-aa410463028e.png"></p><h2 id="Solution2-最小堆法"><a href="#Solution2-最小堆法" class="headerlink" title="Solution2 最小堆法"></a>Solution2 最小堆法</h2><p><img src="https://files.mdnice.com/user/1489/8c154642-a002-4b1e-a451-679ecaab6052.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        map&lt;int, int&gt; freq;</span><br><span class="line">        using pii = std::pair&lt;int, int&gt;;</span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;</span><br><span class="line">        </span><br><span class="line">        for (auto e : nums) ++freq[e];</span><br><span class="line">        </span><br><span class="line">        for (auto&amp; pair : freq) &#123;</span><br><span class="line">            pq.emplace(pair.second, pair.first);</span><br><span class="line">            if (pq.size() &gt; k) pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while (!pq.empty()) &#123;</span><br><span class="line">            res.emplace_back(pq.top().second);</span><br><span class="line">            pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a href="https://leetcode.com/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h1><p>给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。</p><p> </p><p>示例 1：</p><p>输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]<br>输出：[2]<br>示例 2：</p><p>输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]<br>输出：[9,4]<br>解释：[4,9] 也是可通过的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Approach 1: Two Sets</span><br><span class="line">Intuition</span><br><span class="line"></span><br><span class="line">The naive approach would be to iterate along the first array nums1 and to check for each value if this value in nums2 or not. If yes - add the value to output. Such an approach would result in a pretty bad \mathcal&#123;O&#125;(n \times m)O(n×m) time complexity, where n and m are arrays&#x27; lengths.</span><br><span class="line"></span><br><span class="line">To solve the problem in linear time, let&#x27;s use the structure set, which provides in/contains operation in \mathcal&#123;O&#125;(1)O(1) time in average case.</span><br><span class="line"></span><br><span class="line">The idea is to convert both arrays into sets, and then iterate over the smallest set checking the presence of each element in the larger set. Time complexity of this approach is \mathcal&#123;O&#125;(n + m)O(n+m) in the average case.</span><br></pre></td></tr></table></figure><h2 id="Solution1-6"><a href="#Solution1-6" class="headerlink" title="Solution1"></a>Solution1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; result_set; // 存放结果，之所以用set是为了给结果集去重</span><br><span class="line">        int hash[1005] = &#123;0&#125;; // 默认数值为0</span><br><span class="line">        for (int num : nums1) &#123; // nums1中出现的字母在hash数组中做记录</span><br><span class="line">            hash[num] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int num : nums2) &#123; // nums2中出现话，result记录</span><br><span class="line">            if (hash[num] == 1) &#123;</span><br><span class="line">                result_set.insert(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return vector&lt;int&gt;(result_set.begin(), result_set.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution2-5"><a href="#Solution2-5" class="headerlink" title="Solution2"></a>Solution2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; result_set; // 存放结果</span><br><span class="line">        unordered_set&lt;int&gt; nums_set(nums1.begin(), nums1.end());</span><br><span class="line">        for (int num : nums2) &#123;</span><br><span class="line">            // 发现nums2的元素 在nums_set里又出现过</span><br><span class="line">            if (nums_set.find(num) != nums_set.end()) &#123;</span><br><span class="line">                result_set.insert(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return vector&lt;int&gt;(result_set.begin(), result_set.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="378-有序矩阵中第-K-小的元素"><a href="#378-有序矩阵中第-K-小的元素" class="headerlink" title="378. 有序矩阵中第 K 小的元素"></a><a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/">378. 有序矩阵中第 K 小的元素</a></h1><p>给你一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。<br>请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。</p><p>你必须找到一个内存复杂度优于 O(n2) 的解决方案。</p><p> </p><p>示例 1：</p><p>输入：matrix &#x3D; [[1,5,9],[10,11,13],[12,13,15]], k &#x3D; 8<br>输出：13<br>解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13<br>示例 2：</p><p>输入：matrix &#x3D; [[-5]], k &#x3D; 1<br>输出：-5 </p><p>提示：</p><p>n &#x3D;&#x3D; matrix.length<br>n &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; n &lt;&#x3D; 300<br>-109 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 109<br>题目数据 保证 matrix 中的所有行和列都按 非递减顺序 排列<br>1 &lt;&#x3D; k &lt;&#x3D; n2 </p><p>进阶：</p><p>你能否用一个恒定的内存(即 O(1) 内存复杂度)来解决这个问题?<br>你能在 O(n) 的时间复杂度下解决这个问题吗?这个方法对于面试来说可能太超前了，但是你会发现阅读这篇文章（ this paper ）很有趣。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">✔️ Solution 1: Max Heap keeps up to k elements</span><br><span class="line"></span><br><span class="line">The easy approach is that we iterate all elements in the matrix and and add elements into the maxHeap. The maxHeap will keep up to k smallest elements (because when maxHeap is over size of k, we do remove the top of maxHeap which is the largest one). Finally, the top of the maxHeap is the kth smallest element in the matrix.</span><br><span class="line">This approach leads this problem become the same with 215. Kth Largest Element in an Array, which doesn&#x27;t take the advantage that the matrix is already sorted by rows and by columns.</span><br><span class="line"></span><br><span class="line">Complexity:</span><br><span class="line">Time: O(M * N * logK), where M &lt;= 300 is the number of rows, N &lt;= 300 is the number of columns.</span><br><span class="line">Space: O(K), space for heap which stores up to k elements.</span><br><span class="line">✔️ Solution 2: Min Heap to find kth smallest element from amongst N sorted list</span><br><span class="line"></span><br><span class="line">Since each of the rows in matrix are already sorted, we can understand the problem as finding the kth smallest element from amongst M sorted rows.</span><br><span class="line">We start the pointers to point to the beginning of each rows, then we iterate k times, for each time ith, the top of the minHeap is the ith smallest element in the matrix. We pop the top from the minHeap then add the next element which has the same row with that top to the minHeap.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution1-暴力-13"><a href="#Solution1-暴力-13" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><p><img src="https://files.mdnice.com/user/1489/aa8f67bb-f725-4ac9-b288-f00702b84a55.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123;</span><br><span class="line">        struct point &#123;</span><br><span class="line">            int val, x, y;</span><br><span class="line">            point(int val, int x, int y) : val(val), x(x), y(y) &#123;&#125;</span><br><span class="line">            bool operator&gt; (const point&amp; a) const &#123; return this-&gt;val &gt; a.val; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        priority_queue&lt;point, vector&lt;point&gt;, greater&lt;point&gt;&gt; que;</span><br><span class="line">        int n = matrix.size();</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            que.emplace(matrix[i][0], i, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; k - 1; i++) &#123;</span><br><span class="line">            point now = que.top();</span><br><span class="line">            que.pop();</span><br><span class="line">            if (now.y != n - 1) &#123;</span><br><span class="line">                que.emplace(matrix[now.x][now.y + 1], now.x, now.y + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return que.top().val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution2-最小堆"><a href="#Solution2-最小堆" class="headerlink" title="Solution2 最小堆"></a>Solution2 最小堆</h2><p><img src="https://files.mdnice.com/user/1489/ac2814f5-9f64-451b-8a2f-167966444bc9.png"></p><p><img src="https://files.mdnice.com/user/1489/89471a17-0dc3-4180-9b34-d9d5c6c4f9da.png"></p><p><img src="https://files.mdnice.com/user/1489/bfd3a090-de97-4eff-a66b-be9cddb9bbc8.png"></p><h1 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode.com/problems/decode-string/">394. 字符串解码</a></h1><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><p> </p><p>示例 1：</p><p>输入：s &#x3D; “3[a]2[bc]”<br>输出：”aaabcbc”<br>示例 2：</p><p>输入：s &#x3D; “3[a2[c]]”<br>输出：”accaccacc”<br>示例 3：</p><p>输入：s &#x3D; “2[abc]3[cd]ef”<br>输出：”abcabccdcdcdef”<br>示例 4：</p><p>输入：s &#x3D; “abc3[cd]xyz”<br>输出：”abccdcdcdxyz” </p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 30<br>s 由小写英文字母、数字和方括号 ‘[]’ 组成<br>s 保证是一个 有效 的输入。<br>s 中所有整数的取值范围为 [1, 300] </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This is the standard solution given under the tab &#x27;Solution&#x27; of the same problem: https://leetcode.com/problems/decode-string/solution/</span><br><span class="line">We start with the original string s and index = 0. If the index is not &#x27;]&#x27;, meaning its a digit or alphabet (but not &#x27;[&#x27; -&gt; this is ensured in the later part of the code). Also note that the string won&#x27;t start with &#x27;[&#x27; so there is no chance of having it initially.</span><br><span class="line">First lets take the case when the string isdigit. In that case, count the number of times the inner string need to be repeated. For example 26[X], string X will be repeated 26 times and 26 is stored in k. Now increment the index -&gt; this is done as we know that number will be accompanied by [.</span><br><span class="line">Now recurse on the inner string s and also increment index, this time for ]. While recursing for inner string, if the character is not digit, we store that and return it as a string. Now remember this inner string needs to be repeated &#x27;k&#x27; times so we add that to current return string &#x27;ret&#x27;. Return the ret string.</span><br></pre></td></tr></table></figure><h2 id="Solution1-两个栈"><a href="#Solution1-两个栈" class="headerlink" title="Solution1 两个栈"></a>Solution1 两个栈</h2><p><img src="https://files.mdnice.com/user/1489/57e2bfe5-e188-42e3-9460-4fa79082ecd2.png"></p><h1 id="402-移掉-K-位数字"><a href="#402-移掉-K-位数字" class="headerlink" title="402. 移掉 K 位数字"></a><a href="https://leetcode.com/problems/remove-k-digits/">402. 移掉 K 位数字</a></h1><p>给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p><p> <br>示例 1 ：</p><p>输入：num &#x3D; “1432219”, k &#x3D; 3<br>输出：”1219”<br>解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。<br>示例 2 ：</p><p>输入：num &#x3D; “10200”, k &#x3D; 1<br>输出：”200”<br>解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。<br>示例 3 ：</p><p>输入：num &#x3D; “10”, k &#x3D; 2<br>输出：”0”<br>解释：从原数字移除所有的数字，剩余为空就是 0 。 </p><p>提示：</p><p>1 &lt;&#x3D; k &lt;&#x3D; num.length &lt;&#x3D; 105<br>num 仅由若干位数字（0 - 9）组成<br>除了 0 本身之外，num 不含任何前导零</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">KNOCKCAT</span><br><span class="line"></span><br><span class="line">1. Easy C++</span><br><span class="line">2. Line by Line Explanation with Comments.</span><br><span class="line">3. Detailed Explanation ✅</span><br><span class="line">4. Handwritten snap of an TestCase at the end of code given.</span><br><span class="line">5. Please Upvote if it helps⬆️</span><br><span class="line">6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. ⬇️</span><br><span class="line">LeetCode</span><br><span class="line"></span><br><span class="line">EXPLANATION</span><br><span class="line"></span><br><span class="line">1. Deleting k digits means keeping n - k digits, where n is the total number of digits.</span><br><span class="line"></span><br><span class="line">2. Use a stack that you keep sorted ascendingly. You remove elements from it as long as you can still make it to n - k digits,</span><br><span class="line">and your current element is smaller than the top of the stack:</span><br><span class="line"></span><br><span class="line">push(2) =&gt; 2</span><br><span class="line">push(4) because 2 &lt; 4 =&gt; 24</span><br><span class="line">push(6) because 4 &lt; 6 =&gt; 246</span><br><span class="line">pop() because 3 &lt; 6 and we can still end up with 2 digits =&gt; 24</span><br><span class="line">pop() for the same reason =&gt; 2</span><br><span class="line">push(3) =&gt; 23</span><br><span class="line">push(5) =&gt; 235</span><br><span class="line">Then just take the first k digits =&gt; 23. Or you can make sure never to push more than k digits, and then the final stack is your solution.</span><br><span class="line"></span><br><span class="line">3. Note that you cannot pop elements if that means you will not be able to build a solution of k digits.</span><br><span class="line">For this, you need to check the current number of elements in the stack and the number of digits to the right of your current position on the input number.</span><br><span class="line">Some More Points</span><br><span class="line"></span><br><span class="line">1. Approach is simple. We need a number which is minimum, thus we need to remove the most significant digits first.</span><br><span class="line">For eg. if we have a number having digits 1-4 then 1234 would be the minimum and not 2314 or anything else.</span><br><span class="line">So in case of 2314, we remove 3 first, and then we go for 2 (Because they are more significant than 4). Observing this simple idea,</span><br><span class="line">we need to remove any digit which is greater than its following digit. Thats why we deleted 3 as it,</span><br><span class="line">was greater than 1 and similiarly 2 as it was also greater than 1.</span><br><span class="line"></span><br><span class="line">2. In order to accomplish this, we use stack Data Structure where we pop the top if it is greater than current digit.</span><br><span class="line"></span><br><span class="line">3. The conditions mentioned in while loop are important to avoid any Runtime Error. For eg. [&quot;10001&quot; 2] the answer is &quot;0&quot; but if we don&#x27;t</span><br><span class="line">mention the condition !s.empty(), then the while loop will run on empty stack and try to pop the top which doesn&#x27;t exist thus throwing RE.</span><br><span class="line"></span><br><span class="line">Time Complexity :- O(N) // as we only traversing the string for once</span><br><span class="line">Space complexity:- O(N) // as we will store maximum of n digits in our string</span><br></pre></td></tr></table></figure><h2 id="Solution1-贪心-单调栈"><a href="#Solution1-贪心-单调栈" class="headerlink" title="Solution1 贪心+单调栈"></a>Solution1 贪心+单调栈</h2><p><img src="https://files.mdnice.com/user/1489/702de056-c52b-45b9-9965-8112d4131454.png"></p><p><img src="https://files.mdnice.com/user/1489/48ae75e0-df07-48f0-bfea-017869bac869.png"></p><p><img src="https://files.mdnice.com/user/1489/0052ac37-a066-4e57-97fd-4ebe72e6418e.png"></p><p><img src="https://files.mdnice.com/user/1489/a4c9016a-3529-492d-a5c4-4172619a5168.png"></p><p><img src="https://files.mdnice.com/user/1489/cf2db259-ce16-4284-97f8-6e048c789bd5.png"></p><p><img src="https://files.mdnice.com/user/1489/544a41e4-a185-4dff-941f-79e6a60d6e79.png"></p><p><img src="https://files.mdnice.com/user/1489/f0bf9bc6-9c7f-434c-b924-cba7405ed0fb.png"></p><p><img src="https://files.mdnice.com/user/1489/446462c6-005a-4165-81a4-213042a92492.png"></p><p><img src="https://files.mdnice.com/user/1489/207854fc-5451-44e1-84a6-51cde0d77f0f.png"></p><h1 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406. 根据身高重建队列"></a><a href="https://leetcode.com/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h1><p>假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] &#x3D; [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。</p><p>请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] &#x3D; [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。</p><p> </p><p>示例 1：</p><p>输入：people &#x3D; [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]<br>输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]<br>解释：<br>编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。<br>编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。<br>编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。<br>编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。<br>编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。<br>因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。<br>示例 2：</p><p>输入：people &#x3D; [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]<br>输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]] </p><p>提示：</p><p>1 &lt;&#x3D; people.length &lt;&#x3D; 2000<br>0 &lt;&#x3D; hi &lt;&#x3D; 106<br>0 &lt;&#x3D; ki &lt; people.length<br>题目数据确保队列可以被重建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Time Complexity : O(N^2) , Space Complexity : O(N)</span><br><span class="line"></span><br><span class="line">Upvote if Found Helpful</span><br><span class="line"></span><br><span class="line">Intuition :</span><br><span class="line"></span><br><span class="line">So here if we carefully observe we can notice that if we take any person and insert any other shorter person before or after him in queue then the number of people higher or equal to him before him doesn&#x27;t change. So we need to place the taller people first in the queue and we can add the shorter people in between or after them according to reqirement.</span><br><span class="line"></span><br><span class="line">So we need to sort the array according to their height in decreasing order (Heighest at the first).</span><br><span class="line">Now think if 2 person has same height the person with lower (Ki) will be inserted before other. Because The person before will have at least 1 less number of equal or taller people before him than who is after.</span><br><span class="line"></span><br><span class="line">So in case of equal heights (Hi) the person with lesser (Ki) will be placed first during sorting.</span><br><span class="line">Now if we insert the person from the sorted array in the ans array in the position (Ki) then the people greater than or equal to him will be in his left and they total will be (Ki) in number (From 0 to (Ki-1)th position). After that whatever we insert will be shorter (Which doesn&#x27;t matter if inserted after or before the position) or if equal will have greater (Ki) than the present one i.e. will be inserted in the right.</span><br><span class="line"></span><br><span class="line">So for each element in the sorted array we insert it at the (Ki)th position in the ans array.</span><br><span class="line">Example :</span><br><span class="line"></span><br><span class="line"> People = [[7,0], [4,4], [7,2], [5,0], [6,1], [5,4], [8,0]]</span><br><span class="line"> Sorted People accordin to comp function : [[8,0], [7,0], [7,2], [6,1], [5,0], [5,4], [4,4]]]</span><br><span class="line"> </span><br><span class="line"> Now for each iteration in the loop ; (Ki of each man is included in &#x27; &#x27;, and each inserted man in &quot; &quot;)</span><br><span class="line"> </span><br><span class="line"> man = [8,&#x27;0&#x27;] -&gt; ans.insert(ans.begin()+&#x27;0&#x27;, man) -&gt; ans  = [&quot;[8,0]&quot;]</span><br><span class="line"> man = [7,&#x27;0&#x27;] -&gt; ans.insert(ans.begin()+&#x27;0&#x27;, man) -&gt; ans  = [&quot;[7,0]&quot;, [8,0]]</span><br><span class="line"> man = [7,&#x27;2&#x27;] -&gt; ans.insert(ans.begin()+&#x27;2&#x27;, man) -&gt; ans  = [[7,0], [8,0], &quot;[7,2]&quot;]</span><br><span class="line"> man = [6,&#x27;1&#x27;] -&gt; ans.insert(ans.begin()+&#x27;1&#x27;, man) -&gt; ans  = [[7,0], &quot;[6,1]&quot;, [8,0], [7,2]]</span><br><span class="line"> man = [5,&#x27;0&#x27;] -&gt; ans.insert(ans.begin()+&#x27;0&#x27;, man) -&gt; ans  = [&quot;[5,0]&quot;, [7,0], [6,1], [8,0], [7,2]]</span><br><span class="line"> man = [5,&#x27;4&#x27;] -&gt; ans.insert(ans.begin()+&#x27;4&#x27;, man) -&gt; ans  = [[5,0], [7,0], [6,1], [8,0], &quot;[5,4]&quot;, [7,2]]</span><br><span class="line"> man = [4,&#x27;4&#x27;] -&gt; ans.insert(ans.begin()+&#x27;4&#x27;, man) -&gt; ans  = [[5,0], [7,0], [6,1], [8,0], &quot;[4,4]&quot;, [5,4], [7,2]]</span><br><span class="line"> </span><br><span class="line"> See the final ans array fullfills all the conditions.</span><br></pre></td></tr></table></figure><h2 id="Solution1-先排序-再插队"><a href="#Solution1-先排序-再插队" class="headerlink" title="Solution1 先排序 再插队"></a>Solution1 先排序 再插队</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool cmp(const vector&lt;int&gt; a,const vector&lt;int&gt; b)&#123;</span><br><span class="line">            if (a[0] &gt; b[0]) return true;</span><br><span class="line">            if (a[0] == b[0] &amp;&amp; a[1] &lt; b[1]) return true;</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123;</span><br><span class="line">        vector&lt;vector&lt;int &gt;&gt; res;</span><br><span class="line">        sort(people.begin(),people.end(),cmp);</span><br><span class="line">        for(auto val:people)&#123;</span><br><span class="line">            res.insert(res.begin()+val[1],val);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409. 最长回文串"></a><a href="https://leetcode.com/problems/longest-palindrome/">409. 最长回文串</a></h1><p>给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的回文串 。</p><p>在构造过程中，请注意 区分大小写 。比如 “Aa” 不能当做一个回文字符串。</p><p> </p><p>示例 1:</p><p>输入:s &#x3D; “abccccdd”<br>输出:7<br>解释:<br>我们可以构造的最长的回文串是”dccaccd”, 它的长度是 7。<br>示例 2:</p><p>输入:s &#x3D; “a”<br>输入:1 </p><p>提示:</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 2000<br>s 只由小写 和&#x2F;或 大写英文字母组成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Approach #1: Greedy [Accepted]</span><br><span class="line">Intuition</span><br><span class="line"></span><br><span class="line">A palindrome consists of letters with equal partners, plus possibly a unique center (without a partner). The letter i from the left has its partner i from the right. For example in &#x27;abcba&#x27;, &#x27;aa&#x27; and &#x27;bb&#x27; are partners, and &#x27;c&#x27; is a unique center.</span><br><span class="line"></span><br><span class="line">Imagine we built our palindrome. It consists of as many partnered letters as possible, plus a unique center if possible. This motivates a greedy approach.</span><br><span class="line"></span><br><span class="line">Algorithm</span><br><span class="line"></span><br><span class="line">For each letter, say it occurs v times. We know we have v // 2 * 2 letters that can be partnered for sure. For example, if we have &#x27;aaaaa&#x27;, then we could have &#x27;aaaa&#x27; partnered, which is 5 // 2 * 2 = 4 letters partnered.</span><br><span class="line"></span><br><span class="line">At the end, if there was any v % 2 == 1, then that letter could have been a unique center. Otherwise, every letter was partnered. To perform this check, we will check for v % 2 == 1 and ans % 2 == 0, the latter meaning we haven&#x27;t yet added a unique center to the answer.</span><br><span class="line"></span><br><span class="line">Complexity Analysis</span><br><span class="line"></span><br><span class="line">Time Complexity: O(N)O(N), where NN is the length of s. We need to count each letter.</span><br><span class="line"></span><br><span class="line">Space Complexity: O(1)O(1), the space for our count, as the alphabet size of s is fixed. We should also consider that in a bit complexity model, technically we need O(\log N)O(logN) bits to store the count values.</span><br></pre></td></tr></table></figure><h2 id="Solution1-7"><a href="#Solution1-7" class="headerlink" title="Solution1"></a>Solution1</h2><p><img src="https://files.mdnice.com/user/1489/15ea384d-bb95-4dbf-8d73-ba9536ff3f95.png"></p><h1 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a><a href="https://leetcode.com/problems/add-strings/">415. 字符串相加</a></h1><p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。</p><p>你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。</p><p> </p><p>示例 1：</p><p>输入：num1 &#x3D; “11”, num2 &#x3D; “123”<br>输出：”134”<br>示例 2：</p><p>输入：num1 &#x3D; “456”, num2 &#x3D; “77”<br>输出：”533”<br>示例 3：</p><p>输入：num1 &#x3D; “0”, num2 &#x3D; “0”<br>输出：”0” </p><p> </p><p>提示：</p><p>1 &lt;&#x3D; num1.length, num2.length &lt;&#x3D; 104<br>num1 和num2 都只包含数字 0-9<br>num1 和num2 都不包含任何前导零</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">26</span><br><span class="line">DBabichev&#x27;s avatar</span><br><span class="line">DBabichev</span><br><span class="line">35937</span><br><span class="line">Last Edit: August 9, 2021 10:37 PM</span><br><span class="line"></span><br><span class="line">1.2K VIEWS</span><br><span class="line"></span><br><span class="line">What we need to do in this problem is to perform usual schoolbook addition. We need to start to add numbers from the last elements and take care of carry and cases when one number has more digits that another. Imagine that we want to add two numbers: 986 and 47. Then we have the followint steps:</span><br><span class="line"></span><br><span class="line">Add 6 and 7, so we have digit 3 and carry equal to 1.</span><br><span class="line">Add 8 and 4 and 1, so we have 3 and carry equal to 1.</span><br><span class="line">Add 9 from first number, and we do not have anything from second, so we choose 0 from second. Also we have curry equal to 1, finally we have digit 0 and carry equal to 1.</span><br><span class="line">We still have carry, but no digits left, so we evaluate 0 + 0 + 1 = 1. And now we can stop, we do not have digits and we do not have carry.</span><br><span class="line">Final number we constructed is 1033.</span><br><span class="line"></span><br><span class="line">Complexity</span><br><span class="line">Time complexity is O(m + n), where m and n are lengths of our linked lists, space complexity is O(max(m, n)) if we count answer as memory or O(1) if we do not.</span><br></pre></td></tr></table></figure><h2 id="Solution1-8"><a href="#Solution1-8" class="headerlink" title="Solution1"></a>Solution1</h2><p><img src="https://files.mdnice.com/user/1489/50bd7865-2516-4f4d-bdf7-4de2f00cdf80.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string addStrings(string num1, string num2) &#123;</span><br><span class="line">        int i = num1.length() - 1, j = num2.length() - 1, add = 0;</span><br><span class="line">        string ans = &quot;&quot;;</span><br><span class="line">        while (i &gt;= 0 || j &gt;= 0 || add != 0) &#123;</span><br><span class="line">            int x = i &gt;= 0 ? num1[i] - &#x27;0&#x27; : 0;</span><br><span class="line">            int y = j &gt;= 0 ? num2[j] - &#x27;0&#x27; : 0;</span><br><span class="line">            int result = x + y + add;</span><br><span class="line">            ans.push_back(&#x27;0&#x27; + result % 10);</span><br><span class="line">            add = result / 10;</span><br><span class="line">            i -= 1;</span><br><span class="line">            j -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        // 计算完以后的答案需要翻转过来</span><br><span class="line">        reverse(ans.begin(), ans.end());</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/620df582-d9ad-49fd-a069-2b6bb56fa29c.png"></p><h1 id="求1-2-…n"><a href="#求1-2-…n" class="headerlink" title="求1+2+…n"></a><a href="https://leetcode.cn/problems/qiu-12n-lcof">求1+2+…n</a></h1><p><img src="https://files.mdnice.com/user/1489/a39d57a7-49a2-4353-a4a4-68361420e23e.jpg"></p><p><img src="https://files.mdnice.com/user/1489/19234557-e889-43c9-84a6-e55b36d24aec.jpg"></p><h1 id="求滑动窗口的最大值"><a href="#求滑动窗口的最大值" class="headerlink" title="求滑动窗口的最大值"></a><a href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof">求滑动窗口的最大值</a></h1><p><img src="https://files.mdnice.com/user/1489/15a63a92-7b41-4707-a824-964718554f58.jpg"><br><img src="https://files.mdnice.com/user/1489/91669611-5065-4e62-9bcc-ba187bda8268.jpg"></p><h1 id="扑克牌中的顺子"><a href="#扑克牌中的顺子" class="headerlink" title="扑克牌中的顺子"></a><a href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof">扑克牌中的顺子</a></h1><p><img src="https://files.mdnice.com/user/1489/297b7397-78fa-402f-9848-36a3e6baeafc.jpg"></p><p><img src="https://files.mdnice.com/user/1489/ff5136fb-3f4c-4caa-900f-e4d562a63e80.jpg"></p><h1 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof">左旋转字符串</a></h1><p><img src="https://files.mdnice.com/user/1489/e329b323-7662-4aa8-bef3-0ecf293c49de.jpg"></p><h1 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a><a href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof">最长不含重复字符的子字符串</a></h1><p><img src="https://files.mdnice.com/user/1489/f01b0278-174b-461f-8ac7-191f13995a3b.jpg"></p><p><img src="https://files.mdnice.com/user/1489/bac74319-f5dc-4b47-8f63-1cc381458756.jpg"></p><h1 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a><a href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof">滑动窗口的最大值</a></h1><p><img src="https://files.mdnice.com/user/1489/4a32da04-9232-437a-98df-26863d85179e.jpg"></p><h1 id="和为s连续正数序列"><a href="#和为s连续正数序列" class="headerlink" title="和为s连续正数序列"></a><a href="https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof">和为s连续正数序列</a></h1><p><img src="https://files.mdnice.com/user/1489/aee56655-c266-45ae-aeda-2cb3e1573c71.jpg"><br><img src="https://files.mdnice.com/user/1489/6713148f-44c9-472b-9956-90bcad147d34.jpg"></p><p><img src="https://files.mdnice.com/user/1489/e9aeb4c3-d429-4dbd-ad0a-9d7ae18c6b50.jpg"><br><img src="https://files.mdnice.com/user/1489/9011acac-108a-45de-a940-7dc0cbe33807.jpg"></p><h1 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a><a href="https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof">翻转单词顺序</a></h1><p><img src="https://files.mdnice.com/user/1489/94ef5c0b-92a5-437e-8920-e808dbf6cc4d.jpg"></p><p><img src="https://files.mdnice.com/user/1489/433263e7-9556-438c-8f3d-c260225dbf1d.jpg"></p><h1 id="左旋转字符串-1"><a href="#左旋转字符串-1" class="headerlink" title="左旋转字符串"></a><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof">左旋转字符串</a></h1><p><img src="https://files.mdnice.com/user/1489/4614ddda-961b-4eed-8ee4-cc50ffb25935.jpg"></p><h1 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a><a href="https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof">和为s的两个数字</a></h1><p><img src="https://files.mdnice.com/user/1489/50faf577-63ab-4b9c-bd6f-59ed0c2ce516.jpg"></p><p><img src="https://files.mdnice.com/user/1489/c918777d-7c9e-42a2-95fb-576b4618efd1.jpg"></p><h1 id="数组中出现次数超过一半的次数"><a href="#数组中出现次数超过一半的次数" class="headerlink" title="数组中出现次数超过一半的次数"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof">数组中出现次数超过一半的次数</a></h1><p><img src="https://files.mdnice.com/user/1489/6afab0e0-5928-483e-a44d-bd6fa19e36dd.jpg"></p><p><img src="https://files.mdnice.com/user/1489/63b82d8b-42d1-4360-b5e7-224ad1ccb987.jpg"></p><h1 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a><a href="https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof">第一个只出现一次的字符</a></h1><p><img src="https://files.mdnice.com/user/1489/7134c1a6-a705-41e0-b994-d9df133ffd06.jpg"></p><p><img src="https://files.mdnice.com/user/1489/a5fa6552-4f5e-434b-a31e-38bf09a2cdab.jpg"></p><p><img src="https://files.mdnice.com/user/1489/8accb7cf-0178-49e7-a907-44da8c41ca8e.jpg"></p><p><img src="https://files.mdnice.com/user/1489/5e428394-3fd2-480c-9c7e-2bd099118a10.jpg"></p><h1 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a><a href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof">栈的压入、弹出序列</a></h1><p><img src="https://files.mdnice.com/user/1489/56115b51-a2ce-4bca-8a39-7c4ac2e070e6.jpg"></p><h1 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a><a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof">包含min函数的栈</a></h1><p><img src="https://files.mdnice.com/user/1489/e92fd7e3-d208-4978-bdf6-fd51492fbeb6.jpg"></p><h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list">反转链表</a></h1><p><img src="https://files.mdnice.com/user/1489/6d46c580-ca37-4f4d-89cb-b250a209b90a.jpg"></p><h1 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a><a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof">数值的整数次方</a></h1><p><img src="https://files.mdnice.com/user/1489/52bf9fe5-269b-46c3-8f40-dac13d75ecdb.jpg"></p><p><img src="https://files.mdnice.com/user/1489/4254d052-fced-468a-a06b-80a9c388b798.jpg"></p><p><img src="https://files.mdnice.com/user/1489/ba0409e5-fa6d-4d7e-9292-f5be87a8fd13.jpg"></p><h1 id="删除链表的节点"><a href="#删除链表的节点" class="headerlink" title="删除链表的节点"></a><a href="https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof">删除链表的节点</a></h1><p><img src="https://files.mdnice.com/user/1489/f7b719a0-e068-42c3-b6f8-6f20301194df.jpg"></p><h1 id="链表的倒数第K个节点"><a href="#链表的倒数第K个节点" class="headerlink" title="链表的倒数第K个节点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list">链表的倒数第K个节点</a></h1><p><img src="https://files.mdnice.com/user/1489/4ef04808-5bea-4610-9567-9fe0c028d63c.jpg"></p><p><img src="https://files.mdnice.com/user/1489/bad95909-e879-4f70-97f2-f9d01d7f5d22.jpg"></p><h1 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a><a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof">顺时针打印矩阵</a></h1><p><img src="https://files.mdnice.com/user/1489/ec7c4226-3a47-4a54-bfdc-740e523ceaac.jpg"></p><p><img src="https://files.mdnice.com/user/1489/06c76a5a-8e15-4971-9fa9-4702abdf8348.jpg"></p><p><img src="https://files.mdnice.com/user/1489/3bbe711c-cbeb-459c-ad4b-e00d7b508cb4.jpg"></p><h1 id="调整数组顺序使得奇数位于偶数前"><a href="#调整数组顺序使得奇数位于偶数前" class="headerlink" title="调整数组顺序使得奇数位于偶数前"></a><a href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof">调整数组顺序使得奇数位于偶数前</a></h1><p><img src="https://files.mdnice.com/user/1489/67ec0ae6-0a3c-4dc0-bc54-2f6bfa7b6d5d.jpg"></p><h1 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a><a href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof">合并两个排序的链表</a></h1><p><img src="https://files.mdnice.com/user/1489/5ad4608e-ae3f-4ea6-abc5-01ccba98b8bd.jpg"></p><p><img src="https://files.mdnice.com/user/1489/bdc5a0f5-514e-4994-97ae-4aa2b468d4a1.jpg"></p><h1 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a><a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof">从尾到头打印链表</a></h1><p><img src="https://files.mdnice.com/user/1489/e7287e83-0a0f-4c88-97a9-70c01dd6b61a.jpg"></p><h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof">替换空格</a></h1><p><img src="https://files.mdnice.com/user/1489/12f83946-efa1-4c45-aefb-cf2385b1e4e0.jpg"><br><img src="https://files.mdnice.com/user/1489/014f2c8d-e879-4228-a24e-3c902a6366cf.jpg"><br><img src="https://files.mdnice.com/user/1489/aa420d60-feec-41e4-b141-ad2d40924901.jpg"></p><h1 id="重构字符串"><a href="#重构字符串" class="headerlink" title="重构字符串"></a><a href="https://leetcode-cn.cn/problems/reorganize-string/">重构字符串</a></h1><p><img src="https://files.mdnice.com/user/1489/a0be23ac-6081-411c-96cb-9f2c79fcabb1.jpg"><br><img src="https://files.mdnice.com/user/1489/7c65b823-1c0b-4d4f-8a13-554fb12cf314.jpg"></p><h1 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof">数组中重复的数字</a></h1><p><img src="https://files.mdnice.com/user/1489/e648c0ad-b283-4b66-90d7-4bc23329dd5a.jpg"></p><p><img src="https://files.mdnice.com/user/1489/64f8d26f-c230-49c3-b398-df245f234505.jpg"></p><p><img src="https://files.mdnice.com/user/1489/92daf8e2-3349-475e-af48-4ad83be8a41e.jpg"><br><img src="https://files.mdnice.com/user/1489/174e0c93-01d3-41d0-8a49-c894760318e3.jpg"></p><h1 id="自除数"><a href="#自除数" class="headerlink" title="自除数"></a><a href="https://leetcode.com/problems/self-dividing-numbers/">自除数</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Approach #1: Brute Force [Accepted]</span><br><span class="line">Intuition and Algorithm</span><br><span class="line"></span><br><span class="line">For each number in the given range, we will directly test if that number is self-dividing.</span><br><span class="line"></span><br><span class="line">By definition, we want to test each whether each digit is non-zero and divides the number. For example, with 128, we want to test d != 0 &amp;&amp; 128 % d == 0 for d = 1, 2, 8. To do that, we need to iterate over each digit of the number.</span><br><span class="line"></span><br><span class="line">A straightforward approach to that problem would be to convert the number into a character array (string in Python), and then convert back to integer to perform the modulo operation when checking n % d == 0.</span><br><span class="line"></span><br><span class="line">We could also continually divide the number by 10 and peek at the last digit. That is shown as a variation in a comment.</span><br><span class="line"></span><br><span class="line">Complexity Analysis</span><br><span class="line"></span><br><span class="line">Time Complexity: O(D)O(D), where DD is the number of integers in the range [L, R][L,R], and assuming \log(R)log(R) is bounded. (In general, the complexity would be O(D\log R)O(DlogR).)</span><br><span class="line"></span><br><span class="line">Space Complexity: O(D)O(D), the length of the answer.</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/31bcba36-c886-412a-a41d-069f5cd29713.jpg"></p><h1 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a><a href="https://leetcode.com/problems/partition-labels/">划分字母区间</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Approach 1: Greedy</span><br><span class="line">Intuition</span><br><span class="line"></span><br><span class="line">Let&#x27;s try to repeatedly choose the smallest left-justified partition. Consider the first label, say it&#x27;s &#x27;a&#x27;. The first partition must include it, and also the last occurrence of &#x27;a&#x27;. However, between those two occurrences of &#x27;a&#x27;, there could be other labels that make the minimum size of this partition bigger. For example, in &quot;abccaddbeffe&quot;, the minimum first partition is &quot;abccaddb&quot;. This gives us the idea for the algorithm: For each letter encountered, process the last occurrence of that letter, extending the current partition [anchor, j] appropriately.</span><br><span class="line"></span><br><span class="line">Algorithm</span><br><span class="line"></span><br><span class="line">We need an array last[char] -&gt; index of S where char occurs last. Then, let anchor and j be the start and end of the current partition. If we are at a label that occurs last at some index after j, we&#x27;ll extend the partition j = last[c]. If we are at the end of the partition (i == j) then we&#x27;ll append a partition size to our answer, and set the start of our new partition to i+1.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Complexity Analysis</span><br><span class="line"></span><br><span class="line">Time Complexity: O(N)O(N), where NN is the length of SS.</span><br><span class="line"></span><br><span class="line">Space Complexity: O(1)O(1) to keep data structure last of not more than 26 characters.</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/81edb05f-482a-48d2-a709-9c012a5a148c.jpg"><br><img src="https://files.mdnice.com/user/1489/56fac4ed-d7a0-42b3-b63c-5ae4151b4d95.jpg"></p><h1 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a><a href="https://leetcode.com/problems/daily-temperatures">每日温度</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">❌ Solution - I (Brute-Force)</span><br><span class="line"></span><br><span class="line">Let&#x27;s see how we can solve this using brute-force approach.</span><br><span class="line"></span><br><span class="line">For each index i, we can just iterate over the array till we either find the the 1st index j such that T[j] &gt; T[i] or reach the end of array.</span><br><span class="line">If we find j such that T[j] &gt; T[i], we have ans[i] = j-i.</span><br><span class="line">Otherwise, ans[i] = 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Time Complexity : O(N2), where N is the number of elements in the input array T. In the worst case, we iterate till the end of array for each index i. So, the total number of iterations required are N-1 + N-2 + N-3 +...+ 1 = N(N-1)/2 which is equivalent to O(N2)</span><br><span class="line">Space Complexity : O(1), ignoring the space required by the output array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">✔️ Solution - II (Decreasing Monotonic Stack)</span><br><span class="line"></span><br><span class="line">In the above solution, we can see that in the worst case, we are repeatedly iterating till the end of array either to find the next greater element at the very end or not finding it at all. This is redundant. We can optimize the above approach by observing that multiple elements can share a common warmer day. For eg. Consider [4,3,2,1,5]. In the brute-force, we would have iterated till 5th element in every case and assigned ans[i] as difference between the indices. However, we see that all elments share 5 as the next warmer day.</span><br><span class="line"></span><br><span class="line">Thus, the pattern we see is that we iterate forward till we find a warmer day and that day will be the answer for all elements before it that are cooler (and not found a warmer day). Thus, we can maintain a stack consisting of indices of days which haven&#x27;t found a warmer day. The temperature at these indices will be in decreasing order since we are only storing days that haven&#x27;t found a warmer next day and hence it is known as decreasing monotonic stack. Whenever we find a current day cur which is warmer, we check elements of stack and assign them the difference of indices for all those elements which have temperature of corresponding day less than T[cur].</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Thus, the algorithm can be summarized as -</span><br><span class="line"></span><br><span class="line">Initialize an empty stack s and ans array of size N all initialized to 0s.</span><br><span class="line">Iterate over T from the start</span><br><span class="line">For each current day cur, check if today&#x27;s temperature T[cur] is warmer than values corresponding to previous days&#x27; indices stored in stack (T[s.top()]). Assign answer for all elements of stack for whom current day&#x27;s temperature is warmer (T[cur] &gt; T[s.top()]) and pop them off the stack.</span><br><span class="line">Push cur onto the stack denoting that we need to find warmer next day for cur.</span><br><span class="line">All the elements present in the stack at end don&#x27;t have a next greater element. We don&#x27;t have to worry about them since ans is already initialized to 0. Thus, we can directly return ans.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Time Complexity : O(N), In the worst case, we require O(2*N) ~ O(N) iterations.</span><br><span class="line">Space Complexity : O(N), In the worst case, we may have decreasing elements in T and stack will store all N indices in it</span><br><span class="line"></span><br><span class="line">✔️ Solution - III (Monotonic Stack - 2)</span><br><span class="line"></span><br><span class="line">Another way of modelling the problem in terms of monotonic stack that some may find more intuitive is by starting from the end of the array. We again maintain a monotonic stack in this case as well which is similar to above appraoch, the only change is just that we start from the end.</span><br><span class="line"></span><br><span class="line">This will again allow us to find the next warmer element for each index just by looking through the stack. Since we are maintaining a sorted stack (increasing from top-to-bottom), we know that the first element that we find in stack for curth day such that T[s.top()] &gt; T[cur], will be next warmer day required for that element.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In the above image, we start from the end and each time assign next warmer day to be top of stack element. In the 1st approach, we instead started from beginning and only assigned next warmer day/s at once once we find a warmer day than all preciding elements. Both approach should work just fine.</span><br><span class="line"></span><br><span class="line">The algorithm can be summarized as -</span><br><span class="line"></span><br><span class="line">Initialize an empty stack s and ans array of size N all initialized to 0s.</span><br><span class="line">Iterate over T from the end.</span><br><span class="line">For each current day cur, pop values corresponding from stack that have temperature(T[s.top()]) lower than today&#x27;s temperature T[cur], i.e, T[s.top()] &lt;= T[cur]. This popping is done because these elements are cooler than T[cur] and occur later on than cur. Thus, they will never be a potential answer for elements on the left.</span><br><span class="line">Now that all elements lower than T[cur] have been popped off, stack s is either empty or has some element warmer than cur.</span><br><span class="line">If stack is empty, assign ans[cur] = 0 because no next warmer element exists for cur.</span><br><span class="line">Otherwise, assign ans[cur] = s.top()-cur, the difference between indices of next warmer element and cur.</span><br><span class="line">Then, Push cur onto the stack since it has potential to be next closest warmer day for remaining elements on left of T.</span><br><span class="line">Finally, return ans.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/979f2ad7-bb3d-4d06-8f1e-56c11921e810.jpg"><br><img src="https://files.mdnice.com/user/1489/eee786ba-73e5-4de7-9cc8-b82b80c56364.jpg"><br><img src="https://files.mdnice.com/user/1489/f5e179e8-5c9b-40e5-b110-75d3cb245491.jpg"></p><h1 id="1比特与2比特字符"><a href="#1比特与2比特字符" class="headerlink" title="1比特与2比特字符"></a><a href="https://leetcode.com/problems/1-bit-and-2-bit-characters/">1比特与2比特字符</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Solution Approach:</span><br><span class="line"></span><br><span class="line">Traverse the array from 0 to n-2 (leaving the last character).</span><br><span class="line">Now if current char is 0, increment i by 1.</span><br><span class="line">Else increment by 2 as 1 is always followed by either 1 or 0.</span><br><span class="line">After the loop ends check if i is pointing to last char (i.e. n-1) or before that return true, else false.</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/c8d08da7-0629-49fc-b47b-55d8f9ec7c71.jpg"><br><img src="https://files.mdnice.com/user/1489/2d61a58f-d344-424e-8716-5ab9c5653f6e.jpg"></p><h1 id="最短无序连续子数组"><a href="#最短无序连续子数组" class="headerlink" title="最短无序连续子数组"></a><a href="https://leetcode.com/problems/shortest-unsorted-continuous-subarray/">最短无序连续子数组</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Approach 1: Brute Force</span><br><span class="line">Algorithm</span><br><span class="line"></span><br><span class="line">In the brute force approach, we consider every possible subarray that can be formed from the given array numsnums. For every subarray nums[i:j]nums[i:j] considered, we need to check whether this is the smallest unsorted subarray or not. Thus, for every such subarray considered, we find out the maximum and minimum values lying in that subarray given by maxmax and minmin respectively.</span><br><span class="line"></span><br><span class="line">If the subarrays nums[0:i-1]nums[0:i−1] and nums[j:n-1]nums[j:n−1] are correctly sorted, then only nums[i:j]nums[i:j] could be the required subrray. Further, the elements in nums[0:i-1]nums[0:i−1] all need to be lesser than the minmin for satisfying the required condition. Similarly, all the elements in nums[j:n-1]nums[j:n−1] need to be larger than maxmax. We check for these conditions for every possible ii and jj selected.</span><br><span class="line"></span><br><span class="line">Further, we also need to check if nums[0:i-1]nums[0:i−1] and nums[j:n-1]nums[j:n−1] are sorted correctly. If all the above conditions are satisfied, we determine the length of the unsorted subarray as j-ij−i. We do the same process for every subarray chosen and determine the length of the smallest unsorted subarray found.</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/e5f2d5b8-6440-4910-9eb2-20848cebe369.jpg"></p><p><img src="https://files.mdnice.com/user/1489/08f457d6-d730-4b87-bff8-e9211b8332bd.jpg"></p><p><img src="https://files.mdnice.com/user/1489/86763d3e-dcd7-46e9-bbe3-d0b14813dc5b.jpg"></p><p><img src="https://files.mdnice.com/user/1489/11abbaeb-d616-4866-9bd8-029b298f1f97.jpg"></p><p><img src="https://files.mdnice.com/user/1489/074c12a8-524a-4f31-8abd-878e9aca33be.jpg"></p><p><img src="https://files.mdnice.com/user/1489/c5bfa348-f61c-44be-b5a6-797e736ece90.jpg"></p><p><img src="https://files.mdnice.com/user/1489/90f1cfd8-35b9-44aa-8281-b9fc3097c54a.jpg"></p><h1 id="找到所有数组中消失的数字"><a href="#找到所有数组中消失的数字" class="headerlink" title="找到所有数组中消失的数字"></a><a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array">找到所有数组中消失的数字</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">❌ Solution - I (Brute-Force)</span><br><span class="line"></span><br><span class="line">A brute-force way to solve this question is to take each number in range [1, n] and push it into ans array if it doesn&#x27;t occur in nums.</span><br><span class="line"></span><br><span class="line">C++</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        for(int i = 1; i &lt;= size(nums); i++) </span><br><span class="line">            if(find(begin(nums), end(nums), i) == end(nums))  // linear search in nums for each i</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Python</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def findDisappearedNumbers(self, nums):        </span><br><span class="line">        return [i for i in range(1, len(nums)+1) if i not in nums]</span><br><span class="line">Time Complexity : O(n2), we iterate over the range [1, n] which takes O(n) and for each iteration, we check if that element occurs in nums which takes another O(n) giving total time of O(n2)</span><br><span class="line">Space Complexity : O(1), excluding the space required for the output vector, we only use constant extra space. The output space is generally not included in the space complexity.</span><br><span class="line"></span><br><span class="line">✔️ Solution - II (Sort &amp; Binary-Search)</span><br><span class="line"></span><br><span class="line">Instead of linear-searching if every element in range [1, n] is present in nums or not, we could instead sort nums and then apply binary-search every time. If the element is not found in nums, we include it in ans.</span><br><span class="line"></span><br><span class="line">C++</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        sort(begin(nums), end(nums));</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        for(int i = 1; i &lt;= size(nums); i++) </span><br><span class="line">            if(!binary_search(begin(nums), end(nums), i))   // binary search in nums for each i</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Python</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def findDisappearedNumbers(self, nums):</span><br><span class="line">        nums.sort()</span><br><span class="line">        return [i for i in range(1, len(nums)+1) if nums[bisect_left(nums, i)%len(nums)] != i]</span><br><span class="line">Time Complexity : O(nlogn), we iterate over the range [1, n] which takes O(n) and for each iteration, we check if that element occurs in nums using binary search which takes another O(logn) giving a total time of O(nlogn)</span><br><span class="line">Space Complexity : O(sort), the only extra space required is the one used in internal sorting algorithm. Ignoring that space, we can say it to be O(1)</span><br><span class="line"></span><br><span class="line">✔️ Solution - III (HashSet)</span><br><span class="line"></span><br><span class="line">We can do even better if we just insert every element from nums into a hashset and then iterate over the range [1, n] and only add those elements to ans and are not present in hashset.</span><br><span class="line"></span><br><span class="line">C++</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; s(begin(nums), end(nums));   // insert every nums[i] in hashset</span><br><span class="line">        vector&lt;int&gt; ans(size(nums) - size(s));</span><br><span class="line">        for(int i = 1, j = 0; i &lt;= size(nums); i++)  </span><br><span class="line">            if(!s.count(i)) ans[j++] = i;               // add all elements not found in hashset to ans</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Python</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def findDisappearedNumbers(self, nums):</span><br><span class="line">        s = set(nums)</span><br><span class="line">        return [i for i in range(1, len(nums)+1) if i not in s]</span><br><span class="line">Time Complexity : O(n), we require O(n) time to insert all elements into hashset and another O(n) time to iterate over range and insert elements not present in hashset into ans, thus giving a total time of O(n).</span><br><span class="line">Space Complexity : O(n), required to maintain the hashset.</span><br><span class="line"></span><br><span class="line">✔️ Solution - IV (Boolean array)</span><br><span class="line"></span><br><span class="line">We can slightly optimize previous approach by using an boolean array of size n instead of hashset, since the range is known to be [1, n]</span><br><span class="line"></span><br><span class="line">C++</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;bool&gt; seen(size(nums)+1);</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        for(auto c : nums) seen[c] = true;</span><br><span class="line">        for(int i = 1; i &lt;= size(nums); i++)</span><br><span class="line">            if(!seen[i]) ans.push_back(i);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Solution:</span><br><span class="line">    def findDisappearedNumbers(self, nums):        </span><br><span class="line">        ans, seen = [], [False]*(len(nums)+1)</span><br><span class="line">        for c in nums: seen[c] = True</span><br><span class="line">        for i in range(1, len(nums)+1):</span><br><span class="line">            if not seen[i]:</span><br><span class="line">                ans.append(i)</span><br><span class="line">        return ans</span><br><span class="line">Time Complexity : O(n)</span><br><span class="line">Space Complexity : O(n)</span><br><span class="line"></span><br><span class="line">✔️ Solution - V (Placing Elements at Correct Index - Space Optimized)</span><br><span class="line"></span><br><span class="line">This solution involves placing all possible elements at their right index place. By that, I mean every possible index i should be occupied by correct element i+1, i.e, num[i] = i+1. This allows us to check if a number j from range [1, n] exists in nums or not.</span><br><span class="line"></span><br><span class="line">The numbers j will be present in nums only if the number j itself is present at nums[j-1] which is its correct index place.</span><br><span class="line">The numbers j&#x27; that are not present in nums wont have correct element (which is j&#x27; itself) at its correct index place nums[j&#x27;-1].</span><br><span class="line">The numbers j that are not in nums wont have correct element at their right index place (nums[i-1]) and that index place would be occupied by some other element.</span><br><span class="line"></span><br><span class="line">Now, Can we do this linearly using constant space? Yes!</span><br><span class="line"></span><br><span class="line">We will iterate over each element of nums.</span><br><span class="line">For each element c, if the correct index place of c, i.e, nums[c-1] is not occupied by c, then we place c at its correct index place. But we dont want to lose number which was already present at nums[c-1]. So we swap it instead so the number at nums[c-1] occupies current element c &amp; vice-versa.</span><br><span class="line">We placed original current element c at its correct place but now we have another element as c for which we need to place it at its correct place. So, repeat above step till c is at its correct place in nums.</span><br><span class="line">The steps 2 &amp; 3 are repeated for all elements of nums so that we ensure every possible index is occupied by correct element. At last, the index not occupied by correct element are once which dont occur in nums.</span><br><span class="line">Let nums = [4,3,2,7,8,2,3,1]. The steps take place as -</span><br><span class="line"></span><br><span class="line">[7,3,2,4,8,2,3,1]</span><br><span class="line">[3,3,2,4,8,2,7,1]</span><br><span class="line">[2,3,3,4,8,2,7,1]</span><br><span class="line">[3,2,3,4,8,2,7,1]</span><br><span class="line">[3,2,3,4,1,2,7,8]</span><br><span class="line">[1,2,3,4,3,2,7,8]</span><br><span class="line"></span><br><span class="line">Index 4 &amp; 5 are not occupied by their correct elements meaning the elements corresponding to those indices are missing</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/d1fcc62e-aeaa-4ccf-b224-ab724f90ae37.jpg"></p><h1 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a><a href="https://leetcode.com/problems/assign-cookies">分发饼干</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sort greed array and cookie array. Then simply walk both arrays and match cookie to greed if greed is less than cookie.</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/d3a4ed92-b21e-4237-87cd-5bfb2bee545e.jpg"></p><h1 id="找到所有数组中消失的数字-1"><a href="#找到所有数组中消失的数字-1" class="headerlink" title="找到所有数组中消失的数字"></a><a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array">找到所有数组中消失的数字</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1st for loop: for each value x, negate the element at xth position</span><br><span class="line">2nd for loop: get all the positions that has a positive element. These are the missing values to return.</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line"></span><br><span class="line">        // 1st for loop: nums = [4,3,2,7,8,2,3,1]</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)  // each iteration:</span><br><span class="line">        &#123;                                     // i = 0              i = 1               i = 2                ... i = 7</span><br><span class="line">            int temp = nums[i];               // temp = 4           temp = 3            temp = -2            ... temp = -1</span><br><span class="line">            temp = (temp &gt; 0) ? temp : -temp; // temp = 4           temp = 3            temp = 2             ... temp = 1</span><br><span class="line">            if(nums[temp-1] &gt; 0)              // nums[3] &gt; 0        nums[2] &gt; 0         nums[1] &gt; 0          ... nums[0] &gt; 0</span><br><span class="line">                nums[temp-1] *= -1;           // [4,3,2,-7,8,2,3,1] [4,3,-2,-7,8,2,3,1] [4,-3,-2,-7,8,2,3,1] ... [-4,-3,-2,-7,8,2,-3,-1]</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">// 2nd for loop: nums = [-4,-3,-2,-7,8,2,-3,-1]</span><br><span class="line">        for(int i = 0; i &lt; nums.size(); i++)</span><br><span class="line">            if(nums[i] &gt; 0)         // the 4th &amp; 5th indexes are positive</span><br><span class="line">                ans.push_back(i+1); // ans = [5,6]</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/0f99a883-da18-46ca-9985-d7ba4a46092d.jpg"></p><h1 id="最接近的三数之和"><a href="#最接近的三数之和" class="headerlink" title="最接近的三数之和"></a><a href="https://leetcode.com/problems/3sum-closest/">最接近的三数之和</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        //BRUTE FORCE APPROACH...(but a little improved)</span><br><span class="line">        //Applying two pointers on the sorted array for target-currnumber</span><br><span class="line">        //time complexity O(N^2)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        int ans; //...Our Final sum(of all three integers) will be stored here</span><br><span class="line">        int prevDiff = INT_MAX; //...this will be the closest difference between target and the sum we calculated...this will be changed each time it is compared with a sum that is found to be lower than the previous closest sum</span><br><span class="line">        int temp = target;</span><br><span class="line">        sort(nums.begin(),nums.end()); //sorting the array inorder to carry out our two pointer approach</span><br><span class="line">        for(int i =0;i&lt;nums.size()-2;i++)&#123;  //loop till nums.size()-2 because we always play with three pointers two of which we don&#x27;t want to get out of the array</span><br><span class="line">                temp = target-nums[i]; //reducing the target to target-curr value(this curr value is one of the three integers we take into consideration)</span><br><span class="line">                int start = i+1;        // starting from one index ahead of curr index</span><br><span class="line">                int end = nums.size()-1;</span><br><span class="line">                int x;                  // for calculating and comparing with the new target value(temp)...this is similar as two sum problem..</span><br><span class="line">            </span><br><span class="line">        // so the idea here is to get the sum of two integers as closest as (or equal to ) the new target(temp) which is done by </span><br><span class="line">        // keeping two pointers and changing their positions so as to get as close as possible to our new target value.</span><br><span class="line">                while(start&lt;end)&#123;       </span><br><span class="line">                     x = nums[start]+nums[end];</span><br><span class="line">                    if(x==temp) break;      //breaking here ... cuz can&#x27;t get any closer than the TARGET ITSELF!</span><br><span class="line">                    if(x&lt;temp) start++;     //incase the sum is lower we shift start to right side so as to increase sum and get closer to our target value(temp)</span><br><span class="line">                    else end--; </span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            //now here after this traversal we have obtained a value of sum of three integers as close to temp as possible</span><br><span class="line">            //this value is x + nums[i]</span><br><span class="line">            //we take the difference of target value (original) with this sum and compare this difference with previous difference(because we need to be as close to target as possible right!)</span><br><span class="line">            //if difference is less than prev diff we update our ans and prevDifference gets equal to this difference value..</span><br><span class="line">                if(abs(target-(x+nums[i]))&lt;prevDiff)&#123;   </span><br><span class="line">                    ans = x+nums[i];</span><br><span class="line">                    prevDiff = abs(target-(x+nums[i]));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return ans; //hooray!</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/d5a6910c-41c0-471f-b8c3-3b79ae583be8.jpg"><br><img src="https://files.mdnice.com/user/1489/252bc915-1dc7-43e6-9498-e75607502c81.jpg"></p><h1 id="四数相加"><a href="#四数相加" class="headerlink" title="四数相加||"></a><a href="https://leetcode.com/problems/4sum-ii/">四数相加||</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123;</span><br><span class="line">        </span><br><span class="line">        int count=0;</span><br><span class="line">        unordered_map&lt;int,int&gt; mp;</span><br><span class="line">        </span><br><span class="line">        /* Philosophy</span><br><span class="line">        </span><br><span class="line">        1. I know that Addtion have two parts in it  EG (a +b , Part 1 - a, Part 2- b.</span><br><span class="line">        2.So, Lets make and find this dependency factors. How can I do it?</span><br><span class="line">        </span><br><span class="line">        3. If there are 4 Sum. it means 2 sums is going to Part 1 and another 2 gonna be Part 2 which are dependent on Part 1 for 0 resultant.</span><br><span class="line">        </span><br><span class="line">        4. I gonna store summation 2 nums1 in a FREQUENCY Hashmap.</span><br><span class="line">        </span><br><span class="line">        5. Then I traverse 2nd part of the summation (rest to nums) and keep checking that do (0-it1-it2) is exist in map . </span><br><span class="line">       </span><br><span class="line">        6. If yes, the add the frequency of Part1 int COUNT var.</span><br><span class="line">        </span><br><span class="line">        7. return count;</span><br><span class="line">        */</span><br><span class="line">        </span><br><span class="line">        //Traversing Part 1</span><br><span class="line">        for (auto &amp;it1: nums1)</span><br><span class="line">            for (auto &amp;it2:nums2)</span><br><span class="line">                mp[it1+it2]++; </span><br><span class="line">        </span><br><span class="line">        // Traversing Part 2</span><br><span class="line">        for(auto &amp;it3: nums3)</span><br><span class="line">            for(auto &amp;it4:nums4)</span><br><span class="line">               if(mp.count(0-it3-it4)) count+=mp[0-it3-it4];</span><br><span class="line">        </span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/81e7a78b-6e9b-4804-b4bc-f32031fdd571.jpg"></p><h1 id="分治-最长公共前缀"><a href="#分治-最长公共前缀" class="headerlink" title="分治:最长公共前缀"></a><a href="https://leetcode.com/problems/longest-common-prefix/">分治:最长公共前缀</a></h1><p><img src="https://files.mdnice.com/user/1489/30ad2757-a9f8-4d82-8c7f-c651fdf864de.png"></p><p><img src="https://files.mdnice.com/user/1489/c3f4eaeb-9f8f-4265-9009-1a4b808cb5e6.png"></p><p><img src="https://files.mdnice.com/user/1489/a1c451b7-b2eb-4545-b354-c7c37a1ab8e0.jpg"><br><img src="https://files.mdnice.com/user/1489/d7e4710d-6ea2-41b2-9aba-1dca85dcd9d3.jpg"><br><img src="https://files.mdnice.com/user/1489/6f172e79-74e2-452d-ab77-a7149388bb74.jpg"></p><h1 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a><a href="https://leetcode.com/problems/reverse-integer/">整数反转</a></h1><p><img src="https://files.mdnice.com/user/1489/98e33881-29f0-4462-9991-2012f94ae9f1.png"></p><p><img src="https://files.mdnice.com/user/1489/d5945a88-399a-4b88-a5b5-20e6fe7e7e99.jpg"></p><p><img src="https://files.mdnice.com/user/1489/f8c0d53a-9c66-4d00-857c-cab81d087035.jpg"></p><p><img src="https://files.mdnice.com/user/1489/0e795a17-567a-42d3-a1bb-677b12f407e8.jpg"></p><h1 id="盛水最多的容器"><a href="#盛水最多的容器" class="headerlink" title="盛水最多的容器"></a><a href="https://leetcode.com/problems/container-with-most-water/">盛水最多的容器</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Explanation :</span><br><span class="line"></span><br><span class="line">Intuition : Volume/Area depends upon the bar having minimum height</span><br><span class="line"></span><br><span class="line">Now suppose, height[i] &lt; height[j], in this case we can only store water with area height[i]*(j-i), now there is chance there is a greater value of i present in array so increment i</span><br><span class="line">Vice-vera height[i]&gt;height[j], here area would be height[j]*(j-i), in this case there&#x27;s chance a greater value of j is present in array so decrement j</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/152a336e-c600-4937-850c-d0f1fd5a4c4f.jpg"></p><h1 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters">无重复字符的最长子串</a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A solution for beginners, which is straightforward, easy to understand, without too many complications and room to optimize once you understand the basic premise of the question. Hope this helps!</span><br><span class="line"></span><br><span class="line">Time Complexity: O(n)</span><br><span class="line">Space Complexity: O(min of a,b) for the unordered set. a, is the upper bound of the space complexity.</span><br><span class="line">Where a: Size of the string</span><br><span class="line">b: Size of the number of characters in the character-set</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/f075ebdf-3df9-4229-be81-efdca44423d4.jpg"></p><p><img src="https://files.mdnice.com/user/1489/55e84e02-f0b6-4e27-ace1-28039e20c7ef.jpg"></p><p><img src="https://files.mdnice.com/user/1489/7b8def0f-7d26-40fb-8936-24236b14e7af.jpg"></p>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="Leetcode" scheme="http://example.com/categories/Leetcode/"/>
    
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Linux Command —— Wildcard</title>
    <link href="http://example.com/2022/08/19/Linux-Command-Wildcard/"/>
    <id>http://example.com/2022/08/19/Linux-Command-Wildcard/</id>
    <published>2022-08-19T13:04:07.000Z</published>
    <updated>2022-08-19T13:08:06.584Z</updated>
    
    <content type="html"><![CDATA[<h3 id="asterisk"><a href="#asterisk" class="headerlink" title="* asterisk"></a>* asterisk</h3><ul><li><p>this can represent any number of characters (including zero, in other words, zero or more characters). If you specified a “cd*” it would use “cda”, “cdrom”, “cdrecord” and anything that starts with “cd” also including “cd” itself. “m*l” could by mill, mull, ml, and anything that starts with an m and ends with an l.</p></li><li><h3 id="question-mark"><a href="#question-mark" class="headerlink" title="?  question mark"></a>?  question mark</h3></li><li><p>this can represent any single character. If you specified something at the command line like “hd?” GNU&#x2F;Linux would look for hda, hdb, hdc and every other letter&#x2F;number between a-z, 0-9.</p><h3 id="square-brackets"><a href="#square-brackets" class="headerlink" title="[]   square brackets"></a>[]   square brackets</h3></li><li><p>specifies a range. If you did m[a,o,u]m it can become: mam, mum, mom</p><h3 id="minus-sign-in-the-square-brackets"><a href="#minus-sign-in-the-square-brackets" class="headerlink" title="[-]  minus sign in the square brackets"></a>[-]  minus sign in the square brackets</h3></li><li><p>if you did: m[a-d]m it can become anything that starts and ends with m and has any character a to d in between. For example, these would work: mam, mbm, mcm, mdm. This kind of wildcard specifies an “or” relationship (you only need one to match).</p><h3 id="Exponential-sign-in-the-square-brackets"><a href="#Exponential-sign-in-the-square-brackets" class="headerlink" title="[^] Exponential sign in the square brackets"></a>[^] Exponential sign in the square brackets</h3></li><li><p>if you did: m[a-d]m it can become anything that starts and ends with m and has any character excepts a to d in between.</p></li></ul>]]></content>
    
    
    <summary type="html"> Linux Command —— Wildcard</summary>
    
    
    
    <category term="Linux Command" scheme="http://example.com/categories/Linux-Command/"/>
    
    
    <category term="Linux Command" scheme="http://example.com/tags/Linux-Command/"/>
    
  </entry>
  
  <entry>
    <title>Linux Command _ cut/grep/sort/uniq/wc</title>
    <link href="http://example.com/2022/08/19/Linux-Command-cut-grep-sort-uniq-wc/"/>
    <id>http://example.com/2022/08/19/Linux-Command-cut-grep-sort-uniq-wc/</id>
    <published>2022-08-19T13:03:44.000Z</published>
    <updated>2022-08-19T13:09:06.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH | cut -d  &#x27;:&#x27;  -f 3,5</span><br></pre></td></tr></table></figure><ul><li>-d  Use colon instaed TAB as a field delimiter ,and </li><li>-f  Select 3 to 5 fields of the line data .also print line data with no delimiter charater,unless the  -s option is specified<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep  [-cinv]  &#x27;target string&#x27;  filename </span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file1 | grep  [-cinv]  &#x27;target string&#x27;</span><br></pre></td></tr></table></figure><ul><li>-c  print the count of  matching line  in the input file</li><li>-i   serach the target string ingoring case distinction</li><li>-n print result line number</li><li>-v Invert the sense of matching .print line data with no target string</li></ul><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file1 | sort  [-frutk] </span><br></pre></td></tr></table></figure><ul><li>-f  ingore case distinction</li><li>-r revert the order</li><li>-u  list only one line if line data same with each other</li><li>-t  use specified delimeter charater instead of TAB</li><li>-k  order by specified field</li></ul><h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file1 | uniq   [-ic] </span><br></pre></td></tr></table></figure><p>  only print unique lines ,report or omit repeated lines</p><ul><li>-i igonre case  distinction</li><li>-c print line count</li></ul><h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file1 | wc </span><br></pre></td></tr></table></figure><ul><li><p>-c, –bytes<br> print the byte counts</p></li><li><p>-m, –chars<br> print the character counts</p></li><li><p>-l, –lines<br> print the newline counts</p></li></ul>]]></content>
    
    
    <summary type="html"> Linux Command _ cut/grep/sort/uniq/wc</summary>
    
    
    
    <category term="Linux Command" scheme="http://example.com/categories/Linux-Command/"/>
    
    
    <category term="Linux Command" scheme="http://example.com/tags/Linux-Command/"/>
    
  </entry>
  
  <entry>
    <title>Linux Command �� ls</title>
    <link href="http://example.com/2022/08/19/Linux-Command%E2%80%94%E2%80%94ls/"/>
    <id>http://example.com/2022/08/19/Linux-Command%E2%80%94%E2%80%94ls/</id>
    <published>2022-08-19T13:03:44.000Z</published>
    <updated>2022-08-19T13:10:01.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="9-Basic-�ls�-Command-Examples"><a href="#9-Basic-�ls�-Command-Examples" class="headerlink" title="9 Basic �ls� Command Examples"></a>9 Basic �ls� Command Examples</h2><h3 id="ls-a"><a href="#ls-a" class="headerlink" title="ls -a"></a>ls -a</h3><ul><li>list all files or directories including hidden files or directories. </li><li>file begins with . dot symbol can be regarded as a hidden file<h3 id="ls-d"><a href="#ls-d" class="headerlink" title="ls -d"></a>ls -d</h3></li><li>list directories only  ,rather than files inside the directory</li></ul><h3 id="ls-h"><a href="#ls-h" class="headerlink" title="ls -h"></a>ls -h</h3><ul><li>listall file with human readable format on file sizes (e.g. GB ,KB etc)</li><li><ul><li></li></ul></li></ul><h3 id="ls-i"><a href="#ls-i" class="headerlink" title="ls -i"></a>ls -i</h3><ul><li>list all files with their innode number</li></ul><h3 id="ls-l"><a href="#ls-l" class="headerlink" title="ls -l"></a>ls -l</h3><ul><li>list all files with details</li></ul><h3 id="ls-S"><a href="#ls-S" class="headerlink" title="ls -S"></a>ls -S</h3><ul><li>list files sort by file size rather than by name</li></ul><h3 id="ls-t"><a href="#ls-t" class="headerlink" title="ls -t"></a>ls -t</h3><ul><li>list files order by date  rather than name</li></ul><h3 id="ls-r"><a href="#ls-r" class="headerlink" title="ls -r"></a>ls -r</h3><ul><li>list files with a reversal order </li><li>for example. the deafault order is from a to z , </li><li>the order will turn to be z to a using ls -r<h3 id="ls-R"><a href="#ls-R" class="headerlink" title="ls -R"></a>ls -R</h3></li><li>Recursively list Sub-Directories</li></ul><h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes:"></a>Notes:</h3><p>You can use <code>alias ll = &#39;ls -alh --color=auto&#39; </code><br>to DIY the ls command as ll command</p>]]></content>
    
    
    <summary type="html"> Linux Command �� ls</summary>
    
    
    
    <category term="Linux Command" scheme="http://example.com/categories/Linux-Command/"/>
    
    
    <category term="Linux Command" scheme="http://example.com/tags/Linux-Command/"/>
    
  </entry>
  
  <entry>
    <title>what is Elmore delay</title>
    <link href="http://example.com/2022/08/19/what-is-Elmore-delay/"/>
    <id>http://example.com/2022/08/19/what-is-Elmore-delay/</id>
    <published>2022-08-19T13:03:02.000Z</published>
    <updated>2022-08-19T13:11:16.856Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Elmore delay is a simple approximation to the delay through an RC network in an electronic system. </li><li>For tree structured networks, find the delay through each segment as the R (electrical resistance) times the downstream C (electrical capacitance). Sum the delays from the root to the sink.</li><li>The Elmore delay analysis model estimates the delay from a source (root) to one of the leaf nodes as the sum of the resistance in the path to the ith node multiplied by the capacitance present at the end of the branch. It provides a simplistic delay analysis that avoids time-consuming numerical integration&#x2F;differential equations of an RC network.</li><li>In other words, the propagation delay from a switching source (root) to an ith branch node is given as the product of the capacitance “Ci” of the node with the sum of the resistance from the source to the node, Ris.</li><li><img src="https://img-blog.csdnimg.cn/5136ce6093014a2cb2e93d377454ffa6.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/371d7e24917047c59d8e0ea86cd7861e.png" alt="在这里插入图片描述"><br>The Elmore delay for Vout is given as tpd &#x3D; R1C1+(R1+ R2)C2</li></ul>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="EDA" scheme="http://example.com/categories/EDA/"/>
    
    
    <category term="EDA" scheme="http://example.com/tags/EDA/"/>
    
  </entry>
  
  <entry>
    <title>what is Fan-out</title>
    <link href="http://example.com/2022/08/19/what-is-Fan-out/"/>
    <id>http://example.com/2022/08/19/what-is-Fan-out/</id>
    <published>2022-08-19T13:01:51.000Z</published>
    <updated>2022-08-19T13:11:10.964Z</updated>
    
    <content type="html"><![CDATA[<ul><li>the fan-out is the number of gate inputs driven by the output of another single logic gate.</li><li>扇出（fan-out）是一个定义单个逻辑门能够驱动的数字信号输入最大量的专业术语。</li><li>大多数的TTL逻辑门能够为10个其他数字门或驱动器提供信号。所以，一个典型的TTL逻辑门有10个扇出信号。</li><li>In most designs, logic gates are connected to form more complex circuits. While no logic gate input can be fed by more than one output at a time without causing contention,<code> it is common for one output to be connected to several inputs.</code> The technology used to implement logic gates usually allows a certain number of gate inputs to be wired directly together without additional interfacing circuitry. <code>The maximum fan-out of an output measures its load-driving capability: it is the greatest number of inputs of gates of the same type to which the output can be safely connected.</code></li><li>在大多数设计中，逻辑门被连接起来形成更复杂的电路。虽然没有逻辑门输入可以由多个输出同时提供而不引起争用，但一个输出连接到多个输入是常见的。用于实现逻辑门的技术通常允许一定数量的门输入直接连接在一起，而不需要额外的接口电路。输出的最大扇出测量其负载驱动能力:它是输出可以安全连接的同类型门的最大输入数量。</li></ul>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="EDA" scheme="http://example.com/categories/EDA/"/>
    
    
    <category term="EDA" scheme="http://example.com/tags/EDA/"/>
    
  </entry>
  
  <entry>
    <title>Basic Commands in Tcl(Tool Command Language)</title>
    <link href="http://example.com/2022/06/17/Basic-Commands-in-Tcl-Tool-Command-Language/"/>
    <id>http://example.com/2022/06/17/Basic-Commands-in-Tcl-Tool-Command-Language/</id>
    <published>2022-06-17T05:25:50.000Z</published>
    <updated>2022-06-17T05:32:56.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><a href="https://en.wikipedia.org/wiki/Tcl">What is  Tcl(Tool Command Language) </a></p><h2 id="Basic-Commands"><a href="#Basic-Commands" class="headerlink" title="Basic Commands"></a>Basic Commands</h2><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># variable assign </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> &#123;a&#125; <span class="number">10</span></span><br><span class="line"><span class="keyword">set</span> b <span class="number">12</span></span><br><span class="line"><span class="keyword">set</span> c <span class="number">14</span></span><br><span class="line"><span class="keyword">set</span> d <span class="string">&quot;14&quot;</span></span><br><span class="line"><span class="keyword">set</span> e [<span class="keyword">expr</span> <span class="variable">$d</span> + <span class="number">10</span> + <span class="number">9</span>]</span><br><span class="line"><span class="keyword">set</span> res1 [<span class="keyword">expr</span> <span class="variable">$e</span> / <span class="number">9</span>]<span class="comment">;  # the result is interger,Notice the semicolon here</span></span><br><span class="line"><span class="keyword">set</span> res2 [<span class="keyword">expr</span> <span class="variable">$e</span>/ <span class="number">9.0</span>]<span class="comment">; # the result is float,Notice the semicolon here</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># variable print</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$a</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$&#123;a&#125;</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$b</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$&#123;b&#125;</span></span><br><span class="line"><span class="keyword">puts</span> <span class="string">&quot; $b &quot;</span></span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">expr</span> <span class="variable">$c</span> + <span class="number">10</span> + <span class="number">9</span> ]</span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">expr</span> <span class="variable">$d</span> + <span class="number">10</span> + <span class="number">9</span> ]</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$e</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$res1</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$res2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#===========================================</span></span><br><span class="line"><span class="comment"># Variable Type -String</span></span><br><span class="line"><span class="comment">#===========================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##the default type is string</span></span><br><span class="line"><span class="keyword">set</span> s1 hello        </span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$s1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##use quotation marks</span></span><br><span class="line"><span class="keyword">set</span> s2 <span class="string">&quot;hello world&quot;</span> </span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$s2</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##use brace marks</span></span><br><span class="line"><span class="keyword">set</span> s3 &#123;hello world&#125; </span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$s3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##escape charater</span></span><br><span class="line"><span class="keyword">set</span> s4 <span class="string">&quot;\\  \&#x27; \&quot; \? \a \b \f \n \r \t \v &quot;</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$s4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##string command </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">string</span> compare <span class="variable">$s1</span> <span class="variable">$s2</span>] </span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">string</span> compare <span class="variable">$s2</span> <span class="string">&quot;hello world&quot;</span>]</span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">string</span> length <span class="variable">$s1</span>]</span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">string</span> tolower <span class="variable">$s1</span>]</span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">string</span> index  <span class="variable">$s1</span> <span class="number">2</span>]</span><br><span class="line"><span class="comment">## refer to the TCL manual for more other string related commands</span></span><br><span class="line"><span class="comment">## index,length,range,tplower,toupper,trimleft .etc..</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#===========================================</span></span><br><span class="line"><span class="comment"># Variable Type -List</span></span><br><span class="line"><span class="comment">#===========================================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> list1 &#123;a b c&#125;</span><br><span class="line"><span class="keyword">set</span> list2 [<span class="keyword">list</span> a b c]</span><br><span class="line"><span class="keyword">set</span> list3 [<span class="keyword">split</span> <span class="string">&quot;a_b_c&quot;</span> _]</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$list1</span> </span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$list2</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$list3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## index</span></span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">lindex</span> <span class="variable">$list3</span> <span class="number">2</span>] </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## append</span></span><br><span class="line"><span class="keyword">append</span> list1 <span class="string">&quot; &quot;</span> <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="keyword">append</span> list1 <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="keyword">lappend</span> list1 <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$list1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## length</span></span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">llength</span> <span class="variable">$list1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## index</span></span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">lindex</span> <span class="variable">$list1</span> <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## insert </span></span><br><span class="line"><span class="keyword">puts</span> <span class="string">&quot;insert&quot;</span></span><br><span class="line"><span class="keyword">set</span> list1 [<span class="keyword">linsert</span> <span class="variable">$list1</span> <span class="number">3</span> hi asd asd]</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$list1</span></span><br><span class="line"><span class="comment">##puts  [linsert $list1 3 hi asd asd]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## replace </span></span><br><span class="line"><span class="keyword">set</span> list1 [<span class="keyword">lreplace</span> <span class="variable">$list1</span> <span class="number">1</span> <span class="number">1</span> hello ]</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$list1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## set </span></span><br><span class="line"><span class="comment">#puts [lset list1 0 world]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## assign </span></span><br><span class="line"><span class="comment">#lassign list1 tmp_list1 tmp_list2</span></span><br><span class="line"><span class="comment">#puts $tmp_list1</span></span><br><span class="line"><span class="comment">#puts $tmp_list2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## sort </span></span><br><span class="line"><span class="keyword">set</span> list1 [<span class="keyword">lsort</span> <span class="variable">$list1</span>]</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$list1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#================================</span></span><br><span class="line"><span class="comment"># Variable Type - Array</span></span><br><span class="line"><span class="comment">#================================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> array1(<span class="number">0</span>) chen</span><br><span class="line"><span class="keyword">set</span> array1(<span class="number">1</span>) weijie</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$array1</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$array1</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">array</span> size array1]</span><br><span class="line"><span class="keyword">puts</span> <span class="string">&quot;iterats&quot;</span></span><br><span class="line"><span class="keyword">for</span> &#123; <span class="keyword">set</span> index <span class="number">0</span> &#125;  &#123; <span class="variable">$index</span> &lt; [<span class="keyword">array</span> size array1] &#125;  &#123; <span class="keyword">incr</span> index &#125; &#123;</span><br><span class="line">        <span class="keyword">puts</span> <span class="string">&quot;$&#123;index&#125;&quot;</span></span><br><span class="line">        <span class="keyword">puts</span> <span class="string">&quot;$array1($index)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> person1(age) <span class="number">80</span></span><br><span class="line"><span class="keyword">set</span> person1(name) chen</span><br><span class="line"><span class="keyword">foreach</span> index [<span class="keyword">array</span> names person1] &#123; </span><br><span class="line">        <span class="keyword">puts</span> <span class="string">&quot;$index&quot;</span></span><br><span class="line">        <span class="keyword">puts</span> <span class="string">&quot;$person1($index)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#=====================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Variable Type - dict</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#======================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##dict create d1 name chen  age 17</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##dict set d2 name Jason</span></span><br><span class="line"><span class="comment">##dict set d2 age 18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##set d3 [dict create name Bob age 19]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###puts $d1</span></span><br><span class="line"><span class="comment">##puts $d2</span></span><br><span class="line"><span class="comment">##puts $d3</span></span><br><span class="line"><span class="comment">##puts [dict size $d1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### refer to document for more details</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#=====================</span></span><br><span class="line"><span class="comment"># Condition Statement </span></span><br><span class="line"><span class="comment">#=====================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> a <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> &#123; <span class="variable">$a</span> == <span class="number">10</span> &#125; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">puts</span> <span class="string">&quot;Value is 10&quot;</span></span><br><span class="line"></span><br><span class="line">&#125; elseif &#123; <span class="variable">$a</span> == <span class="number">20</span> &#125; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">puts</span> <span class="string">&quot;Value is 20&quot;</span></span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">puts</span> <span class="string">&quot;no matching value&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> <span class="variable">$a</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="number">10</span> &#123;</span><br><span class="line">         <span class="keyword">puts</span> <span class="string">&quot;the value is 10&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">20</span> &#123;</span><br><span class="line">         <span class="keyword">puts</span> <span class="string">&quot;the value is 20&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        default &#123;</span><br><span class="line">        <span class="keyword">puts</span> <span class="string">&quot;no matching value&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> b [<span class="keyword">expr</span> <span class="variable">$a</span> == <span class="number">10</span> ? <span class="number">10</span> : <span class="number">20</span>]</span><br><span class="line"><span class="keyword">puts</span> <span class="string">&quot;the value of b is : $b \n&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#=====================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Loop Stament</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#=====================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> &#123; <span class="variable">$a</span> &lt; <span class="number">40</span> &#125; &#123;</span><br><span class="line">        <span class="keyword">incr</span> a</span><br><span class="line">        <span class="keyword">puts</span> <span class="string">&quot; the value of $a &quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123; <span class="keyword">set</span> index <span class="variable">$b</span>&#125; &#123; <span class="variable">$index</span> &lt; <span class="number">30</span> &#125; &#123; <span class="keyword">incr</span> index &#125; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">puts</span> <span class="string">&quot; the value of index : $index &quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> &#123; <span class="variable">$index</span> == <span class="number">21</span> &#125; &#123;</span><br><span class="line">                <span class="keyword">incr</span> index</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> &#123; <span class="variable">$index</span> == <span class="number">25</span> &#125; &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#====================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Proc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#====================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">proc</span><span class="title"> func1</span> &#123;&#125; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">puts</span> <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">proc</span><span class="title"> func2</span> &#123; a b &#125; &#123;</span><br><span class="line">        <span class="keyword">return</span> [ <span class="keyword">expr</span> <span class="variable">$a</span> + <span class="variable">$b</span> ]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">proc</span><span class="title"> func3</span> &#123; numbers &#125; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> sum <span class="number">0</span> </span><br><span class="line">        <span class="keyword">foreach</span> number <span class="variable">$numbers</span> &#123;</span><br><span class="line">                <span class="keyword">set</span> sum [ <span class="keyword">expr</span>  <span class="variable">$sum</span> + <span class="variable">$number</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> avg [ <span class="keyword">expr</span> <span class="variable">$sum</span> / [ <span class="keyword">llength</span>  <span class="variable">$numbers</span> ]]</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$avg</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">proc</span><span class="title"> func4</span> &#123; a &#123; b <span class="number">10</span> &#125; &#125; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [ <span class="keyword">expr</span> <span class="variable">$a</span> + <span class="variable">$b</span> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">proc</span><span class="title"> func5</span> &#123; num &#125; &#123;</span><br><span class="line">        <span class="keyword">if</span> &#123; <span class="variable">$num</span> == <span class="number">1</span> &#125; &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [ <span class="keyword">expr</span>  <span class="variable">$num</span> * [ func5 [ <span class="keyword">expr</span> <span class="variable">$num</span> <span class="number">-1</span> ]]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func1</span><br><span class="line"></span><br><span class="line"><span class="keyword">puts</span> [ func2  <span class="number">10</span> <span class="number">20</span>  ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">puts</span> [func3  &#123;<span class="number">10</span> <span class="number">20</span> <span class="number">30</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">puts</span> [func4 <span class="number">10</span> ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">puts</span> [ func4 <span class="number">10</span> <span class="number">20</span> ] </span><br><span class="line"></span><br><span class="line"><span class="keyword">puts</span> [ func5 <span class="number">5</span> ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#NameSpace </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#===================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## define namespace </span></span><br><span class="line"><span class="keyword">namespace</span>  <span class="keyword">eval</span> MyMath &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">variable</span> myResult</span><br><span class="line"></span><br><span class="line">        <span class="keyword">namespace</span> <span class="keyword">eval</span> MyMath_Inner &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">variable</span> myResult1</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## set the variable And proc of the namespace </span></span><br><span class="line"><span class="keyword">proc</span><span class="title"> MyMath::Add</span> &#123; a b &#125; &#123;</span><br><span class="line">        <span class="keyword">set</span> ::MyMath::myResult [ <span class="keyword">expr</span> <span class="variable">$a</span> + <span class="variable">$b</span> ]</span><br><span class="line">        <span class="keyword">set</span> ::MyMath::myResult1 [ <span class="keyword">expr</span> <span class="variable">$a</span> - <span class="variable">$b</span> ]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## print the varible  And proc output of the namespace</span></span><br><span class="line">MyMath::Add <span class="number">10</span> <span class="number">23</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$::MyMath::myResult</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$::MyMath::myResult1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## export the porc of the namespace</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="keyword">eval</span>  testNamespace &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">namespace</span> export testProc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">proc</span><span class="title"> testNamespace::testProc</span> &#123;a  b&#125; &#123;</span><br><span class="line">        <span class="keyword">return</span>  [<span class="keyword">expr</span> <span class="variable">$a</span> * <span class="variable">$b</span> ]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> import testNamespace::* </span><br><span class="line"><span class="keyword">puts</span> [ testProc <span class="number">10</span> <span class="number">20</span> ] </span><br><span class="line"><span class="keyword">namespace</span> forget testNamespace::* </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#=======================</span></span><br><span class="line"><span class="comment">#File IO</span></span><br><span class="line"><span class="comment">#=======================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## write file </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> fp [ <span class="keyword">open</span> <span class="string">&quot;FileIoTest&quot;</span> w+]</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$fp</span> <span class="string">&quot;test&quot;</span></span><br><span class="line"><span class="keyword">close</span> <span class="variable">$fp</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## read file </span></span><br><span class="line"><span class="keyword">set</span> fp [<span class="keyword">open</span> <span class="string">&quot;FileIoTest&quot;</span> r]</span><br><span class="line"><span class="keyword">set</span> content [<span class="keyword">read</span> <span class="variable">$fp</span>]</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$content</span></span><br><span class="line"><span class="keyword">close</span> <span class="variable">$fp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># read file line by line</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> fp [<span class="keyword">open</span> <span class="string">&quot;FileIoTest2&quot;</span> w+] </span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$fp</span> <span class="string">&quot;hello \n world&quot;</span></span><br><span class="line"><span class="keyword">close</span> <span class="variable">$fp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> fp [<span class="keyword">open</span> <span class="string">&quot;FileIoTest2&quot;</span> r]</span><br><span class="line"><span class="keyword">while</span> &#123; [<span class="keyword">gets</span> <span class="variable">$fp</span> data] &gt;<span class="number">0</span> &#125; &#123;</span><br><span class="line">        <span class="keyword">puts</span> <span class="variable">$data</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">close</span> <span class="variable">$fp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#===================</span></span><br><span class="line"><span class="comment">#Error &amp; Catch </span></span><br><span class="line"><span class="comment">#===================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">proc</span><span class="title"> Div</span> &#123;a b&#125; &#123;</span><br><span class="line">    <span class="keyword">if</span> &#123;<span class="variable">$b</span> == <span class="number">0</span>&#125; &#123;</span><br><span class="line">  <span class="keyword">error</span> <span class="string">&quot;Error generated by error&quot;</span> <span class="string">&quot;Info String for error&quot;</span> <span class="number">401</span></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="keyword">expr</span> <span class="variable">$a</span>/<span class="variable">$b</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> &#123;[<span class="keyword">catch</span> &#123;<span class="keyword">puts</span> <span class="string">&quot;Result = [Div 10 0]&quot;</span>&#125; errmsg]&#125; &#123;</span><br><span class="line">   <span class="keyword">puts</span> <span class="string">&quot;ErrorMsg: $errmsg&quot;</span></span><br><span class="line">   <span class="keyword">puts</span> <span class="string">&quot;ErrorCode: $errorCode&quot;</span></span><br><span class="line">   <span class="keyword">puts</span> <span class="string">&quot;ErrorInfo:\n$errorInfo\n&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> &#123;[<span class="keyword">catch</span> &#123;<span class="keyword">puts</span> <span class="string">&quot;Result = [Div 10 2]&quot;</span>&#125; errmsg]&#125; &#123;</span><br><span class="line">   <span class="keyword">puts</span> <span class="string">&quot;ErrorMsg: $errmsg&quot;</span></span><br><span class="line">   <span class="keyword">puts</span> <span class="string">&quot;ErrorCode: $errorCode&quot;</span></span><br><span class="line">   <span class="keyword">puts</span> <span class="string">&quot;ErrorInfo:\n$errorInfo\n&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html"> TCL</summary>
    
    
    
    <category term="TCL" scheme="http://example.com/categories/TCL/"/>
    
    
    <category term="TCL" scheme="http://example.com/tags/TCL/"/>
    
  </entry>
  
  <entry>
    <title>C++中的引用</title>
    <link href="http://example.com/2022/05/29/C-%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/"/>
    <id>http://example.com/2022/05/29/C-%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/</id>
    <published>2022-05-29T06:55:15.000Z</published>
    <updated>2022-08-28T09:46:53.960Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="引用的基本原理"><a href="#引用的基本原理" class="headerlink" title="引用的基本原理"></a>引用的基本原理</h2><p>引用的实现原理其实通过下面5句话,1副图,1段代码就可以说明白了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a=1;</span><br><span class="line">int &amp;b=a</span><br></pre></td></tr></table></figure><p>1.引用变量b和被引用变量a并没有共用一块内存,b是另外开辟了一块内存的</p><p>2.引用变量b开辟的内存中存放的是a的地址</p><p>3.任何对变量b的操作,都将转换为对(*b)的操作,比如b&#x3D;b+1实际上是(*b)&#x3D;(*b)+1 而(*b)代表的就是a </p><p>4.基于上面3点我们可以总结出 引用变量b可以理解为被引用变量a的别名</p><p>5.引用必须在声明引用时将其初始化，而不能先声明，再赋值。也不能在使用过程中途对其赋值企图更改被引用的值,那样是无效的<br>比如:<br>int rats &#x3D; 101;<br>int &amp; rodents &#x3D; rats;<br>int bunnies &#x3D; 50;<br>rodents &#x3D; bunnies;<br>在上面一通操作以后rodent引用的还是rats</p><p>上面的两句代码 对应的内存分布图就如下<br><img src="https://files.mdnice.com/user/1489/9c6eb51d-ee87-436b-9839-0c5bad2ffe87.png"></p><p>再看一个实际的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">  using namespace std;</span><br><span class="line">  </span><br><span class="line">  int main()&#123;</span><br><span class="line">    int  a = 1;</span><br><span class="line">    int&amp;  b = a;</span><br><span class="line">    cout &lt;&lt; &quot;a:address-&gt;&quot; &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;b:address-&gt;&quot; &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a:address-&gt;0031FD54 </span><br><span class="line">b:address-&gt;0031FD54</span><br></pre></td></tr></table></figure><h2 id="引用的基本使用"><a href="#引用的基本使用" class="headerlink" title="引用的基本使用"></a>引用的基本使用</h2><p><img src="https://files.mdnice.com/user/1489/71a4aff5-8ed6-41a9-b935-252f6bd6b451.png"><br>还没有测试函数的引用实参和右值引用</p><h2 id="引用的基本类型"><a href="#引用的基本类型" class="headerlink" title="引用的基本类型"></a>引用的基本类型</h2><h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h3><ul><li><ol><li>在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">举个例子，int a = b+c, a 就是左值，</span><br><span class="line">其有变量名为a，通过&amp;a可以获取该变量的地址；</span><br><span class="line">表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，</span><br><span class="line">我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。</span><br></pre></td></tr></table></figure></li></ol></li><li><ol start="2"><li>左值一定在内存中，右值有可能在内存中也有可能在寄存器中</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a=5；</span><br><span class="line"></span><br><span class="line">int b=a;//此时a在内存中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int a=5；</span><br><span class="line"></span><br><span class="line">int b=a+1;//此时a+1在寄存器中</span><br><span class="line"></span><br><span class="line">int *p=&amp;a;//此时&amp;a在寄存器中</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="左值引用与右值引用"><a href="#左值引用与右值引用" class="headerlink" title="左值引用与右值引用"></a>左值引用与右值引用</h3><ul><li><ol><li>在内存中的变量才是可以取地址的，而在寄存器中的变量是不可以取地址的。对于一个不能取地址的表达式或者值是无法直接引用的。</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">int num1(5);</span><br><span class="line">int num2(10);</span><br><span class="line">int *pnum(&amp;num1);//将num1的地址传递给pnum</span><br><span class="line">int * &amp;rnum = pnum;//rnum是pnum的别名</span><br><span class="line">rnum = &amp;num2;//rnumhe pnum指向同一片内存  改变了rnum就相当于改变了pnum</span><br><span class="line">cout &lt;&lt; *pnum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">int num1(5);</span><br><span class="line">int num2(10);</span><br><span class="line"></span><br><span class="line">int * &amp;rnum = &amp;num1;//这是不允许的  无法从“int *”转换为“int *&amp;”</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>从以上两个例子可以看出int *pnum(&amp;num1); int * &amp;rnum &#x3D; pnum;</p></li><li><p>通过一个指针在进行取别名是可以的，因为此时指针在内存中，而直接int * &amp;rnum &#x3D; &amp;num1;取别名是不行的，&amp;num1在寄存器中。</p></li><li><p>在内存中的值是可以直接取别名的也就是引用。但是在寄存器中的值在不可以直接被引用的。其实这就是所谓的左值引用和右值引用。</p></li><li><p>2.左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型。右值引用和左值引用都是属于引用类型。</p></li><li><p>3.右值引用的方法就是int * &amp;&amp;rnum &#x3D; &amp;num1;  。</p></li><li><p>4.下面来说一下为什么要右值引用，右值引用在你需要使用寄存器中的值的时候可以进行右值引用。寄存器的刷新速度很快，没有右值引用的话就需要将寄存器中的值拷贝到内存中，在进行使用，这是很浪费时间的。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int getdata(int &amp;&amp;num)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; num;</span><br><span class="line">num += 10;</span><br><span class="line">return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 5;</span><br><span class="line">cout &lt;&lt; getdata(a + 1) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如上 int getdata(int &amp;&amp;num)就是对右值进行引用。 getdata(a + 1) 中a+1是右值在寄存器中，我们是不可以直接对他进行操作的，如果要操作得将其拷贝到内存中，如果是一个非常大的数据这种拷贝就会很占用内存，如果直接用右值引用就可以直接对其进行操作。从而节约内存。</p><ul><li><ol start="5"><li>无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。</li></ol></li></ul><h2 id="引用与const"><a href="#引用与const" class="headerlink" title="引用与const"></a>引用与const</h2><ul><li><ol><li>左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值引用只能接受非常量左值对其进行初始化。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int &amp;a = 2;       # 左值引用绑定到右值，编译失败</span><br><span class="line"> </span><br><span class="line">int b = 2;        # 非常量左值</span><br><span class="line">const int &amp;c = b; # 常量左值引用绑定到非常量左值，编译通过</span><br><span class="line">const int d = 2;  # 常量左值</span><br><span class="line">const int &amp;e = c; # 常量左值引用绑定到常量左值，编译通过</span><br><span class="line">const int &amp;b =2;  # 常量左值引用绑定到右值，编程通过</span><br></pre></td></tr></table></figure></li></ol></li></ul><p>常量左值引用内部实现的原理是这样的:对于不可寻址的值，如文字常量，以及不同类型的对象，编译器为了实现引用，必须生成一个临时对象，将该对象的值置入临时对象中，引用实际上指向该对象（对该引用的操作就是对该临时对象的操作），但用户不能访问它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">例如:</span><br><span class="line"></span><br><span class="line">double dval = 23;</span><br><span class="line">const int &amp;ri = dval;</span><br><span class="line">编译器将其转换为:</span><br><span class="line"></span><br><span class="line">int tmp = dval; // double -&gt; int</span><br><span class="line">const int &amp;ri = tmp;</span><br><span class="line">同理：上面代码</span><br><span class="line"></span><br><span class="line">double dval = 3.14159;</span><br><span class="line">//下3行仅对const引用才是合法的</span><br><span class="line">const int &amp;ir = 1024;</span><br><span class="line">const int &amp;ir2 = dval;</span><br><span class="line">const double &amp;dr = dval + 1.0;</span><br><span class="line">内部转化为：</span><br><span class="line"></span><br><span class="line">double dval = 3.14159;</span><br><span class="line">//不可寻址，文字常量</span><br><span class="line">int tmp1 = 1024;</span><br><span class="line">const int &amp;ir = tmp1;</span><br><span class="line">//不同类型</span><br><span class="line">int tmp2 = dval;//double -&gt; int</span><br><span class="line">const int &amp;ir2 = tmp2;</span><br><span class="line">//另一种情况，不可寻址</span><br><span class="line">double tmp3 = dval + 1.0;</span><br><span class="line">const double &amp;dr = tmp3;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><ol start="2"><li>右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值，例如：</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a;</span><br><span class="line">int &amp;&amp;r1 = c;             # 编译失败</span><br><span class="line">int &amp;&amp;r2 = std::move(a);  # 编译通过</span><br></pre></td></tr></table></figure><ul><li>3.const引用与非const引用的对比</li></ul><p>[0].const引用表示，试图通过此引用去(间接)改变其引用的对象的值时，编译器会报错！我们仍然可以直接改变其指向对象的值，只是不能通过引用改变。总结来说就是const引用只是表明：保证不会通过此引用间接的改变被引用的对象！下面是一个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 1 #include &lt;iostream&gt;</span><br><span class="line"> 2 using namespace std;</span><br><span class="line"> 3</span><br><span class="line"> 4 int main()</span><br><span class="line"> 5 &#123;</span><br><span class="line"> 6     int val = 1024;</span><br><span class="line"> 7     const int &amp;ir = val;</span><br><span class="line"> 8     </span><br><span class="line"> 9     val++;//我们仍然可以通过val直接改变其值</span><br><span class="line">10     //ir++;//通过ir来改变val的值，编译时会出错</span><br><span class="line">11</span><br><span class="line">12     cout &lt;&lt; val &lt;&lt; &quot; &quot; &lt;&lt; ir &lt;&lt; endl;</span><br><span class="line">13</span><br><span class="line">14     return 0;</span><br><span class="line">15 &#125;</span><br></pre></td></tr></table></figure><p>另外，const既可以放到类型前又可以放到类型后面，放类型后比较容易理解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string const *t1;</span><br><span class="line">const string *t1;</span><br><span class="line">typedef string* pstring;</span><br><span class="line">string s;</span><br><span class="line">const pstring cstr1 = &amp;s;//此时放前面就出错了</span><br><span class="line">pstring const cstr2 = &amp;s;//但是放在类型后面不会出错</span><br></pre></td></tr></table></figure><p>[1]、const引用可读不可改，与绑定对象是否为const无关；非const引用可读可改，只可与非const对象绑定</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int ival = 1024;</span><br><span class="line">const int &amp;refVal = ival; // ok: both reference and object are const</span><br><span class="line">int &amp;ref2 = ival;            // error: nonconst reference to a const object</span><br></pre></td></tr></table></figure><p>[2]、非const引用只能绑定到与该引用同类型的对象，const引用则可以绑定到不同但相关的类型的对象或绑定到左值，同时const引用可以初始化为不同类型的对象或者初始化为右值，如字面值常量。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int i = 42;</span><br><span class="line">// legal for const references only</span><br><span class="line">const int &amp;r = 42;//初始化为右值</span><br><span class="line">const int &amp;r2 = r + i;//同样的初始化对于非const引用却是不合法的，而且会导致编译时错误。</span><br><span class="line">double dval = 3.14;</span><br><span class="line">const int &amp;ri = dval;//不同类型对象</span><br><span class="line">编译器会把这些代码转换成如以下形式的编码：</span><br><span class="line"></span><br><span class="line">int temp = dval;          // create temporary int from the double</span><br><span class="line">const int &amp;ri = temp;   // bind ri to that temporary</span><br></pre></td></tr></table></figure><p>[3].const引用和非const引用在内存中的对比</p><p>例如const引用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const int t = 9;</span><br><span class="line">const int&amp; k = t;</span><br><span class="line">cout&lt;&lt;&amp;k&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&amp;t&lt;&lt;endl;</span><br><span class="line">输出是</span><br><span class="line">0012FF6C</span><br><span class="line">0012FF74</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例如非const引用：</span><br><span class="line">int t = 9;</span><br><span class="line">int&amp; k = t;</span><br><span class="line">cout&lt;&lt;&amp;k&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&amp;t&lt;&lt;endl;</span><br><span class="line">输出是</span><br><span class="line">0012FF74</span><br><span class="line">0012FF74</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/88d5ede3-221f-4bcc-b76f-1fec42db7c37.png"></p><h2 id="引用与函数"><a href="#引用与函数" class="headerlink" title="引用与函数"></a>引用与函数</h2><h3 id="1-类型匹配问题"><a href="#1-类型匹配问题" class="headerlink" title="1.类型匹配问题"></a>1.类型匹配问题</h3><ul><li>如果函数形参，用到了引用类型<br>则如果不注意实参和形参的类型匹配，就会出现问题<br>比如如果形参是非常量左值引用 void func(int &amp;a)<br>则如果你传进去的是常量左值 比如const int b &#x3D; 1；<br>或者右值5<br>那么就会调用func(b)  func(5)报错</li></ul><p><img src="https://files.mdnice.com/user/1489/88d5ede3-221f-4bcc-b76f-1fec42db7c37.png"></p><p>根据这个表格做好类型匹配<br>具体原理看上面的讲解</p><p><a href="https://blog.csdn.net/qq_40888863/article/details/119078245">https://blog.csdn.net/qq_40888863&#x2F;article&#x2F;details&#x2F;119078245</a></p><ul><li>比如如果形参是非常量左值引用 void swap(int &amp;a,int &amp;b)<br>但是你传进去的实参是long a&#x3D; 1; long b &#x3D; 2;<br>那么你传进去时 在赋值给形参的时候<br>实际上会生成一个临时变量<br>这样swap函数交换的实际上时临时变量<br>不会对实参进行交换</li></ul><p><a href="https://blog.csdn.net/qq_36412526/article/details/109580579?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.pc_relevant_aa&spm=1001.2101.3001.4242.1&utm_relevant_index=3">https://blog.csdn.net/qq_36412526&#x2F;article&#x2F;details&#x2F;109580579?utm_medium&#x3D;distribute.pc_relevant.none-task-blog-2<del>default</del>baidujs_title~default-0.pc_relevant_aa&amp;spm&#x3D;1001.2101.3001.4242.1&amp;utm_relevant_index&#x3D;3</a></p><h3 id="2-什么时候函数形参用引用类型？"><a href="#2-什么时候函数形参用引用类型？" class="headerlink" title="2. 什么时候函数形参用引用类型？"></a>2. 什么时候函数形参用引用类型？</h3><ul><li><ol><li><p>运行效率</p><p> 引用类型形参不用像值传递那样开辟内存空间进行大量数据的赋值</p><p> 对于类对象 不用调用拷贝构造函数</p></li></ol></li><li><ol start="2"><li><p>程序员能够修改调用函数中的数据对象</p><p>如果使用值传递, 修改的只是副本</p></li></ol></li></ul><h3 id="3-什么时候函数形参用const类型？"><a href="#3-什么时候函数形参用const类型？" class="headerlink" title="3. 什么时候函数形参用const类型？"></a>3. 什么时候函数形参用const类型？</h3><p>尽可能使用const<br>将引用参数声明为常量数据的引用的理由有三个：</p><ul><li><p>1)、防修改：<br>使用const可以避免无意中修改数据的编程错误。</p></li><li><p>2)、接受const和非const实参:<br>使用const使函数能够处理const和非const实参，否则将只能接受非const数据。</p></li><li><p>3)、和引用配合，能同时接受左值和右值:<br>使用const引用使函数能够正确生成并使用临时变量。</p></li></ul><h3 id="4-函数参数值传递、指针传递、引用传递区别"><a href="#4-函数参数值传递、指针传递、引用传递区别" class="headerlink" title="4. 函数参数值传递、指针传递、引用传递区别"></a>4. 函数参数值传递、指针传递、引用传递区别</h3><p><a href="https://www.cnblogs.com/yanlingyin/archive/2011/12/07/2278961.html">https://www.cnblogs.com/yanlingyin/archive/2011/12/07/2278961.html</a></p><h3 id="5-函数形参类型的使用准则"><a href="#5-函数形参类型的使用准则" class="headerlink" title="5. 函数形参类型的使用准则"></a>5. 函数形参类型的使用准则</h3><ul><li>对于使用传递值而不做修改的函数：</li></ul><p>如果数据对象较小，如内置数据类型或者小型结构，则按值传递。</p><p>如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针。</p><p>如果数据对象是较大的结构，则使用const指针或const引用，以提高运行效率。这样可以节省复制结构所需的时间和空间。</p><p>如果数据对象是类对象，则使用const引用。类设计的语义常常要求使用引用，这是C++增加引用特性的主要原因。因此，传递类对象参数的标准方式是按引用传递。</p><ul><li>对于修改调用函数中数据的函数：</li></ul><p>如果数据对象是内置数据类型，则使用指针。如果看到诸如fixit(&amp;x)这样的代码（其中x是int型），则很明显，该函数将修改x。</p><p>如果数据对象是数组，则只能使用指针。</p><p>如果数据对象是结构，则使用引用或指针。</p><p>如果数据对象是类对象，则使用引用。</p><p><img src="https://files.mdnice.com/user/1489/bad9ef2e-434c-4542-990a-f762e4618d86.png"></p><h2 id="引用与指针"><a href="#引用与指针" class="headerlink" title="引用与指针"></a>引用与指针</h2><p><img src="https://files.mdnice.com/user/1489/a4b6439c-44c9-4c1f-b4c1-a2a854f26b50.png"></p>]]></content>
    
    
    <summary type="html"> 引用 </summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中的const关键字</title>
    <link href="http://example.com/2022/05/29/C-%E4%B8%AD%E7%9A%84const%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://example.com/2022/05/29/C-%E4%B8%AD%E7%9A%84const%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2022-05-29T05:37:41.000Z</published>
    <updated>2022-05-29T08:35:32.211Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="const与基本变量"><a href="#const与基本变量" class="headerlink" title="const与基本变量"></a>const与基本变量</h2><p><img src="https://files.mdnice.com/user/1489/52d0e399-5cf3-4fab-af68-e2a7a4cd8464.png" alt="img"></p><p><img src="https://files.mdnice.com/user/1489/359421a9-a125-4e7a-ada0-449d650b20b6.png" alt="img"></p><h2 id="const与extern"><a href="#const与extern" class="headerlink" title="const与extern"></a>const与extern</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>正常来说， 在B.cpp中定义了变量int i &#x3D; 0 则A.cpp中使用extern int i 使用这个变量i 但是现在的问题是 如果你在B.cpp中定义的这个变量i是const的 那么用同样的方式在A.cpp中引用这个变量 并编译的时候 g++ A.cpp  B.cpp -o test 就会发现出现了未定义引用的错误</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>错误的原因在这篇文章中说的很清楚 <a href="https://zhuanlan.zhihu.com/p/272828566">https://zhuanlan.zhihu.com/p/272828566</a></p><p>总结一下就是 如果变量被const定义的话 就会修改这个变量的链接属性 那么这个变量就不能被外部的文件链接了</p><h3 id="解决措施"><a href="#解决措施" class="headerlink" title="解决措施"></a>解决措施</h3><p>解决的措施在这篇文章中也说的很清楚 <a href="https://zhuanlan.zhihu.com/p/272828566">https://zhuanlan.zhihu.com/p/272828566</a></p><p>总结一下就是 在B.cpp的该变量i前面也加上extern关键字就可以了 因为extern有一个不太被关注的作用是， 在C++中，它可以改变const变量的链接属性。 让这个变量变得能够被外部文件链接到</p><h3 id="标准用法"><a href="#标准用法" class="headerlink" title="标准用法"></a>标准用法</h3><p>正确用法如下 <img src="https://files.mdnice.com/user/1489/f90c2e3b-45ee-4020-b4c5-66745331b114.png" alt="img"></p><p><img src="https://files.mdnice.com/user/1489/fb4161ac-deb5-4557-b34d-c64ec1fce3ee.png" alt="img"></p><h2 id="const与指针"><a href="#const与指针" class="headerlink" title="const与指针"></a>const与指针</h2><h3 id="指向常量的指针-const在-号前"><a href="#指向常量的指针-const在-号前" class="headerlink" title="指向常量的指针(const在*号前)"></a>指向常量的指针(const在*号前)</h3><ul><li>不能通过指针改变其所指向对象值</li><li>即能指向常量对象也能指向非常量对象</li></ul><h3 id="常量指针-const在-号后"><a href="#常量指针-const在-号后" class="headerlink" title="常量指针 (const在*号后)"></a>常量指针 (const在*号后)</h3><ul><li>其所指向的地址不变</li><li>可以通过常量指针改变所指向对象的值</li></ul><p><img src="https://files.mdnice.com/user/1489/6da8b4da-ac00-4b04-930d-3ee672417e06.png" alt="img"></p><p><img src="https://files.mdnice.com/user/1489/84408089-ea82-4578-aad7-3a0877b28317.png" alt="img"></p><h2 id="const与类型转换"><a href="#const与类型转换" class="headerlink" title="const与类型转换"></a>const与类型转换</h2><ul><li>在C语言中，const限定符通常被用来限定变量，用于表示该变量的值不能被修改。</li><li>而const_cast则正是用于强制去掉这种不能被修改的常数特性，但需要特别注意的是const_cast不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。</li><li>用法：const_cast<type_id> (expression) 该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。 常量指针被转化成非常量指针，并且仍然指向原来的对象； 常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">[例3]一个错误的例子：</span><br><span class="line"></span><br><span class="line">const int a = 10;</span><br><span class="line">const int * p = &amp;a;</span><br><span class="line">*p = 20;                  //compile error</span><br><span class="line">int b = const_cast&lt;int&gt;(a);  //compile error</span><br><span class="line">在本例中出现了两个编译错误，第一个编译错误是*p因为具有常量性，其值是不能被修改的；另一处错误是const_cast强制转换对象必须为指针或引用，而例3中为一个变量，这是不允许的！</span><br><span class="line">[例4]const_cast关键字的使用</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int a = 10;</span><br><span class="line">    const int * p = &amp;a;</span><br><span class="line">    int *q;</span><br><span class="line">    q = const_cast&lt;int *&gt;(p);</span><br><span class="line">    *q = 20;    //fine</span><br><span class="line">    cout &lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;*p&lt;&lt;&quot; &quot;&lt;&lt;*q&lt;&lt;endl;</span><br><span class="line">        cout &lt;&lt;&amp;a&lt;&lt;&quot; &quot;&lt;&lt;p&lt;&lt;&quot; &quot;&lt;&lt;q&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">在本例中，我们将变量a声明为常量变量，同时声明了一个const指针指向该变量（此时如果声明一个普通指针指向该常量变量的话是不允许的，Visual Studio 2010编译器会报错）。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">之后我们定义了一个普通的指针*q。将p指针通过const_cast去掉其常量性，并赋给q指针。之后我再修改q指针所指地址的值时，这是不会有问题的。</span><br><span class="line"></span><br><span class="line">最后将结果打印出来，运行结果如下：</span><br><span class="line">10 20 20</span><br><span class="line">002CFAF4 002CFAF4 002CFAF4</span><br><span class="line"></span><br><span class="line">查看运行结果，问题来了，指针p和指针q都是指向a变量的，指向地址相同，而且经过调试发现002CFAF4地址内的值确实由10被修改成了20，这是怎么一回事呢？为什么a的值打印出来还是10呢？</span><br><span class="line"></span><br><span class="line">其实这是一件好事，我们要庆幸a变量最终的值没有变成20！变量a一开始就被声明为一个常量变量，不管后面的程序怎么处理，它就是一个常量，就是不会变化的。试想一下如果这个变量a最终变成了20会有什么后果呢？对于这些简短的程序而言，如果最后a变成了20，我们会一眼看出是q指针修改了，但是一旦一个项目工程非常庞大的时候，在程序某个地方出现了一个q这样的指针，它可以修改常量a，这是一件很可怕的事情的，可以说是一个程序的漏洞，毕竟将变量a声明为常量就是不希望修改它，如果后面能修改，这就太恐怖了。</span><br><span class="line"></span><br><span class="line">在例4中我们称“*q=20”语句为未定义行为语句，所谓的未定义行为是指在标准的C++规范中并没有明确规定这种语句的具体行为，该语句的具体行为由编译器来自行决定如何处理。对于这种未定义行为的语句我们应该尽量予以避免！</span><br><span class="line"></span><br><span class="line">从例4中我们可以看出我们是不想修改变量a的值的，既然如此，定义一个const_cast关键字强制去掉指针的常量性到底有什么用呢？我们接着来看下面的例子。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">例5：</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">const int * Search(const int * a, int n, int val);</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">    int val = 5;</span><br><span class="line">    int *p;</span><br><span class="line">    p = const_cast&lt;int *&gt;(Search(a, 10, val));</span><br><span class="line">    if(p == NULL)</span><br><span class="line">        cout&lt;&lt;&quot;Not found the val in array a&quot;&lt;&lt;endl;</span><br><span class="line">    else</span><br><span class="line">        cout&lt;&lt;&quot;hvae found the val in array a and the val = &quot;&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">const int * Search(const int * a, int n, int val)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i] == val)</span><br><span class="line">            return &amp;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return  NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">在例5中我们定义了一个函数，用于在a数组中寻找val值，如果找到了就返回该值的地址，如果没有找到则返回NULL。函数Search返回值是const指针，当我们在a数组中找到了val值的时候，我们会返回val的地址，最关键的是a数组在main函数中并不是const，因此即使我们去掉返回值的常量性有可能会造成a数组被修改，但是这也依然是安全的。</span><br><span class="line">对于引用，我们同样能使用const_cast来强制去掉常量性，如例6所示。</span><br><span class="line">例6：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">const int &amp; Search(const int * a, int n, int val);</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">int val = 5;</span><br><span class="line">int &amp;p = const_cast&lt;int &amp;&gt;(Search(a, 10, val));</span><br><span class="line">if(p == NULL)</span><br><span class="line">cout&lt;&lt;&quot;Not found the val in array a&quot;&lt;&lt;endl;</span><br><span class="line">else</span><br><span class="line">cout&lt;&lt;&quot;hvae found the val in array a and the val = &quot;&lt;&lt;p&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">const int &amp; Search(const int * a, int n, int val)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">for(i=0; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i] == val)</span><br><span class="line">return a[i];</span><br><span class="line">&#125;</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> 了解了const_cast的使用场景后，可以知道使用const_cast通常是一种无奈之举，同时也建议大家在今后的C++程序设计过程中一定不要利用const_cast去掉指针或引用的常量性并且去修改原始变量的数值，这是一种非常不好的行为。</span><br></pre></td></tr></table></figure><h2 id="const与constexpr"><a href="#const与constexpr" class="headerlink" title="const与constexpr"></a>const与constexpr</h2><p><a href="https://blog.csdn.net/woxiaohahaa/article/details/78512576">https://blog.csdn.net/woxiaohahaa/article/details/78512576</a></p><p><a href="https://blog.51cto.com/u_15346415/5171568">https://blog.51cto.com/u_15346415/5171568</a></p><h3 id="constexpr与普通变量"><a href="#constexpr与普通变量" class="headerlink" title="constexpr与普通变量"></a>constexpr与普通变量</h3><p>constexpr变量</p><ul><li>将变量声明为constexpr以便于由编译器检测一个表达式是否为一个常量表达式，而const没有此功能：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 3;</span><br><span class="line">int b = 4;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">constexpr int value1 = a + b;//编译器报错，表达式a + b不是常量表达式</span><br><span class="line">const int value2 = a + b;//正常初始化，不会报错</span><br></pre></td></tr></table></figure><ul><li>因此，如果你想用一个你认为是常量的表达式来初始化一个变量，不妨将这个变量声明为constexpr，让编译器为你检测一下。</li><li>只有字面值类型才能声明为constexpr变量。（基本算数类型（bool，int…），引用，指针…）。</li></ul><h3 id="constexpr与指针引用"><a href="#constexpr与指针引用" class="headerlink" title="constexpr与指针引用"></a>constexpr与指针引用</h3><p>当一个指针声明为constexpr时，相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a = 3;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    constexpr int *p1 = &amp;a;</span><br><span class="line">    //两者等价,表示指针为常量，对象的值可以修改。</span><br><span class="line">    int * const p1 = &amp;a;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，如果想要声明一个指针常量指向一个整型常量，则可以有如下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a = 3;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    constexpr const int *p1 = &amp;a;</span><br><span class="line">    //两者等价，指针为常量，指向一个整型常量</span><br><span class="line">    const int *const p3 = &amp;a;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>constexpr指针和引用只能指向所有函数体之外的变量（全局变量）或者函数体内的静态变量。</p><h3 id="constexpr与函数"><a href="#constexpr与函数" class="headerlink" title="constexpr与函数"></a>constexpr与函数</h3><p>constexpr函数</p><p>constexpr函数 可以实现编译期函数（即函数在编译期执行完毕，并在调用处进行替换）： #include  using namespace std; &#x2F;&#x2F;运算n的阶乘 constexpr int factorial(int n) {   return n &#x3D;&#x3D; 0 ? 1 : n * factorial(n - 1); } int main() {   cout &lt;&lt; factorial(10) &lt;&lt; endl;   system(“pause”);   return 0; } 该函数也可以在运行期执行： #include  using namespace std; constexpr int factorial(int n) {   return n &#x3D;&#x3D; 0 ? 1 : n * factorial(n - 1); } int main() {   int a &#x3D; 3;   scanf_s(“%d”, &amp;a);   cout &lt;&lt; factorial(a) &lt;&lt; endl;   system(“pause”);   return 0; } 可以对constexpr变量进行初始化： #include  using namespace std; constexpr int factorial(int n) {   return n &#x3D;&#x3D; 0 ? 1 : n * factorial(n - 1); } int main() {   constexpr int value &#x3D; factorial(10);   system(“pause”);   return 0; } 规定：</p><ul><li>函数的返回值以及参数都必须为字面值类型；</li><li>函数只能有一条return语句（C++14后无该要求）； 函数不一定返回常量表达式，但如果要初始化一个constexpr变量，则必须返回常量表达式（参数也必须为常量或常量表达式）；</li><li>函数被隐式的声明为内联函数；</li><li>函数内部可以声明变量（声明之后是运行期还是编译期？），可以用using声明，空语句，类型别名，循环，判断语句等，但cout不行。</li></ul><h2 id="const与引用"><a href="#const与引用" class="headerlink" title="const与引用"></a>const与引用</h2><p><a href="https://kyleandkelly.github.io/2022/05/29/C-%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/">https://kyleandkelly.github.io/2022/05/29/C-%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/</a></p><h2 id="const与函数形参"><a href="#const与函数形参" class="headerlink" title="const与函数形参"></a>const与函数形参</h2><p><a href="https://kyleandkelly.github.io/2022/05/29/C-%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/">https://kyleandkelly.github.io/2022/05/29/C-%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/</a></p><h2 id="const与类成员函数"><a href="#const与类成员函数" class="headerlink" title="const与类成员函数"></a>const与类成员函数</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://files.mdnice.com/user/1489/88e6c55a-da52-401d-8fd7-a957bd814293.png" alt="img"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><img src="https://files.mdnice.com/user/1489/5683c4b2-0d45-4fe8-8b21-17d92f0ccfad.png" alt="img"></p><h2 id="const顶层或底层"><a href="#const顶层或底层" class="headerlink" title="const顶层或底层"></a>const顶层或底层</h2><p><img src="https://files.mdnice.com/user/1489/89565247-0abc-402d-b263-b52c622cdfc3.png" alt="img"></p>]]></content>
    
    
    <summary type="html"> const关键字</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中的static关键字</title>
    <link href="http://example.com/2022/05/25/C-%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://example.com/2022/05/25/C-%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2022-05-25T07:15:58.000Z</published>
    <updated>2022-05-25T07:17:01.751Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h2><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul><li>在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量。我们先举一个静态全局变量的例子，如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">static int n;  //定义静态全局变量</span><br><span class="line"></span><br><span class="line">void fn()</span><br><span class="line">&#123;</span><br><span class="line">    n++;</span><br><span class="line">    cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    n = 20;</span><br><span class="line">    cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    fn();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量。</li><li>未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化）；</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>全局变量本身就是静态存储方式，<br>静态全局变量当然也是静态存储方式。</p><p>这两者在存储方式上并无不同。</p><p>和全局变量的区别<br>这两者的区别在于非静态全局变量的作用域是整个源程序，<br>当一个源程序由多个原文件组成时，<br>非静态的全局变量在各个源文件中都是有效的。<br>而静态全局变量则限制了其作用域，<br>即只在定义该变量的源文件内有效，<br>在同一源程序的其它源文件中不能使用它。</p><p>如果是全局变量的话<br>你在别的源文件加一个extern<br>就可以使用这个源文件中的全局变量<br>但是如果是静态全局变量就不可以<br>也就是说定义全局变量就可以实现变量在文件中的共享，但定义静态全局变量就不可以 </p><p>这样带来了以下好处：</p><ul><li><p>静态全局变量不能被其它文件所用；静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的； </p></li><li><p>其它文件中可以定义相同名字的变量，不会发生冲突；</p></li></ul><h2 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h2><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。<br>我们先举一个静态局部变量的例子，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void fn();</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    fn();</span><br><span class="line">    fn();</span><br><span class="line">    fn();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fn()</span><br><span class="line">&#123;</span><br><span class="line">    static int n = 10;</span><br><span class="line">    cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    n++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。<br>　　但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。<br>　　静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>静态局部变量有以下特点：</p><ul><li>（1）该变量在全局数据区分配内存；</li><li>（2）静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</li><li>（3）静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；</li><li>（4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；</li><li>（5）初始化时机<br> 静态变量什么时候初始化<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">初始化只有一次，但是可以多次赋值，</span><br><span class="line">在主程序之前，编译器已经为其分配好了内存。</span><br><span class="line">静态局部变量和全局变量一样，数据都存放在全局区域，</span><br><span class="line">所以在主程序之前，编译器已经为其分配好了内存，</span><br><span class="line">但在C和C++中静态局部变量的初始化节点又有点不太一样。</span><br><span class="line">在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，</span><br><span class="line">就会进行初始化，所以我们看到在C语言中</span><br><span class="line">无法使用变量对静态局部变量进行初始化，</span><br><span class="line">在程序运行结束，变量所处的全局内存会被全部回收。</span><br><span class="line"></span><br><span class="line">而在C++中，初始化时在执行相关代码时才会进行初始化，</span><br><span class="line">主要是由于C++引入对象后，</span><br><span class="line">要进行初始化必须执行相应构造函数和析构函数，</span><br><span class="line">在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，</span><br><span class="line">并非简单地分配内存。</span><br><span class="line">所以C++标准定为全局或静态对象是有首次用到时才会进行构造，</span><br><span class="line">并通过atexit()来管理。在程序结束，</span><br><span class="line">按照构造顺序反方向进行逐个析构。</span><br><span class="line">所以在C++中是可以使用变量</span><br><span class="line">对静态局部变量进行初始化的。</span><br></pre></td></tr></table></figure></li></ul><h2 id="静态全局函数"><a href="#静态全局函数" class="headerlink" title="静态全局函数"></a>静态全局函数</h2><ul><li>这样的static函数与普通函数的区别是：用static修饰的函数，限定在本源码文件中，不能被本源码文件以外的代码文件调用。而普通的函数，默认是extern的，也就是说它可以被其它代码文件调用。</li></ul><p>　- 在函数的返回类型前加上关键字static，函数就被定义成为静态函数。普通 函数的定义和声明默认情况下是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。因此定义静态函数有以下好处：<br>　  &lt;1&gt; 其他文件中可以定义相同名字的函数，不会发生冲突。<br>　  　  &lt;2&gt; 静态函数不能被其他文件所用。</p><h2 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>假设你现在要写一个存款类<br>存款类里面有一个利息的成员变量<br>那么把利息这个成员变量设定为static 有什么作用呢？</p><ul><li><p>一是不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以节省了存储空间。</p></li><li><p>二是一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了。</p></li><li><p>三是有一些状态是和类本身相关的而不是和对象相关的 这些状态数据可以用静态成员变量去表达</p></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>类内声明</li></ul><p><img src="https://files.mdnice.com/user/1489/70c33764-36a9-4fe2-8df2-e6c7b4ed60f6.png"></p><ul><li>类外初始化</li></ul><p><img src="https://files.mdnice.com/user/1489/34d1c2cb-608d-409c-aac9-09f85e753797.png"></p><ul><li>使用</li></ul><p><img src="https://files.mdnice.com/user/1489/1c5015be-1be2-4f01-9290-16b6ea09aa73.png"></p><p><img src="https://files.mdnice.com/user/1489/4f1e6aae-89b6-420a-a773-d0f3faf3a65a.png"></p><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p><img src="https://files.mdnice.com/user/1489/533d1e4c-a910-4bbb-87d4-78bab569efbe.png"></p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p><img src="https://files.mdnice.com/user/1489/213752eb-b8a8-45c7-92cb-36757d783b65.png"></p><h2 id="static作用总结"><a href="#static作用总结" class="headerlink" title="static作用总结"></a>static作用总结</h2><h3 id="作用1：隐藏"><a href="#作用1：隐藏" class="headerlink" title="作用1：隐藏"></a>作用1：隐藏</h3><ul><li>1.先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）<br>当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。<br>举例来说明。同时编译两个源文件，一个是a.c，另一个是main.c。</li></ul><p>&#x2F;&#x2F;a.c<br>char a &#x3D; ‘A’; &#x2F;&#x2F; global variable<br>void msg()<br>{<br>     printf(“Hello\n”);<br>}</p><p>&#x2F;&#x2F;main.c</p><p>int main()<br>{<br>     extern char a; &#x2F;&#x2F; extern variable must be declared before use<br>     printf(“%c “, a);<br>     (void)msg();<br>     return 0;<br>}</p><p>程序的运行结果是：<br>A Hello</p><p>为什么在a.c中定义的全局变量a和函数msg能在main.c中使用？前面说过，所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。此例中，a是全局变量，msg是函数，并且都没有加static前缀，因此对于另外的源文件main.c是可见的。<br>如果加了static，就会对其它源文件隐藏。例如在a和msg的定义前加上static，main.c就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏.</p><h3 id="2-内容的持久"><a href="#2-内容的持久" class="headerlink" title="2. 内容的持久"></a>2. 内容的持久</h3><ul><li>2.static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）<br>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。虽然这种用法不常见<br>PS：如果作为static局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与自动变量相同，只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。</li></ul><p>程序举例：</p><p>＃include &lt;stdio.h&gt;</p><p>int fun(){<br>    static int count &#x3D; 10; &#x2F;&#x2F;在第一次进入这个函数的时候，变量a被初始化为10！并接着自减1，以后每次进入该函数，a<br>    return count–; &#x2F;&#x2F;就不会被再次初始化了，仅进行自减1的操作；在static发明前，要达到同样的功能，则只能使用全局变量：    </p><p>}</p><p>int count &#x3D; 1;</p><p>int main(void)<br>{<br>     printf(“global\t\tlocal static\n”);<br>     for(; count &lt;&#x3D; 10; ++count)<br>               printf(“%d\t\t%d\n”, count, fun());<br>     return 0;<br>}</p><p>程序的运行结果是：<br>global  local static<br>1 10<br>2 9<br>3 8<br>4 7<br>5 6<br>6 5<br>7 4<br>8 3<br>9 2<br>10 1</p><p>—基于以上两点可以得出一个结论：把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。</p><h3 id="3-默认初始化为0"><a href="#3-默认初始化为0" class="headerlink" title="3. 默认初始化为0"></a>3. 默认初始化为0</h3><p>其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加‘\0’;太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是‘\0’;不妨做个小实验验证一下。</p><p>＃include &lt;stdio.h&gt;</p><p>int a;</p><p>int main()<br>{<br>     int i;<br>     static char str[10];<br>     printf(“integer: %d; string: (begin)%s(end)”, a, str);<br>     return 0;<br>}</p><p>程序的运行结果是：<br>integer: 0; string: (begin) (end) </p><p>最后对static的三条作用做一句话总结。首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0. </p><h3 id="4-类成员声明static"><a href="#4-类成员声明static" class="headerlink" title="4. 类成员声明static"></a>4. 类成员声明static</h3><p>4.static的第四个作用：C++中的类成员声明static（有些地方与以上作用重叠）<br> 在类中声明static变量或者函数时，初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员，这样就出现以下作用：<br>(1)类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致 了它仅能访问类的静态数据和静态成员函数。<br>(2)不能将静态成员函数定义为虚函数。<br>(3)由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊 ，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”。<br>(4)由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就 产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based X W indow系统结合，同时也成功的应用于线程函数身上。 （这条没遇见过）<br>(5)static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问 时间，节省了子类的内存空间。<br>(6)静态数据成员在&lt;定义或说明&gt;时前面加关键字static。<br>(7)静态数据成员是静态存储的，所以必须对它进行初始化。 （程序员手动初始化，否则编译时一般不会报错，但是在Link时会报错误）<br>(8)静态成员初始化与一般数据成员初始化不同:<br>初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；<br>初始化时不加该成员的访问权限控制符private，public等；<br>初始化时使用作用域运算符来标明它所属类；<br>           所以我们得出静态数据成员初始化的格式：<br>&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;&#x3D;&lt;值&gt;<br>(9)为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。</p>]]></content>
    
    
    <summary type="html">static关键字 </summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中的extern关键字</title>
    <link href="http://example.com/2022/05/25/C-%E4%B8%AD%E7%9A%84extern%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://example.com/2022/05/25/C-%E4%B8%AD%E7%9A%84extern%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2022-05-25T05:33:34.000Z</published>
    <updated>2022-05-25T07:43:21.459Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><ul><li><p>ref:<br><a href="https://www.jianshu.com/p/165b3410b7fa">https://www.jianshu.com/p/165b3410b7fa</a></p><p><a href="https://blog.csdn.net/z702143700/article/details/46805241">https://blog.csdn.net/z702143700/article/details/46805241</a></p><p><a href="https://sites.google.com/site/anythingiikegc/ge-zhong-jiao-cheng/c-ji-qiao/duo-wen-jian-bian-liang-gong-xiang">https://sites.google.com/site/anythingiikegc/ge-zhong-jiao-cheng/c-ji-qiao/duo-wen-jian-bian-liang-gong-xiang</a></p><p><a href="https://developer.aliyun.com/article/338215">https://developer.aliyun.com/article/338215</a></p></li></ul><h2 id="用法一：调用外部变量或者函数"><a href="#用法一：调用外部变量或者函数" class="headerlink" title="用法一：调用外部变量或者函数"></a>用法一：调用外部变量或者函数</h2><h3 id="1-调用别的源文件中的全局变量"><a href="#1-调用别的源文件中的全局变量" class="headerlink" title="1.调用别的源文件中的全局变量"></a>1.调用别的源文件中的全局变量</h3><p><img src="https://files.mdnice.com/user/1489/4a313c7f-5abb-4611-871e-c33900417721.png"></p><ul><li><p>这里需要注意的是，被引用的变量v的链接属性必须是外链接（external）的，也就是说a.cpp要引用到v，不只是取决于在a.cpp中声明extern int v，还取决于变量v本身是能够被引用到的。</p></li><li><p>这涉及到c语言的另外一个话题－－变量的作用域。能够被其他模块以extern修饰符引用到的变量通常是<code>全局变量</code>。</p></li><li><p>还有很重要的一点是，extern int v可以放在a.cpp中的任何地方，比如你可以在a.cpp中的函数fun定义的开头处声明extern int v，然后就可以引用到变量v了，只不过这样只能在函数fun作用域中引用v罢了，这还是变量作用域的问题。对于这一点来说，很多人使用的时候都心存顾虑。好像extern声明只能用于文件作用域似的。</p></li><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在一个源文件里定义了一个数组：char a[6];</span><br><span class="line">在另外一个文件里</span><br><span class="line">用下列语句进行了声明：extern char *a；</span><br><span class="line">请问，这样可以吗？</span><br><span class="line">答案与分析：</span><br><span class="line">1)、不可以，程序运行时会告诉你非法访问。</span><br><span class="line">原因在于，指向类型T的指针并不等价于类型T的数组。</span><br><span class="line">extern char *a声明的是一个指针变量而不是字符数组，</span><br><span class="line">因此与实际的定义不同，从而造成运行时非法访问。</span><br><span class="line">应该将声明改为extern char a[ ]。</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-调用别的源文件中的函数"><a href="#2-调用别的源文件中的函数" class="headerlink" title="2.调用别的源文件中的函数"></a>2.调用别的源文件中的函数</h3><p><img src="https://files.mdnice.com/user/1489/a3c10e0e-c534-4dbd-83e2-2b241b9a32de.png"></p><ul><li><p>全局函数的声明语句中，关键字extern可以省略，因为全局函数默认是extern类型的。</p></li><li><p>从本质上来讲，变量和函数没有区别。函数名是指向函数二进制块开头处的指针。</p></li><li><p>如果文件a.cpp需要引用b.cpp中的函数，比如在b.cpp中原型是int fun(int mu)，那么就可以在a.cpp中声明extern int fun（int mu），然后就能使用fun来做任何事情。</p></li><li><p>就像变量的声明一样，extern int fun（int mu）可以放在a.cpp中任何地方，而不一定非要放在a.cpp的文件作用域的范围中。</p></li><li><p>对其他模块中函数的引用，最常用的方法是包含这些函数声明的头文件。使用extern和包含头文件来引用函数有什么区别呢？extern的引用方式比包含头文件要简洁得多！extern的使用方法是直接了当的，想引用哪个函数就用extern声明哪个函数。</p></li><li><p>这样做的一个明显的好处是，会加速程序的编译（确切的说是预处理）的过程，节省时间。在大型C程序编译过程中，这种差异是非常明显的。</p></li></ul><p><img src="https://files.mdnice.com/user/1489/0134c5d4-c375-4cc1-a7f5-4ef39bcc018b.png"></p><h3 id="3-调用别的头文件中的变量-x2F-函数"><a href="#3-调用别的头文件中的变量-x2F-函数" class="headerlink" title="3.调用别的头文件中的变量&#x2F;函数"></a>3.调用别的头文件中的变量&#x2F;函数</h3><p><img src="https://files.mdnice.com/user/1489/ae484341-5802-40e2-86ae-9628b14b3bee.png"></p><ul><li>通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。例如，如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块A编译生成的目标代码中找到此函数。</li><li><code>extern int a;</code>  仅仅是一个变量的声明，其并不是在定义变量a，并未为a分配内存空间。变量a在所有模块中作为一种全局变量只能被定义一次，否则会出现连接错误。</li><li>externint a; &#x2F;&#x2F;属于声明<br> externint a &#x3D; 10; &#x2F;&#x2F;属于定义</li><li>声明可以拷贝n次，但是定义只能定义一次。</li><li>extern作为声明使用，就是告诉当前编译单元，不要为这个extern修饰的变量分配空间，这个变量已经在别的编译单元分配了空间。 </li><li>extern作为定义使用，用于创建外部变量，也可以认为是全局变量。</li></ul><h2 id="用法二：调用C方式的变量或者函数"><a href="#用法二：调用C方式的变量或者函数" class="headerlink" title="用法二：调用C方式的变量或者函数"></a>用法二：调用C方式的变量或者函数</h2><p>C方式编译和C++方式编译<br>相对于C，C++中新增了诸如重载等新特性，对于他们的编译，必然有一些重要的区别。<br>我们将下面的小程序分别按C和C++方式编译，来探讨两种编译方式的区别。</p><p><img src="https://files.mdnice.com/user/1489/e32d34cc-a6e2-4d82-99c4-997af31ebeed.png"></p><ul><li>extern “C” 包含双重含义，从字面上即可得到：首先，被它修饰的目标是“extern”的；其次，被它修饰的目标是“C”的。</li></ul><h3 id="1-Cpp文件调用C文件中的函数"><a href="#1-Cpp文件调用C文件中的函数" class="headerlink" title="1. Cpp文件调用C文件中的函数"></a>1. Cpp文件调用C文件中的函数</h3><p><img src="https://files.mdnice.com/user/1489/c24ed20c-5231-4b99-9167-367ad4176df0.png"></p><p><img src="https://files.mdnice.com/user/1489/e9f8624a-4cac-4cd0-9116-35069a4cb672.png"></p><p><img src="https://files.mdnice.com/user/1489/bf8dc9e4-4300-440a-9327-91e313099c3d.png"></p><h3 id="2-Cpp文件调用C文件中的变量"><a href="#2-Cpp文件调用C文件中的变量" class="headerlink" title="2. Cpp文件调用C文件中的变量"></a>2. Cpp文件调用C文件中的变量</h3><p><img src="https://files.mdnice.com/user/1489/8a6a50fc-2786-4522-b222-bebc06865a71.png"></p><p><img src="https://files.mdnice.com/user/1489/09df49c3-a940-4c93-aabd-c7945a7bc37a.png"></p><p><img src="https://files.mdnice.com/user/1489/980c0aa6-51ec-47ac-868a-2a27518dab2c.png"></p><h3 id="3-Cpp文件调用C方式的头文件"><a href="#3-Cpp文件调用C方式的头文件" class="headerlink" title="3. Cpp文件调用C方式的头文件"></a>3. Cpp文件调用C方式的头文件</h3><p><img src="https://files.mdnice.com/user/1489/4c686ecf-a08a-4282-85b3-7ec79dddc1a2.png"></p><ul><li>例二</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//Out.h</span><br><span class="line">#ifdef __cplusplus          //该段代码引用网上的...，     </span><br><span class="line">extern &quot;C&quot;&#123;</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">#include &lt;stdio.h&gt;         </span><br><span class="line"> extern void aa();</span><br><span class="line">                                  </span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Out.c</span><br><span class="line">#include &quot;Out.h&quot;</span><br><span class="line">void aa()</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;aa is running&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//Test.cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &quot;Out.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123; </span><br><span class="line">   aa();</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例三</p><p><img src="https://files.mdnice.com/user/1489/3617915f-d89e-44db-8751-c27d958e4b60.png"></p>]]></content>
    
    
    <summary type="html"> extern关键字</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>SSH的原理及常用命令</title>
    <link href="http://example.com/2022/05/24/SSH%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/05/24/SSH%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2022-05-24T04:27:47.000Z</published>
    <updated>2022-05-24T04:33:27.849Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="SSH的含义"><a href="#SSH的含义" class="headerlink" title="SSH的含义"></a>SSH的含义</h2><ul><li><p>SSH是一个应用层协议，专为远程登录会话和其他网络服务提供安全性的保障，防止信息泄露问题。</p></li><li><p>ssh服务端由2部分组成： openssh(提供ssh服务)    openssl(提供加密的程序)</p></li><li><p>ssh的客户端可以用 XShell，XManager、SecureCRT，Putty、Mobaxterm  等工具进行远程连接、登录</p></li></ul><p><img src="https://files.mdnice.com/user/1489/55e5275f-20b0-4e30-b3d1-cce30d62f991.png"></p><h2 id="SSH的历史"><a href="#SSH的历史" class="headerlink" title="SSH的历史"></a>SSH的历史</h2><ul><li>1995年，芬兰学者Tatu Ylonen设计了SSH协议，</li><li>SSH 为 Secure SHell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；</li><li>SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括 HP-UX、Linux、Unix、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。</li><li>　　SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。</li></ul><h2 id="SSH的原理"><a href="#SSH的原理" class="headerlink" title="SSH的原理"></a>SSH的原理</h2><p>SSH(远程连接工具)连接原理：ssh服务是一个守护进程(demon)，系统后台监听客户端的连接，ssh服务端的进程名为sshd，负责实时监听客户端的请求(IP 22默认端口)，包括公共秘钥等交换等信息。</p><p>服务器启动的时候自己产生一个密钥(768bit公钥)，本地的ssh客户端发送连接请求到ssh服务器，服务器检查连接点客户端发送的数据和IP地址，确认合法后，ssh服务器会发送密钥(768bits)给客户端，此时客户端将本地私钥(256bit)和服务器的公钥(768bit)结合成密钥对key(1024bit)，发回给服务器端，建立连接通过key-pair数据传输。</p><h4 id="基于口令的认证-密码登录"><a href="#基于口令的认证-密码登录" class="headerlink" title="基于口令的认证-密码登录"></a>基于口令的认证-密码登录</h4><p><img src="https://files.mdnice.com/user/1489/20d1c527-81d7-46a9-a59c-30311d225a56.png"></p><p><img src="https://files.mdnice.com/user/1489/20a4b7b5-a888-4502-bd09-d5f9c8e98d9c.png"></p><p><img src="https://files.mdnice.com/user/1489/039079ca-b2f9-4b7d-91c5-fc5a3a48ab9e.png"></p><h4 id="基于公钥的认证-免密码登录"><a href="#基于公钥的认证-免密码登录" class="headerlink" title="基于公钥的认证-免密码登录"></a>基于公钥的认证-免密码登录</h4><p><img src="https://files.mdnice.com/user/1489/76ed9dfe-103d-481d-b967-26d9a002f8d1.png"></p><p><img src="https://files.mdnice.com/user/1489/aab013b5-dcfd-4e5b-888e-e5d267c93af7.png"></p><p><img src="https://files.mdnice.com/user/1489/237873e0-cfe1-487b-8ee3-9dad77e29941.png"></p><h2 id="SSH的有关命令"><a href="#SSH的有关命令" class="headerlink" title="SSH的有关命令"></a>SSH的有关命令</h2><h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><p><img src="https://files.mdnice.com/user/1489/b63bd863-def7-4054-a836-c6c90537e0ab.png"></p><p><img src="https://files.mdnice.com/user/1489/29e92daf-1ec4-4f50-92b2-e8a555a9e3bc.png"></p><h3 id="登录操作"><a href="#登录操作" class="headerlink" title="登录操作"></a>登录操作</h3><p><img src="https://files.mdnice.com/user/1489/f044672e-b952-49f1-801d-fa4cebafe9ab.png"></p><h3 id="发送文件"><a href="#发送文件" class="headerlink" title="发送文件"></a>发送文件</h3><p><img src="https://files.mdnice.com/user/1489/c0101bb6-c185-440f-a931-c4a3ed713bfa.png"></p><h3 id="远程执行指令"><a href="#远程执行指令" class="headerlink" title="远程执行指令"></a>远程执行指令</h3><p><img src="https://files.mdnice.com/user/1489/cff768f1-19f0-4999-9179-746b6d5c293a.png"></p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p><a href="https://blog.mimvp.com/article/37361.html">ref : ssh常用命令</a></p>]]></content>
    
    
    <summary type="html">SSH的原理及常用命令 </summary>
    
    
    
    <category term="Linux命令" scheme="http://example.com/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
    <category term="Linux命令" scheme="http://example.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>原型模式C++实现</title>
    <link href="http://example.com/2022/05/21/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/05/21/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-05-20T23:47:46.000Z</published>
    <updated>2022-05-20T23:50:45.814Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/huangyimo/article/details/80390001">原型模式有什么用？</a></p><p><a href="https://blog.csdn.net/chenxun_2010/article/details/48327231">原型模式怎么实现?</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resume</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="type">char</span>* name;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Resume* <span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteResume</span>:<span class="keyword">public</span> Resume&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">ConcreteResume</span>(<span class="type">char</span>* str)&#123;</span><br><span class="line">             name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str)+<span class="number">1</span>];</span><br><span class="line">             <span class="built_in">strcpy</span>(name,str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ConcreteResume</span>(<span class="type">const</span> ConcreteResume&amp; r1)&#123;</span><br><span class="line">            name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(r1.name)+<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(name,r1.name);</span><br><span class="line">        &#125;</span><br><span class="line">        ConcreteResume&amp; <span class="keyword">operator</span>&amp;=(<span class="type">const</span> ConcreteResume&amp; r1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;r1)&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">            <span class="keyword">delete</span>[] name;</span><br><span class="line">            name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(r1.name)+<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(name,r1.name);</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">ConcreteResume* <span class="title">clone</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteResume</span>(*<span class="keyword">this</span>);</span><br><span class="line">        &#125; </span><br><span class="line">       <span class="comment">//debug</span></span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">PinrtInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(name);i++)&#123;</span><br><span class="line">                cout&lt;&lt;name[i]&lt;&lt;endl;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> str[]  = <span class="string">&quot;happy&quot;</span>;</span><br><span class="line">    <span class="function">ConcreteResume <span class="title">r1</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="function">ConcreteResume <span class="title">r2</span><span class="params">(r1)</span></span>;</span><br><span class="line">    <span class="type">char</span> str1[]  = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">    <span class="function">ConcreteResume <span class="title">r3</span><span class="params">(str1)</span></span>;</span><br><span class="line">    r3 = r1;</span><br><span class="line">    <span class="comment">// r3.PinrtInfo();</span></span><br><span class="line">    ConcreteResume *r4 = r3.<span class="built_in">clone</span>();</span><br><span class="line">    r4-&gt;<span class="built_in">PinrtInfo</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html"> 原型模式C++实现</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>外观模式C++实现</title>
    <link href="http://example.com/2022/05/20/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/05/20/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-05-20T03:46:56.000Z</published>
    <updated>2022-05-20T03:49:14.933Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://blog.csdn.net/leonardohaig/article/details/106557237">ref: 外观模式</a></p><p><img src="https://files.mdnice.com/user/1489/d2ca3fbe-6e0e-43d1-95fd-f6e0ae22d2c1.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Control</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Control</span>() = <span class="keyword">default</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>: <span class="keyword">public</span> Control&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;the screen start!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;the screen close!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Keyboard</span>: <span class="keyword">public</span> Control&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;the Keyboard start!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;the Keyboard close!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Host</span>: <span class="keyword">public</span> Control&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;the Keyboard start!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;the Keyboard close!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Host host;</span><br><span class="line">        Keyboard keyboard;</span><br><span class="line">        Screen screen;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">            host.<span class="built_in">start</span>();</span><br><span class="line">            keyboard.<span class="built_in">start</span>();</span><br><span class="line">            screen.<span class="built_in">start</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">            host.<span class="built_in">close</span>();</span><br><span class="line">            keyboard.<span class="built_in">close</span>();</span><br><span class="line">            screen.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Computer computer;</span><br><span class="line">    computer.<span class="built_in">start</span>();</span><br><span class="line">    computer.<span class="built_in">close</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">外观模式C++实现 </summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>系统设计时的常用算法</title>
    <link href="http://example.com/2022/05/20/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%97%B6%E7%9A%84%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2022/05/20/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%97%B6%E7%9A%84%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</id>
    <published>2022-05-20T03:46:56.000Z</published>
    <updated>2022-12-09T06:33:06.735Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/>]]></content>
    
    
    <summary type="html">系统设计时的常用算法 </summary>
    
    
    
    <category term="系统设计" scheme="http://example.com/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="系统设计" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>代理模式C++实现</title>
    <link href="http://example.com/2022/05/19/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/05/19/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-05-19T07:44:25.000Z</published>
    <updated>2022-05-19T07:46:47.358Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/m0_46308273/article/details/117193671">ref : 代理模式</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoSite</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">watchFreemovie</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">watchVipmovie</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">watchSVipmovie</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span>:<span class="keyword">public</span> VideoSite&#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchFreemovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             cout&lt;&lt;<span class="string">&quot;You are watching Free Movie.&quot;</span>&lt;&lt;endl;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchVipmovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             cout&lt;&lt;<span class="string">&quot;You are watching Vip Movie.&quot;</span>&lt;&lt;endl;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchSVipmovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             cout&lt;&lt;<span class="string">&quot;You are watching SVip Movie.&quot;</span>&lt;&lt;endl;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FreeUesrProxy</span>:<span class="keyword">public</span> VideoSite&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        RealSubject* realSubject;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">FreeUesrProxy</span>()&#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> RealSubject;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">FreeUesrProxy</span>()&#123;</span><br><span class="line">            <span class="keyword">delete</span> realSubject;</span><br><span class="line">            realSubject = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">watchFreemovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             realSubject-&gt;<span class="built_in">watchFreemovie</span>();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchVipmovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             cout&lt;&lt;<span class="string">&quot;You cannot watch Vip Movie.&quot;</span>&lt;&lt;endl;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchSVipmovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             cout&lt;&lt;<span class="string">&quot;You cannot watch SVip Movie.&quot;</span>&lt;&lt;endl;</span><br><span class="line">         &#125;        </span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VipUserProxy</span>:<span class="keyword">public</span> VideoSite&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        RealSubject* realSubject;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">VipUserProxy</span>()&#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> RealSubject;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">VipUserProxy</span>()&#123;</span><br><span class="line">            <span class="keyword">delete</span> realSubject;</span><br><span class="line">            realSubject = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">watchFreemovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             realSubject-&gt;<span class="built_in">watchFreemovie</span>();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchVipmovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             realSubject-&gt;<span class="built_in">watchVipmovie</span>();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchSVipmovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             cout&lt;&lt;<span class="string">&quot;You cannot watch SVip Movie.&quot;</span>&lt;&lt;endl;</span><br><span class="line">         &#125;        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SVipUserProxy</span>:<span class="keyword">public</span> VideoSite&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        RealSubject* realSubject;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">SVipUserProxy</span>()&#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> RealSubject;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">SVipUserProxy</span>()&#123;</span><br><span class="line">            <span class="keyword">delete</span> realSubject;</span><br><span class="line">            realSubject = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">watchFreemovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             realSubject-&gt;<span class="built_in">watchFreemovie</span>();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchVipmovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             realSubject-&gt;<span class="built_in">watchVipmovie</span>();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchSVipmovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">            realSubject-&gt;<span class="built_in">watchSVipmovie</span>();</span><br><span class="line">         &#125;  </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">watchMovie</span><span class="params">(VideoSite* videoSite)</span></span>&#123;</span><br><span class="line">    videoSite-&gt;<span class="built_in">watchFreemovie</span>();</span><br><span class="line">    videoSite-&gt;<span class="built_in">watchVipmovie</span>();</span><br><span class="line">    videoSite-&gt;<span class="built_in">watchSVipmovie</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    VideoSite* videoSite = <span class="keyword">new</span> <span class="built_in">VipUserProxy</span>();</span><br><span class="line">    <span class="built_in">watchMovie</span>(videoSite);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">代理模式的C++实现 </summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>装饰器模式C++实现</title>
    <link href="http://example.com/2022/05/19/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/05/19/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-05-19T06:03:01.000Z</published>
    <updated>2022-05-19T06:07:01.291Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/walkerkalr/article/details/28633123">ref: 装饰器模式</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Beverage</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        string description;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> string <span class="title">getCost</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> string <span class="title">getDescription</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MilkTea</span>: <span class="keyword">public</span> Beverage&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string costNum;</span><br><span class="line">        <span class="built_in">MilkTea</span>()&#123;</span><br><span class="line">            description = <span class="string">&quot;milkTea&quot;</span>;</span><br><span class="line">            costNum = <span class="string">&quot;￥15&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">getCost</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> costNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">getDescription</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> description;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decorater</span>:<span class="keyword">public</span> Beverage &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        Beverage* beverage ;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> string <span class="title">getCost</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> string <span class="title">getDescription</span><span class="params">()</span></span>&#123;&#125;;         </span><br><span class="line">        <span class="built_in">Decorater</span>(Beverage* newBeverage)&#123;</span><br><span class="line">            beverage = newBeverage;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zhenzhu</span>:<span class="keyword">public</span> Decorater&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string costNum;</span><br><span class="line">        string description;</span><br><span class="line">        <span class="built_in">Zhenzhu</span>(Beverage* newBeverage):<span class="built_in">Decorater</span>(newBeverage)&#123;</span><br><span class="line">            costNum = <span class="string">&quot;￥3&quot;</span>;</span><br><span class="line">            description = <span class="string">&quot; add Zhenzhu&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function">string <span class="title">getCost</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> beverage-&gt;<span class="built_in">getCost</span>()+<span class="string">&quot;+&quot;</span>+costNum;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">getDescription</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> beverage-&gt;<span class="built_in">getDescription</span>()+description;</span><br><span class="line">            </span><br><span class="line">        &#125;        </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Yeguo</span>:<span class="keyword">public</span> Decorater&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string costNum;</span><br><span class="line">        string description;</span><br><span class="line">        <span class="built_in">Yeguo</span>(Beverage* newBeverage):<span class="built_in">Decorater</span>(newBeverage)&#123;</span><br><span class="line">            costNum = <span class="string">&quot;￥4&quot;</span>;</span><br><span class="line">            description = <span class="string">&quot; add Yeguo&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function">string <span class="title">getCost</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> beverage-&gt;<span class="built_in">getCost</span>()+<span class="string">&quot;+&quot;</span>+costNum;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">getDescription</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> beverage-&gt;<span class="built_in">getDescription</span>()+description;</span><br><span class="line">            </span><br><span class="line">        &#125;      </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Beverage* newMilkTea = <span class="keyword">new</span> MilkTea;</span><br><span class="line">    cout&lt;&lt;newMilkTea-&gt;<span class="built_in">getDescription</span>()&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;newMilkTea-&gt;<span class="built_in">getCost</span>()&lt;&lt;endl;</span><br><span class="line">    newMilkTea = <span class="keyword">new</span> <span class="built_in">Zhenzhu</span>(newMilkTea);</span><br><span class="line">    cout&lt;&lt;newMilkTea-&gt;<span class="built_in">getDescription</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;newMilkTea-&gt;<span class="built_in">getCost</span>()&lt;&lt;endl;</span><br><span class="line">    newMilkTea = <span class="keyword">new</span> <span class="built_in">Yeguo</span>(newMilkTea);</span><br><span class="line">    cout&lt;&lt;newMilkTea-&gt;<span class="built_in">getDescription</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;newMilkTea-&gt;<span class="built_in">getCost</span>()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">装饰器模式C++实现 </summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
