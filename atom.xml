<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog of Chen</title>
  
  <subtitle>陈同学的博客</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-27T08:14:59.793Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode problems Solutions Note</title>
    <link href="http://example.com/2022/08/22/Leetcode-problems-Solutions-Note/"/>
    <id>http://example.com/2022/08/22/Leetcode-problems-Solutions-Note/</id>
    <published>2022-08-22T14:45:47.000Z</published>
    <updated>2022-08-27T08:14:59.793Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a><a href="https://leetcode.cn/problems/two-sum/">1. Two Sum</a></h1><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。<br>示例 2：</p><p>输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]<br>示例 3：</p><p>输入：nums &#x3D; [3,3], target &#x3D; 6<br>输出：[0,1] </p><p>提示：</p><p>2 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>-109 &lt;&#x3D; target &lt;&#x3D; 109<br>只会存在一个有效答案<br>进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？</p><h2 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h2><p>双层遍历</p><h2 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h2><p>哈希表</p><h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h1><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p> </p><p>示例 1：</p><p>输入：digits &#x3D; “23”<br>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]<br>示例 2：</p><p>输入：digits &#x3D; “”<br>输出：[]<br>示例 3：</p><p>输入：digits &#x3D; “2”<br>输出：[“a”,”b”,”c”] </p><p>提示：</p><p>0 &lt;&#x3D; digits.length &lt;&#x3D; 4<br>digits[i] 是范围 [‘2’, ‘9’] 的一个数字。</p><h2 id="Solution-1-暴力"><a href="#Solution-1-暴力" class="headerlink" title="Solution 1  暴力"></a>Solution 1  暴力</h2><h2 id="Soulution-2-回溯"><a href="#Soulution-2-回溯" class="headerlink" title="Soulution 2  回溯"></a>Soulution 2  回溯</h2><p><img src="https://files.mdnice.com/user/1489/eb7c965d-59c0-4b08-8d6a-6d3943f10cf5.png"><br><img src="https://files.mdnice.com/user/1489/7821e311-00aa-40b0-8ab9-57471419d97b.png"></p><h2 id="Solution-3-队列"><a href="#Solution-3-队列" class="headerlink" title="Solution 3  队列"></a>Solution 3  队列</h2><p><img src="https://files.mdnice.com/user/1489/cd61b224-e4ae-4271-bef4-076a650f65b3.png"></p><p><img src="https://files.mdnice.com/user/1489/e078bf30-d641-4c56-b4c9-8d1da707d807.png"></p><p><img src="https://files.mdnice.com/user/1489/e4fa6f50-22c9-41c7-8f6c-e43aab780585.png"></p><h1 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode.cn/problems/4sum/">18. 四数之和</a></h1><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：</p><p>0 &lt;&#x3D; a, b, c, d &lt; n<br>a、b、c 和 d 互不相同<br>nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target<br>你可以按 任意顺序 返回答案 。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0<br>输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]<br>示例 2：</p><p>输入：nums &#x3D; [2,2,2,2,2], target &#x3D; 8<br>输出：[[2,2,2,2]] </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 200<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>-109 &lt;&#x3D; target &lt;&#x3D; 109</p><h2 id="Solution-1-暴力枚举"><a href="#Solution-1-暴力枚举" class="headerlink" title="Solution 1  暴力枚举"></a>Solution 1  暴力枚举</h2><h2 id="Solution-2-双指针法"><a href="#Solution-2-双指针法" class="headerlink" title="Solution 2  双指针法"></a>Solution 2  双指针法</h2><p><img src="https://files.mdnice.com/user/1489/5cd09d98-bd6d-413f-a699-5d03755f5802.png"></p><h1 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list">19. 删除链表的倒数第 N 个结点</a></h1><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p><p> </p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>输出：[1,2,3,5]<br>示例 2：</p><p>输入：head &#x3D; [1], n &#x3D; 1<br>输出：[]<br>示例 3：</p><p>输入：head &#x3D; [1,2], n &#x3D; 1<br>输出：[1] </p><p>提示：</p><p>链表中结点的数目为 sz<br>1 &lt;&#x3D; sz &lt;&#x3D; 30<br>0 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>1 &lt;&#x3D; n &lt;&#x3D; sz </p><h2 id="Solution1-计算链表长度"><a href="#Solution1-计算链表长度" class="headerlink" title="Solution1 计算链表长度"></a>Solution1 计算链表长度</h2><p><img src="https://files.mdnice.com/user/1489/5bfffdd4-470d-482c-849d-e4e82e2b40d8.png"></p><h2 id="Solution2-栈"><a href="#Solution2-栈" class="headerlink" title="Solution2 栈"></a>Solution2 栈</h2><p><img src="https://files.mdnice.com/user/1489/f6e5ea9e-b6b4-4545-97c5-2ef86e5fbd08.png"></p><p><img src="https://files.mdnice.com/user/1489/b3fb36fb-92e9-417d-9c00-60756ed04c17.png"></p><h2 id="Solution3-快慢指针"><a href="#Solution3-快慢指针" class="headerlink" title="Solution3 快慢指针"></a>Solution3 快慢指针</h2><p><img src="https://files.mdnice.com/user/1489/1d658e59-2c76-4ade-a9c5-39a2ff20161f.png"></p><p><img src="https://files.mdnice.com/user/1489/7fc31992-dc5b-4e11-bb5e-7c61942e6e57.png"></p><p>#<a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></p><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。 </p><p>示例 1：</p><p>输入：s &#x3D; “()”<br>输出：true<br>示例 2：</p><p>输入：s &#x3D; “()[]{}”<br>输出：true<br>示例 3：</p><p>输入：s &#x3D; “(]”<br>输出：false<br>示例 4：</p><p>输入：s &#x3D; “([)]”<br>输出：false<br>示例 5：</p><p>输入：s &#x3D; “{[]}”<br>输出：true</p><h2 id="Solution1-栈"><a href="#Solution1-栈" class="headerlink" title="Solution1 栈"></a>Solution1 栈</h2><p><img src="https://files.mdnice.com/user/1489/4097f955-844e-4ceb-a4c1-513342bc6e37.png"></p><p>#<a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></p><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><p>示例 1：</p><p>输入：n &#x3D; 3<br>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]<br>示例 2：</p><p>输入：n &#x3D; 1<br>输出：[“()”]</p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 8</p><h2 id="Solution1-暴力"><a href="#Solution1-暴力" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><p><img src="https://files.mdnice.com/user/1489/9e16db80-4a17-41b8-9d9d-cdef5be73f58.png"></p><h2 id="Solution2-递归-剪枝"><a href="#Solution2-递归-剪枝" class="headerlink" title="Solution2 递归 + 剪枝"></a>Solution2 递归 + 剪枝</h2><p><img src="https://files.mdnice.com/user/1489/10427a40-975c-4b6b-85ff-d17cc899c623.png"></p><h1 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h1><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p> </p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4]<br>输出：[2,1,4,3]<br>示例 2：</p><p>输入：head &#x3D; []<br>输出：[]<br>示例 3：</p><p>输入：head &#x3D; [1]<br>输出：[1]</p><h2 id="Solution1-递归"><a href="#Solution1-递归" class="headerlink" title="Solution1  递归"></a>Solution1  递归</h2><p><img src="https://files.mdnice.com/user/1489/34777dfe-25ba-4a81-883e-b66110b1a8c9.png"></p><h2 id="Solution2-迭代"><a href="#Solution2-迭代" class="headerlink" title="Solution2 迭代"></a>Solution2 迭代</h2><p><img src="https://files.mdnice.com/user/1489/8b223432-03ba-43a5-8968-584c7c8d8068.png"></p><p><img src="https://files.mdnice.com/user/1489/36ee0f58-1bce-411c-b3fc-308d769ad869.png"></p><h1 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="[26. 删除有序数组中的重复项]"></a>[26. 删除有序数组中的重复项]</h1><p>给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。</p><p>由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。</p><p>将最终结果插入 nums 的前 k 个位置后返回 k 。</p><p>不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><p>判题标准:</p><p>系统会用下面的代码来测试你的题解:</p><p>int[] nums &#x3D; […]; &#x2F;&#x2F; 输入数组<br>int[] expectedNums &#x3D; […]; &#x2F;&#x2F; 长度正确的期望答案</p><p>int k &#x3D; removeDuplicates(nums); &#x2F;&#x2F; 调用</p><p>assert k &#x3D;&#x3D; expectedNums.length;<br>for (int i &#x3D; 0; i &lt; k; i++) {<br>    assert nums[i] &#x3D;&#x3D; expectedNums[i];<br>}<br>如果所有断言都通过，那么您的题解将被 通过。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [1,1,2]<br>输出：2, nums &#x3D; [1,2,_]<br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。<br>示例 2：</p><p>输入：nums &#x3D; [0,0,1,1,1,2,2,3,3,4]<br>输出：5, nums &#x3D; [0,1,2,3,4]<br>解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>nums 已按 升序 排列</p><h2 id="Solution1-暴力-1"><a href="#Solution1-暴力-1" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-双指针"><a href="#Solution2-双指针" class="headerlink" title="Solution2 双指针"></a>Solution2 双指针</h2><p><img src="https://files.mdnice.com/user/1489/97cb5a3b-6aaa-4be9-9b17-dde9d86f17ab.png"></p><h2 id="Solution3-双指针-优化"><a href="#Solution3-双指针-优化" class="headerlink" title="Solution3 双指针 优化"></a>Solution3 双指针 优化</h2><p><img src="https://files.mdnice.com/user/1489/80714af6-4b56-4b6d-965a-6d0e396c1b63.png"></p><h1 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列</a></h1><p>整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</p><p>例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。<br>整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><p>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。<br>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。<br>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。<br>给你一个整数数组 nums ，找出 nums 的下一个排列。</p><p>必须 原地 修改，只允许使用额外常数空间。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3]<br>输出：[1,3,2]<br>示例 2：</p><p>输入：nums &#x3D; [3,2,1]<br>输出：[1,2,3]<br>示例 3：</p><p>输入：nums &#x3D; [1,1,5]<br>输出：[1,5,1] </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 100<br>0 &lt;&#x3D; nums[i] &lt;&#x3D; 100</p><h2 id="Solution1-暴力-2"><a href="#Solution1-暴力-2" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h2><p><img src="https://files.mdnice.com/user/1489/997007a2-0e00-49d3-88fc-6865a7578af8.png"></p><h1 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h1><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0<br>输出：4<br>示例 2：</p><p>输入：nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3<br>输出：-1<br>示例 3：</p><p>输入：nums &#x3D; [1], target &#x3D; 0<br>输出：-1 </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 5000<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>nums 中的每个值都 独一无二<br>题目数据保证 nums 在预先未知的某个下标上进行了旋转<br>-104 &lt;&#x3D; target &lt;&#x3D; 104</p><h2 id="Solution1-暴力-3"><a href="#Solution1-暴力-3" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-二分查找"><a href="#Solution2-二分查找" class="headerlink" title="Solution2 二分查找"></a>Solution2 二分查找</h2><p><img src="https://files.mdnice.com/user/1489/60ec6cc2-9148-40df-ad8e-2969def89c43.png"></p><h1 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h1><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8<br>输出：[3,4]<br>示例 2：</p><p>输入：nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6<br>输出：[-1,-1]<br>示例 3：</p><p>输入：nums &#x3D; [], target &#x3D; 0<br>输出：[-1,-1] </p><p>提示：</p><p>0 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>nums 是一个非递减数组<br>-109 &lt;&#x3D; target &lt;&#x3D; 109</p><h2 id="Solution1-暴力-4"><a href="#Solution1-暴力-4" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-二分"><a href="#Solution2-二分" class="headerlink" title="Solution2 二分"></a>Solution2 二分</h2><p>二分搜索讲解<br><a href="https://www.bilibili.com/video/BV1fA4y1o715?spm_id_from=0.0.header_right.history_list.click">https://www.bilibili.com/video/BV1fA4y1o715?spm_id_from=0.0.header_right.history_list.click</a></p><p>寻找target在数组里的左右边界，有如下三种情况：</p><ul><li>情况一：target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1}</li><li>情况二：target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1}</li><li>情况三：target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{1, 1}</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int leftBorder = getLeftBorder(nums, target);</span><br><span class="line">        int rightBorder = getRightBorder(nums, target);</span><br><span class="line">        // 情况一</span><br><span class="line">        if (leftBorder == -2 || rightBorder == -2) return &#123;-1, -1&#125;;</span><br><span class="line">        // 情况三</span><br><span class="line">        if (rightBorder - leftBorder &gt; 1) return &#123;leftBorder + 1, rightBorder - 1&#125;;</span><br><span class="line">        // 情况二</span><br><span class="line">        return &#123;-1, -1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">     int getRightBorder(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.size() - 1;</span><br><span class="line">        int rightBorder = -2; // 记录一下rightBorder没有被赋值的情况</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int middle = left + ((right - left) / 2);</span><br><span class="line">            if (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - 1;</span><br><span class="line">            &#125; else &#123; // 寻找右边界，nums[middle] == target的时候更新left</span><br><span class="line">                left = middle + 1;</span><br><span class="line">                rightBorder = left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return rightBorder;</span><br><span class="line">    &#125;</span><br><span class="line">    int getLeftBorder(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = nums.size() - 1;</span><br><span class="line">        int leftBorder = -2; // 记录一下leftBorder没有被赋值的情况</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int middle = left + ((right - left) / 2);</span><br><span class="line">            if (nums[middle] &gt;= target) &#123; // 寻找左边界，nums[middle] == target的时候更新right</span><br><span class="line">                right = middle - 1;</span><br><span class="line">                leftBorder = right;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                left = middle + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return leftBorder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a><a href=""></a></h1><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><p> </p><p>示例 1:</p><p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 5<br>输出: 2<br>示例 2:</p><p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 2<br>输出: 1<br>示例 3:</p><p>输入: nums &#x3D; [1,3,5,6], target &#x3D; 7<br>输出: 4</p><h2 id="Solution1-暴力-5"><a href="#Solution1-暴力-5" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int searchInsert(int[] nums, int target) &#123;</span><br><span class="line">    for(int i = 0; i &lt; nums.length;i++)&#123;</span><br><span class="line">        if(nums[i] &gt;= target)&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Solution2-二分-1"><a href="#Solution2-二分-1" class="headerlink" title="Solution2 二分"></a>Solution2 二分</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = n; // 定义target在左闭右开的区间里，[left, right)  target</span><br><span class="line">        while (left &lt; right) &#123; // 因为left == right的时候，在[left, right)是无效的空间</span><br><span class="line">            int middle = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">            if (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle; // target 在左区间，在[left, middle)中</span><br><span class="line">            &#125; else if (nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + 1; // target 在右区间，在 [middle+1, right)中</span><br><span class="line">            &#125; else &#123; // nums[middle] == target</span><br><span class="line">                return middle; // 数组中找到目标值的情况，直接返回下标</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 分别处理如下四种情况</span><br><span class="line">        // 目标值在数组所有元素之前 [0,0)</span><br><span class="line">        // 目标值等于数组中某一个元素 return middle</span><br><span class="line">        // 目标值插入数组中的位置 [left, right) ，return right 即可</span><br><span class="line">        // 目标值在数组所有元素之后的情况 [left, right)，这是右开区间，return right 即可</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h1><h2 id="Solution1-暴力-6"><a href="#Solution1-暴力-6" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-回溯"><a href="#Solution2-回溯" class="headerlink" title="Solution2 回溯"></a>Solution2 回溯</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void dfs(vector&lt;int&gt;&amp; candidates, int target, vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt;&amp; combine, int idx) &#123;</span><br><span class="line">        if (idx == candidates.size()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (target == 0) &#123;</span><br><span class="line">            ans.emplace_back(combine);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 直接跳过</span><br><span class="line">        dfs(candidates, target, ans, combine, idx + 1);</span><br><span class="line">        // 选择当前数</span><br><span class="line">        if (target - candidates[idx] &gt;= 0) &#123;</span><br><span class="line">            combine.emplace_back(candidates[idx]);</span><br><span class="line">            dfs(candidates, target - candidates[idx], ans, combine, idx);</span><br><span class="line">            combine.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        vector&lt;int&gt; combine;</span><br><span class="line">        dfs(candidates, target, ans, combine, 0);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h1><h2 id="Solution1-回溯"><a href="#Solution1-回溯" class="headerlink" title="Solution1 回溯"></a>Solution1 回溯</h2><p>方法一：回溯<br>思路与算法</p><p>由于我们需要求出所有和为 \textit{target}target 的组合，并且每个数只能使用一次，因此我们可以使用递归 + 回溯的方法来解决这个问题：</p><p>我们用 \textit{dfs}(\textit{pos}, \textit{rest})dfs(pos,rest) 表示递归的函数，其中 \textit{pos}pos 表示我们当前递归到了数组 \textit{candidates}candidates 中的第 \textit{pos}pos 个数，而 \textit{rest}rest 表示我们还需要选择和为 \textit{rest}rest 的数放入列表作为一个组合；</p><p>对于当前的第 \textit{pos}pos 个数，我们有两种方法：选或者不选。如果我们选了这个数，那么我们调用 \textit{dfs}(\textit{pos} + 1, \textit{rest} - \textit{candidates}[\textit{pos}])dfs(pos+1,rest−candidates[pos]) 进行递归，注意这里必须满足 \textit{rest} \geq \textit{candidates}[\textit{pos}]rest≥candidates[pos]。如果我们不选这个数，那么我们调用 \textit{dfs}(\textit{pos} + 1, \textit{rest})dfs(pos+1,rest) 进行递归；</p><p>在某次递归开始前，如果 \textit{rest}rest 的值为 00，说明我们找到了一个和为 \textit{target}target 的组合，将其放入答案中。每次调用递归函数前，如果我们选了那个数，就需要将其放入列表的末尾，该列表中存储了我们选的所有数。在回溯时，如果我们选了那个数，就要将其从列表的末尾删除。</p><p>上述算法就是一个标准的递归 + 回溯算法，但是它并不适用于本题。这是因为题目描述中规定了解集不能包含重复的组合，而上述的算法中并没有去除重复的组合。</p><p>例如当 \textit{candidates} &#x3D; [2, 2]candidates&#x3D;[2,2]，\textit{target} &#x3D; 2target&#x3D;2 时，上述算法会将列表 [2][2] 放入答案两次。</p><p>因此，我们需要改进上述算法，在求出组合的过程中就进行去重的操作。我们可以考虑将相同的数放在一起进行处理，也就是说，如果数 \textit{x}x 出现了 yy 次，那么在递归时一次性地处理它们，即分别调用选择 0, 1, \cdots, y0,1,⋯,y 次 xx 的递归函数。这样我们就不会得到重复的组合。具体地：</p><p>我们使用一个哈希映射（HashMap）统计数组 \textit{candidates}candidates 中每个数出现的次数。在统计完成之后，我们将结果放入一个列表 \textit{freq}freq 中，方便后续的递归使用。</p><p>列表 \textit{freq}freq 的长度即为数组 \textit{candidates}candidates 中不同数的个数。其中的每一项对应着哈希映射中的一个键值对，即某个数以及它出现的次数。<br>在递归时，对于当前的第 \textit{pos}pos 个数，它的值为 \textit{freq}[\textit{pos}][0]freq[pos][0]，出现的次数为 \textit{freq}[\textit{pos}][1]freq[pos][1]，那么我们可以调用</p><p>\textit{dfs}(\textit{pos} + 1, \textit{rest} - i \times \textit{freq}[\textit{pos}][0])<br>dfs(pos+1,rest−i×freq[pos][0])</p><p>即我们选择了这个数 ii 次。这里 ii 不能大于这个数出现的次数，并且 i \times \textit{freq}[\textit{pos}][0]i×freq[pos][0] 也不能大于 \textit{rest}rest。同时，我们需要将 ii 个 \textit{freq}[\textit{pos}][0]freq[pos][0] 放入列表中。</p><p>这样一来，我们就可以不重复地枚举所有的组合了。</p><p>我们还可以进行什么优化（剪枝）呢？一种比较常用的优化方法是，我们将 \textit{freq}freq 根据数从小到大排序，这样我们在递归时会先选择小的数，再选择大的数。这样做的好处是，当我们递归到 \textit{dfs}(\textit{pos}, \textit{rest})dfs(pos,rest) 时，如果 \textit{freq}[\textit{pos}][0]freq[pos][0] 已经大于 \textit{rest}rest，那么后面还没有递归到的数也都大于 \textit{rest}rest，这就说明不可能再选择若干个和为 \textit{rest}rest 的数放入列表了。此时，我们就可以直接回溯。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; freq;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">    vector&lt;int&gt; sequence;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void dfs(int pos, int rest) &#123;</span><br><span class="line">        if (rest == 0) &#123;</span><br><span class="line">            ans.push_back(sequence);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (pos == freq.size() || rest &lt; freq[pos].first) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(pos + 1, rest);</span><br><span class="line"></span><br><span class="line">        int most = min(rest / freq[pos].first, freq[pos].second);</span><br><span class="line">        for (int i = 1; i &lt;= most; ++i) &#123;</span><br><span class="line">            sequence.push_back(freq[pos].first);</span><br><span class="line">            dfs(pos + 1, rest - i * freq[pos].first);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt;= most; ++i) &#123;</span><br><span class="line">            sequence.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        for (int num: candidates) &#123;</span><br><span class="line">            if (freq.empty() || num != freq.back().first) &#123;</span><br><span class="line">                freq.emplace_back(num, 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ++freq.back().second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(0, target);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h1><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]<br>示例 2：</p><p>输入：nums &#x3D; [0,1]<br>输出：[[0,1],[1,0]]<br>示例 3：</p><p>输入：nums &#x3D; [1]<br>输出：[[1]] </p><h2 id="Solution1-暴力-7"><a href="#Solution1-暴力-7" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-回溯-1"><a href="#Solution2-回溯-1" class="headerlink" title="Solution2 回溯"></a>Solution2 回溯</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void backtrack(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; output, int first, int len)&#123;</span><br><span class="line">        // 所有数都填完了</span><br><span class="line">        if (first == len) &#123;</span><br><span class="line">            res.emplace_back(output);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = first; i &lt; len; ++i) &#123;</span><br><span class="line">            // 动态维护数组</span><br><span class="line">            swap(output[i], output[first]);</span><br><span class="line">            // 继续递归填下一个数</span><br><span class="line">            backtrack(res, output, first + 1, len);</span><br><span class="line">            // 撤销操作</span><br><span class="line">            swap(output[i], output[first]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">        backtrack(res, nums, 0, (int)nums.size());</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h1><p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p><p> </p><p>示例 1：</p><p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[[7,4,1],[8,5,2],[9,6,3]]<br>示例 2：</p><p>输入：matrix &#x3D; [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]<br>输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] </p><p>提示：</p><p>n &#x3D;&#x3D; matrix.length &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; n &lt;&#x3D; 20<br>-1000 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 1000 </p><h2 id="Solution1-原地查找"><a href="#Solution1-原地查找" class="headerlink" title="Solution1 原地查找"></a>Solution1 原地查找</h2><h2 id="Solution2-先转置再竖直对称反转"><a href="#Solution2-先转置再竖直对称反转" class="headerlink" title="Solution2 先转置再竖直对称反转"></a>Solution2 先转置再竖直对称反转</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        //先转置</span><br><span class="line">        for(int row=0;row&lt;=matrix.size()-1;row++)&#123;</span><br><span class="line"></span><br><span class="line">            for(int col=row;col&lt;=matrix[0].size()-1;col++)&#123;</span><br><span class="line">                swap(matrix[row][col],matrix[col][row]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //在竖直对称翻转</span><br><span class="line">        for(int row=0;row&lt;=matrix.size()-1;row++)&#123;</span><br><span class="line">            for(int col = 0;col&lt;=(matrix.size()-1)/2;col++)&#123;</span><br><span class="line">                swap(matrix[row][col],matrix[row][matrix.size()-1-col]);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></h1><p>给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。</p><p>字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><p> </p><p>示例 1:</p><p>输入: strs &#x3D; [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]<br>示例 2:</p><p>输入: strs &#x3D; [“”]<br>输出: [[“”]]<br>示例 3:</p><p>输入: strs &#x3D; [“a”]<br>输出: [[“a”]] </p><p>提示：</p><p>1 &lt;&#x3D; strs.length &lt;&#x3D; 104<br>0 &lt;&#x3D; strs[i].length &lt;&#x3D; 100<br>strs[i] 仅包含小写字母</p><h2 id="Solution1-Map"><a href="#Solution1-Map" class="headerlink" title="Solution1 Map"></a>Solution1 Map</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        </span><br><span class="line">        map&lt;string,vector&lt;string&gt;&gt;res;</span><br><span class="line">        //遍历 </span><br><span class="line">        for(auto val:strs)&#123;</span><br><span class="line">            string tmp=val;</span><br><span class="line">               //以排序后的str作为key  vector&lt;string&gt;作为value 放进map</span><br><span class="line">            sort(val.begin(),val.end());</span><br><span class="line">            if(res.find(val)==res.end())&#123;</span><br><span class="line">                vector&lt;string&gt; t=&#123;tmp&#125;;</span><br><span class="line">                res.insert(&#123;val,t&#125;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res[val].push_back(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //遍历输出结果</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">        for(auto p:res)&#123;</span><br><span class="line">            result.push_back(p.second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode.cn/problems/powx-n/">50. Pow(x, n)</a></h1><p>实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，xn ）。</p><p> </p><p>示例 1：</p><p>输入：x &#x3D; 2.00000, n &#x3D; 10<br>输出：1024.00000<br>示例 2：</p><p>输入：x &#x3D; 2.10000, n &#x3D; 3<br>输出：9.26100<br>示例 3：</p><p>输入：x &#x3D; 2.00000, n &#x3D; -2<br>输出：0.25000<br>解释：2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25 </p><p>提示：</p><p>-100.0 &lt; x &lt; 100.0<br>-231 &lt;&#x3D; n &lt;&#x3D; 231-1<br>-104 &lt;&#x3D; xn &lt;&#x3D; 104</p><h2 id="Solution1-快速幂-递归"><a href="#Solution1-快速幂-递归" class="headerlink" title="Solution1  快速幂+递归"></a>Solution1  快速幂+递归</h2><p><img src="https://files.mdnice.com/user/1489/56d57700-be9b-4a89-b09c-1d373b1d5318.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double quickMul(double x, long long N) &#123;</span><br><span class="line">        if (N == 0) &#123;</span><br><span class="line">            return 1.0;</span><br><span class="line">        &#125;</span><br><span class="line">        double y = quickMul(x, N / 2);</span><br><span class="line">        return N % 2 == 0 ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double myPow(double x, int n) &#123;</span><br><span class="line">        long long N = n;</span><br><span class="line">        return N &gt;= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h1><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组 是数组中的一个连续部分。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]<br>输出：6<br>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。<br>示例 2：</p><p>输入：nums &#x3D; [1]<br>输出：1<br>示例 3：</p><p>输入：nums &#x3D; [5,4,-1,7,8]<br>输出：23 </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104 </p><h2 id="Solution1-暴力-8"><a href="#Solution1-暴力-8" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-动态规划"><a href="#Solution2-动态规划" class="headerlink" title="Solution2 动态规划"></a>Solution2 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/8a4705a4-439c-4262-bdce-8186ee916289.png"></p><p><img src="https://files.mdnice.com/user/1489/5700074e-68cb-427a-9e58-a1858ab736e1.png"></p><h1 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></h1><p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。</p><p> </p><p>示例 1：</p><p>输入：matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]<br>输出：[1,2,3,6,9,8,7,4,5]<br>示例 2：</p><p>输入：matrix &#x3D; [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br>输出：[1,2,3,4,8,12,11,10,9,5,6,7] </p><p>提示：</p><p>m &#x3D;&#x3D; matrix.length<br>n &#x3D;&#x3D; matrix[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 10<br>-100 &lt;&#x3D; matrix[i][j] &lt;&#x3D; 100</p><h2 id="Solution1-原地遍历"><a href="#Solution1-原地遍历" class="headerlink" title="Solution1 原地遍历"></a>Solution1 原地遍历</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">          if(matrix.empty())&#123;return res;&#125;</span><br><span class="line">        int s=0,x=matrix.size()-1,z=0,y=matrix[0].size()-1;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">        while(true)&#123;</span><br><span class="line">            //在上边沿</span><br><span class="line">            for(int i=s,j=z;j&lt;=y;j++)&#123;</span><br><span class="line">                res.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(++s&gt;x)   break;</span><br><span class="line">            //在右边沿</span><br><span class="line">            for(int i=s,j=y;i&lt;=x;i++)&#123;</span><br><span class="line">                  res.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(--y&lt;z) break;</span><br><span class="line">            //在下边沿</span><br><span class="line">           for(int i=x,j=y;j&gt;=z;j--)&#123;</span><br><span class="line">                  res.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(--x&lt;s) break;</span><br><span class="line">            //在左边沿</span><br><span class="line">           for(int i=x,j=z;i&gt;=s;i--)&#123;</span><br><span class="line">                  res.push_back(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            if(++z&gt;y) break;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution2-按层遍历"><a href="#Solution2-按层遍历" class="headerlink" title="Solution2 按层遍历"></a>Solution2 按层遍历</h2><p><img src="https://files.mdnice.com/user/1489/6fc73b94-e500-4182-a9f9-e1d8a4e29a32.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        if (matrix.size() == 0 || matrix[0].size() == 0) &#123;</span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int rows = matrix.size(), columns = matrix[0].size();</span><br><span class="line">        vector&lt;int&gt; order;</span><br><span class="line">        int left = 0, right = columns - 1, top = 0, bottom = rows - 1;</span><br><span class="line">        while (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">            for (int column = left; column &lt;= right; column++) &#123;</span><br><span class="line">                order.push_back(matrix[top][column]);</span><br><span class="line">            &#125;</span><br><span class="line">            for (int row = top + 1; row &lt;= bottom; row++) &#123;</span><br><span class="line">                order.push_back(matrix[row][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            if (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">                for (int column = right - 1; column &gt; left; column--) &#123;</span><br><span class="line">                    order.push_back(matrix[bottom][column]);</span><br><span class="line">                &#125;</span><br><span class="line">                for (int row = bottom; row &gt; top; row--) &#123;</span><br><span class="line">                    order.push_back(matrix[row][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        return order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h1><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。</p><p> </p><p>示例 1：</p><p>输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].<br>示例 2：</p><p>输入：intervals &#x3D; [[1,4],[4,5]]<br>输出：[[1,5]]<br>解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。 </p><p>提示：</p><p>1 &lt;&#x3D; intervals.length &lt;&#x3D; 104<br>intervals[i].length &#x3D;&#x3D; 2<br>0 &lt;&#x3D; starti &lt;&#x3D; endi &lt;&#x3D; 104</p><h2 id="Solution1-排序"><a href="#Solution1-排序" class="headerlink" title="Solution1 排序"></a>Solution1 排序</h2><p><img src="https://files.mdnice.com/user/1489/e8db6a23-fe74-4f65-b6a6-6cafbddff0bc.png"></p><p>复杂度分析</p><p>时间复杂度：O(n\log n)O(nlogn)，其中 nn 为区间的数量。除去排序的开销，我们只需要一次线性扫描，所以主要的时间开销是排序的 O(n\log n)O(nlogn)。</p><p>空间复杂度：O(\log n)O(logn)，其中 nn 为区间的数量。这里计算的是存储答案之外，使用的额外空间。O(\log n)O(logn) 即为排序所需要的空间复杂度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        if (intervals.size() == 0) &#123;</span><br><span class="line">            return &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(intervals.begin(), intervals.end());</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; merged;</span><br><span class="line">        for (int i = 0; i &lt; intervals.size(); ++i) &#123;</span><br><span class="line">            int L = intervals[i][0], R = intervals[i][1];</span><br><span class="line">            if (!merged.size() || merged.back()[1] &lt; L) &#123;</span><br><span class="line">                merged.push_back(&#123;L, R&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                merged.back()[1] = max(merged.back()[1], R);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a><a href="https://leetcode.cn/problems/rotate-list/">61. 旋转链表</a></h1><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p><p> </p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2<br>输出：[4,5,1,2,3]<br>示例 2：</p><p>输入：head &#x3D; [0,1,2], k &#x3D; 4<br>输出：[2,0,1] </p><p>提示：</p><p>链表中节点的数目在范围 [0, 500] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>0 &lt;&#x3D; k &lt;&#x3D; 2 * 109</p><h2 id="Solution1-暴力-9"><a href="#Solution1-暴力-9" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Soluion2-闭环"><a href="#Soluion2-闭环" class="headerlink" title="Soluion2  闭环"></a>Soluion2  闭环</h2><p><img src="https://files.mdnice.com/user/1489/319c806f-a568-403a-9a39-c4ac50f30308.png"></p><h1 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h1><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p> </p><p>示例 1：</p><p>输入：m &#x3D; 3, n &#x3D; 7<br>输出：28<br>示例 2：</p><p>输入：m &#x3D; 3, n &#x3D; 2<br>输出：3<br>解释：<br>从左上角开始，总共有 3 条路径可以到达右下角。</p><ol><li>向右 -&gt; 向下 -&gt; 向下</li><li>向下 -&gt; 向下 -&gt; 向右</li><li>向下 -&gt; 向右 -&gt; 向下<br>示例 3：</li></ol><p>输入：m &#x3D; 7, n &#x3D; 3<br>输出：28<br>示例 4：</p><p>输入：m &#x3D; 3, n &#x3D; 3<br>输出：6 </p><p>提示：</p><p>1 &lt;&#x3D; m, n &lt;&#x3D; 100<br>题目数据保证答案小于等于 2 * 109</p><h2 id="Solution1-排列组合"><a href="#Solution1-排列组合" class="headerlink" title="Solution1 排列组合"></a>Solution1 排列组合</h2><p><img src="https://files.mdnice.com/user/1489/4a4d21b3-ff48-457a-a612-9723074e0647.png"></p><h2 id="Solution2-动态规划-1"><a href="#Solution2-动态规划-1" class="headerlink" title="Solution2 动态规划"></a>Solution2 动态规划</h2><p>我们令 dp[i][j] 是到达 i, j 最多路径</p><p>动态方程：dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-1]</p><p>注意，对于第一行 dp[0][j]，或者第一列 dp[i][0]，由于都是在边界，所以只能为 1</p><p>时间复杂度：O(m*n)O(m∗n)</p><p>空间复杂度：O(m * n)O(m∗n)</p><p>优化：因为我们每次只需要 dp[i-1][j],dp[i][j-1]</p><p>所以我们只要记录这两个数，直接看代码吧！</p><p>思路二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[][] dp = new int[m][n];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) dp[0][i] = 1;</span><br><span class="line">        for (int i = 0; i &lt; m; i++) dp[i][0] = 1;</span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m - 1][n - 1];  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化1：空间复杂度 O(2n)O(2n)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[] pre = new int[n];</span><br><span class="line">        int[] cur = new int[n];</span><br><span class="line">        Arrays.fill(pre, 1);</span><br><span class="line">        Arrays.fill(cur,1);</span><br><span class="line">        for (int i = 1; i &lt; m;i++)&#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++)&#123;</span><br><span class="line">                cur[j] = cur[j-1] + pre[j];</span><br><span class="line">            &#125;</span><br><span class="line">            pre = cur.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        return pre[n-1]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化2：空间复杂度 O(n)O(n)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        int[] cur = new int[n];</span><br><span class="line">        Arrays.fill(cur,1);</span><br><span class="line">        for (int i = 1; i &lt; m;i++)&#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++)&#123;</span><br><span class="line">                cur[j] += cur[j-1] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur[n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h1><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p> </p><p>示例 1：</p><p>输入：grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。<br>示例 2：</p><p>输入：grid &#x3D; [[1,2,3],[4,5,6]]<br>输出：12 </p><p>提示：</p><p>m &#x3D;&#x3D; grid.length<br>n &#x3D;&#x3D; grid[i].length<br>1 &lt;&#x3D; m, n &lt;&#x3D; 200<br>0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 100</p><h2 id="Solution0-暴力"><a href="#Solution0-暴力" class="headerlink" title="Solution0 暴力"></a>Solution0 暴力</h2><h2 id="Solution1-动态规划"><a href="#Solution1-动态规划" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/5984996e-8148-4ae1-8ed9-8198e3625d2f.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minPathSum(int[][] grid) &#123;</span><br><span class="line">        for(int i = 0; i &lt; grid.length; i++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; grid[0].length; j++) &#123;</span><br><span class="line">                if(i == 0 &amp;&amp; j == 0) continue;</span><br><span class="line">                else if(i == 0)  grid[i][j] = grid[i][j - 1] + grid[i][j];</span><br><span class="line">                else if(j == 0)  grid[i][j] = grid[i - 1][j] + grid[i][j];</span><br><span class="line">                else grid[i][j] = Math.min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return grid[grid.length - 1][grid[0].length - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a><a href="https://leetcode.cn/problems/plus-one/">66. 加一</a></h1><p>给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p> </p><p>示例 1：</p><p>输入：digits &#x3D; [1,2,3]<br>输出：[1,2,4]<br>解释：输入数组表示数字 123。<br>示例 2：</p><p>输入：digits &#x3D; [4,3,2,1]<br>输出：[4,3,2,2]<br>解释：输入数组表示数字 4321。<br>示例 3：</p><p>输入：digits &#x3D; [0]<br>输出：[1] </p><p>提示：</p><p>1 &lt;&#x3D; digits.length &lt;&#x3D; 100<br>0 &lt;&#x3D; digits[i] &lt;&#x3D; 9</p><h2 id="Solution-0-暴力"><a href="#Solution-0-暴力" class="headerlink" title="Solution 0  暴力"></a>Solution 0  暴力</h2><h2 id="Solution-1-逆序遍历-找到9"><a href="#Solution-1-逆序遍历-找到9" class="headerlink" title="Solution 1 逆序遍历 找到9"></a>Solution 1 逆序遍历 找到9</h2><p><img src="https://files.mdnice.com/user/1489/846120fb-5574-4fde-bd23-c798e938fa6e.png"></p><h1 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根 "></a><a href="https://leetcode.cn/problems/sqrtx/">69. x 的平方根 </a></h1><p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p><p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p><p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p><p> </p><p>示例 1：</p><p>输入：x &#x3D; 4<br>输出：2<br>示例 2：</p><p>输入：x &#x3D; 8<br>输出：2<br>解释：8 的算术平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。 </p><p>提示：</p><p>0 &lt;&#x3D; x &lt;&#x3D; 231 - 1</p><h2 id="Solution1-暴力-10"><a href="#Solution1-暴力-10" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><h2 id="Solution2-二分搜索"><a href="#Solution2-二分搜索" class="headerlink" title="Solution2 二分搜索"></a>Solution2 二分搜索</h2><p><img src="https://files.mdnice.com/user/1489/19d7f700-92c7-4591-bef6-efe163c000f3.png"></p><h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h1><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p> </p><p>示例 1：</p><p>输入：n &#x3D; 2<br>输出：2<br>解释：有两种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶</li><li>2 阶<br>示例 2：</li></ol><p>输入：n &#x3D; 3<br>输出：3<br>解释：有三种方法可以爬到楼顶。</p><ol><li>1 阶 + 1 阶 + 1 阶</li><li>1 阶 + 2 阶</li><li>2 阶 + 1 阶</li></ol><p> </p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 45</p><h2 id="Solution1-递归-1"><a href="#Solution1-递归-1" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int climbStairs(int n) &#123;</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">      int dp0=1;</span><br><span class="line">       int dp1=1;</span><br><span class="line">        for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">            int tmp=dp0;</span><br><span class="line">            dp0=dp1;</span><br><span class="line">            dp1=tmp+dp1;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp1;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a></h1><p>给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><p>必须在不使用库的sort函数的情况下解决这个问题。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [2,0,2,1,1,0]<br>输出：[0,0,1,1,2,2]<br>示例 2：</p><p>输入：nums &#x3D; [2,0,1]<br>输出：[0,1,2] </p><p>提示：</p><p>n &#x3D;&#x3D; nums.length<br>1 &lt;&#x3D; n &lt;&#x3D; 300<br>nums[i] 为 0、1 或 2 </p><p>进阶：</p><p>你可以不使用代码库中的排序函数来解决这道题吗？<br>你能想出一个仅使用常数空间的一趟扫描算法吗？</p><h2 id="Solution1-暴力-11"><a href="#Solution1-暴力-11" class="headerlink" title="Solution1 暴力"></a>Solution1 暴力</h2><p>根据题目中的提示，我们可以统计出数组中 0, 1, 20,1,2 的个数，再根据它们的数量，重写整个数组。这种方法较为简单，也很容易想到，而本题解中会介绍两种基于指针进行交换的方法。</p><h2 id="Solution2-单指针"><a href="#Solution2-单指针" class="headerlink" title="Solution2 单指针"></a>Solution2 单指针</h2><p>我们可以考虑对数组进行两次遍历。在第一次遍历中，我们将数组中所有的 00 交换到数组的头部。在第二次遍历中，我们将数组中所有的 11 交换到头部的 00 之后。此时，所有的 22 都出现在数组的尾部，这样我们就完成了排序。</p><p>具体地，我们使用一个指针 \textit{ptr}ptr 表示「头部」的范围，\textit{ptr}ptr 中存储了一个整数，表示数组 \textit{nums}nums 从位置 00 到位置 \textit{ptr}-1ptr−1 都属于「头部」。\textit{ptr}ptr 的初始值为 00，表示还没有数处于「头部」。</p><p>在第一次遍历中，我们从左向右遍历整个数组，如果找到了 00，那么就需要将 00 与「头部」位置的元素进行交换，并将「头部」向后扩充一个位置。在遍历结束之后，所有的 00 都被交换到「头部」的范围，并且「头部」只包含 00。</p><p>在第二次遍历中，我们从「头部」开始，从左向右遍历整个数组，如果找到了 11，那么就需要将 11 与「头部」位置的元素进行交换，并将「头部」向后扩充一个位置。在遍历结束之后，所有的 11 都被交换到「头部」的范围，并且都在 00 之后，此时 22 只出现在「头部」之外的位置，因此排序完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void sortColors(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int ptr = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            if (nums[i] == 0) &#123;</span><br><span class="line">                swap(nums[i], nums[ptr]);</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = ptr; i &lt; n; ++i) &#123;</span><br><span class="line">            if (nums[i] == 1) &#123;</span><br><span class="line">                swap(nums[i], nums[ptr]);</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution3-双指针"><a href="#Solution3-双指针" class="headerlink" title="Solution3 双指针"></a>Solution3 双指针</h2><p><img src="https://files.mdnice.com/user/1489/d99bbb87-979c-426b-b6e5-647acf2cad20.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void sortColors(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int p0 = 0, p2 = n - 1;</span><br><span class="line">        for (int i = 0; i &lt;= p2; ++i) &#123;</span><br><span class="line">            while (i &lt;= p2 &amp;&amp; nums[i] == 2) &#123;</span><br><span class="line">                swap(nums[i], nums[p2]);</span><br><span class="line">                --p2;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums[i] == 0) &#123;</span><br><span class="line">                swap(nums[i], nums[p0]);</span><br><span class="line">                ++p0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h1><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [1,2,3]<br>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]<br>示例 2：</p><p>输入：nums &#x3D; [0]<br>输出：[[],[0]] </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 10<br>-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10<br>nums 中的所有元素 互不相同</p><h2 id="Solution1-回溯-1"><a href="#Solution1-回溯-1" class="headerlink" title="Solution1 回溯"></a>Solution1 回溯</h2><p><a href="https://leetcode.cn/problems/subsets/comments/1011321">https://leetcode.cn/problems/subsets/comments/1011321</a></p><p><a href="https://leetcode.cn/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/">https://leetcode.cn/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line">    void backtracking(vector&lt;int&gt;&amp; nums, int startIndex) &#123;</span><br><span class="line">        result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉自己</span><br><span class="line">        if (startIndex &gt;= nums.size()) &#123; // 终止条件可以不加</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = startIndex; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            path.push_back(nums[i]);</span><br><span class="line">            backtracking(nums, i + 1);</span><br><span class="line">            path.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        result.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        backtracking(nums, 0);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="90-子集"><a href="#90-子集" class="headerlink" title="90.子集||"></a><a href="https://leetcode-cn.com/problems/subsets-ii/">90.子集||</a></h1><h1 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h1><h1 id="39-组合总和-1"><a href="#39-组合总和-1" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h1><h1 id="40-组合总和-II-1"><a href="#40-组合总和-II-1" class="headerlink" title="40. 组合总和 II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></h1><h1 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a><a href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h1><h1 id="784-字母大小写全排列"><a href="#784-字母大小写全排列" class="headerlink" title="784. 字母大小写全排列"></a><a href="https://leetcode.cn/problems/letter-case-permutation/">784. 字母大小写全排列</a></h1><h1 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a href="https://leetcode.cn/problems/word-search/comments/">79. 单词搜索</a></h1><h1 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h1><p>给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</p><p> </p><p>示例 1：</p><p>输入：head &#x3D; [1,1,2]<br>输出：[1,2]<br>示例 2：</p><p>输入：head &#x3D; [1,1,2,3,3]<br>输出：[1,2,3] </p><p>提示：</p><p>链表中节点数目在范围 [0, 300] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>题目数据保证链表已经按升序 排列</p><h2 id="Solution1-一次遍历"><a href="#Solution1-一次遍历" class="headerlink" title="Solution1 一次遍历"></a>Solution1 一次遍历</h2><p>方法一：一次遍历<br>思路与算法</p><p>由于给定的链表是排好序的，因此重复的元素在链表中出现的位置是连续的，因此我们只需要对链表进行一次遍历，就可以删除重复的元素。</p><p>具体地，我们从指针 \textit{cur}cur 指向链表的头节点，随后开始对链表进行遍历。如果当前 \textit{cur}cur 与 \textit{cur.next}cur.next 对应的元素相同，那么我们就将 \textit{cur.next}cur.next 从链表中移除；否则说明链表中已经不存在其它与 \textit{cur}cur 对应的元素相同的节点，因此可以将 \textit{cur}cur 指向 \textit{cur.next}cur.next。</p><p>当遍历完整个链表之后，我们返回链表的头节点即可。</p><p>细节</p><p>当我们遍历到链表的最后一个节点时，\textit{cur.next}cur.next 为空节点，如果不加以判断，访问 \textit{cur.next}cur.next 对应的元素会产生运行错误。因此我们只需要遍历到链表的最后一个节点，而不需要遍历完整个链表。</p><p>复杂度分析</p><p>时间复杂度：O(n)O(n)，其中 nn 是链表的长度。</p><p>空间复杂度：O(1)O(1)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">        if (!head) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        while (cur-&gt;next) &#123;</span><br><span class="line">            if (cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a><a href="https://leetcode.cn/problems/partition-list/">86. 分隔链表</a></h1><p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p><p>你应当 保留 两个分区中每个节点的初始相对位置。</p><p> </p><p>示例 1：</p><p>输入：head &#x3D; [1,4,3,2,5,2], x &#x3D; 3<br>输出：[1,2,2,4,3,5]<br>示例 2：</p><p>输入：head &#x3D; [2,1], x &#x3D; 2<br>输出：[1,2] </p><p>提示：</p><p>链表中节点的数目在范围 [0, 200] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100<br>-200 &lt;&#x3D; x &lt;&#x3D; 200</p><h2 id="Solution1-双指针"><a href="#Solution1-双指针" class="headerlink" title="Solution1  双指针"></a>Solution1  双指针</h2><p><img src="https://files.mdnice.com/user/1489/1a1aae99-5b02-4641-9e50-5bd0913d1e4d.png"></p><h1 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a href="https://leetcode.cn/problems/merge-sorted-array/">88. 合并两个有序数组</a></h1><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><p> </p><p>示例 1：</p><p>输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3<br>输出：[1,2,2,3,5,6]<br>解释：需要合并 [1,2,3] 和 [2,5,6] 。<br>合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。<br>示例 2：</p><p>输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0<br>输出：[1]<br>解释：需要合并 [1] 和 [] 。<br>合并结果是 [1] 。<br>示例 3：</p><p>输入：nums1 &#x3D; [0], m &#x3D; 0, nums2 &#x3D; [1], n &#x3D; 1<br>输出：[1]<br>解释：需要合并的数组是 [] 和 [1] 。<br>合并结果是 [1] 。<br>注意，因为 m &#x3D; 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。 </p><p>提示：</p><p>nums1.length &#x3D;&#x3D; m + n<br>nums2.length &#x3D;&#x3D; n<br>0 &lt;&#x3D; m, n &lt;&#x3D; 200<br>1 &lt;&#x3D; m + n &lt;&#x3D; 200<br>-109 &lt;&#x3D; nums1[i], nums2[j] &lt;&#x3D; 109 </p><p>进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？</p><h2 id="Solution1-暴力直接合并后排序"><a href="#Solution1-暴力直接合并后排序" class="headerlink" title="Solution1 暴力直接合并后排序"></a>Solution1 暴力直接合并后排序</h2><p><img src="https://files.mdnice.com/user/1489/8aeff7af-53ed-467e-aebc-7835db5b52f5.png"></p><h2 id="Solution2-双指针-1"><a href="#Solution2-双指针-1" class="headerlink" title="Solution2 双指针"></a>Solution2 双指针</h2><p><img src="https://files.mdnice.com/user/1489/5be86979-df7c-4994-a29c-088dc60e24e6.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        int p1 = 0, p2 = 0;</span><br><span class="line">        int sorted[m + n];</span><br><span class="line">        int cur;</span><br><span class="line">        while (p1 &lt; m || p2 &lt; n) &#123;</span><br><span class="line">            if (p1 == m) &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125; else if (p2 == n) &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125; else if (nums1[p1] &lt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">            sorted[p1 + p2 - 1] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i != m + n; ++i) &#123;</span><br><span class="line">            nums1[i] = sorted[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(m+n)O(m+n)。<br>指针移动单调递增，最多移动 m+nm+n 次，因此时间复杂度为 O(m+n)O(m+n)。</p><p>空间复杂度：O(m+n)O(m+n)。<br>需要建立长度为 m+nm+n 的中间数组 \textit{sorted}sorted。</p><h2 id="Solution3-逆向双指针"><a href="#Solution3-逆向双指针" class="headerlink" title="Solution3 逆向双指针"></a>Solution3 逆向双指针</h2><p><img src="https://files.mdnice.com/user/1489/a825eedd-e311-4153-bc5b-ed31be497911.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;</span><br><span class="line">        int p1 = m - 1, p2 = n - 1;</span><br><span class="line">        int tail = m + n - 1;</span><br><span class="line">        int cur;</span><br><span class="line">        while (p1 &gt;= 0 || p2 &gt;= 0) &#123;</span><br><span class="line">            if (p1 == -1) &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125; else if (p2 == -1) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; else if (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">            nums1[tail--] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a href="https://leetcode.cn/problems/decode-ways/">91. 解码方法</a></h1><p>一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</p><p>‘A’ -&gt; “1”<br>‘B’ -&gt; “2”<br>…<br>‘Z’ -&gt; “26”<br>要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，”11106” 可以映射为：</p><p>“AAJF” ，将消息分组为 (1 1 10 6)<br>“KJF” ，将消息分组为 (11 10 6)<br>注意，消息不能分组为  (1 11 06) ，因为 “06” 不能映射为 “F” ，这是由于 “6” 和 “06” 在映射中并不等价。</p><p>给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。</p><p>题目数据保证答案肯定是一个 32 位 的整数。</p><p> </p><p>示例 1：</p><p>输入：s &#x3D; “12”<br>输出：2<br>解释：它可以解码为 “AB”（1 2）或者 “L”（12）。<br>示例 2：</p><p>输入：s &#x3D; “226”<br>输出：3<br>解释：它可以解码为 “BZ” (2 26), “VF” (22 6), 或者 “BBF” (2 2 6) 。<br>示例 3：</p><p>输入：s &#x3D; “0”<br>输出：0<br>解释：没有字符映射到以 0 开头的数字。<br>含有 0 的有效映射是 ‘J’ -&gt; “10” 和 ‘T’-&gt; “20” 。<br>由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。 </p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 100<br>s 只包含数字，并且可能包含前导零。<br>通过次数235,094提交次数721,617</p><h2 id="Solution1-动态规划-1"><a href="#Solution1-动态规划-1" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/707aac6e-eec8-4f5a-8f0f-b7b45d344451.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numDecodings(string s) &#123;</span><br><span class="line">        if (s[0] == &#x27;0&#x27;) return 0;</span><br><span class="line">        vector&lt;int&gt; dp(s.size()+1);</span><br><span class="line">        dp[0]=1;dp[1]=1;</span><br><span class="line">        for (int i =1; i &lt; s.size(); i++) &#123;</span><br><span class="line">            if (s[i] == &#x27;0&#x27;)//1.s[i]为0的情况</span><br><span class="line">                if (s[i - 1] == &#x27;1&#x27; || s[i - 1] == &#x27;2&#x27;) //s[i - 1]等于1或2的情况</span><br><span class="line">                    dp[i+1] = dp[i-1];//由于s[1]指第二个下标，对应为dp[2],所以dp的下标要比s大1，故为dp[i+1]</span><br><span class="line">                else </span><br><span class="line">                    return 0;</span><br><span class="line">            else //2.s[i]不为0的情况</span><br><span class="line">                if (s[i - 1] == &#x27;1&#x27; || (s[i - 1] == &#x27;2&#x27; &amp;&amp; s[i] &lt;= &#x27;6&#x27;))//s[i-1]s[i]两位数要小于26的情况</span><br><span class="line">                    dp[i+1] = dp[i]+dp[i-1];</span><br><span class="line">                else//其他情况</span><br><span class="line">                    dp[i+1] = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution2-动态规划-空间复杂度优化为O-1"><a href="#Solution2-动态规划-空间复杂度优化为O-1" class="headerlink" title="Solution2 动态规划 空间复杂度优化为O(1)"></a>Solution2 动态规划 空间复杂度优化为O(1)</h2><p><img src="https://files.mdnice.com/user/1489/ebc2117f-b989-4c3d-b852-4b2b26c77453.png"></p><h1 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h1><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。 </p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4,5], left &#x3D; 2, right &#x3D; 4<br>输出：[1,4,3,2,5]<br>示例 2：</p><p>输入：head &#x3D; [5], left &#x3D; 1, right &#x3D; 1<br>输出：[5] </p><p>提示：</p><p>链表中节点数目为 n<br>1 &lt;&#x3D; n &lt;&#x3D; 500<br>-500 &lt;&#x3D; Node.val &lt;&#x3D; 500<br>1 &lt;&#x3D; left &lt;&#x3D; right &lt;&#x3D; n </p><p>进阶： 你可以使用一趟扫描完成反转吗？</p><h2 id="Solution1-原地反转"><a href="#Solution1-原地反转" class="headerlink" title="Solution1 原地反转"></a>Solution1 原地反转</h2><p><img src="https://files.mdnice.com/user/1489/1d9b3377-72f8-4c1b-8451-a2e484bfdc1c.png"></p><h1 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h1><p>给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。</p><p> </p><p>示例 1：</p><p>输入：root &#x3D; [1,null,2,3]<br>输出：[1,3,2]<br>示例 2：</p><p>输入：root &#x3D; []<br>输出：[]<br>示例 3：</p><p>输入：root &#x3D; [1]<br>输出：[1] </p><p>提示：</p><p>树中节点数目在范围 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100 </p><h2 id="Solution1-递归-2"><a href="#Solution1-递归-2" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><p><img src="https://files.mdnice.com/user/1489/166bca4c-bcc2-4718-b6f4-1576acf3ff36.png"></p><h2 id="Solution2-迭代-1"><a href="#Solution2-迭代-1" class="headerlink" title="Solution2 迭代"></a>Solution2 迭代</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        while (root != nullptr || !stk.empty()) &#123;</span><br><span class="line">            while (root != nullptr) &#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96. 不同的二叉搜索树"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h1><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p><p> </p><p>示例 1：</p><p>输入：n &#x3D; 3<br>输出：5<br>示例 2：</p><p>输入：n &#x3D; 1<br>输出：1 </p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 19</p><h2 id="Solution1-动态规划-2"><a href="#Solution1-动态规划-2" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p>结题思路：假设n个节点存在二叉排序树的个数是G(n)，1为根节点，2为根节点，…，n为根节点，<br>当1为根节点时，其左子树节点个数为0，右子树节点个数为n-1，<br>同理当2为根节点时，其左子树节点个数为1，右子树节点为n-2，<br>所以可得G(n) &#x3D; G(0)<em>G(n-1)+G(1)</em>(n-2)+…+G(n-1)*G(0)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numTrees(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n + 1);</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j - 1] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="95. 不同的二叉搜索树 II"></a><a href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">95. 不同的二叉搜索树 II</a></h1><p>给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树 。可以按 任意顺序 返回答案。</p><p> </p><p>示例 1：</p><p>输入：n &#x3D; 3<br>输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]<br>示例 2：</p><p>输入：n &#x3D; 1<br>输出：[[1]] </p><p>提示：</p><p>1 &lt;&#x3D; n &lt;&#x3D; 8</p><h2 id="Solution1-回溯-2"><a href="#Solution1-回溯-2" class="headerlink" title="Solution1 回溯"></a>Solution1 回溯</h2><p><img src="https://files.mdnice.com/user/1489/a150914f-1207-4dc6-8091-639f11405933.png"></p><p><img src="https://files.mdnice.com/user/1489/d66220b0-0d89-479e-9313-6adce6816e8c.png"></p><h1 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h1><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。 </p><p>示例 1：</p><p>输入：root &#x3D; [2,1,3]<br>输出：true<br>示例 2：</p><p>输入：root &#x3D; [5,1,4,null,null,3,6]<br>输出：false<br>解释：根节点的值是 5 ，但是右子节点的值是 4 。 </p><p>提示：</p><p>树中节点数目范围在[1, 104] 内<br>-231 &lt;&#x3D; Node.val &lt;&#x3D; 231 - 1</p><h2 id="Solution1-递归-3"><a href="#Solution1-递归-3" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><p>方法一: 递归<br>思路和算法</p><p>要解决这道题首先我们要了解二叉搜索树有什么性质可以给我们利用，由题目给出的信息我们可以知道：如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。</p><p>这启示我们设计一个递归函数 helper(root, lower, upper) 来递归判断，函数表示考虑以 root 为根的子树，判断子树中所有节点的值是否都在 (l,r)(l,r) 的范围内（注意是开区间）。如果 root 节点的值 val 不在 (l,r)(l,r) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。</p><p>那么根据二叉搜索树的性质，在递归调用左子树时，我们需要把上界 upper 改为 root.val，即调用 helper(root.left, lower, root.val)，因为左子树里所有节点的值均小于它的根节点的值。同理递归调用右子树时，我们需要把下界 lower 改为 root.val，即调用 helper(root.right, root.val, upper)。</p><p>函数递归调用的入口为 helper(root, -inf, +inf)， inf 表示一个无穷大的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool helper(TreeNode* root, long long lower, long long upper) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root -&gt; val &lt;= lower || root -&gt; val &gt;= upper) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return helper(root -&gt; left, lower, root -&gt; val) &amp;&amp; helper(root -&gt; right, root -&gt; val, upper);</span><br><span class="line">    &#125;</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        return helper(root, LONG_MIN, LONG_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(n)O(n)，其中 nn 为二叉树的节点个数。在递归调用的时候二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)O(n)。</p><p>空间复杂度：O(n)O(n)，其中 nn 为二叉树的节点个数。递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，即二叉树的高度。最坏情况下二叉树为一条链，树的高度为 nn ，递归最深达到 nn 层，故最坏情况下空间复杂度为 O(n)O(n) 。</p><h2 id="Solution2-中序遍历为升序"><a href="#Solution2-中序遍历为升序" class="headerlink" title="Solution2 中序遍历为升序"></a>Solution2 中序遍历为升序</h2><p>基于方法一中提及的性质，我们可以进一步知道二叉搜索树「中序遍历」得到的值构成的序列一定是升序的，这启示我们在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。如果均大于说明这个序列是升序的，整棵树是二叉搜索树，否则不是，下面的代码我们使用栈来模拟中序遍历的过程。</p><p>可能有读者不知道中序遍历是什么，我们这里简单提及。中序遍历是二叉树的一种遍历方式，它先遍历左子树，再遍历根节点，最后遍历右子树。而我们二叉搜索树保证了左子树的节点的值均小于根节点的值，根节点的值均小于右子树的值，因此中序遍历以后得到的序列一定是升序序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isValidBST(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; stack;</span><br><span class="line">        long long inorder = (long long)INT_MIN - 1;</span><br><span class="line"></span><br><span class="line">        while (!stack.empty() || root != nullptr) &#123;</span><br><span class="line">            while (root != nullptr) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root -&gt; left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.top();</span><br><span class="line">            stack.pop();</span><br><span class="line">            // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树</span><br><span class="line">            if (root -&gt; val &lt;= inorder) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            inorder = root -&gt; val;</span><br><span class="line">            root = root -&gt; right;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(n)O(n)，其中 nn 为二叉树的节点个数。二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)O(n)。</p><p>空间复杂度：O(n)O(n)，其中 nn 为二叉树的节点个数。栈最多存储 nn 个节点，因此需要额外的 O(n)O(n) 的空间。</p><h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h1><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p><p> </p><p>示例 1：</p><p>输入：root &#x3D; [1,2,2,3,4,4,3]<br>输出：true<br>示例 2：</p><p>输入：root &#x3D; [1,2,2,null,3,null,3]<br>输出：false </p><p>提示：</p><p>树中节点数目在范围 [1, 1000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100 </p><p>进阶：你可以运用递归和迭代两种方法解决这个问题吗？</p><h2 id="Solution1-递归-4"><a href="#Solution1-递归-4" class="headerlink" title="Solution1  递归"></a>Solution1  递归</h2><p><img src="https://files.mdnice.com/user/1489/17bcb971-2dd2-4659-a84f-24493a37c88e.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">if(root==null) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">//调用递归函数，比较左节点，右节点</span><br><span class="line">return dfs(root.left,root.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean dfs(TreeNode left, TreeNode right) &#123;</span><br><span class="line">//递归的终止条件是两个节点都为空</span><br><span class="line">//或者两个节点中有一个为空</span><br><span class="line">//或者两个节点的值不相等</span><br><span class="line">if(left==null &amp;&amp; right==null) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">if(left==null || right==null) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">if(left.val!=right.val) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">//再递归的比较 左节点的左孩子 和 右节点的右孩子</span><br><span class="line">//以及比较  左节点的右孩子 和 右节点的左孩子</span><br><span class="line">return dfs(left.left,right.right) &amp;&amp; dfs(left.right,right.left);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution2-队列"><a href="#Solution2-队列" class="headerlink" title="Solution2 队列"></a>Solution2 队列</h2><p>回想下递归的实现：<br>当两个子树的根节点相等时，就比较:<br>左子树的 left 和 右子树的 right，这个比较是用递归实现的。<br>现在我们改用队列来实现，思路如下：<br>首先从队列中拿出两个节点(left 和 right)比较<br>将 left 的 left 节点和 right 的 right 节点放入队列<br>将 left 的 right 节点和 right 的 left 节点放入队列<br>时间复杂度是 O(n)O(n)，空间复杂度是 O(n)O(n)<br>动画演示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">if(root==null || (root.left==null &amp;&amp; root.right==null)) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">//用队列保存节点</span><br><span class="line">LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">//将根节点的左右孩子放到队列中</span><br><span class="line">queue.add(root.left);</span><br><span class="line">queue.add(root.right);</span><br><span class="line">while(queue.size()&gt;0) &#123;</span><br><span class="line">//从队列中取出两个节点，再比较这两个节点</span><br><span class="line">TreeNode left = queue.removeFirst();</span><br><span class="line">TreeNode right = queue.removeFirst();</span><br><span class="line">//如果两个节点都为空就继续循环，两者有一个为空就返回false</span><br><span class="line">if(left==null &amp;&amp; right==null) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">if(left==null || right==null) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">if(left.val!=right.val) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">//将左节点的左孩子， 右节点的右孩子放入队列</span><br><span class="line">queue.add(left.left);</span><br><span class="line">queue.add(right.right);</span><br><span class="line">//将左节点的右孩子，右节点的左孩子放入队列</span><br><span class="line">queue.add(left.right);</span><br><span class="line">queue.add(right.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h1><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。</p><p> </p><p>示例 1：</p><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[3],[9,20],[15,7]]<br>示例 2：</p><p>输入：root &#x3D; [1]<br>输出：[[1]]<br>示例 3：</p><p>输入：root &#x3D; []<br>输出：[] </p><p>提示：</p><p>树中节点数目在范围 [0, 2000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000</p><h2 id="Solution1-队列实现"><a href="#Solution1-队列实现" class="headerlink" title="Solution1 队列实现"></a>Solution1 队列实现</h2><p><img src="https://files.mdnice.com/user/1489/35a4e4dc-eb76-4d87-ba29-735a5042bfe1.png"></p><p><img src="https://files.mdnice.com/user/1489/3f09955d-d39b-41e9-8495-445cf9b35418.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector &lt;vector &lt;int&gt;&gt; ret;</span><br><span class="line">        if (!root) &#123;</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue &lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            int currentLevelSize = q.size();</span><br><span class="line">            ret.push_back(vector &lt;int&gt; ());</span><br><span class="line">            for (int i = 1; i &lt;= currentLevelSize; ++i) &#123;</span><br><span class="line">                auto node = q.front(); q.pop();</span><br><span class="line">                ret.back().push_back(node-&gt;val);</span><br><span class="line">                if (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">                if (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution2-递归实现"><a href="#Solution2-递归实现" class="headerlink" title="Solution2 递归实现"></a>Solution2 递归实现</h2><p>层序遍历一般来说确实是用队列实现的，但是这里很明显用递归前序遍历就能实现呀，而且复杂度O(n)。。。</p><p>要点有几个：</p><p>利用depth变量记录当前在第几层（从0开始），进入下层时depth + 1；<br>如果depth &gt;&#x3D; vector.size()说明这一层还没来过，这是第一次来，所以得扩容咯；<br>因为是前序遍历，中-左-右，对于每一层来说，左边的肯定比右边先被遍历到，实际上后序中序都是一样的。。。<br>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ans;</span><br><span class="line">        pre(root, 0, ans);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void pre(TreeNode *root, int depth, vector&lt;vector&lt;int&gt;&gt; &amp;ans) &#123;</span><br><span class="line">        if (!root) return ;</span><br><span class="line">        if (depth &gt;= ans.size())</span><br><span class="line">            ans.push_back(vector&lt;int&gt; &#123;&#125;);</span><br><span class="line">        ans[depth].push_back(root-&gt;val);</span><br><span class="line">        pre(root-&gt;left, depth + 1, ans);</span><br><span class="line">        pre(root-&gt;right, depth + 1, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h1><p>给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p> </p><p>示例 1：</p><p>输入：root &#x3D; [3,9,20,null,null,15,7]<br>输出：[[3],[20,9],[15,7]]<br>示例 2：</p><p>输入：root &#x3D; [1]<br>输出：[[1]]<br>示例 3：</p><p>输入：root &#x3D; []<br>输出：[] </p><p>提示：</p><p>树中节点数目在范围 [0, 2000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><h2 id="Solution1-层序遍历"><a href="#Solution1-层序遍历" class="headerlink" title="Solution1 层序遍历"></a>Solution1 层序遍历</h2><p>层序遍历，然后在奇数时逆序一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; res;</span><br><span class="line">        if(!root) return res;</span><br><span class="line">        </span><br><span class="line">        queue&lt;TreeNode *&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        int flag = 0;</span><br><span class="line">        while(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; out;</span><br><span class="line">            int size = q.size(); //取得每一层的长度</span><br><span class="line">            for(int i = 0; i &lt; size; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                auto temp = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                out.push_back(temp-&gt;val);</span><br><span class="line">                if(temp-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(temp-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(temp-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(temp-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag%2==1)</span><br><span class="line">            &#123;</span><br><span class="line">                reverse(out.begin(),out.end());</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(out);</span><br><span class="line">            flag++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h1><h2 id="Solution1-DFS"><a href="#Solution1-DFS" class="headerlink" title="Solution1 DFS"></a>Solution1 DFS</h2><p><img src="https://files.mdnice.com/user/1489/f28b6ed7-01b5-4a89-952f-d626edf15d9e.png"></p><p><img src="https://files.mdnice.com/user/1489/988437b9-f65e-4111-8cde-79a687333027.png"></p><h2 id="Slution2-BFS"><a href="#Slution2-BFS" class="headerlink" title="Slution2 BFS"></a>Slution2 BFS</h2><p><img src="https://files.mdnice.com/user/1489/c915e202-251b-48cd-816b-cfcabdbf2214.png"></p><h1 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h1><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><p> </p><p>示例 1:</p><p>输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]<br>输出: [3,9,20,null,null,15,7]<br>示例 2:</p><p>输入: preorder &#x3D; [-1], inorder &#x3D; [-1]<br>输出: [-1] </p><p>提示:</p><p>1 &lt;&#x3D; preorder.length &lt;&#x3D; 3000<br>inorder.length &#x3D;&#x3D; preorder.length<br>-3000 &lt;&#x3D; preorder[i], inorder[i] &lt;&#x3D; 3000<br>preorder 和 inorder 均 无重复 元素<br>inorder 均出现在 preorder<br>preorder 保证 为二叉树的前序遍历序列<br>inorder 保证 为二叉树的中序遍历序列</p><h1 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a><a href="https://leetcode.cn/problems/pascals-triangle/">118. 杨辉三角</a></h1><p>给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p> </p><p>示例 1:</p><p>输入: numRows &#x3D; 5<br>输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]<br>示例 2:</p><p>输入: numRows &#x3D; 1<br>输出: [[1]]</p><h2 id="Solution1-直接求解"><a href="#Solution1-直接求解" class="headerlink" title="Solution1 直接求解"></a>Solution1 直接求解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; yanghui;</span><br><span class="line">        for (int i = 0; i &lt; numRows; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;int&gt; data(i + 1);</span><br><span class="line">            yanghui.push_back(data);</span><br><span class="line">            for (int j = 0; j &lt; i; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                if(j == 0) yanghui[i][j] = 1;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    yanghui[i][j] = yanghui[i - 1][j - 1] + yanghui[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            yanghui[i][yanghui[i].size() - 1] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return yanghui;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h1><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p><p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。 </p><p>示例 1：</p><p>输入：root &#x3D; [1,2,5,3,4,null,6]<br>输出：[1,null,2,null,3,null,4,null,5,null,6]<br>示例 2：</p><p>输入：root &#x3D; []<br>输出：[]<br>示例 3：</p><p>输入：root &#x3D; [0]<br>输出：[0] </p><p>提示：</p><p>树中结点数在范围 [0, 2000] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100 </p><h2 id="Solution1-递归-5"><a href="#Solution1-递归-5" class="headerlink" title="Solution1  递归"></a>Solution1  递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* last = nullptr;</span><br><span class="line">void flatten(TreeNode* root) &#123;</span><br><span class="line">    if (root == nullptr) return;</span><br><span class="line">    flatten(root-&gt;right);</span><br><span class="line">    flatten(root-&gt;left);</span><br><span class="line">    root-&gt;right = last;</span><br><span class="line">    root-&gt;left = nullptr;</span><br><span class="line">    last = root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Solution2-迭代-2"><a href="#Solution2-迭代-2" class="headerlink" title="Solution2   迭代"></a>Solution2   迭代</h2><p><img src="https://files.mdnice.com/user/1489/5f3de36e-929d-4f22-adcb-a8070f305409.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void flatten(TreeNode* root) &#123;</span><br><span class="line">        while(root)&#123;</span><br><span class="line">            TreeNode* p = root-&gt;left;</span><br><span class="line">            if(p)&#123;</span><br><span class="line">                while(p-&gt;right) p = p-&gt;right; </span><br><span class="line">                p-&gt;right = root-&gt;right;</span><br><span class="line">                root-&gt;right = root-&gt;left;</span><br><span class="line">                root-&gt;left = nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="113-路径总和-II"><a href="#113-路径总和-II" class="headerlink" title="113. 路径总和 II"></a><a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h1><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><p> </p><p>示例 1：</p><p>输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22<br>输出：[[5,4,11,2],[5,8,4,5]]<br>示例 2：</p><p>输入：root &#x3D; [1,2,3], targetSum &#x3D; 5<br>输出：[]<br>示例 3：</p><p>输入：root &#x3D; [1,2], targetSum &#x3D; 0<br>输出：[] </p><p>提示：</p><p>树中节点总数在范围 [0, 5000] 内<br>-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000<br>-1000 &lt;&#x3D; targetSum &lt;&#x3D; 1000</p><h2 id="Solution1-DFS-1"><a href="#Solution1-DFS-1" class="headerlink" title="Solution1 DFS"></a>Solution1 DFS</h2><p>我们可以采用深度优先搜索的方式，枚举每一条从根节点到叶子节点的路径。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p><p>复杂度分析</p><p><img src="https://files.mdnice.com/user/1489/070d05a3-3ee3-4b0a-90da-bed5c1c2b9a8.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ret;</span><br><span class="line">    vector&lt;int&gt; path;</span><br><span class="line"></span><br><span class="line">    void dfs(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        path.emplace_back(root-&gt;val);</span><br><span class="line">        targetSum -= root-&gt;val;</span><br><span class="line">        if (root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr &amp;&amp; targetSum == 0) &#123;</span><br><span class="line">            ret.emplace_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root-&gt;left, targetSum);</span><br><span class="line">        dfs(root-&gt;right, targetSum);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        dfs(root, targetSum);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Solution2-BFS"><a href="#Solution2-BFS" class="headerlink" title="Solution2 BFS"></a>Solution2 BFS</h2><p>方法二：广度优先搜索<br>思路及算法</p><p>我们也可以采用广度优先搜索的方式，遍历这棵树。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p><p>为了节省空间，我们使用哈希表记录树中的每一个节点的父节点。每次找到一个满足条件的节点，我们就从该节点出发不断向父节点迭代，即可还原出从根节点到当前节点的路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; ret;</span><br><span class="line">    unordered_map&lt;TreeNode*, TreeNode*&gt; parent;</span><br><span class="line"></span><br><span class="line">    void getPath(TreeNode* node) &#123;</span><br><span class="line">        vector&lt;int&gt; tmp;</span><br><span class="line">        while (node != nullptr) &#123;</span><br><span class="line">            tmp.emplace_back(node-&gt;val);</span><br><span class="line">            node = parent[node];</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(tmp.begin(), tmp.end());</span><br><span class="line">        ret.emplace_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;TreeNode*&gt; que_node;</span><br><span class="line">        queue&lt;int&gt; que_sum;</span><br><span class="line">        que_node.emplace(root);</span><br><span class="line">        que_sum.emplace(0);</span><br><span class="line"></span><br><span class="line">        while (!que_node.empty()) &#123;</span><br><span class="line">            TreeNode* node = que_node.front();</span><br><span class="line">            que_node.pop();</span><br><span class="line">            int rec = que_sum.front() + node-&gt;val;</span><br><span class="line">            que_sum.pop();</span><br><span class="line"></span><br><span class="line">            if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr) &#123;</span><br><span class="line">                if (rec == targetSum) &#123;</span><br><span class="line">                    getPath(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (node-&gt;left != nullptr) &#123;</span><br><span class="line">                    parent[node-&gt;left] = node;</span><br><span class="line">                    que_node.emplace(node-&gt;left);</span><br><span class="line">                    que_sum.emplace(rec);</span><br><span class="line">                &#125;</span><br><span class="line">                if (node-&gt;right != nullptr) &#123;</span><br><span class="line">                    parent[node-&gt;right] = node;</span><br><span class="line">                    que_node.emplace(node-&gt;right);</span><br><span class="line">                    que_sum.emplace(rec);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="109-有序链表转换二叉搜索树"><a href="#109-有序链表转换二叉搜索树" class="headerlink" title="109. 有序链表转换二叉搜索树"></a><a href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></h1><p>给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差不超过 1。</p><p> </p><p>示例 1:</p><p>输入: head &#x3D; [-10,-3,0,5,9]<br>输出: [0,-3,9,-10,null,5]<br>解释: 一个可能的答案是[0，-3,9，-10,null,5]，它表示所示的高度平衡的二叉搜索树。<br>示例 2:</p><p>输入: head &#x3D; []<br>输出: [] </p><p>提示:</p><p>head 中的节点数在[0, 2 * 104] 范围内<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105</p><h2 id="Solution1-先找中点-然后再左右分别构造"><a href="#Solution1-先找中点-然后再左右分别构造" class="headerlink" title="Solution1 先找中点 然后再左右分别构造"></a>Solution1 先找中点 然后再左右分别构造</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode sortedListToBST(ListNode head) &#123;</span><br><span class="line">        if(head == null) return null;</span><br><span class="line">        else if(head.next == null) return new TreeNode(head.val);</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        ListNode p = pre.next;</span><br><span class="line">        ListNode q = p.next;</span><br><span class="line">        //找到链表的中点p</span><br><span class="line">        while(q!=null &amp;&amp; q.next!=null)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            p = pre.next;</span><br><span class="line">            q = q.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //将中点左边的链表分开</span><br><span class="line">        pre.next = null;</span><br><span class="line">        TreeNode root = new TreeNode(p.val);</span><br><span class="line">        root.left = sortedListToBST(head);</span><br><span class="line">        root.right = sortedListToBST(p.next);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="105-从前序与中序遍历序列构造二叉树-1"><a href="#105-从前序与中序遍历序列构造二叉树-1" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h1><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><p> </p><p>示例 1:</p><p>输入: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]<br>输出: [3,9,20,null,null,15,7]<br>示例 2:</p><p>输入: preorder &#x3D; [-1], inorder &#x3D; [-1]<br>输出: [-1] </p><p>提示:</p><p>1 &lt;&#x3D; preorder.length &lt;&#x3D; 3000<br>inorder.length &#x3D;&#x3D; preorder.length<br>-3000 &lt;&#x3D; preorder[i], inorder[i] &lt;&#x3D; 3000<br>preorder 和 inorder 均 无重复 元素<br>inorder 均出现在 preorder<br>preorder 保证 为二叉树的前序遍历序列<br>inorder 保证 为二叉树的中序遍历序列</p><h2 id="Solution1-递归-6"><a href="#Solution1-递归-6" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;</span><br><span class="line">        // preorder: [root, [left], [right]]</span><br><span class="line">        // inorder:  [[left], root, [right]]</span><br><span class="line">        return buildTree(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, int lo1, int hi1, vector&lt;int&gt;&amp; inorder, int lo2, int hi2) &#123;</span><br><span class="line">        if (lo1 &gt; hi1 || lo2 &gt; hi2) return nullptr;</span><br><span class="line">        int root = preorder[lo1];</span><br><span class="line">        int mid = lo2;</span><br><span class="line">        // 在 inorder 中查找 root 位置</span><br><span class="line">        for (int i = lo2; i &lt;= hi2; ++i) &#123;</span><br><span class="line">            if (inorder[i] == root) &#123;</span><br><span class="line">                mid = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        auto s = new TreeNode(root);</span><br><span class="line">        // 下面的数组表示分割长度</span><br><span class="line">        // inorder: [mid-lo2, mid, hi2-mid]</span><br><span class="line">        // preorder:[root, mid-lo2, hi2-mid]</span><br><span class="line">        s-&gt;left = buildTree(preorder, lo1+1, lo1+mid-lo2, inorder, lo2, mid-1);</span><br><span class="line">        s-&gt;right = buildTree(preorder, lo1+mid-lo2+1, hi1, inorder, mid+1, hi2);</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution2-1"><a href="#Solution2-1" class="headerlink" title="Solution2"></a>Solution2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int getLength(ListNode* head) &#123;</span><br><span class="line">        int ret = 0;</span><br><span class="line">        for (; head != nullptr; ++ret, head = head-&gt;next);</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* buildTree(ListNode*&amp; head, int left, int right) &#123;</span><br><span class="line">        if (left &gt; right) &#123;</span><br><span class="line">            return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = (left + right + 1) / 2;</span><br><span class="line">        TreeNode* root = new TreeNode();</span><br><span class="line">        root-&gt;left = buildTree(head, left, mid - 1);</span><br><span class="line">        root-&gt;val = head-&gt;val;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        root-&gt;right = buildTree(head, mid + 1, right);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode* sortedListToBST(ListNode* head) &#123;</span><br><span class="line">        int length = getLength(head);</span><br><span class="line">        return buildTree(head, 0, length - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h1><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p> </p><p>示例 1：</p><p>输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。<br>     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br>示例 2：</p><p>输入：prices &#x3D; [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 </p><p>提示：</p><p>1 &lt;&#x3D; prices.length &lt;&#x3D; 105<br>0 &lt;&#x3D; prices[i] &lt;&#x3D; 104</p><h2 id="Solution0-暴力解法"><a href="#Solution0-暴力解法" class="headerlink" title="Solution0 暴力解法"></a>Solution0 暴力解法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</span><br><span class="line">        int n = (int)prices.size(), ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            for (int j = i + 1; j &lt; n; ++j) &#123;</span><br><span class="line">                ans = max(ans, prices[j] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution1-动态规划-3"><a href="#Solution1-动态规划-3" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><p>动态规划 前i天的最大收益 &#x3D; max{前i-1天的最大收益，第i天的价格-前i-1天中的最小价格}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        if(prices.length &lt;= 1)</span><br><span class="line">            return 0;</span><br><span class="line">        int min = prices[0], max = 0;</span><br><span class="line">        for(int i = 1; i &lt; prices.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, prices[i] - min);</span><br><span class="line">            min = Math.min(min, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h1><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p><p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p><p>返回 你能获得的 最大 利润 。</p><p> </p><p>示例 1：</p><p>输入：prices &#x3D; [7,1,5,3,6,4]<br>输出：7<br>解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。<br>     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6 - 3 &#x3D; 3 。<br>     总利润为 4 + 3 &#x3D; 7 。<br>示例 2：</p><p>输入：prices &#x3D; [1,2,3,4,5]<br>输出：4<br>解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。<br>     总利润为 4 。<br>示例 3：</p><p>输入：prices &#x3D; [7,6,4,3,1]<br>输出：0<br>解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。 </p><p>提示：</p><p>1 &lt;&#x3D; prices.length &lt;&#x3D; 3 * 104<br>0 &lt;&#x3D; prices[i] &lt;&#x3D; 104</p><h2 id="Solution1-贪心算法"><a href="#Solution1-贪心算法" class="headerlink" title="Solution1 贪心算法"></a>Solution1 贪心算法</h2><p><img src="https://files.mdnice.com/user/1489/5536a636-d181-42b9-a760-57aff155691a.png"></p><h2 id="Solution2-动态规划-2"><a href="#Solution2-动态规划-2" class="headerlink" title="Solution2 动态规划"></a>Solution2 动态规划</h2><p><img src="https://files.mdnice.com/user/1489/9d910293-a6c0-4c4b-bfd8-c8e32fae01e8.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProfit(int[] prices) &#123;</span><br><span class="line">        int [] dp = new int [prices.length+1];//这里从第0天开始，到底i天</span><br><span class="line">        dp[0] = 0;//第0天没有股票，最大利润为0</span><br><span class="line">        dp[1] = 0;//第一天只能买，不能买，因此最大利润也是0</span><br><span class="line">        for(int i = 1;i&lt;prices.length;i++)&#123;</span><br><span class="line">            int A =dp[i]+prices[i]-prices[i-1];//第一种选择</span><br><span class="line">            int B = dp[i];//第二种选择</span><br><span class="line">            dp[i+1] = A&gt;B ? A : B;//i从0开始，所以dp[I＋1]是当前天数 </span><br><span class="line">        &#125;</span><br><span class="line">        return dp[prices.length];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a><a href="https://leetcode.cn/problems/valid-palindrome/">125. 验证回文串</a></h1><p>如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个回文串。</p><p>字母和数字都属于字母数字字符。</p><p>给你一个字符串 s，如果它是回文串，返回 true ；否则，返回 false 。</p><p> </p><p>示例 1：</p><p>输入: “A man, a plan, a canal: Panama”<br>输出：true<br>解释：”amanaplanacanalpanama” 是回文串。<br>示例 2：</p><p>输入：”race a car”<br>输出：false<br>解释：”raceacar” 不是回文串。<br>示例 3：</p><p>输入：s &#x3D; “ “<br>输出：true<br>解释：在移除非字母数字字符之后，s 是一个空字符串 “” 。<br>由于空字符串正着反着读都一样，所以是回文串。 </p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 2 * 105<br>s 仅由可打印的 ASCII 字符组成</p><h2 id="Solution1-筛选-判断"><a href="#Solution1-筛选-判断" class="headerlink" title="Solution1 筛选 + 判断"></a>Solution1 筛选 + 判断</h2><p><img src="https://files.mdnice.com/user/1489/fb453ee9-27d8-4bad-86ea-346219e70b18.png"></p><h2 id="Solution2-筛选-判断-02"><a href="#Solution2-筛选-判断-02" class="headerlink" title="Solution2 筛选 + 判断 02"></a>Solution2 筛选 + 判断 02</h2><p><img src="https://files.mdnice.com/user/1489/bd915655-54ae-4387-8d94-22cabd830f19.png"></p><h2 id="Solution03-在原字符串上直接判断"><a href="#Solution03-在原字符串上直接判断" class="headerlink" title="Solution03 在原字符串上直接判断"></a>Solution03 在原字符串上直接判断</h2><p><img src="https://files.mdnice.com/user/1489/4391ada0-91de-488d-a3a9-23fa346ea804.png"></p><h1 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="">136. 只出现一次的数字</a></h1><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p><p>输入: [4,1,2,1,2]<br>输出: 4</p><h2 id="Solution1-空间复杂度O-n-方法"><a href="#Solution1-空间复杂度O-n-方法" class="headerlink" title="Solution1  空间复杂度O(n)方法"></a>Solution1  空间复杂度O(n)方法</h2><p>如果不考虑时间复杂度和空间复杂度的限制，这道题有很多种解法，可能的解法有如下几种。</p><p>使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。</p><p>使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。</p><p>使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。</p><h2 id="Solution2-空间复杂夫O-1-方法"><a href="#Solution2-空间复杂夫O-1-方法" class="headerlink" title="Solution2 空间复杂夫O(1)方法"></a>Solution2 空间复杂夫O(1)方法</h2><p><img src="https://files.mdnice.com/user/1489/ae0e1058-6b96-43e8-9daa-10bf26ee4ccd.png"></p><p><img src="https://files.mdnice.com/user/1489/779a4035-c7d9-4b9a-b232-3f2cddeaa550.png"></p><h1 id="137-只出现一次的数字-II"><a href="#137-只出现一次的数字-II" class="headerlink" title="137. 只出现一次的数字 II"></a><a href="https://leetcode.cn/problems/single-number-ii/">137. 只出现一次的数字 II</a></h1><p>给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。</p><p> </p><p>示例 1：</p><p>输入：nums &#x3D; [2,2,3,2]<br>输出：3<br>示例 2：</p><p>输入：nums &#x3D; [0,1,0,1,0,1,99]<br>输出：99 </p><p>提示：</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104<br>-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1<br>nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 </p><p>进阶：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><h2 id="Solution1-哈希表"><a href="#Solution1-哈希表" class="headerlink" title="Solution1 哈希表"></a>Solution1 哈希表</h2><p><img src="https://files.mdnice.com/user/1489/12eb162d-772a-41e8-b79b-1e8acfb28d87.png"></p><h2 id="Solution2-二进制"><a href="#Solution2-二进制" class="headerlink" title="Solution2 二进制"></a>Solution2 二进制</h2><p><img src="https://files.mdnice.com/user/1489/7e979e15-b4a4-41bb-92d8-1cfb54630ee6.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int singleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; 32; ++i) &#123;</span><br><span class="line">            int total = 0;</span><br><span class="line">            for (int num: nums) &#123;</span><br><span class="line">                total += ((num &gt;&gt; i) &amp; 1);</span><br><span class="line">            &#125;</span><br><span class="line">            if (total % 3) &#123;</span><br><span class="line">                ans |= (1 &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(n \log C)O(nlogC)，其中 nn 是数组的长度，CC 是元素的数据范围，在本题中 \log C&#x3D;\log 2^{32} &#x3D; 32logC&#x3D;log2<br>32<br> &#x3D;32，也就是我们需要遍历第 0\sim310∼31 个二进制位。</p><p>空间复杂度：O(1)O(1)。</p><h1 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></h1><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</p><p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p> </p><p>示例 1：</p><p>输入: s &#x3D; “leetcode”, wordDict &#x3D; [“leet”, “code”]<br>输出: true<br>解释: 返回 true 因为 “leetcode” 可以由 “leet” 和 “code” 拼接成。<br>示例 2：</p><p>输入: s &#x3D; “applepenapple”, wordDict &#x3D; [“apple”, “pen”]<br>输出: true<br>解释: 返回 true 因为 “applepenapple” 可以由 “apple” “pen” “apple” 拼接成。<br>     注意，你可以重复使用字典中的单词。<br>示例 3：</p><p>输入: s &#x3D; “catsandog”, wordDict &#x3D; [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出: false </p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 300<br>1 &lt;&#x3D; wordDict.length &lt;&#x3D; 1000<br>1 &lt;&#x3D; wordDict[i].length &lt;&#x3D; 20<br>s 和 wordDict[i] 仅有小写英文字母组成<br>wordDict 中的所有字符串 互不相同</p><h2 id="Solution1-动态规划-4"><a href="#Solution1-动态规划-4" class="headerlink" title="Solution1 动态规划"></a>Solution1 动态规划</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</span><br><span class="line">    vector&lt;bool&gt; dp(s.size()+1, false);</span><br><span class="line">    unordered_set&lt;string&gt; m(wordDict.begin(), wordDict.end());</span><br><span class="line">    dp[0] = true;</span><br><span class="line">    for (int i = 1; i &lt;= s.size(); ++i)&#123;</span><br><span class="line">        for (int j = 0; j &lt; i; ++j)&#123;</span><br><span class="line">            if (dp[j] &amp;&amp; m.find(s.substr(j, i-j)) != m.end())&#123;</span><br><span class="line">                dp[i] = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[s.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Solution2-动态规划-优化版"><a href="#Solution2-动态规划-优化版" class="headerlink" title="Solution2 动态规划 优化版"></a>Solution2 动态规划 优化版</h2><p>【优化】对于以上代码可以优化。每次并不需要从s[0]开始搜索。因为wordDict中的字符串长度是有限的。只需要从i-maxWordLength开始搜索就可以了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123;</span><br><span class="line">    vector&lt;bool&gt; dp(s.size()+1, false);</span><br><span class="line">    unordered_set&lt;string&gt; m(wordDict.begin(), wordDict.end());</span><br><span class="line">    dp[0] = true;</span><br><span class="line">    //获取最长字符串长度</span><br><span class="line">    int maxWordLength = 0;</span><br><span class="line">    for (int i = 0; i &lt; wordDict.size(); ++i)&#123;</span><br><span class="line">        maxWordLength = std::max(maxWordLength, (int)wordDict[i].size());</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= s.size(); ++i)&#123;</span><br><span class="line">        for (int j = std::max(i-maxWordLength, 0); j &lt; i; ++j)&#123;</span><br><span class="line">            if (dp[j] &amp;&amp; m.find(s.substr(j, i-j)) != m.end())&#123;</span><br><span class="line">                dp[i] = true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[s.size()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h1><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><p> </p><p>示例 1：</p><p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p><p>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p><p>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：false<br>解释：链表中没有环。 </p><p>提示：</p><p>链表中节点的数目范围是 [0, 104]<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>pos 为 -1 或者链表中的一个 有效索引 。 </p><p>进阶：你能用 O(1)（即，常量）内存解决此问题吗？</p><h2 id="Solution1-哈希表-1"><a href="#Solution1-哈希表-1" class="headerlink" title="Solution1 哈希表"></a>Solution1 哈希表</h2><p><img src="https://files.mdnice.com/user/1489/f65c3a6a-debe-4c68-ac3b-171b07af7262.png"></p><h2 id="Solution2-2"><a href="#Solution2-2" class="headerlink" title="Solution2"></a>Solution2</h2><p><img src="https://files.mdnice.com/user/1489/9add3a1c-b13f-4277-a2b6-e511bf914864.png"></p><p><img src="https://files.mdnice.com/user/1489/1411c0a9-8a0f-452f-8fc6-ff371d70d1d0.png"></p><p><img src="https://files.mdnice.com/user/1489/fc7adb50-508e-4b31-b28e-f3f11eea8217.png"></p><h1 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h1><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>不允许修改 链表。</p><p> </p><p>示例 1：</p><p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p><p>输入：head &#x3D; [1,2], pos &#x3D; 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p><p>输入：head &#x3D; [1], pos &#x3D; -1<br>输出：返回 null<br>解释：链表中没有环。 </p><p>提示：</p><p>链表中节点的数目范围在范围 [0, 104] 内<br>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105<br>pos 的值为 -1 或者链表中的一个有效索引</p><h2 id="Solution1-哈希表-2"><a href="#Solution1-哈希表-2" class="headerlink" title="Solution1 哈希表"></a>Solution1 哈希表</h2><p><img src="https://files.mdnice.com/user/1489/335701cf-1815-4ee0-a266-d54c6c35669b.png"></p><h2 id="Solution2-双指针-2"><a href="#Solution2-双指针-2" class="headerlink" title="Solution2 双指针"></a>Solution2 双指针</h2><p><img src="https://files.mdnice.com/user/1489/725fc0e8-c8e6-4660-b971-9c47beb3c888.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *detectCycle(ListNode *head) &#123;</span><br><span class="line">        ListNode *slow = head, *fast = head;</span><br><span class="line">        while (fast != nullptr) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            if (fast-&gt;next == nullptr) &#123;</span><br><span class="line">                return nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            if (fast == slow) &#123;</span><br><span class="line">                ListNode *ptr = head;</span><br><span class="line">                while (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                return ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/7323d75f-2b46-4b8a-9908-4f5c654281f5.png"></p><h1 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a href="https://leetcode.cn/problems/reorder-list/">143. 重排链表</a></h1><p>给定一个单链表 L 的头节点 head ，单链表 L 表示为：</p><p>L0 → L1 → … → Ln - 1 → Ln<br>请将其重新排列后变为：</p><p>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …<br>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p> </p><p>示例 1：</p><p>输入：head &#x3D; [1,2,3,4]<br>输出：[1,4,2,3]<br>示例 2：</p><p>输入：head &#x3D; [1,2,3,4,5]<br>输出：[1,5,2,4,3] </p><p>提示：</p><p>链表的长度范围为 [1, 5 * 104]<br>1 &lt;&#x3D; node.val &lt;&#x3D; 1000</p><h2 id="Solution0-暴力-1"><a href="#Solution0-暴力-1" class="headerlink" title="Solution0 暴力"></a>Solution0 暴力</h2><h2 id="Solution1-双指针-1"><a href="#Solution1-双指针-1" class="headerlink" title="Solution1 双指针"></a>Solution1 双指针</h2><p>1.快慢指针找到中点 2.拆成两个链表 3.遍历两个链表，后面的塞到前面的“缝隙里”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">void reorderList(ListNode* head) &#123;</span><br><span class="line">    </span><br><span class="line">    if(head==NULL || head-&gt;next == NULL)</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line">    //快慢指针分出两段</span><br><span class="line">    ListNode *slow = head,*fast = head;</span><br><span class="line">    </span><br><span class="line">    while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)&#123;</span><br><span class="line">        </span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //后端反转</span><br><span class="line">    ListNode *needReverser = slow-&gt;next;</span><br><span class="line">    slow-&gt;next = NULL;</span><br><span class="line">    needReverser = reverse(needReverser);</span><br><span class="line">    </span><br><span class="line">    //插入前端缝隙</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    while(cur &amp;&amp; needReverser)&#123;</span><br><span class="line">        ListNode *curSecond = needReverser;</span><br><span class="line">        needReverser = needReverser-&gt;next;</span><br><span class="line">        ListNode *nextCur = cur-&gt;next;</span><br><span class="line">        curSecond-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = curSecond;</span><br><span class="line">        </span><br><span class="line">        cur = nextCur;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode *reverse(ListNode *head)&#123;</span><br><span class="line">    </span><br><span class="line">    ListNode *p1 = NULL;</span><br><span class="line">    ListNode *p2 = head;</span><br><span class="line">    ListNode *p3 = p2;</span><br><span class="line">    </span><br><span class="line">    while(p2)&#123;</span><br><span class="line">        p3 = p2-&gt;next;</span><br><span class="line">        p2-&gt;next = p1;</span><br><span class="line">        p1 = p2;</span><br><span class="line">        p2 = p3;            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return p1;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h1><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p><p> </p><p>示例 1：</p><p>输入：root &#x3D; [1,null,2,3]<br>输出：[1,2,3]<br>示例 2：</p><p>输入：root &#x3D; []<br>输出：[]<br>示例 3：</p><p>输入：root &#x3D; [1]<br>输出：[1]<br>示例 4：</p><p>输入：root &#x3D; [1,2]<br>输出：[1,2]<br>示例 5：</p><p>输入：root &#x3D; [1,null,2]<br>输出：[1,2] </p><p>提示：</p><p>树中节点数目在范围 [0, 100] 内<br>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</p><h2 id="Solution1-递归-7"><a href="#Solution1-递归-7" class="headerlink" title="Solution1 递归"></a>Solution1 递归</h2><p><img src="https://files.mdnice.com/user/1489/04aefe28-f537-4f0f-a96c-e08abbe1030f.png"></p><h2 id="Solution2-迭代-3"><a href="#Solution2-迭代-3" class="headerlink" title="Solution2 迭代"></a>Solution2 迭代</h2><p><img src="https://files.mdnice.com/user/1489/de302c02-3172-4795-81bf-b52f9a497fcf.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        if (root == nullptr) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line">        while (!stk.empty() || node != nullptr) &#123;</span><br><span class="line">            while (node != nullptr) &#123;</span><br><span class="line">                res.emplace_back(node-&gt;val);</span><br><span class="line">                stk.emplace(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(n)O(n)，其中 nn 是二叉树的节点数。每一个节点恰好被遍历一次。</p><p>空间复杂度：O(n)O(n)，为迭代过程中显式栈的开销，平均情况下为 O(\log n)O(logn)，最坏情况下树呈现链状，为 O(n)O(n)。</p>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="Leetcode" scheme="http://example.com/categories/Leetcode/"/>
    
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Linux Command —— Wildcard</title>
    <link href="http://example.com/2022/08/19/Linux-Command-Wildcard/"/>
    <id>http://example.com/2022/08/19/Linux-Command-Wildcard/</id>
    <published>2022-08-19T13:04:07.000Z</published>
    <updated>2022-08-19T13:08:06.584Z</updated>
    
    <content type="html"><![CDATA[<h3 id="asterisk"><a href="#asterisk" class="headerlink" title="* asterisk"></a>* asterisk</h3><ul><li><p>this can represent any number of characters (including zero, in other words, zero or more characters). If you specified a “cd*” it would use “cda”, “cdrom”, “cdrecord” and anything that starts with “cd” also including “cd” itself. “m*l” could by mill, mull, ml, and anything that starts with an m and ends with an l.</p></li><li><h3 id="question-mark"><a href="#question-mark" class="headerlink" title="?  question mark"></a>?  question mark</h3></li><li><p>this can represent any single character. If you specified something at the command line like “hd?” GNU&#x2F;Linux would look for hda, hdb, hdc and every other letter&#x2F;number between a-z, 0-9.</p><h3 id="square-brackets"><a href="#square-brackets" class="headerlink" title="[]   square brackets"></a>[]   square brackets</h3></li><li><p>specifies a range. If you did m[a,o,u]m it can become: mam, mum, mom</p><h3 id="minus-sign-in-the-square-brackets"><a href="#minus-sign-in-the-square-brackets" class="headerlink" title="[-]  minus sign in the square brackets"></a>[-]  minus sign in the square brackets</h3></li><li><p>if you did: m[a-d]m it can become anything that starts and ends with m and has any character a to d in between. For example, these would work: mam, mbm, mcm, mdm. This kind of wildcard specifies an “or” relationship (you only need one to match).</p><h3 id="Exponential-sign-in-the-square-brackets"><a href="#Exponential-sign-in-the-square-brackets" class="headerlink" title="[^] Exponential sign in the square brackets"></a>[^] Exponential sign in the square brackets</h3></li><li><p>if you did: m[a-d]m it can become anything that starts and ends with m and has any character excepts a to d in between.</p></li></ul>]]></content>
    
    
    <summary type="html"> Linux Command —— Wildcard</summary>
    
    
    
    <category term="Linux Command" scheme="http://example.com/categories/Linux-Command/"/>
    
    
    <category term="Linux Command" scheme="http://example.com/tags/Linux-Command/"/>
    
  </entry>
  
  <entry>
    <title>Linux Command _ cut/grep/sort/uniq/wc</title>
    <link href="http://example.com/2022/08/19/Linux-Command-cut-grep-sort-uniq-wc/"/>
    <id>http://example.com/2022/08/19/Linux-Command-cut-grep-sort-uniq-wc/</id>
    <published>2022-08-19T13:03:44.000Z</published>
    <updated>2022-08-19T13:09:06.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH | cut -d  &#x27;:&#x27;  -f 3,5</span><br></pre></td></tr></table></figure><ul><li>-d  Use colon instaed TAB as a field delimiter ,and </li><li>-f  Select 3 to 5 fields of the line data .also print line data with no delimiter charater,unless the  -s option is specified<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep  [-cinv]  &#x27;target string&#x27;  filename </span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file1 | grep  [-cinv]  &#x27;target string&#x27;</span><br></pre></td></tr></table></figure><ul><li>-c  print the count of  matching line  in the input file</li><li>-i   serach the target string ingoring case distinction</li><li>-n print result line number</li><li>-v Invert the sense of matching .print line data with no target string</li></ul><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file1 | sort  [-frutk] </span><br></pre></td></tr></table></figure><ul><li>-f  ingore case distinction</li><li>-r revert the order</li><li>-u  list only one line if line data same with each other</li><li>-t  use specified delimeter charater instead of TAB</li><li>-k  order by specified field</li></ul><h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file1 | uniq   [-ic] </span><br></pre></td></tr></table></figure><p>  only print unique lines ,report or omit repeated lines</p><ul><li>-i igonre case  distinction</li><li>-c print line count</li></ul><h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file1 | wc </span><br></pre></td></tr></table></figure><ul><li><p>-c, –bytes<br> print the byte counts</p></li><li><p>-m, –chars<br> print the character counts</p></li><li><p>-l, –lines<br> print the newline counts</p></li></ul>]]></content>
    
    
    <summary type="html"> Linux Command _ cut/grep/sort/uniq/wc</summary>
    
    
    
    <category term="Linux Command" scheme="http://example.com/categories/Linux-Command/"/>
    
    
    <category term="Linux Command" scheme="http://example.com/tags/Linux-Command/"/>
    
  </entry>
  
  <entry>
    <title>Linux Command �� ls</title>
    <link href="http://example.com/2022/08/19/Linux-Command%E2%80%94%E2%80%94ls/"/>
    <id>http://example.com/2022/08/19/Linux-Command%E2%80%94%E2%80%94ls/</id>
    <published>2022-08-19T13:03:44.000Z</published>
    <updated>2022-08-19T13:10:01.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="9-Basic-�ls�-Command-Examples"><a href="#9-Basic-�ls�-Command-Examples" class="headerlink" title="9 Basic �ls� Command Examples"></a>9 Basic �ls� Command Examples</h2><h3 id="ls-a"><a href="#ls-a" class="headerlink" title="ls -a"></a>ls -a</h3><ul><li>list all files or directories including hidden files or directories. </li><li>file begins with . dot symbol can be regarded as a hidden file<h3 id="ls-d"><a href="#ls-d" class="headerlink" title="ls -d"></a>ls -d</h3></li><li>list directories only  ,rather than files inside the directory</li></ul><h3 id="ls-h"><a href="#ls-h" class="headerlink" title="ls -h"></a>ls -h</h3><ul><li>listall file with human readable format on file sizes (e.g. GB ,KB etc)</li><li><ul><li></li></ul></li></ul><h3 id="ls-i"><a href="#ls-i" class="headerlink" title="ls -i"></a>ls -i</h3><ul><li>list all files with their innode number</li></ul><h3 id="ls-l"><a href="#ls-l" class="headerlink" title="ls -l"></a>ls -l</h3><ul><li>list all files with details</li></ul><h3 id="ls-S"><a href="#ls-S" class="headerlink" title="ls -S"></a>ls -S</h3><ul><li>list files sort by file size rather than by name</li></ul><h3 id="ls-t"><a href="#ls-t" class="headerlink" title="ls -t"></a>ls -t</h3><ul><li>list files order by date  rather than name</li></ul><h3 id="ls-r"><a href="#ls-r" class="headerlink" title="ls -r"></a>ls -r</h3><ul><li>list files with a reversal order </li><li>for example. the deafault order is from a to z , </li><li>the order will turn to be z to a using ls -r<h3 id="ls-R"><a href="#ls-R" class="headerlink" title="ls -R"></a>ls -R</h3></li><li>Recursively list Sub-Directories</li></ul><h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes:"></a>Notes:</h3><p>You can use <code>alias ll = &#39;ls -alh --color=auto&#39; </code><br>to DIY the ls command as ll command</p>]]></content>
    
    
    <summary type="html"> Linux Command �� ls</summary>
    
    
    
    <category term="Linux Command" scheme="http://example.com/categories/Linux-Command/"/>
    
    
    <category term="Linux Command" scheme="http://example.com/tags/Linux-Command/"/>
    
  </entry>
  
  <entry>
    <title>what is Elmore delay</title>
    <link href="http://example.com/2022/08/19/what-is-Elmore-delay/"/>
    <id>http://example.com/2022/08/19/what-is-Elmore-delay/</id>
    <published>2022-08-19T13:03:02.000Z</published>
    <updated>2022-08-19T13:11:16.856Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Elmore delay is a simple approximation to the delay through an RC network in an electronic system. </li><li>For tree structured networks, find the delay through each segment as the R (electrical resistance) times the downstream C (electrical capacitance). Sum the delays from the root to the sink.</li><li>The Elmore delay analysis model estimates the delay from a source (root) to one of the leaf nodes as the sum of the resistance in the path to the ith node multiplied by the capacitance present at the end of the branch. It provides a simplistic delay analysis that avoids time-consuming numerical integration&#x2F;differential equations of an RC network.</li><li>In other words, the propagation delay from a switching source (root) to an ith branch node is given as the product of the capacitance “Ci” of the node with the sum of the resistance from the source to the node, Ris.</li><li><img src="https://img-blog.csdnimg.cn/5136ce6093014a2cb2e93d377454ffa6.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/371d7e24917047c59d8e0ea86cd7861e.png" alt="在这里插入图片描述"><br>The Elmore delay for Vout is given as tpd &#x3D; R1C1+(R1+ R2)C2</li></ul>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="EDA" scheme="http://example.com/categories/EDA/"/>
    
    
    <category term="EDA" scheme="http://example.com/tags/EDA/"/>
    
  </entry>
  
  <entry>
    <title>what is Fan-out</title>
    <link href="http://example.com/2022/08/19/what-is-Fan-out/"/>
    <id>http://example.com/2022/08/19/what-is-Fan-out/</id>
    <published>2022-08-19T13:01:51.000Z</published>
    <updated>2022-08-19T13:11:10.964Z</updated>
    
    <content type="html"><![CDATA[<ul><li>the fan-out is the number of gate inputs driven by the output of another single logic gate.</li><li>扇出（fan-out）是一个定义单个逻辑门能够驱动的数字信号输入最大量的专业术语。</li><li>大多数的TTL逻辑门能够为10个其他数字门或驱动器提供信号。所以，一个典型的TTL逻辑门有10个扇出信号。</li><li>In most designs, logic gates are connected to form more complex circuits. While no logic gate input can be fed by more than one output at a time without causing contention,<code> it is common for one output to be connected to several inputs.</code> The technology used to implement logic gates usually allows a certain number of gate inputs to be wired directly together without additional interfacing circuitry. <code>The maximum fan-out of an output measures its load-driving capability: it is the greatest number of inputs of gates of the same type to which the output can be safely connected.</code></li><li>在大多数设计中，逻辑门被连接起来形成更复杂的电路。虽然没有逻辑门输入可以由多个输出同时提供而不引起争用，但一个输出连接到多个输入是常见的。用于实现逻辑门的技术通常允许一定数量的门输入直接连接在一起，而不需要额外的接口电路。输出的最大扇出测量其负载驱动能力:它是输出可以安全连接的同类型门的最大输入数量。</li></ul>]]></content>
    
    
    <summary type="html"> </summary>
    
    
    
    <category term="EDA" scheme="http://example.com/categories/EDA/"/>
    
    
    <category term="EDA" scheme="http://example.com/tags/EDA/"/>
    
  </entry>
  
  <entry>
    <title>Basic Commands in Tcl(Tool Command Language)</title>
    <link href="http://example.com/2022/06/17/Basic-Commands-in-Tcl-Tool-Command-Language/"/>
    <id>http://example.com/2022/06/17/Basic-Commands-in-Tcl-Tool-Command-Language/</id>
    <published>2022-06-17T05:25:50.000Z</published>
    <updated>2022-06-17T05:32:56.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><a href="https://en.wikipedia.org/wiki/Tcl">What is  Tcl(Tool Command Language) </a></p><h2 id="Basic-Commands"><a href="#Basic-Commands" class="headerlink" title="Basic Commands"></a>Basic Commands</h2><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/tclsh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># variable assign </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> &#123;a&#125; <span class="number">10</span></span><br><span class="line"><span class="keyword">set</span> b <span class="number">12</span></span><br><span class="line"><span class="keyword">set</span> c <span class="number">14</span></span><br><span class="line"><span class="keyword">set</span> d <span class="string">&quot;14&quot;</span></span><br><span class="line"><span class="keyword">set</span> e [<span class="keyword">expr</span> <span class="variable">$d</span> + <span class="number">10</span> + <span class="number">9</span>]</span><br><span class="line"><span class="keyword">set</span> res1 [<span class="keyword">expr</span> <span class="variable">$e</span> / <span class="number">9</span>]<span class="comment">;  # the result is interger,Notice the semicolon here</span></span><br><span class="line"><span class="keyword">set</span> res2 [<span class="keyword">expr</span> <span class="variable">$e</span>/ <span class="number">9.0</span>]<span class="comment">; # the result is float,Notice the semicolon here</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># variable print</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$a</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$&#123;a&#125;</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$b</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$&#123;b&#125;</span></span><br><span class="line"><span class="keyword">puts</span> <span class="string">&quot; $b &quot;</span></span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">expr</span> <span class="variable">$c</span> + <span class="number">10</span> + <span class="number">9</span> ]</span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">expr</span> <span class="variable">$d</span> + <span class="number">10</span> + <span class="number">9</span> ]</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$e</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$res1</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$res2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#===========================================</span></span><br><span class="line"><span class="comment"># Variable Type -String</span></span><br><span class="line"><span class="comment">#===========================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##the default type is string</span></span><br><span class="line"><span class="keyword">set</span> s1 hello        </span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$s1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##use quotation marks</span></span><br><span class="line"><span class="keyword">set</span> s2 <span class="string">&quot;hello world&quot;</span> </span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$s2</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##use brace marks</span></span><br><span class="line"><span class="keyword">set</span> s3 &#123;hello world&#125; </span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$s3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##escape charater</span></span><br><span class="line"><span class="keyword">set</span> s4 <span class="string">&quot;\\  \&#x27; \&quot; \? \a \b \f \n \r \t \v &quot;</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$s4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##string command </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">string</span> compare <span class="variable">$s1</span> <span class="variable">$s2</span>] </span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">string</span> compare <span class="variable">$s2</span> <span class="string">&quot;hello world&quot;</span>]</span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">string</span> length <span class="variable">$s1</span>]</span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">string</span> tolower <span class="variable">$s1</span>]</span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">string</span> index  <span class="variable">$s1</span> <span class="number">2</span>]</span><br><span class="line"><span class="comment">## refer to the TCL manual for more other string related commands</span></span><br><span class="line"><span class="comment">## index,length,range,tplower,toupper,trimleft .etc..</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#===========================================</span></span><br><span class="line"><span class="comment"># Variable Type -List</span></span><br><span class="line"><span class="comment">#===========================================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> list1 &#123;a b c&#125;</span><br><span class="line"><span class="keyword">set</span> list2 [<span class="keyword">list</span> a b c]</span><br><span class="line"><span class="keyword">set</span> list3 [<span class="keyword">split</span> <span class="string">&quot;a_b_c&quot;</span> _]</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$list1</span> </span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$list2</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$list3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## index</span></span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">lindex</span> <span class="variable">$list3</span> <span class="number">2</span>] </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## append</span></span><br><span class="line"><span class="keyword">append</span> list1 <span class="string">&quot; &quot;</span> <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="keyword">append</span> list1 <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="keyword">lappend</span> list1 <span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$list1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## length</span></span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">llength</span> <span class="variable">$list1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## index</span></span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">lindex</span> <span class="variable">$list1</span> <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## insert </span></span><br><span class="line"><span class="keyword">puts</span> <span class="string">&quot;insert&quot;</span></span><br><span class="line"><span class="keyword">set</span> list1 [<span class="keyword">linsert</span> <span class="variable">$list1</span> <span class="number">3</span> hi asd asd]</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$list1</span></span><br><span class="line"><span class="comment">##puts  [linsert $list1 3 hi asd asd]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## replace </span></span><br><span class="line"><span class="keyword">set</span> list1 [<span class="keyword">lreplace</span> <span class="variable">$list1</span> <span class="number">1</span> <span class="number">1</span> hello ]</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$list1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## set </span></span><br><span class="line"><span class="comment">#puts [lset list1 0 world]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## assign </span></span><br><span class="line"><span class="comment">#lassign list1 tmp_list1 tmp_list2</span></span><br><span class="line"><span class="comment">#puts $tmp_list1</span></span><br><span class="line"><span class="comment">#puts $tmp_list2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## sort </span></span><br><span class="line"><span class="keyword">set</span> list1 [<span class="keyword">lsort</span> <span class="variable">$list1</span>]</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$list1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#================================</span></span><br><span class="line"><span class="comment"># Variable Type - Array</span></span><br><span class="line"><span class="comment">#================================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> array1(<span class="number">0</span>) chen</span><br><span class="line"><span class="keyword">set</span> array1(<span class="number">1</span>) weijie</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$array1</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$array1</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">puts</span> [<span class="keyword">array</span> size array1]</span><br><span class="line"><span class="keyword">puts</span> <span class="string">&quot;iterats&quot;</span></span><br><span class="line"><span class="keyword">for</span> &#123; <span class="keyword">set</span> index <span class="number">0</span> &#125;  &#123; <span class="variable">$index</span> &lt; [<span class="keyword">array</span> size array1] &#125;  &#123; <span class="keyword">incr</span> index &#125; &#123;</span><br><span class="line">        <span class="keyword">puts</span> <span class="string">&quot;$&#123;index&#125;&quot;</span></span><br><span class="line">        <span class="keyword">puts</span> <span class="string">&quot;$array1($index)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> person1(age) <span class="number">80</span></span><br><span class="line"><span class="keyword">set</span> person1(name) chen</span><br><span class="line"><span class="keyword">foreach</span> index [<span class="keyword">array</span> names person1] &#123; </span><br><span class="line">        <span class="keyword">puts</span> <span class="string">&quot;$index&quot;</span></span><br><span class="line">        <span class="keyword">puts</span> <span class="string">&quot;$person1($index)&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#=====================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Variable Type - dict</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#======================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##dict create d1 name chen  age 17</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##dict set d2 name Jason</span></span><br><span class="line"><span class="comment">##dict set d2 age 18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##set d3 [dict create name Bob age 19]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###puts $d1</span></span><br><span class="line"><span class="comment">##puts $d2</span></span><br><span class="line"><span class="comment">##puts $d3</span></span><br><span class="line"><span class="comment">##puts [dict size $d1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### refer to document for more details</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#=====================</span></span><br><span class="line"><span class="comment"># Condition Statement </span></span><br><span class="line"><span class="comment">#=====================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> a <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> &#123; <span class="variable">$a</span> == <span class="number">10</span> &#125; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">puts</span> <span class="string">&quot;Value is 10&quot;</span></span><br><span class="line"></span><br><span class="line">&#125; elseif &#123; <span class="variable">$a</span> == <span class="number">20</span> &#125; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">puts</span> <span class="string">&quot;Value is 20&quot;</span></span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">puts</span> <span class="string">&quot;no matching value&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> <span class="variable">$a</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="number">10</span> &#123;</span><br><span class="line">         <span class="keyword">puts</span> <span class="string">&quot;the value is 10&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">20</span> &#123;</span><br><span class="line">         <span class="keyword">puts</span> <span class="string">&quot;the value is 20&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        default &#123;</span><br><span class="line">        <span class="keyword">puts</span> <span class="string">&quot;no matching value&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> b [<span class="keyword">expr</span> <span class="variable">$a</span> == <span class="number">10</span> ? <span class="number">10</span> : <span class="number">20</span>]</span><br><span class="line"><span class="keyword">puts</span> <span class="string">&quot;the value of b is : $b \n&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#=====================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Loop Stament</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#=====================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> &#123; <span class="variable">$a</span> &lt; <span class="number">40</span> &#125; &#123;</span><br><span class="line">        <span class="keyword">incr</span> a</span><br><span class="line">        <span class="keyword">puts</span> <span class="string">&quot; the value of $a &quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123; <span class="keyword">set</span> index <span class="variable">$b</span>&#125; &#123; <span class="variable">$index</span> &lt; <span class="number">30</span> &#125; &#123; <span class="keyword">incr</span> index &#125; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">puts</span> <span class="string">&quot; the value of index : $index &quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> &#123; <span class="variable">$index</span> == <span class="number">21</span> &#125; &#123;</span><br><span class="line">                <span class="keyword">incr</span> index</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> &#123; <span class="variable">$index</span> == <span class="number">25</span> &#125; &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#====================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Proc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#====================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">proc</span><span class="title"> func1</span> &#123;&#125; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">puts</span> <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">proc</span><span class="title"> func2</span> &#123; a b &#125; &#123;</span><br><span class="line">        <span class="keyword">return</span> [ <span class="keyword">expr</span> <span class="variable">$a</span> + <span class="variable">$b</span> ]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">proc</span><span class="title"> func3</span> &#123; numbers &#125; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">set</span> sum <span class="number">0</span> </span><br><span class="line">        <span class="keyword">foreach</span> number <span class="variable">$numbers</span> &#123;</span><br><span class="line">                <span class="keyword">set</span> sum [ <span class="keyword">expr</span>  <span class="variable">$sum</span> + <span class="variable">$number</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> avg [ <span class="keyword">expr</span> <span class="variable">$sum</span> / [ <span class="keyword">llength</span>  <span class="variable">$numbers</span> ]]</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$avg</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">proc</span><span class="title"> func4</span> &#123; a &#123; b <span class="number">10</span> &#125; &#125; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [ <span class="keyword">expr</span> <span class="variable">$a</span> + <span class="variable">$b</span> ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">proc</span><span class="title"> func5</span> &#123; num &#125; &#123;</span><br><span class="line">        <span class="keyword">if</span> &#123; <span class="variable">$num</span> == <span class="number">1</span> &#125; &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [ <span class="keyword">expr</span>  <span class="variable">$num</span> * [ func5 [ <span class="keyword">expr</span> <span class="variable">$num</span> <span class="number">-1</span> ]]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func1</span><br><span class="line"></span><br><span class="line"><span class="keyword">puts</span> [ func2  <span class="number">10</span> <span class="number">20</span>  ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">puts</span> [func3  &#123;<span class="number">10</span> <span class="number">20</span> <span class="number">30</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">puts</span> [func4 <span class="number">10</span> ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">puts</span> [ func4 <span class="number">10</span> <span class="number">20</span> ] </span><br><span class="line"></span><br><span class="line"><span class="keyword">puts</span> [ func5 <span class="number">5</span> ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#NameSpace </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#===================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## define namespace </span></span><br><span class="line"><span class="keyword">namespace</span>  <span class="keyword">eval</span> MyMath &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">variable</span> myResult</span><br><span class="line"></span><br><span class="line">        <span class="keyword">namespace</span> <span class="keyword">eval</span> MyMath_Inner &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">variable</span> myResult1</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## set the variable And proc of the namespace </span></span><br><span class="line"><span class="keyword">proc</span><span class="title"> MyMath::Add</span> &#123; a b &#125; &#123;</span><br><span class="line">        <span class="keyword">set</span> ::MyMath::myResult [ <span class="keyword">expr</span> <span class="variable">$a</span> + <span class="variable">$b</span> ]</span><br><span class="line">        <span class="keyword">set</span> ::MyMath::myResult1 [ <span class="keyword">expr</span> <span class="variable">$a</span> - <span class="variable">$b</span> ]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## print the varible  And proc output of the namespace</span></span><br><span class="line">MyMath::Add <span class="number">10</span> <span class="number">23</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$::MyMath::myResult</span></span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$::MyMath::myResult1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## export the porc of the namespace</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="keyword">eval</span>  testNamespace &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">namespace</span> export testProc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">proc</span><span class="title"> testNamespace::testProc</span> &#123;a  b&#125; &#123;</span><br><span class="line">        <span class="keyword">return</span>  [<span class="keyword">expr</span> <span class="variable">$a</span> * <span class="variable">$b</span> ]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> import testNamespace::* </span><br><span class="line"><span class="keyword">puts</span> [ testProc <span class="number">10</span> <span class="number">20</span> ] </span><br><span class="line"><span class="keyword">namespace</span> forget testNamespace::* </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#=======================</span></span><br><span class="line"><span class="comment">#File IO</span></span><br><span class="line"><span class="comment">#=======================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## write file </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> fp [ <span class="keyword">open</span> <span class="string">&quot;FileIoTest&quot;</span> w+]</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$fp</span> <span class="string">&quot;test&quot;</span></span><br><span class="line"><span class="keyword">close</span> <span class="variable">$fp</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## read file </span></span><br><span class="line"><span class="keyword">set</span> fp [<span class="keyword">open</span> <span class="string">&quot;FileIoTest&quot;</span> r]</span><br><span class="line"><span class="keyword">set</span> content [<span class="keyword">read</span> <span class="variable">$fp</span>]</span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$content</span></span><br><span class="line"><span class="keyword">close</span> <span class="variable">$fp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># read file line by line</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> fp [<span class="keyword">open</span> <span class="string">&quot;FileIoTest2&quot;</span> w+] </span><br><span class="line"><span class="keyword">puts</span> <span class="variable">$fp</span> <span class="string">&quot;hello \n world&quot;</span></span><br><span class="line"><span class="keyword">close</span> <span class="variable">$fp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> fp [<span class="keyword">open</span> <span class="string">&quot;FileIoTest2&quot;</span> r]</span><br><span class="line"><span class="keyword">while</span> &#123; [<span class="keyword">gets</span> <span class="variable">$fp</span> data] &gt;<span class="number">0</span> &#125; &#123;</span><br><span class="line">        <span class="keyword">puts</span> <span class="variable">$data</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">close</span> <span class="variable">$fp</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#===================</span></span><br><span class="line"><span class="comment">#Error &amp; Catch </span></span><br><span class="line"><span class="comment">#===================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">proc</span><span class="title"> Div</span> &#123;a b&#125; &#123;</span><br><span class="line">    <span class="keyword">if</span> &#123;<span class="variable">$b</span> == <span class="number">0</span>&#125; &#123;</span><br><span class="line">  <span class="keyword">error</span> <span class="string">&quot;Error generated by error&quot;</span> <span class="string">&quot;Info String for error&quot;</span> <span class="number">401</span></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="keyword">expr</span> <span class="variable">$a</span>/<span class="variable">$b</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> &#123;[<span class="keyword">catch</span> &#123;<span class="keyword">puts</span> <span class="string">&quot;Result = [Div 10 0]&quot;</span>&#125; errmsg]&#125; &#123;</span><br><span class="line">   <span class="keyword">puts</span> <span class="string">&quot;ErrorMsg: $errmsg&quot;</span></span><br><span class="line">   <span class="keyword">puts</span> <span class="string">&quot;ErrorCode: $errorCode&quot;</span></span><br><span class="line">   <span class="keyword">puts</span> <span class="string">&quot;ErrorInfo:\n$errorInfo\n&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> &#123;[<span class="keyword">catch</span> &#123;<span class="keyword">puts</span> <span class="string">&quot;Result = [Div 10 2]&quot;</span>&#125; errmsg]&#125; &#123;</span><br><span class="line">   <span class="keyword">puts</span> <span class="string">&quot;ErrorMsg: $errmsg&quot;</span></span><br><span class="line">   <span class="keyword">puts</span> <span class="string">&quot;ErrorCode: $errorCode&quot;</span></span><br><span class="line">   <span class="keyword">puts</span> <span class="string">&quot;ErrorInfo:\n$errorInfo\n&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html"> TCL</summary>
    
    
    
    <category term="TCL" scheme="http://example.com/categories/TCL/"/>
    
    
    <category term="TCL" scheme="http://example.com/tags/TCL/"/>
    
  </entry>
  
  <entry>
    <title>C++中的引用</title>
    <link href="http://example.com/2022/05/29/C-%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/"/>
    <id>http://example.com/2022/05/29/C-%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/</id>
    <published>2022-05-29T06:55:15.000Z</published>
    <updated>2022-08-28T09:46:53.960Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="引用的基本原理"><a href="#引用的基本原理" class="headerlink" title="引用的基本原理"></a>引用的基本原理</h2><p>引用的实现原理其实通过下面5句话,1副图,1段代码就可以说明白了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a=1;</span><br><span class="line">int &amp;b=a</span><br></pre></td></tr></table></figure><p>1.引用变量b和被引用变量a并没有共用一块内存,b是另外开辟了一块内存的</p><p>2.引用变量b开辟的内存中存放的是a的地址</p><p>3.任何对变量b的操作,都将转换为对(*b)的操作,比如b&#x3D;b+1实际上是(*b)&#x3D;(*b)+1 而(*b)代表的就是a </p><p>4.基于上面3点我们可以总结出 引用变量b可以理解为被引用变量a的别名</p><p>5.引用必须在声明引用时将其初始化，而不能先声明，再赋值。也不能在使用过程中途对其赋值企图更改被引用的值,那样是无效的<br>比如:<br>int rats &#x3D; 101;<br>int &amp; rodents &#x3D; rats;<br>int bunnies &#x3D; 50;<br>rodents &#x3D; bunnies;<br>在上面一通操作以后rodent引用的还是rats</p><p>上面的两句代码 对应的内存分布图就如下<br><img src="https://files.mdnice.com/user/1489/9c6eb51d-ee87-436b-9839-0c5bad2ffe87.png"></p><p>再看一个实际的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">  using namespace std;</span><br><span class="line">  </span><br><span class="line">  int main()&#123;</span><br><span class="line">    int  a = 1;</span><br><span class="line">    int&amp;  b = a;</span><br><span class="line">    cout &lt;&lt; &quot;a:address-&gt;&quot; &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;b:address-&gt;&quot; &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a:address-&gt;0031FD54 </span><br><span class="line">b:address-&gt;0031FD54</span><br></pre></td></tr></table></figure><h2 id="引用的基本使用"><a href="#引用的基本使用" class="headerlink" title="引用的基本使用"></a>引用的基本使用</h2><p><img src="https://files.mdnice.com/user/1489/71a4aff5-8ed6-41a9-b935-252f6bd6b451.png"><br>还没有测试函数的引用实参和右值引用</p><h2 id="引用的基本类型"><a href="#引用的基本类型" class="headerlink" title="引用的基本类型"></a>引用的基本类型</h2><h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h3><ul><li><ol><li>在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">举个例子，int a = b+c, a 就是左值，</span><br><span class="line">其有变量名为a，通过&amp;a可以获取该变量的地址；</span><br><span class="line">表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，</span><br><span class="line">我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。</span><br></pre></td></tr></table></figure></li></ol></li><li><ol start="2"><li>左值一定在内存中，右值有可能在内存中也有可能在寄存器中</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a=5；</span><br><span class="line"></span><br><span class="line">int b=a;//此时a在内存中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int a=5；</span><br><span class="line"></span><br><span class="line">int b=a+1;//此时a+1在寄存器中</span><br><span class="line"></span><br><span class="line">int *p=&amp;a;//此时&amp;a在寄存器中</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="左值引用与右值引用"><a href="#左值引用与右值引用" class="headerlink" title="左值引用与右值引用"></a>左值引用与右值引用</h3><ul><li><ol><li>在内存中的变量才是可以取地址的，而在寄存器中的变量是不可以取地址的。对于一个不能取地址的表达式或者值是无法直接引用的。</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">int num1(5);</span><br><span class="line">int num2(10);</span><br><span class="line">int *pnum(&amp;num1);//将num1的地址传递给pnum</span><br><span class="line">int * &amp;rnum = pnum;//rnum是pnum的别名</span><br><span class="line">rnum = &amp;num2;//rnumhe pnum指向同一片内存  改变了rnum就相当于改变了pnum</span><br><span class="line">cout &lt;&lt; *pnum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">int num1(5);</span><br><span class="line">int num2(10);</span><br><span class="line"></span><br><span class="line">int * &amp;rnum = &amp;num1;//这是不允许的  无法从“int *”转换为“int *&amp;”</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>从以上两个例子可以看出int *pnum(&amp;num1); int * &amp;rnum &#x3D; pnum;</p></li><li><p>通过一个指针在进行取别名是可以的，因为此时指针在内存中，而直接int * &amp;rnum &#x3D; &amp;num1;取别名是不行的，&amp;num1在寄存器中。</p></li><li><p>在内存中的值是可以直接取别名的也就是引用。但是在寄存器中的值在不可以直接被引用的。其实这就是所谓的左值引用和右值引用。</p></li><li><p>2.左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型。右值引用和左值引用都是属于引用类型。</p></li><li><p>3.右值引用的方法就是int * &amp;&amp;rnum &#x3D; &amp;num1;  。</p></li><li><p>4.下面来说一下为什么要右值引用，右值引用在你需要使用寄存器中的值的时候可以进行右值引用。寄存器的刷新速度很快，没有右值引用的话就需要将寄存器中的值拷贝到内存中，在进行使用，这是很浪费时间的。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int getdata(int &amp;&amp;num)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; num;</span><br><span class="line">num += 10;</span><br><span class="line">return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 5;</span><br><span class="line">cout &lt;&lt; getdata(a + 1) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如上 int getdata(int &amp;&amp;num)就是对右值进行引用。 getdata(a + 1) 中a+1是右值在寄存器中，我们是不可以直接对他进行操作的，如果要操作得将其拷贝到内存中，如果是一个非常大的数据这种拷贝就会很占用内存，如果直接用右值引用就可以直接对其进行操作。从而节约内存。</p><ul><li><ol start="5"><li>无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。</li></ol></li></ul><h2 id="引用与const"><a href="#引用与const" class="headerlink" title="引用与const"></a>引用与const</h2><ul><li><ol><li>左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值引用只能接受非常量左值对其进行初始化。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int &amp;a = 2;       # 左值引用绑定到右值，编译失败</span><br><span class="line"> </span><br><span class="line">int b = 2;        # 非常量左值</span><br><span class="line">const int &amp;c = b; # 常量左值引用绑定到非常量左值，编译通过</span><br><span class="line">const int d = 2;  # 常量左值</span><br><span class="line">const int &amp;e = c; # 常量左值引用绑定到常量左值，编译通过</span><br><span class="line">const int &amp;b =2;  # 常量左值引用绑定到右值，编程通过</span><br></pre></td></tr></table></figure></li></ol></li></ul><p>常量左值引用内部实现的原理是这样的:对于不可寻址的值，如文字常量，以及不同类型的对象，编译器为了实现引用，必须生成一个临时对象，将该对象的值置入临时对象中，引用实际上指向该对象（对该引用的操作就是对该临时对象的操作），但用户不能访问它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">例如:</span><br><span class="line"></span><br><span class="line">double dval = 23;</span><br><span class="line">const int &amp;ri = dval;</span><br><span class="line">编译器将其转换为:</span><br><span class="line"></span><br><span class="line">int tmp = dval; // double -&gt; int</span><br><span class="line">const int &amp;ri = tmp;</span><br><span class="line">同理：上面代码</span><br><span class="line"></span><br><span class="line">double dval = 3.14159;</span><br><span class="line">//下3行仅对const引用才是合法的</span><br><span class="line">const int &amp;ir = 1024;</span><br><span class="line">const int &amp;ir2 = dval;</span><br><span class="line">const double &amp;dr = dval + 1.0;</span><br><span class="line">内部转化为：</span><br><span class="line"></span><br><span class="line">double dval = 3.14159;</span><br><span class="line">//不可寻址，文字常量</span><br><span class="line">int tmp1 = 1024;</span><br><span class="line">const int &amp;ir = tmp1;</span><br><span class="line">//不同类型</span><br><span class="line">int tmp2 = dval;//double -&gt; int</span><br><span class="line">const int &amp;ir2 = tmp2;</span><br><span class="line">//另一种情况，不可寻址</span><br><span class="line">double tmp3 = dval + 1.0;</span><br><span class="line">const double &amp;dr = tmp3;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><ol start="2"><li>右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值，例如：</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a;</span><br><span class="line">int &amp;&amp;r1 = c;             # 编译失败</span><br><span class="line">int &amp;&amp;r2 = std::move(a);  # 编译通过</span><br></pre></td></tr></table></figure><ul><li>3.const引用与非const引用的对比</li></ul><p>[0].const引用表示，试图通过此引用去(间接)改变其引用的对象的值时，编译器会报错！我们仍然可以直接改变其指向对象的值，只是不能通过引用改变。总结来说就是const引用只是表明：保证不会通过此引用间接的改变被引用的对象！下面是一个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 1 #include &lt;iostream&gt;</span><br><span class="line"> 2 using namespace std;</span><br><span class="line"> 3</span><br><span class="line"> 4 int main()</span><br><span class="line"> 5 &#123;</span><br><span class="line"> 6     int val = 1024;</span><br><span class="line"> 7     const int &amp;ir = val;</span><br><span class="line"> 8     </span><br><span class="line"> 9     val++;//我们仍然可以通过val直接改变其值</span><br><span class="line">10     //ir++;//通过ir来改变val的值，编译时会出错</span><br><span class="line">11</span><br><span class="line">12     cout &lt;&lt; val &lt;&lt; &quot; &quot; &lt;&lt; ir &lt;&lt; endl;</span><br><span class="line">13</span><br><span class="line">14     return 0;</span><br><span class="line">15 &#125;</span><br></pre></td></tr></table></figure><p>另外，const既可以放到类型前又可以放到类型后面，放类型后比较容易理解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string const *t1;</span><br><span class="line">const string *t1;</span><br><span class="line">typedef string* pstring;</span><br><span class="line">string s;</span><br><span class="line">const pstring cstr1 = &amp;s;//此时放前面就出错了</span><br><span class="line">pstring const cstr2 = &amp;s;//但是放在类型后面不会出错</span><br></pre></td></tr></table></figure><p>[1]、const引用可读不可改，与绑定对象是否为const无关；非const引用可读可改，只可与非const对象绑定</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int ival = 1024;</span><br><span class="line">const int &amp;refVal = ival; // ok: both reference and object are const</span><br><span class="line">int &amp;ref2 = ival;            // error: nonconst reference to a const object</span><br></pre></td></tr></table></figure><p>[2]、非const引用只能绑定到与该引用同类型的对象，const引用则可以绑定到不同但相关的类型的对象或绑定到左值，同时const引用可以初始化为不同类型的对象或者初始化为右值，如字面值常量。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int i = 42;</span><br><span class="line">// legal for const references only</span><br><span class="line">const int &amp;r = 42;//初始化为右值</span><br><span class="line">const int &amp;r2 = r + i;//同样的初始化对于非const引用却是不合法的，而且会导致编译时错误。</span><br><span class="line">double dval = 3.14;</span><br><span class="line">const int &amp;ri = dval;//不同类型对象</span><br><span class="line">编译器会把这些代码转换成如以下形式的编码：</span><br><span class="line"></span><br><span class="line">int temp = dval;          // create temporary int from the double</span><br><span class="line">const int &amp;ri = temp;   // bind ri to that temporary</span><br></pre></td></tr></table></figure><p>[3].const引用和非const引用在内存中的对比</p><p>例如const引用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const int t = 9;</span><br><span class="line">const int&amp; k = t;</span><br><span class="line">cout&lt;&lt;&amp;k&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&amp;t&lt;&lt;endl;</span><br><span class="line">输出是</span><br><span class="line">0012FF6C</span><br><span class="line">0012FF74</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例如非const引用：</span><br><span class="line">int t = 9;</span><br><span class="line">int&amp; k = t;</span><br><span class="line">cout&lt;&lt;&amp;k&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&amp;t&lt;&lt;endl;</span><br><span class="line">输出是</span><br><span class="line">0012FF74</span><br><span class="line">0012FF74</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/88d5ede3-221f-4bcc-b76f-1fec42db7c37.png"></p><h2 id="引用与函数"><a href="#引用与函数" class="headerlink" title="引用与函数"></a>引用与函数</h2><h3 id="1-类型匹配问题"><a href="#1-类型匹配问题" class="headerlink" title="1.类型匹配问题"></a>1.类型匹配问题</h3><ul><li>如果函数形参，用到了引用类型<br>则如果不注意实参和形参的类型匹配，就会出现问题<br>比如如果形参是非常量左值引用 void func(int &amp;a)<br>则如果你传进去的是常量左值 比如const int b &#x3D; 1；<br>或者右值5<br>那么就会调用func(b)  func(5)报错</li></ul><p><img src="https://files.mdnice.com/user/1489/88d5ede3-221f-4bcc-b76f-1fec42db7c37.png"></p><p>根据这个表格做好类型匹配<br>具体原理看上面的讲解</p><p><a href="https://blog.csdn.net/qq_40888863/article/details/119078245">https://blog.csdn.net/qq_40888863&#x2F;article&#x2F;details&#x2F;119078245</a></p><ul><li>比如如果形参是非常量左值引用 void swap(int &amp;a,int &amp;b)<br>但是你传进去的实参是long a&#x3D; 1; long b &#x3D; 2;<br>那么你传进去时 在赋值给形参的时候<br>实际上会生成一个临时变量<br>这样swap函数交换的实际上时临时变量<br>不会对实参进行交换</li></ul><p><a href="https://blog.csdn.net/qq_36412526/article/details/109580579?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.pc_relevant_aa&spm=1001.2101.3001.4242.1&utm_relevant_index=3">https://blog.csdn.net/qq_36412526&#x2F;article&#x2F;details&#x2F;109580579?utm_medium&#x3D;distribute.pc_relevant.none-task-blog-2<del>default</del>baidujs_title~default-0.pc_relevant_aa&amp;spm&#x3D;1001.2101.3001.4242.1&amp;utm_relevant_index&#x3D;3</a></p><h3 id="2-什么时候函数形参用引用类型？"><a href="#2-什么时候函数形参用引用类型？" class="headerlink" title="2. 什么时候函数形参用引用类型？"></a>2. 什么时候函数形参用引用类型？</h3><ul><li><ol><li><p>运行效率</p><p> 引用类型形参不用像值传递那样开辟内存空间进行大量数据的赋值</p><p> 对于类对象 不用调用拷贝构造函数</p></li></ol></li><li><ol start="2"><li><p>程序员能够修改调用函数中的数据对象</p><p>如果使用值传递, 修改的只是副本</p></li></ol></li></ul><h3 id="3-什么时候函数形参用const类型？"><a href="#3-什么时候函数形参用const类型？" class="headerlink" title="3. 什么时候函数形参用const类型？"></a>3. 什么时候函数形参用const类型？</h3><p>尽可能使用const<br>将引用参数声明为常量数据的引用的理由有三个：</p><ul><li><p>1)、防修改：<br>使用const可以避免无意中修改数据的编程错误。</p></li><li><p>2)、接受const和非const实参:<br>使用const使函数能够处理const和非const实参，否则将只能接受非const数据。</p></li><li><p>3)、和引用配合，能同时接受左值和右值:<br>使用const引用使函数能够正确生成并使用临时变量。</p></li></ul><h3 id="4-函数参数值传递、指针传递、引用传递区别"><a href="#4-函数参数值传递、指针传递、引用传递区别" class="headerlink" title="4. 函数参数值传递、指针传递、引用传递区别"></a>4. 函数参数值传递、指针传递、引用传递区别</h3><p><a href="https://www.cnblogs.com/yanlingyin/archive/2011/12/07/2278961.html">https://www.cnblogs.com/yanlingyin/archive/2011/12/07/2278961.html</a></p><h3 id="5-函数形参类型的使用准则"><a href="#5-函数形参类型的使用准则" class="headerlink" title="5. 函数形参类型的使用准则"></a>5. 函数形参类型的使用准则</h3><ul><li>对于使用传递值而不做修改的函数：</li></ul><p>如果数据对象较小，如内置数据类型或者小型结构，则按值传递。</p><p>如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针。</p><p>如果数据对象是较大的结构，则使用const指针或const引用，以提高运行效率。这样可以节省复制结构所需的时间和空间。</p><p>如果数据对象是类对象，则使用const引用。类设计的语义常常要求使用引用，这是C++增加引用特性的主要原因。因此，传递类对象参数的标准方式是按引用传递。</p><ul><li>对于修改调用函数中数据的函数：</li></ul><p>如果数据对象是内置数据类型，则使用指针。如果看到诸如fixit(&amp;x)这样的代码（其中x是int型），则很明显，该函数将修改x。</p><p>如果数据对象是数组，则只能使用指针。</p><p>如果数据对象是结构，则使用引用或指针。</p><p>如果数据对象是类对象，则使用引用。</p><p><img src="https://files.mdnice.com/user/1489/bad9ef2e-434c-4542-990a-f762e4618d86.png"></p><h2 id="引用与指针"><a href="#引用与指针" class="headerlink" title="引用与指针"></a>引用与指针</h2><p><img src="https://files.mdnice.com/user/1489/a4b6439c-44c9-4c1f-b4c1-a2a854f26b50.png"></p>]]></content>
    
    
    <summary type="html"> 引用 </summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中的const关键字</title>
    <link href="http://example.com/2022/05/29/C-%E4%B8%AD%E7%9A%84const%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://example.com/2022/05/29/C-%E4%B8%AD%E7%9A%84const%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2022-05-29T05:37:41.000Z</published>
    <updated>2022-05-29T08:35:32.211Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="const与基本变量"><a href="#const与基本变量" class="headerlink" title="const与基本变量"></a>const与基本变量</h2><p><img src="https://files.mdnice.com/user/1489/52d0e399-5cf3-4fab-af68-e2a7a4cd8464.png" alt="img"></p><p><img src="https://files.mdnice.com/user/1489/359421a9-a125-4e7a-ada0-449d650b20b6.png" alt="img"></p><h2 id="const与extern"><a href="#const与extern" class="headerlink" title="const与extern"></a>const与extern</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>正常来说， 在B.cpp中定义了变量int i &#x3D; 0 则A.cpp中使用extern int i 使用这个变量i 但是现在的问题是 如果你在B.cpp中定义的这个变量i是const的 那么用同样的方式在A.cpp中引用这个变量 并编译的时候 g++ A.cpp  B.cpp -o test 就会发现出现了未定义引用的错误</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>错误的原因在这篇文章中说的很清楚 <a href="https://zhuanlan.zhihu.com/p/272828566">https://zhuanlan.zhihu.com/p/272828566</a></p><p>总结一下就是 如果变量被const定义的话 就会修改这个变量的链接属性 那么这个变量就不能被外部的文件链接了</p><h3 id="解决措施"><a href="#解决措施" class="headerlink" title="解决措施"></a>解决措施</h3><p>解决的措施在这篇文章中也说的很清楚 <a href="https://zhuanlan.zhihu.com/p/272828566">https://zhuanlan.zhihu.com/p/272828566</a></p><p>总结一下就是 在B.cpp的该变量i前面也加上extern关键字就可以了 因为extern有一个不太被关注的作用是， 在C++中，它可以改变const变量的链接属性。 让这个变量变得能够被外部文件链接到</p><h3 id="标准用法"><a href="#标准用法" class="headerlink" title="标准用法"></a>标准用法</h3><p>正确用法如下 <img src="https://files.mdnice.com/user/1489/f90c2e3b-45ee-4020-b4c5-66745331b114.png" alt="img"></p><p><img src="https://files.mdnice.com/user/1489/fb4161ac-deb5-4557-b34d-c64ec1fce3ee.png" alt="img"></p><h2 id="const与指针"><a href="#const与指针" class="headerlink" title="const与指针"></a>const与指针</h2><h3 id="指向常量的指针-const在-号前"><a href="#指向常量的指针-const在-号前" class="headerlink" title="指向常量的指针(const在*号前)"></a>指向常量的指针(const在*号前)</h3><ul><li>不能通过指针改变其所指向对象值</li><li>即能指向常量对象也能指向非常量对象</li></ul><h3 id="常量指针-const在-号后"><a href="#常量指针-const在-号后" class="headerlink" title="常量指针 (const在*号后)"></a>常量指针 (const在*号后)</h3><ul><li>其所指向的地址不变</li><li>可以通过常量指针改变所指向对象的值</li></ul><p><img src="https://files.mdnice.com/user/1489/6da8b4da-ac00-4b04-930d-3ee672417e06.png" alt="img"></p><p><img src="https://files.mdnice.com/user/1489/84408089-ea82-4578-aad7-3a0877b28317.png" alt="img"></p><h2 id="const与类型转换"><a href="#const与类型转换" class="headerlink" title="const与类型转换"></a>const与类型转换</h2><ul><li>在C语言中，const限定符通常被用来限定变量，用于表示该变量的值不能被修改。</li><li>而const_cast则正是用于强制去掉这种不能被修改的常数特性，但需要特别注意的是const_cast不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。</li><li>用法：const_cast<type_id> (expression) 该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。 常量指针被转化成非常量指针，并且仍然指向原来的对象； 常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">[例3]一个错误的例子：</span><br><span class="line"></span><br><span class="line">const int a = 10;</span><br><span class="line">const int * p = &amp;a;</span><br><span class="line">*p = 20;                  //compile error</span><br><span class="line">int b = const_cast&lt;int&gt;(a);  //compile error</span><br><span class="line">在本例中出现了两个编译错误，第一个编译错误是*p因为具有常量性，其值是不能被修改的；另一处错误是const_cast强制转换对象必须为指针或引用，而例3中为一个变量，这是不允许的！</span><br><span class="line">[例4]const_cast关键字的使用</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int a = 10;</span><br><span class="line">    const int * p = &amp;a;</span><br><span class="line">    int *q;</span><br><span class="line">    q = const_cast&lt;int *&gt;(p);</span><br><span class="line">    *q = 20;    //fine</span><br><span class="line">    cout &lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;*p&lt;&lt;&quot; &quot;&lt;&lt;*q&lt;&lt;endl;</span><br><span class="line">        cout &lt;&lt;&amp;a&lt;&lt;&quot; &quot;&lt;&lt;p&lt;&lt;&quot; &quot;&lt;&lt;q&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">在本例中，我们将变量a声明为常量变量，同时声明了一个const指针指向该变量（此时如果声明一个普通指针指向该常量变量的话是不允许的，Visual Studio 2010编译器会报错）。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">之后我们定义了一个普通的指针*q。将p指针通过const_cast去掉其常量性，并赋给q指针。之后我再修改q指针所指地址的值时，这是不会有问题的。</span><br><span class="line"></span><br><span class="line">最后将结果打印出来，运行结果如下：</span><br><span class="line">10 20 20</span><br><span class="line">002CFAF4 002CFAF4 002CFAF4</span><br><span class="line"></span><br><span class="line">查看运行结果，问题来了，指针p和指针q都是指向a变量的，指向地址相同，而且经过调试发现002CFAF4地址内的值确实由10被修改成了20，这是怎么一回事呢？为什么a的值打印出来还是10呢？</span><br><span class="line"></span><br><span class="line">其实这是一件好事，我们要庆幸a变量最终的值没有变成20！变量a一开始就被声明为一个常量变量，不管后面的程序怎么处理，它就是一个常量，就是不会变化的。试想一下如果这个变量a最终变成了20会有什么后果呢？对于这些简短的程序而言，如果最后a变成了20，我们会一眼看出是q指针修改了，但是一旦一个项目工程非常庞大的时候，在程序某个地方出现了一个q这样的指针，它可以修改常量a，这是一件很可怕的事情的，可以说是一个程序的漏洞，毕竟将变量a声明为常量就是不希望修改它，如果后面能修改，这就太恐怖了。</span><br><span class="line"></span><br><span class="line">在例4中我们称“*q=20”语句为未定义行为语句，所谓的未定义行为是指在标准的C++规范中并没有明确规定这种语句的具体行为，该语句的具体行为由编译器来自行决定如何处理。对于这种未定义行为的语句我们应该尽量予以避免！</span><br><span class="line"></span><br><span class="line">从例4中我们可以看出我们是不想修改变量a的值的，既然如此，定义一个const_cast关键字强制去掉指针的常量性到底有什么用呢？我们接着来看下面的例子。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">例5：</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">const int * Search(const int * a, int n, int val);</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">    int val = 5;</span><br><span class="line">    int *p;</span><br><span class="line">    p = const_cast&lt;int *&gt;(Search(a, 10, val));</span><br><span class="line">    if(p == NULL)</span><br><span class="line">        cout&lt;&lt;&quot;Not found the val in array a&quot;&lt;&lt;endl;</span><br><span class="line">    else</span><br><span class="line">        cout&lt;&lt;&quot;hvae found the val in array a and the val = &quot;&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">const int * Search(const int * a, int n, int val)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i] == val)</span><br><span class="line">            return &amp;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return  NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">在例5中我们定义了一个函数，用于在a数组中寻找val值，如果找到了就返回该值的地址，如果没有找到则返回NULL。函数Search返回值是const指针，当我们在a数组中找到了val值的时候，我们会返回val的地址，最关键的是a数组在main函数中并不是const，因此即使我们去掉返回值的常量性有可能会造成a数组被修改，但是这也依然是安全的。</span><br><span class="line">对于引用，我们同样能使用const_cast来强制去掉常量性，如例6所示。</span><br><span class="line">例6：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">const int &amp; Search(const int * a, int n, int val);</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">int val = 5;</span><br><span class="line">int &amp;p = const_cast&lt;int &amp;&gt;(Search(a, 10, val));</span><br><span class="line">if(p == NULL)</span><br><span class="line">cout&lt;&lt;&quot;Not found the val in array a&quot;&lt;&lt;endl;</span><br><span class="line">else</span><br><span class="line">cout&lt;&lt;&quot;hvae found the val in array a and the val = &quot;&lt;&lt;p&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">const int &amp; Search(const int * a, int n, int val)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">for(i=0; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i] == val)</span><br><span class="line">return a[i];</span><br><span class="line">&#125;</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> 了解了const_cast的使用场景后，可以知道使用const_cast通常是一种无奈之举，同时也建议大家在今后的C++程序设计过程中一定不要利用const_cast去掉指针或引用的常量性并且去修改原始变量的数值，这是一种非常不好的行为。</span><br></pre></td></tr></table></figure><h2 id="const与constexpr"><a href="#const与constexpr" class="headerlink" title="const与constexpr"></a>const与constexpr</h2><p><a href="https://blog.csdn.net/woxiaohahaa/article/details/78512576">https://blog.csdn.net/woxiaohahaa/article/details/78512576</a></p><p><a href="https://blog.51cto.com/u_15346415/5171568">https://blog.51cto.com/u_15346415/5171568</a></p><h3 id="constexpr与普通变量"><a href="#constexpr与普通变量" class="headerlink" title="constexpr与普通变量"></a>constexpr与普通变量</h3><p>constexpr变量</p><ul><li>将变量声明为constexpr以便于由编译器检测一个表达式是否为一个常量表达式，而const没有此功能：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 3;</span><br><span class="line">int b = 4;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">constexpr int value1 = a + b;//编译器报错，表达式a + b不是常量表达式</span><br><span class="line">const int value2 = a + b;//正常初始化，不会报错</span><br></pre></td></tr></table></figure><ul><li>因此，如果你想用一个你认为是常量的表达式来初始化一个变量，不妨将这个变量声明为constexpr，让编译器为你检测一下。</li><li>只有字面值类型才能声明为constexpr变量。（基本算数类型（bool，int…），引用，指针…）。</li></ul><h3 id="constexpr与指针引用"><a href="#constexpr与指针引用" class="headerlink" title="constexpr与指针引用"></a>constexpr与指针引用</h3><p>当一个指针声明为constexpr时，相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a = 3;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    constexpr int *p1 = &amp;a;</span><br><span class="line">    //两者等价,表示指针为常量，对象的值可以修改。</span><br><span class="line">    int * const p1 = &amp;a;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，如果想要声明一个指针常量指向一个整型常量，则可以有如下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a = 3;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    constexpr const int *p1 = &amp;a;</span><br><span class="line">    //两者等价，指针为常量，指向一个整型常量</span><br><span class="line">    const int *const p3 = &amp;a;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>constexpr指针和引用只能指向所有函数体之外的变量（全局变量）或者函数体内的静态变量。</p><h3 id="constexpr与函数"><a href="#constexpr与函数" class="headerlink" title="constexpr与函数"></a>constexpr与函数</h3><p>constexpr函数</p><p>constexpr函数 可以实现编译期函数（即函数在编译期执行完毕，并在调用处进行替换）： #include  using namespace std; &#x2F;&#x2F;运算n的阶乘 constexpr int factorial(int n) {   return n &#x3D;&#x3D; 0 ? 1 : n * factorial(n - 1); } int main() {   cout &lt;&lt; factorial(10) &lt;&lt; endl;   system(“pause”);   return 0; } 该函数也可以在运行期执行： #include  using namespace std; constexpr int factorial(int n) {   return n &#x3D;&#x3D; 0 ? 1 : n * factorial(n - 1); } int main() {   int a &#x3D; 3;   scanf_s(“%d”, &amp;a);   cout &lt;&lt; factorial(a) &lt;&lt; endl;   system(“pause”);   return 0; } 可以对constexpr变量进行初始化： #include  using namespace std; constexpr int factorial(int n) {   return n &#x3D;&#x3D; 0 ? 1 : n * factorial(n - 1); } int main() {   constexpr int value &#x3D; factorial(10);   system(“pause”);   return 0; } 规定：</p><ul><li>函数的返回值以及参数都必须为字面值类型；</li><li>函数只能有一条return语句（C++14后无该要求）； 函数不一定返回常量表达式，但如果要初始化一个constexpr变量，则必须返回常量表达式（参数也必须为常量或常量表达式）；</li><li>函数被隐式的声明为内联函数；</li><li>函数内部可以声明变量（声明之后是运行期还是编译期？），可以用using声明，空语句，类型别名，循环，判断语句等，但cout不行。</li></ul><h2 id="const与引用"><a href="#const与引用" class="headerlink" title="const与引用"></a>const与引用</h2><p><a href="https://kyleandkelly.github.io/2022/05/29/C-%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/">https://kyleandkelly.github.io/2022/05/29/C-%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/</a></p><h2 id="const与函数形参"><a href="#const与函数形参" class="headerlink" title="const与函数形参"></a>const与函数形参</h2><p><a href="https://kyleandkelly.github.io/2022/05/29/C-%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/">https://kyleandkelly.github.io/2022/05/29/C-%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/</a></p><h2 id="const与类成员函数"><a href="#const与类成员函数" class="headerlink" title="const与类成员函数"></a>const与类成员函数</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://files.mdnice.com/user/1489/88e6c55a-da52-401d-8fd7-a957bd814293.png" alt="img"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><img src="https://files.mdnice.com/user/1489/5683c4b2-0d45-4fe8-8b21-17d92f0ccfad.png" alt="img"></p><h2 id="const顶层或底层"><a href="#const顶层或底层" class="headerlink" title="const顶层或底层"></a>const顶层或底层</h2><p><img src="https://files.mdnice.com/user/1489/89565247-0abc-402d-b263-b52c622cdfc3.png" alt="img"></p>]]></content>
    
    
    <summary type="html"> const关键字</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中的static关键字</title>
    <link href="http://example.com/2022/05/25/C-%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://example.com/2022/05/25/C-%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2022-05-25T07:15:58.000Z</published>
    <updated>2022-05-25T07:17:01.751Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h2><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul><li>在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量。我们先举一个静态全局变量的例子，如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">static int n;  //定义静态全局变量</span><br><span class="line"></span><br><span class="line">void fn()</span><br><span class="line">&#123;</span><br><span class="line">    n++;</span><br><span class="line">    cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    n = 20;</span><br><span class="line">    cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    fn();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量。</li><li>未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化）；</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>全局变量本身就是静态存储方式，<br>静态全局变量当然也是静态存储方式。</p><p>这两者在存储方式上并无不同。</p><p>和全局变量的区别<br>这两者的区别在于非静态全局变量的作用域是整个源程序，<br>当一个源程序由多个原文件组成时，<br>非静态的全局变量在各个源文件中都是有效的。<br>而静态全局变量则限制了其作用域，<br>即只在定义该变量的源文件内有效，<br>在同一源程序的其它源文件中不能使用它。</p><p>如果是全局变量的话<br>你在别的源文件加一个extern<br>就可以使用这个源文件中的全局变量<br>但是如果是静态全局变量就不可以<br>也就是说定义全局变量就可以实现变量在文件中的共享，但定义静态全局变量就不可以 </p><p>这样带来了以下好处：</p><ul><li><p>静态全局变量不能被其它文件所用；静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的； </p></li><li><p>其它文件中可以定义相同名字的变量，不会发生冲突；</p></li></ul><h2 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h2><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。<br>我们先举一个静态局部变量的例子，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void fn();</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    fn();</span><br><span class="line">    fn();</span><br><span class="line">    fn();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fn()</span><br><span class="line">&#123;</span><br><span class="line">    static int n = 10;</span><br><span class="line">    cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    n++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。<br>　　但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。<br>　　静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>静态局部变量有以下特点：</p><ul><li>（1）该变量在全局数据区分配内存；</li><li>（2）静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</li><li>（3）静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；</li><li>（4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；</li><li>（5）初始化时机<br> 静态变量什么时候初始化<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">初始化只有一次，但是可以多次赋值，</span><br><span class="line">在主程序之前，编译器已经为其分配好了内存。</span><br><span class="line">静态局部变量和全局变量一样，数据都存放在全局区域，</span><br><span class="line">所以在主程序之前，编译器已经为其分配好了内存，</span><br><span class="line">但在C和C++中静态局部变量的初始化节点又有点不太一样。</span><br><span class="line">在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，</span><br><span class="line">就会进行初始化，所以我们看到在C语言中</span><br><span class="line">无法使用变量对静态局部变量进行初始化，</span><br><span class="line">在程序运行结束，变量所处的全局内存会被全部回收。</span><br><span class="line"></span><br><span class="line">而在C++中，初始化时在执行相关代码时才会进行初始化，</span><br><span class="line">主要是由于C++引入对象后，</span><br><span class="line">要进行初始化必须执行相应构造函数和析构函数，</span><br><span class="line">在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，</span><br><span class="line">并非简单地分配内存。</span><br><span class="line">所以C++标准定为全局或静态对象是有首次用到时才会进行构造，</span><br><span class="line">并通过atexit()来管理。在程序结束，</span><br><span class="line">按照构造顺序反方向进行逐个析构。</span><br><span class="line">所以在C++中是可以使用变量</span><br><span class="line">对静态局部变量进行初始化的。</span><br></pre></td></tr></table></figure></li></ul><h2 id="静态全局函数"><a href="#静态全局函数" class="headerlink" title="静态全局函数"></a>静态全局函数</h2><ul><li>这样的static函数与普通函数的区别是：用static修饰的函数，限定在本源码文件中，不能被本源码文件以外的代码文件调用。而普通的函数，默认是extern的，也就是说它可以被其它代码文件调用。</li></ul><p>　- 在函数的返回类型前加上关键字static，函数就被定义成为静态函数。普通 函数的定义和声明默认情况下是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。因此定义静态函数有以下好处：<br>　  &lt;1&gt; 其他文件中可以定义相同名字的函数，不会发生冲突。<br>　  　  &lt;2&gt; 静态函数不能被其他文件所用。</p><h2 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>假设你现在要写一个存款类<br>存款类里面有一个利息的成员变量<br>那么把利息这个成员变量设定为static 有什么作用呢？</p><ul><li><p>一是不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以节省了存储空间。</p></li><li><p>二是一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了。</p></li><li><p>三是有一些状态是和类本身相关的而不是和对象相关的 这些状态数据可以用静态成员变量去表达</p></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>类内声明</li></ul><p><img src="https://files.mdnice.com/user/1489/70c33764-36a9-4fe2-8df2-e6c7b4ed60f6.png"></p><ul><li>类外初始化</li></ul><p><img src="https://files.mdnice.com/user/1489/34d1c2cb-608d-409c-aac9-09f85e753797.png"></p><ul><li>使用</li></ul><p><img src="https://files.mdnice.com/user/1489/1c5015be-1be2-4f01-9290-16b6ea09aa73.png"></p><p><img src="https://files.mdnice.com/user/1489/4f1e6aae-89b6-420a-a773-d0f3faf3a65a.png"></p><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p><img src="https://files.mdnice.com/user/1489/533d1e4c-a910-4bbb-87d4-78bab569efbe.png"></p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p><img src="https://files.mdnice.com/user/1489/213752eb-b8a8-45c7-92cb-36757d783b65.png"></p><h2 id="static作用总结"><a href="#static作用总结" class="headerlink" title="static作用总结"></a>static作用总结</h2><h3 id="作用1：隐藏"><a href="#作用1：隐藏" class="headerlink" title="作用1：隐藏"></a>作用1：隐藏</h3><ul><li>1.先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）<br>当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。<br>举例来说明。同时编译两个源文件，一个是a.c，另一个是main.c。</li></ul><p>&#x2F;&#x2F;a.c<br>char a &#x3D; ‘A’; &#x2F;&#x2F; global variable<br>void msg()<br>{<br>     printf(“Hello\n”);<br>}</p><p>&#x2F;&#x2F;main.c</p><p>int main()<br>{<br>     extern char a; &#x2F;&#x2F; extern variable must be declared before use<br>     printf(“%c “, a);<br>     (void)msg();<br>     return 0;<br>}</p><p>程序的运行结果是：<br>A Hello</p><p>为什么在a.c中定义的全局变量a和函数msg能在main.c中使用？前面说过，所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。此例中，a是全局变量，msg是函数，并且都没有加static前缀，因此对于另外的源文件main.c是可见的。<br>如果加了static，就会对其它源文件隐藏。例如在a和msg的定义前加上static，main.c就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏.</p><h3 id="2-内容的持久"><a href="#2-内容的持久" class="headerlink" title="2. 内容的持久"></a>2. 内容的持久</h3><ul><li>2.static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）<br>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。虽然这种用法不常见<br>PS：如果作为static局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与自动变量相同，只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。</li></ul><p>程序举例：</p><p>＃include &lt;stdio.h&gt;</p><p>int fun(){<br>    static int count &#x3D; 10; &#x2F;&#x2F;在第一次进入这个函数的时候，变量a被初始化为10！并接着自减1，以后每次进入该函数，a<br>    return count–; &#x2F;&#x2F;就不会被再次初始化了，仅进行自减1的操作；在static发明前，要达到同样的功能，则只能使用全局变量：    </p><p>}</p><p>int count &#x3D; 1;</p><p>int main(void)<br>{<br>     printf(“global\t\tlocal static\n”);<br>     for(; count &lt;&#x3D; 10; ++count)<br>               printf(“%d\t\t%d\n”, count, fun());<br>     return 0;<br>}</p><p>程序的运行结果是：<br>global  local static<br>1 10<br>2 9<br>3 8<br>4 7<br>5 6<br>6 5<br>7 4<br>8 3<br>9 2<br>10 1</p><p>—基于以上两点可以得出一个结论：把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。</p><h3 id="3-默认初始化为0"><a href="#3-默认初始化为0" class="headerlink" title="3. 默认初始化为0"></a>3. 默认初始化为0</h3><p>其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加‘\0’;太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是‘\0’;不妨做个小实验验证一下。</p><p>＃include &lt;stdio.h&gt;</p><p>int a;</p><p>int main()<br>{<br>     int i;<br>     static char str[10];<br>     printf(“integer: %d; string: (begin)%s(end)”, a, str);<br>     return 0;<br>}</p><p>程序的运行结果是：<br>integer: 0; string: (begin) (end) </p><p>最后对static的三条作用做一句话总结。首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0. </p><h3 id="4-类成员声明static"><a href="#4-类成员声明static" class="headerlink" title="4. 类成员声明static"></a>4. 类成员声明static</h3><p>4.static的第四个作用：C++中的类成员声明static（有些地方与以上作用重叠）<br> 在类中声明static变量或者函数时，初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员，这样就出现以下作用：<br>(1)类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致 了它仅能访问类的静态数据和静态成员函数。<br>(2)不能将静态成员函数定义为虚函数。<br>(3)由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊 ，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”。<br>(4)由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就 产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based X W indow系统结合，同时也成功的应用于线程函数身上。 （这条没遇见过）<br>(5)static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问 时间，节省了子类的内存空间。<br>(6)静态数据成员在&lt;定义或说明&gt;时前面加关键字static。<br>(7)静态数据成员是静态存储的，所以必须对它进行初始化。 （程序员手动初始化，否则编译时一般不会报错，但是在Link时会报错误）<br>(8)静态成员初始化与一般数据成员初始化不同:<br>初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；<br>初始化时不加该成员的访问权限控制符private，public等；<br>初始化时使用作用域运算符来标明它所属类；<br>           所以我们得出静态数据成员初始化的格式：<br>&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;&#x3D;&lt;值&gt;<br>(9)为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。</p>]]></content>
    
    
    <summary type="html">static关键字 </summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中的extern关键字</title>
    <link href="http://example.com/2022/05/25/C-%E4%B8%AD%E7%9A%84extern%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://example.com/2022/05/25/C-%E4%B8%AD%E7%9A%84extern%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2022-05-25T05:33:34.000Z</published>
    <updated>2022-05-25T05:35:07.053Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><ul><li><p>ref:<br><a href="https://www.jianshu.com/p/165b3410b7fa">https://www.jianshu.com/p/165b3410b7fa</a></p><p><a href="https://blog.csdn.net/z702143700/article/details/46805241">https://blog.csdn.net/z702143700/article/details/46805241</a></p><p><a href="https://sites.google.com/site/anythingiikegc/ge-zhong-jiao-cheng/c-ji-qiao/duo-wen-jian-bian-liang-gong-xiang">https://sites.google.com/site/anythingiikegc/ge-zhong-jiao-cheng/c-ji-qiao/duo-wen-jian-bian-liang-gong-xiang</a></p><p><a href="https://developer.aliyun.com/article/338215">https://developer.aliyun.com/article/338215</a></p></li></ul><h2 id="用法一：调用外部变量或者函数"><a href="#用法一：调用外部变量或者函数" class="headerlink" title="用法一：调用外部变量或者函数"></a>用法一：调用外部变量或者函数</h2><h3 id="1-调用别的源文件中的全局变量"><a href="#1-调用别的源文件中的全局变量" class="headerlink" title="1.调用别的源文件中的全局变量"></a>1.调用别的源文件中的全局变量</h3><p><img src="https://files.mdnice.com/user/1489/4a313c7f-5abb-4611-871e-c33900417721.png"></p><ul><li><p>这里需要注意的是，被引用的变量v的链接属性必须是外链接（external）的，也就是说a.cpp要引用到v，不只是取决于在a.cpp中声明extern int v，还取决于变量v本身是能够被引用到的。</p></li><li><p>这涉及到c语言的另外一个话题－－变量的作用域。能够被其他模块以extern修饰符引用到的变量通常是<code>全局变量</code>。</p></li><li><p>还有很重要的一点是，extern int v可以放在a.cpp中的任何地方，比如你可以在a.cpp中的函数fun定义的开头处声明extern int v，然后就可以引用到变量v了，只不过这样只能在函数fun作用域中引用v罢了，这还是变量作用域的问题。对于这一点来说，很多人使用的时候都心存顾虑。好像extern声明只能用于文件作用域似的。</p></li><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在一个源文件里定义了一个数组：char a[6];</span><br><span class="line">在另外一个文件里</span><br><span class="line">用下列语句进行了声明：extern char *a；</span><br><span class="line">请问，这样可以吗？</span><br><span class="line">答案与分析：</span><br><span class="line">1)、不可以，程序运行时会告诉你非法访问。</span><br><span class="line">原因在于，指向类型T的指针并不等价于类型T的数组。</span><br><span class="line">extern char *a声明的是一个指针变量而不是字符数组，</span><br><span class="line">因此与实际的定义不同，从而造成运行时非法访问。</span><br><span class="line">应该将声明改为extern char a[ ]。</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-调用别的源文件中的函数"><a href="#2-调用别的源文件中的函数" class="headerlink" title="2.调用别的源文件中的函数"></a>2.调用别的源文件中的函数</h3><p><img src="https://files.mdnice.com/user/1489/a3c10e0e-c534-4dbd-83e2-2b241b9a32de.png"></p><ul><li><p>全局函数的声明语句中，关键字extern可以省略，因为全局函数默认是extern类型的。</p></li><li><p>从本质上来讲，变量和函数没有区别。函数名是指向函数二进制块开头处的指针。</p></li><li><p>如果文件a.cpp需要引用b.cpp中的函数，比如在b.cpp中原型是int fun(int mu)，那么就可以在a.cpp中声明extern int fun（int mu），然后就能使用fun来做任何事情。</p></li><li><p>就像变量的声明一样，extern int fun（int mu）可以放在a.cpp中任何地方，而不一定非要放在a.cpp的文件作用域的范围中。</p></li><li><p>对其他模块中函数的引用，最常用的方法是包含这些函数声明的头文件。使用extern和包含头文件来引用函数有什么区别呢？extern的引用方式比包含头文件要简洁得多！extern的使用方法是直接了当的，想引用哪个函数就用extern声明哪个函数。</p></li><li><p>这样做的一个明显的好处是，会加速程序的编译（确切的说是预处理）的过程，节省时间。在大型C程序编译过程中，这种差异是非常明显的。</p></li></ul><p><img src="https://files.mdnice.com/user/1489/0134c5d4-c375-4cc1-a7f5-4ef39bcc018b.png"></p><h3 id="3-调用别的头文件中的变量-x2F-函数"><a href="#3-调用别的头文件中的变量-x2F-函数" class="headerlink" title="3.调用别的头文件中的变量&#x2F;函数"></a>3.调用别的头文件中的变量&#x2F;函数</h3><p><img src="https://files.mdnice.com/user/1489/ae484341-5802-40e2-86ae-9628b14b3bee.png"></p><ul><li>通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。例如，如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块A编译生成的目标代码中找到此函数。</li><li><code>extern int a;</code>  仅仅是一个变量的声明，其并不是在定义变量a，并未为a分配内存空间。变量a在所有模块中作为一种全局变量只能被定义一次，否则会出现连接错误。</li><li>externint a; &#x2F;&#x2F;属于声明<br> externint a &#x3D; 10; &#x2F;&#x2F;属于定义</li><li>声明可以拷贝n次，但是定义只能定义一次。</li><li>extern作为声明使用，就是告诉当前编译单元，不要为这个extern修饰的变量分配空间，这个变量已经在别的编译单元分配了空间。 </li><li>extern作为定义使用，用于创建外部变量，也可以认为是全局变量。</li></ul><h2 id="用法二：调用C方式的变量或者函数"><a href="#用法二：调用C方式的变量或者函数" class="headerlink" title="用法二：调用C方式的变量或者函数"></a>用法二：调用C方式的变量或者函数</h2><p>C方式编译和C++方式编译<br>相对于C，C++中新增了诸如重载等新特性，对于他们的编译，必然有一些重要的区别。<br>我们将下面的小程序分别按C和C++方式编译，来探讨两种编译方式的区别。</p><p><img src="https://files.mdnice.com/user/1489/e32d34cc-a6e2-4d82-99c4-997af31ebeed.png"></p><ul><li>extern “C” 包含双重含义，从字面上即可得到：首先，被它修饰的目标是“extern”的；其次，被它修饰的目标是“C”的。</li></ul><h3 id="1-Cpp文件调用C文件中的函数"><a href="#1-Cpp文件调用C文件中的函数" class="headerlink" title="1. Cpp文件调用C文件中的函数"></a>1. Cpp文件调用C文件中的函数</h3><p><img src="https://files.mdnice.com/user/1489/c24ed20c-5231-4b99-9167-367ad4176df0.png"></p><p><img src="https://files.mdnice.com/user/1489/e9f8624a-4cac-4cd0-9116-35069a4cb672.png"></p><p><img src="https://files.mdnice.com/user/1489/bf8dc9e4-4300-440a-9327-91e313099c3d.png"></p><h3 id="2-Cpp文件调用C文件中的变量"><a href="#2-Cpp文件调用C文件中的变量" class="headerlink" title="2. Cpp文件调用C文件中的变量"></a>2. Cpp文件调用C文件中的变量</h3><p><img src="https://files.mdnice.com/user/1489/8a6a50fc-2786-4522-b222-bebc06865a71.png"></p><p><img src="https://files.mdnice.com/user/1489/09df49c3-a940-4c93-aabd-c7945a7bc37a.png"></p><p><img src="https://files.mdnice.com/user/1489/980c0aa6-51ec-47ac-868a-2a27518dab2c.png"></p><h3 id="3-Cpp文件调用C方式的头文件"><a href="#3-Cpp文件调用C方式的头文件" class="headerlink" title="3. Cpp文件调用C方式的头文件"></a>3. Cpp文件调用C方式的头文件</h3><p><img src="https://files.mdnice.com/user/1489/4c686ecf-a08a-4282-85b3-7ec79dddc1a2.png"></p><ul><li>例二</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//Out.h</span><br><span class="line">#ifdef __cplusplus          //该段代码引用网上的...，     </span><br><span class="line">extern &quot;C&quot;&#123;</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">#include &lt;stdio.h&gt;         </span><br><span class="line"> extern void aa();</span><br><span class="line">                                  </span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Out.c</span><br><span class="line">#include &quot;Out.h&quot;</span><br><span class="line">void aa()</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;aa is running&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//Test.cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &quot;Out.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123; </span><br><span class="line">   aa();</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例三</p><p><img src="https://files.mdnice.com/user/1489/3617915f-d89e-44db-8751-c27d958e4b60.png"></p>]]></content>
    
    
    <summary type="html"> extern关键字</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>SSH的原理及常用命令</title>
    <link href="http://example.com/2022/05/24/SSH%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/05/24/SSH%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2022-05-24T04:27:47.000Z</published>
    <updated>2022-05-24T04:33:27.849Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="SSH的含义"><a href="#SSH的含义" class="headerlink" title="SSH的含义"></a>SSH的含义</h2><ul><li><p>SSH是一个应用层协议，专为远程登录会话和其他网络服务提供安全性的保障，防止信息泄露问题。</p></li><li><p>ssh服务端由2部分组成： openssh(提供ssh服务)    openssl(提供加密的程序)</p></li><li><p>ssh的客户端可以用 XShell，XManager、SecureCRT，Putty、Mobaxterm  等工具进行远程连接、登录</p></li></ul><p><img src="https://files.mdnice.com/user/1489/55e5275f-20b0-4e30-b3d1-cce30d62f991.png"></p><h2 id="SSH的历史"><a href="#SSH的历史" class="headerlink" title="SSH的历史"></a>SSH的历史</h2><ul><li>1995年，芬兰学者Tatu Ylonen设计了SSH协议，</li><li>SSH 为 Secure SHell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；</li><li>SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括 HP-UX、Linux、Unix、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。</li><li>　　SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。</li></ul><h2 id="SSH的原理"><a href="#SSH的原理" class="headerlink" title="SSH的原理"></a>SSH的原理</h2><p>SSH(远程连接工具)连接原理：ssh服务是一个守护进程(demon)，系统后台监听客户端的连接，ssh服务端的进程名为sshd，负责实时监听客户端的请求(IP 22默认端口)，包括公共秘钥等交换等信息。</p><p>服务器启动的时候自己产生一个密钥(768bit公钥)，本地的ssh客户端发送连接请求到ssh服务器，服务器检查连接点客户端发送的数据和IP地址，确认合法后，ssh服务器会发送密钥(768bits)给客户端，此时客户端将本地私钥(256bit)和服务器的公钥(768bit)结合成密钥对key(1024bit)，发回给服务器端，建立连接通过key-pair数据传输。</p><h4 id="基于口令的认证-密码登录"><a href="#基于口令的认证-密码登录" class="headerlink" title="基于口令的认证-密码登录"></a>基于口令的认证-密码登录</h4><p><img src="https://files.mdnice.com/user/1489/20d1c527-81d7-46a9-a59c-30311d225a56.png"></p><p><img src="https://files.mdnice.com/user/1489/20a4b7b5-a888-4502-bd09-d5f9c8e98d9c.png"></p><p><img src="https://files.mdnice.com/user/1489/039079ca-b2f9-4b7d-91c5-fc5a3a48ab9e.png"></p><h4 id="基于公钥的认证-免密码登录"><a href="#基于公钥的认证-免密码登录" class="headerlink" title="基于公钥的认证-免密码登录"></a>基于公钥的认证-免密码登录</h4><p><img src="https://files.mdnice.com/user/1489/76ed9dfe-103d-481d-b967-26d9a002f8d1.png"></p><p><img src="https://files.mdnice.com/user/1489/aab013b5-dcfd-4e5b-888e-e5d267c93af7.png"></p><p><img src="https://files.mdnice.com/user/1489/237873e0-cfe1-487b-8ee3-9dad77e29941.png"></p><h2 id="SSH的有关命令"><a href="#SSH的有关命令" class="headerlink" title="SSH的有关命令"></a>SSH的有关命令</h2><h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><p><img src="https://files.mdnice.com/user/1489/b63bd863-def7-4054-a836-c6c90537e0ab.png"></p><p><img src="https://files.mdnice.com/user/1489/29e92daf-1ec4-4f50-92b2-e8a555a9e3bc.png"></p><h3 id="登录操作"><a href="#登录操作" class="headerlink" title="登录操作"></a>登录操作</h3><p><img src="https://files.mdnice.com/user/1489/f044672e-b952-49f1-801d-fa4cebafe9ab.png"></p><h3 id="发送文件"><a href="#发送文件" class="headerlink" title="发送文件"></a>发送文件</h3><p><img src="https://files.mdnice.com/user/1489/c0101bb6-c185-440f-a931-c4a3ed713bfa.png"></p><h3 id="远程执行指令"><a href="#远程执行指令" class="headerlink" title="远程执行指令"></a>远程执行指令</h3><p><img src="https://files.mdnice.com/user/1489/cff768f1-19f0-4999-9179-746b6d5c293a.png"></p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p><a href="https://blog.mimvp.com/article/37361.html">ref : ssh常用命令</a></p>]]></content>
    
    
    <summary type="html">SSH的原理及常用命令 </summary>
    
    
    
    <category term="Linux命令" scheme="http://example.com/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
    <category term="Linux命令" scheme="http://example.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>原型模式C++实现</title>
    <link href="http://example.com/2022/05/21/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/05/21/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-05-20T23:47:46.000Z</published>
    <updated>2022-05-20T23:50:45.814Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/huangyimo/article/details/80390001">原型模式有什么用？</a></p><p><a href="https://blog.csdn.net/chenxun_2010/article/details/48327231">原型模式怎么实现?</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resume</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="type">char</span>* name;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Resume* <span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteResume</span>:<span class="keyword">public</span> Resume&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">ConcreteResume</span>(<span class="type">char</span>* str)&#123;</span><br><span class="line">             name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str)+<span class="number">1</span>];</span><br><span class="line">             <span class="built_in">strcpy</span>(name,str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ConcreteResume</span>(<span class="type">const</span> ConcreteResume&amp; r1)&#123;</span><br><span class="line">            name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(r1.name)+<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(name,r1.name);</span><br><span class="line">        &#125;</span><br><span class="line">        ConcreteResume&amp; <span class="keyword">operator</span>&amp;=(<span class="type">const</span> ConcreteResume&amp; r1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;r1)&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">            <span class="keyword">delete</span>[] name;</span><br><span class="line">            name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(r1.name)+<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(name,r1.name);</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">ConcreteResume* <span class="title">clone</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteResume</span>(*<span class="keyword">this</span>);</span><br><span class="line">        &#125; </span><br><span class="line">       <span class="comment">//debug</span></span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">PinrtInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(name);i++)&#123;</span><br><span class="line">                cout&lt;&lt;name[i]&lt;&lt;endl;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> str[]  = <span class="string">&quot;happy&quot;</span>;</span><br><span class="line">    <span class="function">ConcreteResume <span class="title">r1</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="function">ConcreteResume <span class="title">r2</span><span class="params">(r1)</span></span>;</span><br><span class="line">    <span class="type">char</span> str1[]  = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">    <span class="function">ConcreteResume <span class="title">r3</span><span class="params">(str1)</span></span>;</span><br><span class="line">    r3 = r1;</span><br><span class="line">    <span class="comment">// r3.PinrtInfo();</span></span><br><span class="line">    ConcreteResume *r4 = r3.<span class="built_in">clone</span>();</span><br><span class="line">    r4-&gt;<span class="built_in">PinrtInfo</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html"> 原型模式C++实现</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>外观模式C++实现</title>
    <link href="http://example.com/2022/05/20/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/05/20/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-05-20T03:46:56.000Z</published>
    <updated>2022-05-20T03:49:14.933Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://blog.csdn.net/leonardohaig/article/details/106557237">ref: 外观模式</a></p><p><img src="https://files.mdnice.com/user/1489/d2ca3fbe-6e0e-43d1-95fd-f6e0ae22d2c1.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Control</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Control</span>() = <span class="keyword">default</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>: <span class="keyword">public</span> Control&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;the screen start!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;the screen close!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Keyboard</span>: <span class="keyword">public</span> Control&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;the Keyboard start!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;the Keyboard close!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Host</span>: <span class="keyword">public</span> Control&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;the Keyboard start!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;the Keyboard close!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Host host;</span><br><span class="line">        Keyboard keyboard;</span><br><span class="line">        Screen screen;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">            host.<span class="built_in">start</span>();</span><br><span class="line">            keyboard.<span class="built_in">start</span>();</span><br><span class="line">            screen.<span class="built_in">start</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">            host.<span class="built_in">close</span>();</span><br><span class="line">            keyboard.<span class="built_in">close</span>();</span><br><span class="line">            screen.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Computer computer;</span><br><span class="line">    computer.<span class="built_in">start</span>();</span><br><span class="line">    computer.<span class="built_in">close</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">外观模式C++实现 </summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>代理模式C++实现</title>
    <link href="http://example.com/2022/05/19/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/05/19/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-05-19T07:44:25.000Z</published>
    <updated>2022-05-19T07:46:47.358Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/m0_46308273/article/details/117193671">ref : 代理模式</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoSite</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">watchFreemovie</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">watchVipmovie</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">watchSVipmovie</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span>:<span class="keyword">public</span> VideoSite&#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchFreemovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             cout&lt;&lt;<span class="string">&quot;You are watching Free Movie.&quot;</span>&lt;&lt;endl;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchVipmovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             cout&lt;&lt;<span class="string">&quot;You are watching Vip Movie.&quot;</span>&lt;&lt;endl;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchSVipmovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             cout&lt;&lt;<span class="string">&quot;You are watching SVip Movie.&quot;</span>&lt;&lt;endl;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FreeUesrProxy</span>:<span class="keyword">public</span> VideoSite&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        RealSubject* realSubject;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">FreeUesrProxy</span>()&#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> RealSubject;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">FreeUesrProxy</span>()&#123;</span><br><span class="line">            <span class="keyword">delete</span> realSubject;</span><br><span class="line">            realSubject = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">watchFreemovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             realSubject-&gt;<span class="built_in">watchFreemovie</span>();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchVipmovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             cout&lt;&lt;<span class="string">&quot;You cannot watch Vip Movie.&quot;</span>&lt;&lt;endl;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchSVipmovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             cout&lt;&lt;<span class="string">&quot;You cannot watch SVip Movie.&quot;</span>&lt;&lt;endl;</span><br><span class="line">         &#125;        </span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VipUserProxy</span>:<span class="keyword">public</span> VideoSite&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        RealSubject* realSubject;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">VipUserProxy</span>()&#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> RealSubject;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">VipUserProxy</span>()&#123;</span><br><span class="line">            <span class="keyword">delete</span> realSubject;</span><br><span class="line">            realSubject = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">watchFreemovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             realSubject-&gt;<span class="built_in">watchFreemovie</span>();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchVipmovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             realSubject-&gt;<span class="built_in">watchVipmovie</span>();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchSVipmovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             cout&lt;&lt;<span class="string">&quot;You cannot watch SVip Movie.&quot;</span>&lt;&lt;endl;</span><br><span class="line">         &#125;        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SVipUserProxy</span>:<span class="keyword">public</span> VideoSite&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        RealSubject* realSubject;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">SVipUserProxy</span>()&#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> RealSubject;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">SVipUserProxy</span>()&#123;</span><br><span class="line">            <span class="keyword">delete</span> realSubject;</span><br><span class="line">            realSubject = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">watchFreemovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             realSubject-&gt;<span class="built_in">watchFreemovie</span>();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchVipmovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             realSubject-&gt;<span class="built_in">watchVipmovie</span>();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchSVipmovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">            realSubject-&gt;<span class="built_in">watchSVipmovie</span>();</span><br><span class="line">         &#125;  </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">watchMovie</span><span class="params">(VideoSite* videoSite)</span></span>&#123;</span><br><span class="line">    videoSite-&gt;<span class="built_in">watchFreemovie</span>();</span><br><span class="line">    videoSite-&gt;<span class="built_in">watchVipmovie</span>();</span><br><span class="line">    videoSite-&gt;<span class="built_in">watchSVipmovie</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    VideoSite* videoSite = <span class="keyword">new</span> <span class="built_in">VipUserProxy</span>();</span><br><span class="line">    <span class="built_in">watchMovie</span>(videoSite);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">代理模式的C++实现 </summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>装饰器模式C++实现</title>
    <link href="http://example.com/2022/05/19/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/05/19/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-05-19T06:03:01.000Z</published>
    <updated>2022-05-19T06:07:01.291Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/walkerkalr/article/details/28633123">ref: 装饰器模式</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Beverage</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        string description;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> string <span class="title">getCost</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> string <span class="title">getDescription</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MilkTea</span>: <span class="keyword">public</span> Beverage&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string costNum;</span><br><span class="line">        <span class="built_in">MilkTea</span>()&#123;</span><br><span class="line">            description = <span class="string">&quot;milkTea&quot;</span>;</span><br><span class="line">            costNum = <span class="string">&quot;￥15&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">getCost</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> costNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">getDescription</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> description;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decorater</span>:<span class="keyword">public</span> Beverage &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        Beverage* beverage ;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> string <span class="title">getCost</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> string <span class="title">getDescription</span><span class="params">()</span></span>&#123;&#125;;         </span><br><span class="line">        <span class="built_in">Decorater</span>(Beverage* newBeverage)&#123;</span><br><span class="line">            beverage = newBeverage;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zhenzhu</span>:<span class="keyword">public</span> Decorater&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string costNum;</span><br><span class="line">        string description;</span><br><span class="line">        <span class="built_in">Zhenzhu</span>(Beverage* newBeverage):<span class="built_in">Decorater</span>(newBeverage)&#123;</span><br><span class="line">            costNum = <span class="string">&quot;￥3&quot;</span>;</span><br><span class="line">            description = <span class="string">&quot; add Zhenzhu&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function">string <span class="title">getCost</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> beverage-&gt;<span class="built_in">getCost</span>()+<span class="string">&quot;+&quot;</span>+costNum;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">getDescription</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> beverage-&gt;<span class="built_in">getDescription</span>()+description;</span><br><span class="line">            </span><br><span class="line">        &#125;        </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Yeguo</span>:<span class="keyword">public</span> Decorater&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string costNum;</span><br><span class="line">        string description;</span><br><span class="line">        <span class="built_in">Yeguo</span>(Beverage* newBeverage):<span class="built_in">Decorater</span>(newBeverage)&#123;</span><br><span class="line">            costNum = <span class="string">&quot;￥4&quot;</span>;</span><br><span class="line">            description = <span class="string">&quot; add Yeguo&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function">string <span class="title">getCost</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> beverage-&gt;<span class="built_in">getCost</span>()+<span class="string">&quot;+&quot;</span>+costNum;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">getDescription</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> beverage-&gt;<span class="built_in">getDescription</span>()+description;</span><br><span class="line">            </span><br><span class="line">        &#125;      </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Beverage* newMilkTea = <span class="keyword">new</span> MilkTea;</span><br><span class="line">    cout&lt;&lt;newMilkTea-&gt;<span class="built_in">getDescription</span>()&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;newMilkTea-&gt;<span class="built_in">getCost</span>()&lt;&lt;endl;</span><br><span class="line">    newMilkTea = <span class="keyword">new</span> <span class="built_in">Zhenzhu</span>(newMilkTea);</span><br><span class="line">    cout&lt;&lt;newMilkTea-&gt;<span class="built_in">getDescription</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;newMilkTea-&gt;<span class="built_in">getCost</span>()&lt;&lt;endl;</span><br><span class="line">    newMilkTea = <span class="keyword">new</span> <span class="built_in">Yeguo</span>(newMilkTea);</span><br><span class="line">    cout&lt;&lt;newMilkTea-&gt;<span class="built_in">getDescription</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;newMilkTea-&gt;<span class="built_in">getCost</span>()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">装饰器模式C++实现 </summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式的C++实现</title>
    <link href="http://example.com/2022/04/29/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/04/29/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-04-29T06:58:07.000Z</published>
    <updated>2022-05-19T06:07:29.031Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/83535678">ref:  工厂模式</a></p><h2 id="方法工厂"><a href="#方法工厂" class="headerlink" title="方法工厂"></a>方法工厂</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shoe</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Shoe</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NikeShoe</span>:<span class="keyword">public</span> Shoe&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;我是Nike&quot;</span>&lt;&lt;endl;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Factory</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Shoe* <span class="title">Makeshoe</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NikeFactory</span> : <span class="keyword">public</span> Factory&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Shoe* <span class="title">Makeshoe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Shoe* tmp = <span class="keyword">new</span> NikeShoe;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Step1 指定工厂</span></span><br><span class="line">    Factory* f = <span class="keyword">new</span> <span class="built_in">NikeFactory</span>();</span><br><span class="line">    <span class="comment">//Step2 工厂生产出鞋子</span></span><br><span class="line">     Shoe*  s  = f-&gt;<span class="built_in">Makeshoe</span>();   </span><br><span class="line">    <span class="comment">//Step3 打出口号</span></span><br><span class="line">    s-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;hello world&quot;&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shoe</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Shoe</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NikeShoe</span>:<span class="keyword">public</span> Shoe&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;我是Nike的鞋子&quot;</span>&lt;&lt;endl;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cloth</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Cloth</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NikeCloth</span>:<span class="keyword">public</span> Cloth&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;我是Nike的衣服&quot;</span>&lt;&lt;endl;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Factory</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Shoe* <span class="title">Makeshoe</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Cloth* <span class="title">Makecloth</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NikeFactory</span> : <span class="keyword">public</span> Factory&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Shoe* <span class="title">Makeshoe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Shoe* tmp = <span class="keyword">new</span> NikeShoe;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">Cloth* <span class="title">Makecloth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Cloth* tmp = <span class="keyword">new</span> NikeCloth;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Step1 指定工厂</span></span><br><span class="line">    Factory* f = <span class="keyword">new</span> <span class="built_in">NikeFactory</span>();</span><br><span class="line">    <span class="comment">//Step2 工厂生产出鞋子</span></span><br><span class="line">     Shoe*  s  = f-&gt;<span class="built_in">Makeshoe</span>();   </span><br><span class="line">    <span class="comment">//Step3 打出口号</span></span><br><span class="line">    s-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Step2 工厂生产衣服</span></span><br><span class="line">     Cloth*  c  = f-&gt;<span class="built_in">Makecloth</span>();   </span><br><span class="line">    <span class="comment">//Step3 打出口号</span></span><br><span class="line">    c-&gt;<span class="built_in">show</span>();</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板工厂"><a href="#模板工厂" class="headerlink" title="模板工厂"></a>模板工厂</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shoe</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Shoe</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NikeShoe</span>:<span class="keyword">public</span> Shoe&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;我是Nike的鞋子&quot;</span>&lt;&lt;endl;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cloth</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Cloth</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NikeCloth</span>:<span class="keyword">public</span> Cloth&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;我是Nike的衣服&quot;</span>&lt;&lt;endl;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">AbsProductType_t</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Factory</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> AbsProductType_t* <span class="title">MakeProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">AbsProductType_t</span>,<span class="keyword">class</span> <span class="title class_">ConcreatProductType_t</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreatFactory</span> : <span class="keyword">public</span> Factory&lt;AbsProductType_t&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">  </span><br><span class="line">        <span class="function">AbsProductType_t* <span class="title">MakeProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            AbsProductType_t* tmp = <span class="keyword">new</span> ConcreatProductType_t;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     ConcreatFactory&lt;Cloth,NikeCloth&gt; f;</span><br><span class="line">     Cloth* ns = f.<span class="built_in">MakeProduct</span>();</span><br><span class="line">     ns-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">工厂模式的C++实现</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>策略模式C++实现</title>
    <link href="http://example.com/2022/04/20/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/04/20/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-04-20T07:05:26.000Z</published>
    <updated>2022-04-29T06:52:52.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="没有用策略模式的场景"><a href="#没有用策略模式的场景" class="headerlink" title="没有用策略模式的场景"></a>没有用策略模式的场景</h2><p><em>Strategy_origin.cpp</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Runto</span><span class="params">(string country)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(country == <span class="string">&quot;Singpore&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Welcome to  Singpore&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(country == <span class="string">&quot;Canada&quot;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Welcome to  Canada&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(country == <span class="string">&quot;France&quot;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Welcome to  France&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(country == <span class="string">&quot;German&quot;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Welcome to  German&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Oops! no such choice&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string destination;</span><br><span class="line">    cin&gt;&gt;destination;</span><br><span class="line">    <span class="built_in">Runto</span>(destination);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用策略模式的场景"><a href="#使用策略模式的场景" class="headerlink" title="使用策略模式的场景"></a>使用策略模式的场景</h2><p><em>Strategy_modfied.cpp</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//策略类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountryStrategy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printInfo</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singpore</span>: <span class="keyword">public</span> CountryStrategy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;welcome to Singpore &quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">France</span>: <span class="keyword">public</span> CountryStrategy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;welcome to France &quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Canada</span>: <span class="keyword">public</span> CountryStrategy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;welcome to Canada &quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上下文选择类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChooseCountry</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">          CountryStrategy* country;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      </span><br><span class="line">        <span class="built_in">ChooseCountry</span>(CountryStrategy* c):<span class="built_in">country</span>(c)&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            country-&gt;<span class="built_in">printInfo</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Canada*  c = <span class="keyword">new</span> Canada;</span><br><span class="line">    Singpore*  s = <span class="keyword">new</span> Singpore;</span><br><span class="line">    <span class="function">ChooseCountry <span class="title">ch</span><span class="params">(s)</span></span>;</span><br><span class="line">    ch.<span class="built_in">printInfo</span>();</span><br><span class="line">    <span class="keyword">delete</span> c;</span><br><span class="line">    <span class="keyword">delete</span> s;</span><br><span class="line">    c= <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html"> 策略模式的一种简单实现C++</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单例模式的C++实现</title>
    <link href="http://example.com/2022/04/19/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84C-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/04/19/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84C-%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-04-19T12:06:56.000Z</published>
    <updated>2022-04-29T06:52:45.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul><li>采用懒汉式</li><li>使用垃圾回收器自动回收内存</li><li>使用双层锁进行线程同步</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">std::mutex m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Singleton</span>()&#123;&#125;;</span><br><span class="line"><span class="type">static</span> Singleton* instance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> data = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// void Release();</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Deletor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Deletor</span>() &#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;now in the Deletor function&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">if</span>(Singleton::instance != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">delete</span> Singleton::instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> Deletor deletor;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton::Deletor Singleton::deletor;<span class="comment">//一定要加这段垃圾回收类初始化的代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// //此处不能使用析构函数进行内存释放!!</span></span><br><span class="line"><span class="comment">// //问题1</span></span><br><span class="line"><span class="comment">// //本质上instance是在 getInstance中使用new出来的一个对象 </span></span><br><span class="line"><span class="comment">// //所以在程序结束的时候 如果你不对他进行delete </span></span><br><span class="line"><span class="comment">// //它不会主动调用析构函数 这样就会造成内存泄漏</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// //问题2</span></span><br><span class="line"><span class="comment">// //在析构函数中delete进行内存释放的时候</span></span><br><span class="line"><span class="comment">// //会造成递归调用</span></span><br><span class="line"><span class="comment">// void Singleton::Release()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;&quot;DE<span class="doctag">BUG:</span> now in the destructor function &quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// if(instance != NULL)&#123;</span></span><br><span class="line"><span class="comment">// delete Singleton::instance;</span></span><br><span class="line"><span class="comment">// instance = NULL;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance  = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;DEBUG: now in getInstance &quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">m.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">instance  = <span class="keyword">new</span>  Singleton;</span><br><span class="line">&#125;</span><br><span class="line">m.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt;<span class="string">&quot;the address of instance &quot;</span> &lt;&lt; Singleton::instance&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Hello world&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span>  Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ;i&lt;<span class="number">500</span> ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">thread <span class="title">th</span><span class="params">(GetInstance)</span></span>;</span><br><span class="line"></span><br><span class="line">th.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;LOG: end of main&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html"> 单例模式的一种简单实现C++</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>用C++实现简易版vector</title>
    <link href="http://example.com/2022/04/16/%E7%94%A8C++%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%89%88vector/"/>
    <id>http://example.com/2022/04/16/%E7%94%A8C++%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%89%88vector/</id>
    <published>2022-04-16T06:30:36.000Z</published>
    <updated>2022-04-29T06:53:00.490Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/KyleAndKelly/miniSTL"> https://github.com/KyleAndKelly/miniSTL</a></p><p>实现一个简易版的Vector</p><ul><li><em>miniVector.h</em></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;assert.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">miniVector</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">             </span><br><span class="line">        T* vectorArr;</span><br><span class="line">        <span class="type">int</span> capacity ;</span><br><span class="line">        <span class="type">int</span> size ;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">memoryExpand</span><span class="params">(<span class="type">const</span> <span class="type">int</span> elem)</span></span>;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        ~<span class="built_in">miniVector</span>();</span><br><span class="line">        <span class="built_in">miniVector</span>():<span class="built_in">vectorArr</span>(<span class="literal">NULL</span>),<span class="built_in">capacity</span>(<span class="number">2</span>),<span class="built_in">size</span>(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line">        <span class="built_in">miniVector</span>(<span class="type">const</span> <span class="type">int</span> cap);</span><br><span class="line">        <span class="built_in">miniVector</span>(<span class="type">const</span> <span class="type">int</span> ini_size,T ini_data);</span><br><span class="line">        <span class="built_in">miniVector</span>(<span class="type">const</span> miniVector&amp; vec);</span><br><span class="line">        miniVector&amp; <span class="keyword">operator</span>=(<span class="type">const</span> miniVector&amp; vec);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; num)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        T&amp;  <span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">int</span>&amp; index) <span class="type">const</span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; index,<span class="type">const</span> T&amp; data)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><em>miniVector_Impl.h</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;miniVector.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> miniVector&lt;T&gt;::<span class="built_in">memoryExpand</span>(<span class="type">const</span> <span class="type">int</span> elem)&#123;</span><br><span class="line">    </span><br><span class="line">    T* newArr = <span class="keyword">new</span> T[elem*capacity];</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DEBUG: create newArr success&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">memcpy</span>(newArr,vectorArr,size*<span class="built_in">sizeof</span>(T));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] vectorArr;</span><br><span class="line">    vectorArr = newArr;</span><br><span class="line">    capacity = elem*capacity;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DEBUG:  capacity &quot;</span>&lt;&lt; capacity&lt;&lt;endl;     </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">miniVector&lt;T&gt;::<span class="built_in">miniVector</span>(<span class="type">const</span> <span class="type">int</span> cap)&#123;</span><br><span class="line">    capacity = cap;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    vectorArr = <span class="keyword">new</span> T[capacity];</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: capcity &quot;</span>&lt;&lt;capacity&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: size &quot;</span>&lt;&lt;size&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">miniVector&lt;T&gt;::<span class="built_in">miniVector</span>(<span class="type">const</span> <span class="type">int</span> ini_size,T ini_data)&#123;</span><br><span class="line">    </span><br><span class="line">    capacity = <span class="number">20</span>+ini_size;</span><br><span class="line">    size = ini_size;</span><br><span class="line">    vectorArr = <span class="keyword">new</span> T[capacity];</span><br><span class="line">    <span class="comment">// memset(vectorArr, ini_data,ini_size);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ini_size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vectorArr[i] = ini_data;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: capcity &quot;</span>&lt;&lt;capacity&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: size &quot;</span>&lt;&lt;size&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">miniVector&lt;T&gt;::~<span class="built_in">miniVector</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] vectorArr;</span><br><span class="line">    vectorArr = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> miniVector&lt;T&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> T&amp; num)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(vectorArr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        capacity = <span class="number">2</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        vectorArr = <span class="keyword">new</span> T[capacity];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(size &gt;= capacity)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">memoryExpand</span>(<span class="number">2</span>);<span class="comment">//2倍扩容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vectorArr[size] = num;</span><br><span class="line">    ++size;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DEBUG: size=&quot;</span>&lt;&lt;size&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DEBUG: vectorArr[&quot;</span>&lt;&lt;size<span class="number">-1</span>&lt;&lt;<span class="string">&quot;]=&quot;</span>&lt;&lt;vectorArr[size<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DEBUG: capacity&quot;</span>&lt;&lt;capacity&lt;&lt;endl;              </span><br><span class="line">    <span class="keyword">return</span>;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> miniVector&lt;T&gt;::<span class="built_in">print_info</span>() <span class="type">const</span> </span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG vector capacity: &quot;</span>&lt;&lt; capacity&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG vector size: &quot;</span>&lt;&lt; size&lt;&lt;endl;   </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG vector data: &quot;</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">       cout&lt;&lt;vectorArr[i]&lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp;  miniVector&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">int</span>&amp; index) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(vectorArr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Error: Memory Not Initial!&quot;</span>&lt;&lt;endl;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( index &gt;= size || index &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Error: Out of Ranger!&quot;</span>&lt;&lt;endl;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vectorArr[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> miniVector&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">const</span> <span class="type">int</span>&amp; index,<span class="type">const</span> T&amp; data)&#123;</span><br><span class="line">    <span class="keyword">if</span>(vectorArr == <span class="literal">NULL</span>)<span class="comment">//如果还没有初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Error: Vector is not Initial!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index &gt;= size<span class="number">-1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Error: The insert index should be from 0 to &quot;</span>&lt;&lt;size<span class="number">-1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(size&gt;=capacity)&#123;</span><br><span class="line">        <span class="built_in">memoryExpand</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = size<span class="number">-1</span>;i&gt;= index;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        vectorArr[i+<span class="number">1</span>]=vectorArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    vectorArr[index]= data;</span><br><span class="line">    ++size;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DEBUG: vectorArr[&quot;</span>&lt;&lt;index&lt;&lt;<span class="string">&quot;]=&quot;</span>&lt;&lt;vectorArr[index]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> miniVector&lt;T&gt;::<span class="built_in">pop_back</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(vectorArr == <span class="literal">NULL</span> || size == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Error: Vector size is 0!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    --size;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: size &quot;</span>&lt;&lt; size&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: capacity &quot;</span>&lt;&lt;capacity&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">miniVector&lt;T&gt;::<span class="built_in">miniVector</span>(<span class="type">const</span> miniVector&amp; vec)&#123;</span><br><span class="line">    <span class="comment">//深拷贝</span></span><br><span class="line"></span><br><span class="line">    capacity = vec.capacity;</span><br><span class="line">    size = vec.size;</span><br><span class="line">    vectorArr = <span class="keyword">new</span> T[capacity];</span><br><span class="line">    <span class="built_in">memcpy</span>(vectorArr,vec.vectorArr,size*<span class="built_in">sizeof</span>(T));</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: now in miniVector(const miniVector&amp; vec)  &quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: size &quot;</span>&lt;&lt;size&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: capacity &quot;</span>&lt;&lt;capacity&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">miniVector&lt;T&gt;&amp; miniVector&lt;T&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> miniVector&amp; vec)&#123;</span><br><span class="line">     <span class="comment">//深拷贝</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;vec) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">    capacity = vec.capacity;</span><br><span class="line">    size = vec.size;</span><br><span class="line">    <span class="keyword">delete</span>[] vectorArr;</span><br><span class="line">    vectorArr = <span class="keyword">new</span> T[capacity];</span><br><span class="line">    <span class="built_in">memcpy</span>(vectorArr,vec.vectorArr,size*<span class="built_in">sizeof</span>(T));</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: now in miniVector operator=  &quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: size &quot;</span>&lt;&lt;size&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: capacity &quot;</span>&lt;&lt;capacity&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> miniVector&lt;T&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;</span><br><span class="line">    size=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>mainTest.cpp</em></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;miniVector_impl.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">miniVectorTest_pushback_int</span><span class="params">()</span></span>&#123;</span><br><span class="line">    miniVector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">9</span>);    </span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">2</span>);    </span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">3</span>);    </span><br><span class="line">    vec.<span class="built_in">print_info</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DEBUG: vec[2] &quot;</span> &lt;&lt;vec[<span class="number">2</span>]&lt;&lt;endl;</span><br><span class="line">    vec[<span class="number">13</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">miniVectorTest_pushback_char</span><span class="params">()</span></span>&#123;</span><br><span class="line">    miniVector&lt;<span class="type">char</span>&gt; vec;</span><br><span class="line">    vec[<span class="number">1</span>];</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="string">&#x27;h&#x27;</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);    </span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="string">&#x27;p&#x27;</span>);    </span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="string">&#x27;y&#x27;</span>);    </span><br><span class="line">    vec.<span class="built_in">print_info</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DEBUG: vec[2] &quot;</span> &lt;&lt;vec[<span class="number">2</span>]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">miniVectorTest_insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">miniVector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">5</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    vec.<span class="built_in">insert</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    vec.<span class="built_in">print_info</span>();</span><br><span class="line">    vec.<span class="built_in">insert</span>(<span class="number">8</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">miniVectorTest_popback</span><span class="params">()</span></span>&#123;</span><br><span class="line">    miniVector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="function">miniVector&lt;<span class="type">int</span>&gt; <span class="title">vec1</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">miniVectorTest_copy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">miniVector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">miniVector&lt;<span class="type">int</span>&gt; <span class="title">vec1</span><span class="params">(vec)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: vec1[1] &quot;</span>&lt;&lt;vec1[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">    miniVector&lt;<span class="type">int</span>&gt; vec2 = vec1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">miniVectorTest_copyoperator</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">miniVector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    miniVector&lt;<span class="type">int</span>&gt; vec1;</span><br><span class="line">    miniVector&lt;<span class="type">int</span>&gt; vec2;</span><br><span class="line">    vec2=vec1 = vec;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: vec1[1] &quot;</span>&lt;&lt;vec1[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: vec2[1] &quot;</span>&lt;&lt;vec2[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">miniVectorTest_copyoperator</span>();</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html"> 用C++实现简易版的Vector</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
</feed>
