<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈同学的博客</title>
  
  <subtitle>Blog of Chen</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-05-29T07:15:21.880Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++中的引用</title>
    <link href="http://example.com/2022/05/29/C-%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/"/>
    <id>http://example.com/2022/05/29/C-%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8/</id>
    <published>2022-05-29T06:55:15.000Z</published>
    <updated>2022-05-29T07:15:21.880Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="引用的基本原理"><a href="#引用的基本原理" class="headerlink" title="引用的基本原理"></a>引用的基本原理</h2><p>引用的实现原理其实通过下面5句话,1副图,1段代码就可以说明白了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a=1;</span><br><span class="line">int &amp;b=a</span><br></pre></td></tr></table></figure><p>1.引用变量b和被引用变量a并没有共用一块内存,b是另外开辟了一块内存的</p><p>2.引用变量b开辟的内存中存放的是a的地址</p><p>3.任何对变量b的操作,都将转换为对(*b)的操作,比如b&#x3D;b+1实际上是(*b)&#x3D;(*b)+1 而(*b)代表的就是a </p><p>4.基于上面3点我们可以总结出 引用变量b可以理解为被引用变量a的别名</p><p>5.引用必须在声明引用时将其初始化，而不能先声明，再赋值。也不能在使用过程中途对其赋值企图更改被引用的值,那样是无效的<br>比如:<br>int rats &#x3D; 101;<br>int &amp; rodents &#x3D; rats;<br>int bunnies &#x3D; 50;<br>rodents &#x3D; bunnies;<br>在上面一通操作以后rodent引用的还是rats</p><p>上面的两句代码 对应的内存分布图就如下<br><img src="https://files.mdnice.com/user/1489/9c6eb51d-ee87-436b-9839-0c5bad2ffe87.png"></p><p>再看一个实际的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">  using namespace std;</span><br><span class="line">  </span><br><span class="line">  int main()&#123;</span><br><span class="line">    int  a = 1;</span><br><span class="line">    int&amp;  b = a;</span><br><span class="line">    cout &lt;&lt; &quot;a:address-&gt;&quot; &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;b:address-&gt;&quot; &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a:address-&gt;0031FD54 </span><br><span class="line">b:address-&gt;0031FD54</span><br></pre></td></tr></table></figure><h2 id="引用的基本使用"><a href="#引用的基本使用" class="headerlink" title="引用的基本使用"></a>引用的基本使用</h2><p><img src="https://files.mdnice.com/user/1489/71a4aff5-8ed6-41a9-b935-252f6bd6b451.png"><br>还没有测试函数的引用实参和右值引用</p><h2 id="引用的基本类型"><a href="#引用的基本类型" class="headerlink" title="引用的基本类型"></a>引用的基本类型</h2><h3 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h3><ul><li><ol><li>在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">举个例子，int a = b+c, a 就是左值，</span><br><span class="line">其有变量名为a，通过&amp;a可以获取该变量的地址；</span><br><span class="line">表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，</span><br><span class="line">我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。</span><br></pre></td></tr></table></figure></li></ol></li><li><ol start="2"><li>左值一定在内存中，右值有可能在内存中也有可能在寄存器中</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a=5；</span><br><span class="line"></span><br><span class="line">int b=a;//此时a在内存中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int a=5；</span><br><span class="line"></span><br><span class="line">int b=a+1;//此时a+1在寄存器中</span><br><span class="line"></span><br><span class="line">int *p=&amp;a;//此时&amp;a在寄存器中</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="左值引用与右值引用"><a href="#左值引用与右值引用" class="headerlink" title="左值引用与右值引用"></a>左值引用与右值引用</h3><ul><li><ol><li>在内存中的变量才是可以取地址的，而在寄存器中的变量是不可以取地址的。对于一个不能取地址的表达式或者值是无法直接引用的。</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">int num1(5);</span><br><span class="line">int num2(10);</span><br><span class="line">int *pnum(&amp;num1);//将num1的地址传递给pnum</span><br><span class="line">int * &amp;rnum = pnum;//rnum是pnum的别名</span><br><span class="line">rnum = &amp;num2;//rnumhe pnum指向同一片内存  改变了rnum就相当于改变了pnum</span><br><span class="line">cout &lt;&lt; *pnum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">int num1(5);</span><br><span class="line">int num2(10);</span><br><span class="line"></span><br><span class="line">int * &amp;rnum = &amp;num1;//这是不允许的  无法从“int *”转换为“int *&amp;”</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>从以上两个例子可以看出int *pnum(&amp;num1); int * &amp;rnum &#x3D; pnum;</p></li><li><p>通过一个指针在进行取别名是可以的，因为此时指针在内存中，而直接int * &amp;rnum &#x3D; &amp;num1;取别名是不行的，&amp;num1在寄存器中。</p></li><li><p>在内存中的值是可以直接取别名的也就是引用。但是在寄存器中的值在不可以直接被引用的。其实这就是所谓的左值引用和右值引用。</p></li><li><p>2.左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型。右值引用和左值引用都是属于引用类型。</p></li><li><p>3.右值引用的方法就是int * &amp;&amp;rnum &#x3D; &amp;num1;  。</p></li><li><p>4.下面来说一下为什么要右值引用，右值引用在你需要使用寄存器中的值的时候可以进行右值引用。寄存器的刷新速度很快，没有右值引用的话就需要将寄存器中的值拷贝到内存中，在进行使用，这是很浪费时间的。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int getdata(int &amp;&amp;num)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; num;</span><br><span class="line">num += 10;</span><br><span class="line">return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 5;</span><br><span class="line">cout &lt;&lt; getdata(a + 1) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如上 int getdata(int &amp;&amp;num)就是对右值进行引用。 getdata(a + 1) 中a+1是右值在寄存器中，我们是不可以直接对他进行操作的，如果要操作得将其拷贝到内存中，如果是一个非常大的数据这种拷贝就会很占用内存，如果直接用右值引用就可以直接对其进行操作。从而节约内存。</p><ul><li><ol start="5"><li>无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。</li></ol></li></ul><h2 id="引用与const"><a href="#引用与const" class="headerlink" title="引用与const"></a>引用与const</h2><ul><li><ol><li>左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值引用只能接受非常量左值对其进行初始化。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int &amp;a = 2;       # 左值引用绑定到右值，编译失败</span><br><span class="line"> </span><br><span class="line">int b = 2;        # 非常量左值</span><br><span class="line">const int &amp;c = b; # 常量左值引用绑定到非常量左值，编译通过</span><br><span class="line">const int d = 2;  # 常量左值</span><br><span class="line">const int &amp;e = c; # 常量左值引用绑定到常量左值，编译通过</span><br><span class="line">const int &amp;b =2;  # 常量左值引用绑定到右值，编程通过</span><br></pre></td></tr></table></figure></li></ol></li></ul><p>常量左值引用内部实现的原理是这样的:对于不可寻址的值，如文字常量，以及不同类型的对象，编译器为了实现引用，必须生成一个临时对象，将该对象的值置入临时对象中，引用实际上指向该对象（对该引用的操作就是对该临时对象的操作），但用户不能访问它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">例如:</span><br><span class="line"></span><br><span class="line">double dval = 23;</span><br><span class="line">const int &amp;ri = dval;</span><br><span class="line">编译器将其转换为:</span><br><span class="line"></span><br><span class="line">int tmp = dval; // double -&gt; int</span><br><span class="line">const int &amp;ri = tmp;</span><br><span class="line">同理：上面代码</span><br><span class="line"></span><br><span class="line">double dval = 3.14159;</span><br><span class="line">//下3行仅对const引用才是合法的</span><br><span class="line">const int &amp;ir = 1024;</span><br><span class="line">const int &amp;ir2 = dval;</span><br><span class="line">const double &amp;dr = dval + 1.0;</span><br><span class="line">内部转化为：</span><br><span class="line"></span><br><span class="line">double dval = 3.14159;</span><br><span class="line">//不可寻址，文字常量</span><br><span class="line">int tmp1 = 1024;</span><br><span class="line">const int &amp;ir = tmp1;</span><br><span class="line">//不同类型</span><br><span class="line">int tmp2 = dval;//double -&gt; int</span><br><span class="line">const int &amp;ir2 = tmp2;</span><br><span class="line">//另一种情况，不可寻址</span><br><span class="line">double tmp3 = dval + 1.0;</span><br><span class="line">const double &amp;dr = tmp3;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><ol start="2"><li>右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值，例如：</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a;</span><br><span class="line">int &amp;&amp;r1 = c;             # 编译失败</span><br><span class="line">int &amp;&amp;r2 = std::move(a);  # 编译通过</span><br></pre></td></tr></table></figure><ul><li>3.const引用与非const引用的对比</li></ul><p>[0].const引用表示，试图通过此引用去(间接)改变其引用的对象的值时，编译器会报错！我们仍然可以直接改变其指向对象的值，只是不能通过引用改变。总结来说就是const引用只是表明：保证不会通过此引用间接的改变被引用的对象！下面是一个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 1 #include &lt;iostream&gt;</span><br><span class="line"> 2 using namespace std;</span><br><span class="line"> 3</span><br><span class="line"> 4 int main()</span><br><span class="line"> 5 &#123;</span><br><span class="line"> 6     int val = 1024;</span><br><span class="line"> 7     const int &amp;ir = val;</span><br><span class="line"> 8     </span><br><span class="line"> 9     val++;//我们仍然可以通过val直接改变其值</span><br><span class="line">10     //ir++;//通过ir来改变val的值，编译时会出错</span><br><span class="line">11</span><br><span class="line">12     cout &lt;&lt; val &lt;&lt; &quot; &quot; &lt;&lt; ir &lt;&lt; endl;</span><br><span class="line">13</span><br><span class="line">14     return 0;</span><br><span class="line">15 &#125;</span><br></pre></td></tr></table></figure><p>另外，const既可以放到类型前又可以放到类型后面，放类型后比较容易理解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string const *t1;</span><br><span class="line">const string *t1;</span><br><span class="line">typedef string* pstring;</span><br><span class="line">string s;</span><br><span class="line">const pstring cstr1 = &amp;s;//此时放前面就出错了</span><br><span class="line">pstring const cstr2 = &amp;s;//但是放在类型后面不会出错</span><br></pre></td></tr></table></figure><p>[1]、const引用可读不可改，与绑定对象是否为const无关；非const引用可读可改，只可与非const对象绑定</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int ival = 1024;</span><br><span class="line">const int &amp;refVal = ival; // ok: both reference and object are const</span><br><span class="line">int &amp;ref2 = ival;            // error: nonconst reference to a const object</span><br></pre></td></tr></table></figure><p>[2]、非const引用只能绑定到与该引用同类型的对象，const引用则可以绑定到不同但相关的类型的对象或绑定到左值，同时const引用可以初始化为不同类型的对象或者初始化为右值，如字面值常量。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int i = 42;</span><br><span class="line">// legal for const references only</span><br><span class="line">const int &amp;r = 42;//初始化为右值</span><br><span class="line">const int &amp;r2 = r + i;//同样的初始化对于非const引用却是不合法的，而且会导致编译时错误。</span><br><span class="line">double dval = 3.14;</span><br><span class="line">const int &amp;ri = dval;//不同类型对象</span><br><span class="line">编译器会把这些代码转换成如以下形式的编码：</span><br><span class="line"></span><br><span class="line">int temp = dval;          // create temporary int from the double</span><br><span class="line">const int &amp;ri = temp;   // bind ri to that temporary</span><br></pre></td></tr></table></figure><p>[3].const引用和非const引用在内存中的对比</p><p>例如const引用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const int t = 9;</span><br><span class="line">const int&amp; k = t;</span><br><span class="line">cout&lt;&lt;&amp;k&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&amp;t&lt;&lt;endl;</span><br><span class="line">输出是</span><br><span class="line">0012FF6C</span><br><span class="line">0012FF74</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例如非const引用：</span><br><span class="line">int t = 9;</span><br><span class="line">int&amp; k = t;</span><br><span class="line">cout&lt;&lt;&amp;k&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&amp;t&lt;&lt;endl;</span><br><span class="line">输出是</span><br><span class="line">0012FF74</span><br><span class="line">0012FF74</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/88d5ede3-221f-4bcc-b76f-1fec42db7c37.png"></p><h2 id="引用与函数"><a href="#引用与函数" class="headerlink" title="引用与函数"></a>引用与函数</h2><h2 id="引用与指针"><a href="#引用与指针" class="headerlink" title="引用与指针"></a>引用与指针</h2>]]></content>
    
    
    <summary type="html"> 引用 </summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中的const关键字</title>
    <link href="http://example.com/2022/05/29/C-%E4%B8%AD%E7%9A%84const%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://example.com/2022/05/29/C-%E4%B8%AD%E7%9A%84const%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2022-05-29T05:37:41.000Z</published>
    <updated>2022-05-29T05:38:48.292Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="const与基本变量"><a href="#const与基本变量" class="headerlink" title="const与基本变量"></a>const与基本变量</h2><p><img src="https://files.mdnice.com/user/1489/52d0e399-5cf3-4fab-af68-e2a7a4cd8464.png"></p><p><img src="https://files.mdnice.com/user/1489/359421a9-a125-4e7a-ada0-449d650b20b6.png"></p><h2 id="const与extern"><a href="#const与extern" class="headerlink" title="const与extern"></a>const与extern</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>正常来说，<br>在B.cpp中定义了变量int i &#x3D; 0<br>则A.cpp中使用extern int i 使用这个变量i<br>但是现在的问题是<br>如果你在B.cpp中定义的这个变量i是const的<br>那么用同样的方式在A.cpp中引用这个变量<br>并编译的时候 g++ A.cpp  B.cpp -o test<br>就会发现出现了未定义引用的错误</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>错误的原因在这篇文章中说的很清楚<br><a href="https://zhuanlan.zhihu.com/p/272828566">https://zhuanlan.zhihu.com/p/272828566</a></p><p>总结一下就是<br>如果变量被const定义的话<br>就会修改这个变量的链接属性<br>那么这个变量就不能被外部的文件链接了</p><h3 id="解决措施"><a href="#解决措施" class="headerlink" title="解决措施"></a>解决措施</h3><p>解决的措施在这篇文章中也说的很清楚<br><a href="https://zhuanlan.zhihu.com/p/272828566">https://zhuanlan.zhihu.com/p/272828566</a></p><p>总结一下就是<br>在B.cpp的该变量i前面也加上extern关键字就可以了<br>因为extern有一个不太被关注的作用是，<br>在C++中，它可以改变const变量的链接属性。<br>让这个变量变得能够被外部文件链接到</p><h3 id="标准用法"><a href="#标准用法" class="headerlink" title="标准用法"></a>标准用法</h3><p>正确用法如下<br><img src="https://files.mdnice.com/user/1489/f90c2e3b-45ee-4020-b4c5-66745331b114.png"></p><p><img src="https://files.mdnice.com/user/1489/fb4161ac-deb5-4557-b34d-c64ec1fce3ee.png"></p><h2 id="const与指针"><a href="#const与指针" class="headerlink" title="const与指针"></a>const与指针</h2><h3 id="指向常量的指针-const在-号前"><a href="#指向常量的指针-const在-号前" class="headerlink" title="指向常量的指针(const在*号前)"></a>指向常量的指针(const在*号前)</h3><ul><li>不能通过指针改变其所指向对象值</li><li>即能指向常量对象也能指向非常量对象</li></ul><h3 id="常量指针-const在-号后"><a href="#常量指针-const在-号后" class="headerlink" title="常量指针 (const在*号后)"></a>常量指针 (const在*号后)</h3><ul><li>其所指向的地址不变</li><li>可以通过常量指针改变所指向对象的值</li></ul><p><img src="https://files.mdnice.com/user/1489/6da8b4da-ac00-4b04-930d-3ee672417e06.png"></p><p><img src="https://files.mdnice.com/user/1489/84408089-ea82-4578-aad7-3a0877b28317.png"></p><h2 id="const与类型转换"><a href="#const与类型转换" class="headerlink" title="const与类型转换"></a>const与类型转换</h2><ul><li><p>在C语言中，const限定符通常被用来限定变量，用于表示该变量的值不能被修改。</p></li><li><p>而const_cast则正是用于强制去掉这种不能被修改的常数特性，但需要特别注意的是const_cast不是用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，其去除常量性的对象必须为指针或引用。</p></li><li><p>用法：const_cast<type_id> (expression)<br>  该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。<br>  常量指针被转化成非常量指针，并且仍然指向原来的对象；<br>  常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[例3]一个错误的例子：</span><br><span class="line"></span><br><span class="line">const int a = 10;</span><br><span class="line">const int * p = &amp;a;</span><br><span class="line">*p = 20;                  //compile error</span><br><span class="line">int b = const_cast&lt;int&gt;(a);  //compile error</span><br><span class="line">在本例中出现了两个编译错误，第一个编译错误是*p因为具有常量性，其值是不能被修改的；另一处错误是const_cast强制转换对象必须为指针或引用，而例3中为一个变量，这是不允许的！</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[例4]const_cast关键字的使用</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int a = 10;</span><br><span class="line">    const int * p = &amp;a;</span><br><span class="line">    int *q;</span><br><span class="line">    q = const_cast&lt;int *&gt;(p);</span><br><span class="line">    *q = 20;    //fine</span><br><span class="line">    cout &lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;*p&lt;&lt;&quot; &quot;&lt;&lt;*q&lt;&lt;endl;</span><br><span class="line">        cout &lt;&lt;&amp;a&lt;&lt;&quot; &quot;&lt;&lt;p&lt;&lt;&quot; &quot;&lt;&lt;q&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">在本例中，我们将变量a声明为常量变量，同时声明了一个const指针指向该变量（此时如果声明一个普通指针指向该常量变量的话是不允许的，Visual Studio 2010编译器会报错）。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">之后我们定义了一个普通的指针*q。将p指针通过const_cast去掉其常量性，并赋给q指针。之后我再修改q指针所指地址的值时，这是不会有问题的。</span><br><span class="line"></span><br><span class="line">最后将结果打印出来，运行结果如下：</span><br><span class="line">10 20 20</span><br><span class="line">002CFAF4 002CFAF4 002CFAF4</span><br><span class="line"></span><br><span class="line">查看运行结果，问题来了，指针p和指针q都是指向a变量的，指向地址相同，而且经过调试发现002CFAF4地址内的值确实由10被修改成了20，这是怎么一回事呢？为什么a的值打印出来还是10呢？</span><br><span class="line"></span><br><span class="line">其实这是一件好事，我们要庆幸a变量最终的值没有变成20！变量a一开始就被声明为一个常量变量，不管后面的程序怎么处理，它就是一个常量，就是不会变化的。试想一下如果这个变量a最终变成了20会有什么后果呢？对于这些简短的程序而言，如果最后a变成了20，我们会一眼看出是q指针修改了，但是一旦一个项目工程非常庞大的时候，在程序某个地方出现了一个q这样的指针，它可以修改常量a，这是一件很可怕的事情的，可以说是一个程序的漏洞，毕竟将变量a声明为常量就是不希望修改它，如果后面能修改，这就太恐怖了。</span><br><span class="line"></span><br><span class="line">在例4中我们称“*q=20”语句为未定义行为语句，所谓的未定义行为是指在标准的C++规范中并没有明确规定这种语句的具体行为，该语句的具体行为由编译器来自行决定如何处理。对于这种未定义行为的语句我们应该尽量予以避免！</span><br><span class="line"></span><br><span class="line">从例4中我们可以看出我们是不想修改变量a的值的，既然如此，定义一个const_cast关键字强制去掉指针的常量性到底有什么用呢？我们接着来看下面的例子。</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">例5：</span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">const int * Search(const int * a, int n, int val);</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">    int val = 5;</span><br><span class="line">    int *p;</span><br><span class="line">    p = const_cast&lt;int *&gt;(Search(a, 10, val));</span><br><span class="line">    if(p == NULL)</span><br><span class="line">        cout&lt;&lt;&quot;Not found the val in array a&quot;&lt;&lt;endl;</span><br><span class="line">    else</span><br><span class="line">        cout&lt;&lt;&quot;hvae found the val in array a and the val = &quot;&lt;&lt;*p&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">const int * Search(const int * a, int n, int val)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i=0; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[i] == val)</span><br><span class="line">            return &amp;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return  NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">在例5中我们定义了一个函数，用于在a数组中寻找val值，如果找到了就返回该值的地址，如果没有找到则返回NULL。函数Search返回值是const指针，当我们在a数组中找到了val值的时候，我们会返回val的地址，最关键的是a数组在main函数中并不是const，因此即使我们去掉返回值的常量性有可能会造成a数组被修改，但是这也依然是安全的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">对于引用，我们同样能使用const_cast来强制去掉常量性，如例6所示。</span><br><span class="line">例6：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">const int &amp; Search(const int * a, int n, int val);</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">int val = 5;</span><br><span class="line">int &amp;p = const_cast&lt;int &amp;&gt;(Search(a, 10, val));</span><br><span class="line">if(p == NULL)</span><br><span class="line">cout&lt;&lt;&quot;Not found the val in array a&quot;&lt;&lt;endl;</span><br><span class="line">else</span><br><span class="line">cout&lt;&lt;&quot;hvae found the val in array a and the val = &quot;&lt;&lt;p&lt;&lt;endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">const int &amp; Search(const int * a, int n, int val)</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">for(i=0; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line">if(a[i] == val)</span><br><span class="line">return a[i];</span><br><span class="line">&#125;</span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> 了解了const_cast的使用场景后，可以知道使用const_cast通常是一种无奈之举，同时也建议大家在今后的C++程序设计过程中一定不要利用const_cast去掉指针或引用的常量性并且去修改原始变量的数值，这是一种非常不好的行为。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="const与constexpr"><a href="#const与constexpr" class="headerlink" title="const与constexpr"></a>const与constexpr</h2><p><a href="https://blog.csdn.net/woxiaohahaa/article/details/78512576">https://blog.csdn.net/woxiaohahaa/article/details/78512576</a></p><p><a href="https://blog.51cto.com/u_15346415/5171568">https://blog.51cto.com/u_15346415&#x2F;5171568</a></p><h3 id="constexpr与普通变量"><a href="#constexpr与普通变量" class="headerlink" title="constexpr与普通变量"></a>constexpr与普通变量</h3><p>constexpr变量</p><ul><li>将变量声明为constexpr以便于由编译器检测一个表达式是否为一个常量表达式，而const没有此功能：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 3;</span><br><span class="line">int b = 4;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;a);</span><br><span class="line">constexpr int value1 = a + b;//编译器报错，表达式a + b不是常量表达式</span><br><span class="line">const int value2 = a + b;//正常初始化，不会报错</span><br></pre></td></tr></table></figure></li><li>因此，如果你想用一个你认为是常量的表达式来初始化一个变量，不妨将这个变量声明为constexpr，让编译器为你检测一下。</li><li>只有字面值类型才能声明为constexpr变量。（基本算数类型（bool，int…），引用，指针…）。</li></ul><h3 id="const与指针引用"><a href="#const与指针引用" class="headerlink" title="const与指针引用"></a>const与指针引用</h3><p>当一个指针声明为constexpr时，相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a = 3;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    constexpr int *p1 = &amp;a;</span><br><span class="line">    //两者等价,表示指针为常量，对象的值可以修改。</span><br><span class="line">    int * const p1 = &amp;a;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，如果想要声明一个指针常量指向一个整型常量，则可以有如下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int a = 3;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    constexpr const int *p1 = &amp;a;</span><br><span class="line">    //两者等价，指针为常量，指向一个整型常量</span><br><span class="line">    const int *const p3 = &amp;a;</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>constexpr指针和引用只能指向所有函数体之外的变量（全局变量）或者函数体内的静态变量。</p><h3 id="constexpr与函数"><a href="#constexpr与函数" class="headerlink" title="constexpr与函数"></a>constexpr与函数</h3><p>constexpr函数</p><p>constexpr函数<br>可以实现编译期函数（即函数在编译期执行完毕，并在调用处进行替换）：<br>#include <iostream><br>using namespace std;<br>&#x2F;&#x2F;运算n的阶乘<br>constexpr int factorial(int n)<br>{<br>    return n &#x3D;&#x3D; 0 ? 1 : n * factorial(n - 1);<br>}<br>int main()<br>{<br>    cout &lt;&lt; factorial(10) &lt;&lt; endl;<br>    system(“pause”);<br>    return 0;<br>}<br>该函数也可以在运行期执行：<br>#include <iostream><br>using namespace std;<br>constexpr int factorial(int n)<br>{<br>    return n &#x3D;&#x3D; 0 ? 1 : n * factorial(n - 1);<br>}<br>int main()<br>{<br>    int a &#x3D; 3;<br>    scanf_s(“%d”, &amp;a);<br>    cout &lt;&lt; factorial(a) &lt;&lt; endl;<br>    system(“pause”);<br>    return 0;<br>}<br>可以对constexpr变量进行初始化：<br>#include <iostream><br>using namespace std;<br>constexpr int factorial(int n)<br>{<br>    return n &#x3D;&#x3D; 0 ? 1 : n * factorial(n - 1);<br>}<br>int main()<br>{<br>    constexpr int value &#x3D; factorial(10);<br>    system(“pause”);<br>    return 0;<br>}<br>规定：</p><ul><li>函数的返回值以及参数都必须为字面值类型；</li><li>函数只能有一条return语句（C++14后无该要求）；<br>函数不一定返回常量表达式，但如果要初始化一个constexpr变量，则必须返回常量表达式（参数也必须为常量或常量表达式）；</li><li>函数被隐式的声明为内联函数；</li><li>函数内部可以声明变量（声明之后是运行期还是编译期？），可以用using声明，空语句，类型别名，循环，判断语句等，但cout不行。</li></ul>]]></content>
    
    
    <summary type="html"> const关键字</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中的static关键字</title>
    <link href="http://example.com/2022/05/25/C-%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://example.com/2022/05/25/C-%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2022-05-25T07:15:58.000Z</published>
    <updated>2022-05-25T07:17:01.751Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h2><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul><li>在全局变量前，加上关键字static，该变量就被定义成为一个静态全局变量。我们先举一个静态全局变量的例子，如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">static int n;  //定义静态全局变量</span><br><span class="line"></span><br><span class="line">void fn()</span><br><span class="line">&#123;</span><br><span class="line">    n++;</span><br><span class="line">    cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    n = 20;</span><br><span class="line">    cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    fn();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量。</li><li>未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化）；</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>全局变量本身就是静态存储方式，<br>静态全局变量当然也是静态存储方式。</p><p>这两者在存储方式上并无不同。</p><p>和全局变量的区别<br>这两者的区别在于非静态全局变量的作用域是整个源程序，<br>当一个源程序由多个原文件组成时，<br>非静态的全局变量在各个源文件中都是有效的。<br>而静态全局变量则限制了其作用域，<br>即只在定义该变量的源文件内有效，<br>在同一源程序的其它源文件中不能使用它。</p><p>如果是全局变量的话<br>你在别的源文件加一个extern<br>就可以使用这个源文件中的全局变量<br>但是如果是静态全局变量就不可以<br>也就是说定义全局变量就可以实现变量在文件中的共享，但定义静态全局变量就不可以 </p><p>这样带来了以下好处：</p><ul><li><p>静态全局变量不能被其它文件所用；静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的； </p></li><li><p>其它文件中可以定义相同名字的变量，不会发生冲突；</p></li></ul><h2 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h2><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。<br>我们先举一个静态局部变量的例子，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void fn();</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    fn();</span><br><span class="line">    fn();</span><br><span class="line">    fn();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fn()</span><br><span class="line">&#123;</span><br><span class="line">    static int n = 10;</span><br><span class="line">    cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    n++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。<br>　　但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。<br>　　静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>静态局部变量有以下特点：</p><ul><li>（1）该变量在全局数据区分配内存；</li><li>（2）静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</li><li>（3）静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；</li><li>（4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；</li><li>（5）初始化时机<br> 静态变量什么时候初始化<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">初始化只有一次，但是可以多次赋值，</span><br><span class="line">在主程序之前，编译器已经为其分配好了内存。</span><br><span class="line">静态局部变量和全局变量一样，数据都存放在全局区域，</span><br><span class="line">所以在主程序之前，编译器已经为其分配好了内存，</span><br><span class="line">但在C和C++中静态局部变量的初始化节点又有点不太一样。</span><br><span class="line">在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，</span><br><span class="line">就会进行初始化，所以我们看到在C语言中</span><br><span class="line">无法使用变量对静态局部变量进行初始化，</span><br><span class="line">在程序运行结束，变量所处的全局内存会被全部回收。</span><br><span class="line"></span><br><span class="line">而在C++中，初始化时在执行相关代码时才会进行初始化，</span><br><span class="line">主要是由于C++引入对象后，</span><br><span class="line">要进行初始化必须执行相应构造函数和析构函数，</span><br><span class="line">在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，</span><br><span class="line">并非简单地分配内存。</span><br><span class="line">所以C++标准定为全局或静态对象是有首次用到时才会进行构造，</span><br><span class="line">并通过atexit()来管理。在程序结束，</span><br><span class="line">按照构造顺序反方向进行逐个析构。</span><br><span class="line">所以在C++中是可以使用变量</span><br><span class="line">对静态局部变量进行初始化的。</span><br></pre></td></tr></table></figure></li></ul><h2 id="静态全局函数"><a href="#静态全局函数" class="headerlink" title="静态全局函数"></a>静态全局函数</h2><ul><li>这样的static函数与普通函数的区别是：用static修饰的函数，限定在本源码文件中，不能被本源码文件以外的代码文件调用。而普通的函数，默认是extern的，也就是说它可以被其它代码文件调用。</li></ul><p>　- 在函数的返回类型前加上关键字static，函数就被定义成为静态函数。普通 函数的定义和声明默认情况下是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。因此定义静态函数有以下好处：<br>　  &lt;1&gt; 其他文件中可以定义相同名字的函数，不会发生冲突。<br>　  　  &lt;2&gt; 静态函数不能被其他文件所用。</p><h2 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>假设你现在要写一个存款类<br>存款类里面有一个利息的成员变量<br>那么把利息这个成员变量设定为static 有什么作用呢？</p><ul><li><p>一是不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以节省了存储空间。</p></li><li><p>二是一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了。</p></li><li><p>三是有一些状态是和类本身相关的而不是和对象相关的 这些状态数据可以用静态成员变量去表达</p></li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>类内声明</li></ul><p><img src="https://files.mdnice.com/user/1489/70c33764-36a9-4fe2-8df2-e6c7b4ed60f6.png"></p><ul><li>类外初始化</li></ul><p><img src="https://files.mdnice.com/user/1489/34d1c2cb-608d-409c-aac9-09f85e753797.png"></p><ul><li>使用</li></ul><p><img src="https://files.mdnice.com/user/1489/1c5015be-1be2-4f01-9290-16b6ea09aa73.png"></p><p><img src="https://files.mdnice.com/user/1489/4f1e6aae-89b6-420a-a773-d0f3faf3a65a.png"></p><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p><img src="https://files.mdnice.com/user/1489/533d1e4c-a910-4bbb-87d4-78bab569efbe.png"></p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p><img src="https://files.mdnice.com/user/1489/213752eb-b8a8-45c7-92cb-36757d783b65.png"></p><h2 id="static作用总结"><a href="#static作用总结" class="headerlink" title="static作用总结"></a>static作用总结</h2><h3 id="作用1：隐藏"><a href="#作用1：隐藏" class="headerlink" title="作用1：隐藏"></a>作用1：隐藏</h3><ul><li>1.先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）<br>当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。<br>举例来说明。同时编译两个源文件，一个是a.c，另一个是main.c。</li></ul><p>&#x2F;&#x2F;a.c<br>char a &#x3D; ‘A’; &#x2F;&#x2F; global variable<br>void msg()<br>{<br>     printf(“Hello\n”);<br>}</p><p>&#x2F;&#x2F;main.c</p><p>int main()<br>{<br>     extern char a; &#x2F;&#x2F; extern variable must be declared before use<br>     printf(“%c “, a);<br>     (void)msg();<br>     return 0;<br>}</p><p>程序的运行结果是：<br>A Hello</p><p>为什么在a.c中定义的全局变量a和函数msg能在main.c中使用？前面说过，所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。此例中，a是全局变量，msg是函数，并且都没有加static前缀，因此对于另外的源文件main.c是可见的。<br>如果加了static，就会对其它源文件隐藏。例如在a和msg的定义前加上static，main.c就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏.</p><h3 id="2-内容的持久"><a href="#2-内容的持久" class="headerlink" title="2. 内容的持久"></a>2. 内容的持久</h3><ul><li>2.static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）<br>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。虽然这种用法不常见<br>PS：如果作为static局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与自动变量相同，只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。</li></ul><p>程序举例：</p><p>＃include &lt;stdio.h&gt;</p><p>int fun(){<br>    static int count &#x3D; 10; &#x2F;&#x2F;在第一次进入这个函数的时候，变量a被初始化为10！并接着自减1，以后每次进入该函数，a<br>    return count–; &#x2F;&#x2F;就不会被再次初始化了，仅进行自减1的操作；在static发明前，要达到同样的功能，则只能使用全局变量：    </p><p>}</p><p>int count &#x3D; 1;</p><p>int main(void)<br>{<br>     printf(“global\t\tlocal static\n”);<br>     for(; count &lt;&#x3D; 10; ++count)<br>               printf(“%d\t\t%d\n”, count, fun());<br>     return 0;<br>}</p><p>程序的运行结果是：<br>global  local static<br>1 10<br>2 9<br>3 8<br>4 7<br>5 6<br>6 5<br>7 4<br>8 3<br>9 2<br>10 1</p><p>—基于以上两点可以得出一个结论：把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。</p><h3 id="3-默认初始化为0"><a href="#3-默认初始化为0" class="headerlink" title="3. 默认初始化为0"></a>3. 默认初始化为0</h3><p>其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加‘\0’;太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是‘\0’;不妨做个小实验验证一下。</p><p>＃include &lt;stdio.h&gt;</p><p>int a;</p><p>int main()<br>{<br>     int i;<br>     static char str[10];<br>     printf(“integer: %d; string: (begin)%s(end)”, a, str);<br>     return 0;<br>}</p><p>程序的运行结果是：<br>integer: 0; string: (begin) (end) </p><p>最后对static的三条作用做一句话总结。首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0. </p><h3 id="4-类成员声明static"><a href="#4-类成员声明static" class="headerlink" title="4. 类成员声明static"></a>4. 类成员声明static</h3><p>4.static的第四个作用：C++中的类成员声明static（有些地方与以上作用重叠）<br> 在类中声明static变量或者函数时，初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员，这样就出现以下作用：<br>(1)类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致 了它仅能访问类的静态数据和静态成员函数。<br>(2)不能将静态成员函数定义为虚函数。<br>(3)由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊 ，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”。<br>(4)由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就 产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based X W indow系统结合，同时也成功的应用于线程函数身上。 （这条没遇见过）<br>(5)static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问 时间，节省了子类的内存空间。<br>(6)静态数据成员在&lt;定义或说明&gt;时前面加关键字static。<br>(7)静态数据成员是静态存储的，所以必须对它进行初始化。 （程序员手动初始化，否则编译时一般不会报错，但是在Link时会报错误）<br>(8)静态成员初始化与一般数据成员初始化不同:<br>初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；<br>初始化时不加该成员的访问权限控制符private，public等；<br>初始化时使用作用域运算符来标明它所属类；<br>           所以我们得出静态数据成员初始化的格式：<br>&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;&#x3D;&lt;值&gt;<br>(9)为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。</p>]]></content>
    
    
    <summary type="html">static关键字 </summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中的extern关键字</title>
    <link href="http://example.com/2022/05/25/C-%E4%B8%AD%E7%9A%84extern%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://example.com/2022/05/25/C-%E4%B8%AD%E7%9A%84extern%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2022-05-25T05:33:34.000Z</published>
    <updated>2022-05-25T05:35:07.053Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><ul><li><p>ref:<br><a href="https://www.jianshu.com/p/165b3410b7fa">https://www.jianshu.com/p/165b3410b7fa</a></p><p><a href="https://blog.csdn.net/z702143700/article/details/46805241">https://blog.csdn.net/z702143700/article/details/46805241</a></p><p><a href="https://sites.google.com/site/anythingiikegc/ge-zhong-jiao-cheng/c-ji-qiao/duo-wen-jian-bian-liang-gong-xiang">https://sites.google.com/site/anythingiikegc/ge-zhong-jiao-cheng/c-ji-qiao/duo-wen-jian-bian-liang-gong-xiang</a></p><p><a href="https://developer.aliyun.com/article/338215">https://developer.aliyun.com/article/338215</a></p></li></ul><h2 id="用法一：调用外部变量或者函数"><a href="#用法一：调用外部变量或者函数" class="headerlink" title="用法一：调用外部变量或者函数"></a>用法一：调用外部变量或者函数</h2><h3 id="1-调用别的源文件中的全局变量"><a href="#1-调用别的源文件中的全局变量" class="headerlink" title="1.调用别的源文件中的全局变量"></a>1.调用别的源文件中的全局变量</h3><p><img src="https://files.mdnice.com/user/1489/4a313c7f-5abb-4611-871e-c33900417721.png"></p><ul><li><p>这里需要注意的是，被引用的变量v的链接属性必须是外链接（external）的，也就是说a.cpp要引用到v，不只是取决于在a.cpp中声明extern int v，还取决于变量v本身是能够被引用到的。</p></li><li><p>这涉及到c语言的另外一个话题－－变量的作用域。能够被其他模块以extern修饰符引用到的变量通常是<code>全局变量</code>。</p></li><li><p>还有很重要的一点是，extern int v可以放在a.cpp中的任何地方，比如你可以在a.cpp中的函数fun定义的开头处声明extern int v，然后就可以引用到变量v了，只不过这样只能在函数fun作用域中引用v罢了，这还是变量作用域的问题。对于这一点来说，很多人使用的时候都心存顾虑。好像extern声明只能用于文件作用域似的。</p></li><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在一个源文件里定义了一个数组：char a[6];</span><br><span class="line">在另外一个文件里</span><br><span class="line">用下列语句进行了声明：extern char *a；</span><br><span class="line">请问，这样可以吗？</span><br><span class="line">答案与分析：</span><br><span class="line">1)、不可以，程序运行时会告诉你非法访问。</span><br><span class="line">原因在于，指向类型T的指针并不等价于类型T的数组。</span><br><span class="line">extern char *a声明的是一个指针变量而不是字符数组，</span><br><span class="line">因此与实际的定义不同，从而造成运行时非法访问。</span><br><span class="line">应该将声明改为extern char a[ ]。</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-调用别的源文件中的函数"><a href="#2-调用别的源文件中的函数" class="headerlink" title="2.调用别的源文件中的函数"></a>2.调用别的源文件中的函数</h3><p><img src="https://files.mdnice.com/user/1489/a3c10e0e-c534-4dbd-83e2-2b241b9a32de.png"></p><ul><li><p>全局函数的声明语句中，关键字extern可以省略，因为全局函数默认是extern类型的。</p></li><li><p>从本质上来讲，变量和函数没有区别。函数名是指向函数二进制块开头处的指针。</p></li><li><p>如果文件a.cpp需要引用b.cpp中的函数，比如在b.cpp中原型是int fun(int mu)，那么就可以在a.cpp中声明extern int fun（int mu），然后就能使用fun来做任何事情。</p></li><li><p>就像变量的声明一样，extern int fun（int mu）可以放在a.cpp中任何地方，而不一定非要放在a.cpp的文件作用域的范围中。</p></li><li><p>对其他模块中函数的引用，最常用的方法是包含这些函数声明的头文件。使用extern和包含头文件来引用函数有什么区别呢？extern的引用方式比包含头文件要简洁得多！extern的使用方法是直接了当的，想引用哪个函数就用extern声明哪个函数。</p></li><li><p>这样做的一个明显的好处是，会加速程序的编译（确切的说是预处理）的过程，节省时间。在大型C程序编译过程中，这种差异是非常明显的。</p></li></ul><p><img src="https://files.mdnice.com/user/1489/0134c5d4-c375-4cc1-a7f5-4ef39bcc018b.png"></p><h3 id="3-调用别的头文件中的变量-x2F-函数"><a href="#3-调用别的头文件中的变量-x2F-函数" class="headerlink" title="3.调用别的头文件中的变量&#x2F;函数"></a>3.调用别的头文件中的变量&#x2F;函数</h3><p><img src="https://files.mdnice.com/user/1489/ae484341-5802-40e2-86ae-9628b14b3bee.png"></p><ul><li>通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。例如，如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块A编译生成的目标代码中找到此函数。</li><li><code>extern int a;</code>  仅仅是一个变量的声明，其并不是在定义变量a，并未为a分配内存空间。变量a在所有模块中作为一种全局变量只能被定义一次，否则会出现连接错误。</li><li>externint a; &#x2F;&#x2F;属于声明<br> externint a &#x3D; 10; &#x2F;&#x2F;属于定义</li><li>声明可以拷贝n次，但是定义只能定义一次。</li><li>extern作为声明使用，就是告诉当前编译单元，不要为这个extern修饰的变量分配空间，这个变量已经在别的编译单元分配了空间。 </li><li>extern作为定义使用，用于创建外部变量，也可以认为是全局变量。</li></ul><h2 id="用法二：调用C方式的变量或者函数"><a href="#用法二：调用C方式的变量或者函数" class="headerlink" title="用法二：调用C方式的变量或者函数"></a>用法二：调用C方式的变量或者函数</h2><p>C方式编译和C++方式编译<br>相对于C，C++中新增了诸如重载等新特性，对于他们的编译，必然有一些重要的区别。<br>我们将下面的小程序分别按C和C++方式编译，来探讨两种编译方式的区别。</p><p><img src="https://files.mdnice.com/user/1489/e32d34cc-a6e2-4d82-99c4-997af31ebeed.png"></p><ul><li>extern “C” 包含双重含义，从字面上即可得到：首先，被它修饰的目标是“extern”的；其次，被它修饰的目标是“C”的。</li></ul><h3 id="1-Cpp文件调用C文件中的函数"><a href="#1-Cpp文件调用C文件中的函数" class="headerlink" title="1. Cpp文件调用C文件中的函数"></a>1. Cpp文件调用C文件中的函数</h3><p><img src="https://files.mdnice.com/user/1489/c24ed20c-5231-4b99-9167-367ad4176df0.png"></p><p><img src="https://files.mdnice.com/user/1489/e9f8624a-4cac-4cd0-9116-35069a4cb672.png"></p><p><img src="https://files.mdnice.com/user/1489/bf8dc9e4-4300-440a-9327-91e313099c3d.png"></p><h3 id="2-Cpp文件调用C文件中的变量"><a href="#2-Cpp文件调用C文件中的变量" class="headerlink" title="2. Cpp文件调用C文件中的变量"></a>2. Cpp文件调用C文件中的变量</h3><p><img src="https://files.mdnice.com/user/1489/8a6a50fc-2786-4522-b222-bebc06865a71.png"></p><p><img src="https://files.mdnice.com/user/1489/09df49c3-a940-4c93-aabd-c7945a7bc37a.png"></p><p><img src="https://files.mdnice.com/user/1489/980c0aa6-51ec-47ac-868a-2a27518dab2c.png"></p><h3 id="3-Cpp文件调用C方式的头文件"><a href="#3-Cpp文件调用C方式的头文件" class="headerlink" title="3. Cpp文件调用C方式的头文件"></a>3. Cpp文件调用C方式的头文件</h3><p><img src="https://files.mdnice.com/user/1489/4c686ecf-a08a-4282-85b3-7ec79dddc1a2.png"></p><ul><li>例二</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//Out.h</span><br><span class="line">#ifdef __cplusplus          //该段代码引用网上的...，     </span><br><span class="line">extern &quot;C&quot;&#123;</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">#include &lt;stdio.h&gt;         </span><br><span class="line"> extern void aa();</span><br><span class="line">                                  </span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//Out.c</span><br><span class="line">#include &quot;Out.h&quot;</span><br><span class="line">void aa()</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;aa is running&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//Test.cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &quot;Out.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123; </span><br><span class="line">   aa();</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例三</p><p><img src="https://files.mdnice.com/user/1489/3617915f-d89e-44db-8751-c27d958e4b60.png"></p>]]></content>
    
    
    <summary type="html"> extern关键字</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>SSH的原理及常用命令</title>
    <link href="http://example.com/2022/05/24/SSH%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/05/24/SSH%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2022-05-24T04:27:47.000Z</published>
    <updated>2022-05-24T04:33:27.849Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="SSH的含义"><a href="#SSH的含义" class="headerlink" title="SSH的含义"></a>SSH的含义</h2><ul><li><p>SSH是一个应用层协议，专为远程登录会话和其他网络服务提供安全性的保障，防止信息泄露问题。</p></li><li><p>ssh服务端由2部分组成： openssh(提供ssh服务)    openssl(提供加密的程序)</p></li><li><p>ssh的客户端可以用 XShell，XManager、SecureCRT，Putty、Mobaxterm  等工具进行远程连接、登录</p></li></ul><p><img src="https://files.mdnice.com/user/1489/55e5275f-20b0-4e30-b3d1-cce30d62f991.png"></p><h2 id="SSH的历史"><a href="#SSH的历史" class="headerlink" title="SSH的历史"></a>SSH的历史</h2><ul><li>1995年，芬兰学者Tatu Ylonen设计了SSH协议，</li><li>SSH 为 Secure SHell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；</li><li>SSH最初是UNIX系统上的一个程序，后来又迅速扩展到其他操作平台。SSH在正确使用时可弥补网络中的漏洞。SSH客户端适用于多种平台。几乎所有UNIX平台—包括 HP-UX、Linux、Unix、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。</li><li>　　SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。</li></ul><h2 id="SSH的原理"><a href="#SSH的原理" class="headerlink" title="SSH的原理"></a>SSH的原理</h2><p>SSH(远程连接工具)连接原理：ssh服务是一个守护进程(demon)，系统后台监听客户端的连接，ssh服务端的进程名为sshd，负责实时监听客户端的请求(IP 22默认端口)，包括公共秘钥等交换等信息。</p><p>服务器启动的时候自己产生一个密钥(768bit公钥)，本地的ssh客户端发送连接请求到ssh服务器，服务器检查连接点客户端发送的数据和IP地址，确认合法后，ssh服务器会发送密钥(768bits)给客户端，此时客户端将本地私钥(256bit)和服务器的公钥(768bit)结合成密钥对key(1024bit)，发回给服务器端，建立连接通过key-pair数据传输。</p><h4 id="基于口令的认证-密码登录"><a href="#基于口令的认证-密码登录" class="headerlink" title="基于口令的认证-密码登录"></a>基于口令的认证-密码登录</h4><p><img src="https://files.mdnice.com/user/1489/20d1c527-81d7-46a9-a59c-30311d225a56.png"></p><p><img src="https://files.mdnice.com/user/1489/20a4b7b5-a888-4502-bd09-d5f9c8e98d9c.png"></p><p><img src="https://files.mdnice.com/user/1489/039079ca-b2f9-4b7d-91c5-fc5a3a48ab9e.png"></p><h4 id="基于公钥的认证-免密码登录"><a href="#基于公钥的认证-免密码登录" class="headerlink" title="基于公钥的认证-免密码登录"></a>基于公钥的认证-免密码登录</h4><p><img src="https://files.mdnice.com/user/1489/76ed9dfe-103d-481d-b967-26d9a002f8d1.png"></p><p><img src="https://files.mdnice.com/user/1489/aab013b5-dcfd-4e5b-888e-e5d267c93af7.png"></p><p><img src="https://files.mdnice.com/user/1489/237873e0-cfe1-487b-8ee3-9dad77e29941.png"></p><h2 id="SSH的有关命令"><a href="#SSH的有关命令" class="headerlink" title="SSH的有关命令"></a>SSH的有关命令</h2><h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><p><img src="https://files.mdnice.com/user/1489/b63bd863-def7-4054-a836-c6c90537e0ab.png"></p><p><img src="https://files.mdnice.com/user/1489/29e92daf-1ec4-4f50-92b2-e8a555a9e3bc.png"></p><h3 id="登录操作"><a href="#登录操作" class="headerlink" title="登录操作"></a>登录操作</h3><p><img src="https://files.mdnice.com/user/1489/f044672e-b952-49f1-801d-fa4cebafe9ab.png"></p><h3 id="发送文件"><a href="#发送文件" class="headerlink" title="发送文件"></a>发送文件</h3><p><img src="https://files.mdnice.com/user/1489/c0101bb6-c185-440f-a931-c4a3ed713bfa.png"></p><h3 id="远程执行指令"><a href="#远程执行指令" class="headerlink" title="远程执行指令"></a>远程执行指令</h3><p><img src="https://files.mdnice.com/user/1489/cff768f1-19f0-4999-9179-746b6d5c293a.png"></p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p><a href="https://blog.mimvp.com/article/37361.html">ref : ssh常用命令</a></p>]]></content>
    
    
    <summary type="html">SSH的原理及常用命令 </summary>
    
    
    
    <category term="Linux命令" scheme="http://example.com/categories/Linux%E5%91%BD%E4%BB%A4/"/>
    
    
    <category term="Linux命令" scheme="http://example.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>原型模式C++实现</title>
    <link href="http://example.com/2022/05/21/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/05/21/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-05-20T23:47:46.000Z</published>
    <updated>2022-05-20T23:50:45.814Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/huangyimo/article/details/80390001">原型模式有什么用？</a></p><p><a href="https://blog.csdn.net/chenxun_2010/article/details/48327231">原型模式怎么实现?</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resume</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="type">char</span>* name;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Resume* <span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteResume</span>:<span class="keyword">public</span> Resume&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">ConcreteResume</span>(<span class="type">char</span>* str)&#123;</span><br><span class="line">             name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str)+<span class="number">1</span>];</span><br><span class="line">             <span class="built_in">strcpy</span>(name,str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ConcreteResume</span>(<span class="type">const</span> ConcreteResume&amp; r1)&#123;</span><br><span class="line">            name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(r1.name)+<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(name,r1.name);</span><br><span class="line">        &#125;</span><br><span class="line">        ConcreteResume&amp; <span class="keyword">operator</span>&amp;=(<span class="type">const</span> ConcreteResume&amp; r1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;r1)&#123;<span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">            <span class="keyword">delete</span>[] name;</span><br><span class="line">            name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(r1.name)+<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(name,r1.name);</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">ConcreteResume* <span class="title">clone</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">ConcreteResume</span>(*<span class="keyword">this</span>);</span><br><span class="line">        &#125; </span><br><span class="line">       <span class="comment">//debug</span></span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">PinrtInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(name);i++)&#123;</span><br><span class="line">                cout&lt;&lt;name[i]&lt;&lt;endl;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> str[]  = <span class="string">&quot;happy&quot;</span>;</span><br><span class="line">    <span class="function">ConcreteResume <span class="title">r1</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="function">ConcreteResume <span class="title">r2</span><span class="params">(r1)</span></span>;</span><br><span class="line">    <span class="type">char</span> str1[]  = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">    <span class="function">ConcreteResume <span class="title">r3</span><span class="params">(str1)</span></span>;</span><br><span class="line">    r3 = r1;</span><br><span class="line">    <span class="comment">// r3.PinrtInfo();</span></span><br><span class="line">    ConcreteResume *r4 = r3.<span class="built_in">clone</span>();</span><br><span class="line">    r4-&gt;<span class="built_in">PinrtInfo</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html"> 原型模式C++实现</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>外观模式C++实现</title>
    <link href="http://example.com/2022/05/20/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/05/20/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-05-20T03:46:56.000Z</published>
    <updated>2022-05-20T03:49:14.933Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><a href="https://blog.csdn.net/leonardohaig/article/details/106557237">ref: 外观模式</a></p><p><img src="https://files.mdnice.com/user/1489/d2ca3fbe-6e0e-43d1-95fd-f6e0ae22d2c1.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Control</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Control</span>() = <span class="keyword">default</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>: <span class="keyword">public</span> Control&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;the screen start!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;the screen close!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Keyboard</span>: <span class="keyword">public</span> Control&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;the Keyboard start!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;the Keyboard close!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Host</span>: <span class="keyword">public</span> Control&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;the Keyboard start!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;the Keyboard close!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Host host;</span><br><span class="line">        Keyboard keyboard;</span><br><span class="line">        Screen screen;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">            host.<span class="built_in">start</span>();</span><br><span class="line">            keyboard.<span class="built_in">start</span>();</span><br><span class="line">            screen.<span class="built_in">start</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">            host.<span class="built_in">close</span>();</span><br><span class="line">            keyboard.<span class="built_in">close</span>();</span><br><span class="line">            screen.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Computer computer;</span><br><span class="line">    computer.<span class="built_in">start</span>();</span><br><span class="line">    computer.<span class="built_in">close</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">外观模式C++实现 </summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>代理模式C++实现</title>
    <link href="http://example.com/2022/05/19/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/05/19/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-05-19T07:44:25.000Z</published>
    <updated>2022-05-19T07:46:47.358Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/m0_46308273/article/details/117193671">ref : 代理模式</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoSite</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">watchFreemovie</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">watchVipmovie</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">watchSVipmovie</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span>:<span class="keyword">public</span> VideoSite&#123;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchFreemovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             cout&lt;&lt;<span class="string">&quot;You are watching Free Movie.&quot;</span>&lt;&lt;endl;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchVipmovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             cout&lt;&lt;<span class="string">&quot;You are watching Vip Movie.&quot;</span>&lt;&lt;endl;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchSVipmovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             cout&lt;&lt;<span class="string">&quot;You are watching SVip Movie.&quot;</span>&lt;&lt;endl;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FreeUesrProxy</span>:<span class="keyword">public</span> VideoSite&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        RealSubject* realSubject;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">FreeUesrProxy</span>()&#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> RealSubject;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">FreeUesrProxy</span>()&#123;</span><br><span class="line">            <span class="keyword">delete</span> realSubject;</span><br><span class="line">            realSubject = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">watchFreemovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             realSubject-&gt;<span class="built_in">watchFreemovie</span>();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchVipmovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             cout&lt;&lt;<span class="string">&quot;You cannot watch Vip Movie.&quot;</span>&lt;&lt;endl;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchSVipmovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             cout&lt;&lt;<span class="string">&quot;You cannot watch SVip Movie.&quot;</span>&lt;&lt;endl;</span><br><span class="line">         &#125;        </span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VipUserProxy</span>:<span class="keyword">public</span> VideoSite&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        RealSubject* realSubject;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">VipUserProxy</span>()&#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> RealSubject;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">VipUserProxy</span>()&#123;</span><br><span class="line">            <span class="keyword">delete</span> realSubject;</span><br><span class="line">            realSubject = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">watchFreemovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             realSubject-&gt;<span class="built_in">watchFreemovie</span>();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchVipmovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             realSubject-&gt;<span class="built_in">watchVipmovie</span>();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchSVipmovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             cout&lt;&lt;<span class="string">&quot;You cannot watch SVip Movie.&quot;</span>&lt;&lt;endl;</span><br><span class="line">         &#125;        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SVipUserProxy</span>:<span class="keyword">public</span> VideoSite&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        RealSubject* realSubject;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">SVipUserProxy</span>()&#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> RealSubject;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">SVipUserProxy</span>()&#123;</span><br><span class="line">            <span class="keyword">delete</span> realSubject;</span><br><span class="line">            realSubject = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">watchFreemovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             realSubject-&gt;<span class="built_in">watchFreemovie</span>();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchVipmovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">             realSubject-&gt;<span class="built_in">watchVipmovie</span>();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="function"><span class="type">void</span> <span class="title">watchSVipmovie</span><span class="params">()</span></span>&#123;</span><br><span class="line">            realSubject-&gt;<span class="built_in">watchSVipmovie</span>();</span><br><span class="line">         &#125;  </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">watchMovie</span><span class="params">(VideoSite* videoSite)</span></span>&#123;</span><br><span class="line">    videoSite-&gt;<span class="built_in">watchFreemovie</span>();</span><br><span class="line">    videoSite-&gt;<span class="built_in">watchVipmovie</span>();</span><br><span class="line">    videoSite-&gt;<span class="built_in">watchSVipmovie</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    VideoSite* videoSite = <span class="keyword">new</span> <span class="built_in">VipUserProxy</span>();</span><br><span class="line">    <span class="built_in">watchMovie</span>(videoSite);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">代理模式的C++实现 </summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>装饰器模式C++实现</title>
    <link href="http://example.com/2022/05/19/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/05/19/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-05-19T06:03:01.000Z</published>
    <updated>2022-05-19T06:07:01.291Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/walkerkalr/article/details/28633123">ref: 装饰器模式</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Beverage</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        string description;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> string <span class="title">getCost</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> string <span class="title">getDescription</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MilkTea</span>: <span class="keyword">public</span> Beverage&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string costNum;</span><br><span class="line">        <span class="built_in">MilkTea</span>()&#123;</span><br><span class="line">            description = <span class="string">&quot;milkTea&quot;</span>;</span><br><span class="line">            costNum = <span class="string">&quot;￥15&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">getCost</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> costNum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">getDescription</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> description;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decorater</span>:<span class="keyword">public</span> Beverage &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        Beverage* beverage ;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> string <span class="title">getCost</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> string <span class="title">getDescription</span><span class="params">()</span></span>&#123;&#125;;         </span><br><span class="line">        <span class="built_in">Decorater</span>(Beverage* newBeverage)&#123;</span><br><span class="line">            beverage = newBeverage;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zhenzhu</span>:<span class="keyword">public</span> Decorater&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string costNum;</span><br><span class="line">        string description;</span><br><span class="line">        <span class="built_in">Zhenzhu</span>(Beverage* newBeverage):<span class="built_in">Decorater</span>(newBeverage)&#123;</span><br><span class="line">            costNum = <span class="string">&quot;￥3&quot;</span>;</span><br><span class="line">            description = <span class="string">&quot; add Zhenzhu&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function">string <span class="title">getCost</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> beverage-&gt;<span class="built_in">getCost</span>()+<span class="string">&quot;+&quot;</span>+costNum;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">getDescription</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> beverage-&gt;<span class="built_in">getDescription</span>()+description;</span><br><span class="line">            </span><br><span class="line">        &#125;        </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Yeguo</span>:<span class="keyword">public</span> Decorater&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string costNum;</span><br><span class="line">        string description;</span><br><span class="line">        <span class="built_in">Yeguo</span>(Beverage* newBeverage):<span class="built_in">Decorater</span>(newBeverage)&#123;</span><br><span class="line">            costNum = <span class="string">&quot;￥4&quot;</span>;</span><br><span class="line">            description = <span class="string">&quot; add Yeguo&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function">string <span class="title">getCost</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> beverage-&gt;<span class="built_in">getCost</span>()+<span class="string">&quot;+&quot;</span>+costNum;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">getDescription</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> beverage-&gt;<span class="built_in">getDescription</span>()+description;</span><br><span class="line">            </span><br><span class="line">        &#125;      </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Beverage* newMilkTea = <span class="keyword">new</span> MilkTea;</span><br><span class="line">    cout&lt;&lt;newMilkTea-&gt;<span class="built_in">getDescription</span>()&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;newMilkTea-&gt;<span class="built_in">getCost</span>()&lt;&lt;endl;</span><br><span class="line">    newMilkTea = <span class="keyword">new</span> <span class="built_in">Zhenzhu</span>(newMilkTea);</span><br><span class="line">    cout&lt;&lt;newMilkTea-&gt;<span class="built_in">getDescription</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;newMilkTea-&gt;<span class="built_in">getCost</span>()&lt;&lt;endl;</span><br><span class="line">    newMilkTea = <span class="keyword">new</span> <span class="built_in">Yeguo</span>(newMilkTea);</span><br><span class="line">    cout&lt;&lt;newMilkTea-&gt;<span class="built_in">getDescription</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;newMilkTea-&gt;<span class="built_in">getCost</span>()&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">装饰器模式C++实现 </summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Notes of System Design No.05  — Design a Youtube</title>
    <link href="http://example.com/2022/05/14/Notes-of-System-Design-No-53-%E2%80%94-Design-a-Youtube/"/>
    <id>http://example.com/2022/05/14/Notes-of-System-Design-No-53-%E2%80%94-Design-a-Youtube/</id>
    <published>2022-05-14T05:45:37.000Z</published>
    <updated>2022-05-14T05:46:42.100Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="01-Funtional-Requirements"><a href="#01-Funtional-Requirements" class="headerlink" title="01. Funtional Requirements"></a>01. Funtional Requirements</h2><p><img src="https://files.mdnice.com/user/1489/bd8ff45e-32bc-4ca1-80f4-9bf31e98a57a.png"></p><h2 id="02-Non-Functional-Requirements"><a href="#02-Non-Functional-Requirements" class="headerlink" title="02. Non Functional Requirements"></a>02. Non Functional Requirements</h2><p><img src="https://files.mdnice.com/user/1489/15ce9e3e-b314-474f-8d65-87c183e26721.png"></p><h2 id="03-Assumption"><a href="#03-Assumption" class="headerlink" title="03.Assumption"></a>03.Assumption</h2><p><img src="https://files.mdnice.com/user/1489/9e0154e0-b218-4605-81c4-c472a4b33237.png"></p><p><img src="https://files.mdnice.com/user/1489/f7d4ad8f-ca0e-45bc-ae96-ed5bf1b2167e.png"></p><p><img src="https://files.mdnice.com/user/1489/8bfb69f6-552d-4506-b23c-40a312eed6b7.png"></p><p><img src="https://files.mdnice.com/user/1489/64308aae-bc9e-4ac4-a336-d239706e6139.png"></p><h2 id="04-API"><a href="#04-API" class="headerlink" title="04 API"></a>04 API</h2><p><img src="https://files.mdnice.com/user/1489/074c8b44-9210-4c77-a5a0-ff88cc7e303f.png"></p><p><img src="https://files.mdnice.com/user/1489/3dc2bd89-527a-434d-9484-7a93b9ba8ba4.png"></p><h2 id="05-High-Level-Design"><a href="#05-High-Level-Design" class="headerlink" title="05 High Level Design"></a>05 High Level Design</h2><h3 id="上传业务"><a href="#上传业务" class="headerlink" title="上传业务"></a>上传业务</h3><p><img src="https://files.mdnice.com/user/1489/13eb6921-638c-44a5-bf89-2bea619a4c1e.png"></p><ul><li><p>Video Processing 模块主要做的是编码解码 提取缩略图等等<br><img src="https://files.mdnice.com/user/1489/3a798d5f-4836-40d9-a863-d3ee434f9260.png"></p></li><li><p>视频格式主要有以下这些<br><img src="https://files.mdnice.com/user/1489/3e5e1c98-2be1-4839-b86a-8fa9460d09a3.png"></p></li><li><p>什么是CDN</p></li></ul><p><img src="https://files.mdnice.com/user/1489/911232aa-07b5-4416-9f5e-93d87f53e383.png"></p><h3 id="视频播放业务"><a href="#视频播放业务" class="headerlink" title="视频播放业务"></a>视频播放业务</h3><p><img src="https://files.mdnice.com/user/1489/4d90fa45-dbb7-46e7-b65c-793f0fa99d87.png"></p><h2 id="06-Low-Level-Design"><a href="#06-Low-Level-Design" class="headerlink" title="06 Low Level Design"></a>06 Low Level Design</h2><p><img src="https://files.mdnice.com/user/1489/5286b42b-4505-4945-b3ac-bdc5afb8a9b0.png"></p><p><img src="https://files.mdnice.com/user/1489/3d365597-8956-4bf9-a52a-f36d13bb83c8.png"></p><h2 id="07-Scalability"><a href="#07-Scalability" class="headerlink" title="07 Scalability"></a>07 Scalability</h2><p><img src="https://files.mdnice.com/user/1489/50376216-1e9e-4205-b29b-338014ac6ea7.png"></p><p><img src="https://files.mdnice.com/user/1489/2746c354-de4f-4518-ad16-bc9c6927e81b.png"></p><p><a href="https://www.bilibili.com/video/BV1s5411p7dR?spm_id_from=333.999.0.0">优化方案</a></p>]]></content>
    
    
    <summary type="html">Design a Youtube</summary>
    
    
    
    <category term="系统设计" scheme="http://example.com/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="系统设计" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Notes of System Design No.04 —Design a Twitter</title>
    <link href="http://example.com/2022/05/14/Notes-of-System-Design-No-41-%E2%80%94Design-a-Twitter/"/>
    <id>http://example.com/2022/05/14/Notes-of-System-Design-No-41-%E2%80%94Design-a-Twitter/</id>
    <published>2022-05-14T01:50:32.000Z</published>
    <updated>2022-05-14T01:54:11.409Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="00-What-is-Twitter"><a href="#00-What-is-Twitter" class="headerlink" title="00.What is Twitter"></a>00.What is Twitter</h2><p><img src="https://files.mdnice.com/user/1489/214c1d26-e12a-46c0-a6eb-1d80113f93b8.png"></p><p>注：TimeLine 就是按照时间顺序显示的信息流</p><h2 id="01-Functional-Requirements"><a href="#01-Functional-Requirements" class="headerlink" title="01. Functional Requirements"></a>01. Functional Requirements</h2><p><img src="https://files.mdnice.com/user/1489/37577333-5746-4e53-8957-acd915dd0e4d.png"></p><ul><li>1.发布推特</li><li>2.删除推特</li><li>3.主页信息流</li><li>4.用户页面信息流</li><li>5.关注</li><li>6.搜索</li><li>7.点赞<br>…</li></ul><h2 id="02-Non-Functional-Requirements"><a href="#02-Non-Functional-Requirements" class="headerlink" title="02. Non-Functional Requirements"></a>02. Non-Functional Requirements</h2><p><img src="https://files.mdnice.com/user/1489/4ed36dcb-d460-49e9-9290-e8373373a458.png"></p><ul><li>一致性<br>每次都能读取到最新的数据</li><li>可用性<br>每次刷新都不会报错，并不用求保证必须得到最新的数据，高可用性的前提是这个系统必须是可扩展的，保证系统在很多拥塞的时候，也能够很好的返回数据。</li><li>Partition Tolerance(Fault Tolerance)</li></ul><p>系统丢包了，或者有几个设备宕机了 或者有几个磁盘坏掉了 不影响系统运行</p><h2 id="03-Assumption"><a href="#03-Assumption" class="headerlink" title="03.  Assumption"></a>03.  Assumption</h2><p><img src="https://files.mdnice.com/user/1489/420ec39a-e793-418f-a1c1-dafab6becdf6.png"></p><h3 id="关键指标"><a href="#关键指标" class="headerlink" title="关键指标"></a>关键指标</h3><ul><li>200m的DAU  100m的新推特</li><li>每个用户每天看timeline 5次，看别的用户timeline 3次</li><li>每个timeline 有20条数据</li><li>每个推特有280个字节(因为限制了每个推特是140个字符)  </li><li>每个推特的元数据(发布时间 发布地点等等) 限制了是30个字节</li><li>20%的推特含有照片 每个照片200kb</li><li>10%的推特含有视频 30%的视频会被观看 每个视频2MB<h3 id="存储估算"><a href="#存储估算" class="headerlink" title="存储估算"></a>存储估算</h3></li></ul><p><img src="https://files.mdnice.com/user/1489/fed2d04c-52dd-4081-b2a0-caeb61bc6b29.png"></p><h3 id="带宽估计"><a href="#带宽估计" class="headerlink" title="带宽估计"></a>带宽估计</h3><p><img src="https://files.mdnice.com/user/1489/a090b31a-3f8b-427d-92e1-24ae1de27475.png"><br>注:</p><ul><li>200M 表示的是DAU</li><li>20表示的是每个Timeline显示的推特数量</li></ul><h2 id="04-API"><a href="#04-API" class="headerlink" title="04. API"></a>04. API</h2><p><img src="https://files.mdnice.com/user/1489/4bb7e652-60a9-4675-9de6-7bd77100ba1b.png"></p><p>注：</p><ul><li>readHomeTimeLine 中有的参数pageSize表示设定的每个page的推特数量，因为不同的终端屏幕大小不一样 需要显示的推特数量也不一样。pageToken表示当前的页码，如果不设定的话 默认显示最新的页号所对应的推特</li></ul><h2 id="05-High-Level-Design"><a href="#05-High-Level-Design" class="headerlink" title="05.High Level Design"></a>05.High Level Design</h2><h3 id="Sceranio1-Post-twieets-发布推特"><a href="#Sceranio1-Post-twieets-发布推特" class="headerlink" title="Sceranio1 :Post twieets 发布推特"></a>Sceranio1 :Post twieets 发布推特</h3><p><img src="https://files.mdnice.com/user/1489/86fb0489-5677-4062-bd20-453b7de136cc.png"></p><h3 id="Sceranio2-Visit-Uesr-TimeLine-访问用户的TimeLine"><a href="#Sceranio2-Visit-Uesr-TimeLine-访问用户的TimeLine" class="headerlink" title="Sceranio2 :Visit Uesr TimeLine 访问用户的TimeLine"></a>Sceranio2 :Visit Uesr TimeLine 访问用户的TimeLine</h3><p><img src="https://files.mdnice.com/user/1489/a6d6a857-dcbb-421a-80c5-d30bbeaa3683.png"></p><p>每次读取某个用户的timeline都比较费时间，可以采用的改进措施是<code>采用Cache</code>.</p><ul><li>用户每次发布推特的时候 把他最新的推特写入到cache </li><li>然后读取的时候 直接读取cache就可以了</li></ul><h3 id="Scenario3-Visit-Home-TimeLine"><a href="#Scenario3-Visit-Home-TimeLine" class="headerlink" title="Scenario3  Visit Home TimeLine"></a>Scenario3  Visit Home TimeLine</h3><p><img src="https://files.mdnice.com/user/1489/109dd247-8b38-4fa8-a6f3-9d7e926e97ef.png"></p><h4 id="Pull-Mode"><a href="#Pull-Mode" class="headerlink" title="Pull Mode"></a>Pull Mode</h4><ul><li>同样的 如果采用的方式是用户从数据库里面query每个关注者的最新推特，然后把它们merge到一起，比较费时间，可以采用的方式也是<code>采用缓存</code></li></ul><h4 id="Push-Mode"><a href="#Push-Mode" class="headerlink" title="Push Mode"></a>Push Mode</h4><ul><li>每个被关注的大V每次发布新推特的时候 把它写入到Cache里面每个粉丝follower的hometimeline里面  在图表里就是Fan out on Write</li><li>然后某个小粉丝读取的时候 直接读取Cache里面自己的hometimeline就可以了</li></ul><p>上面对应了两种方式Pull Mode和Push Mode<br>分析一下利弊</p><p><img src="https://files.mdnice.com/user/1489/e3473806-239a-43c3-82a1-c8dabd702564.png"></p><p><img src="https://files.mdnice.com/user/1489/997b3fa9-c963-474f-ab85-4d8bb94948d1.png"></p><p>注：Push Mode的劣势</p><p>1.每个用户发布新推特时候，写延迟更高</p><ul><li>但是可以采用Async tasks异步的方式 写入每个小粉丝的home timeline</li><li>虽然这样会导致不同小粉丝的hometimeline 读取到更新推特的时间不一致  但是这个Eventual Consistency是可以接受的</li></ul><ol start="2"><li>如果是那种百万粉的大v，那么在发布新推特的时候 要写入百万个小粉丝的hometimeline 而且有一些粉丝可能还是僵尸粉以及不活跃的用户 那其实很耗费资源</li></ol><ul><li>可以采用下面这个Pull Mode和Push Mode结合的方式</li></ul><h4 id="Pull-Mode-amp-Push-Mode（Hybrid-Solution）"><a href="#Pull-Mode-amp-Push-Mode（Hybrid-Solution）" class="headerlink" title="Pull Mode &amp; Push Mode（Hybrid Solution）"></a>Pull Mode &amp; Push Mode（Hybrid Solution）</h4><p>-<br><img src="https://files.mdnice.com/user/1489/8f9023e0-cc1d-4655-85b1-ff42484e25ba.png"></p><ul><li>对于一定数量以下的用户 （小V），采用Push Mode没问题</li><li>对于一定数量以上的用户(大V)， 他在发布推特的时候 不会把自己的最新推特写入到缓存里面每个粉丝的timeline中，它们的小粉丝在读取自己的timeline的时候，会先从缓存里面把已有的homeline读取出来，然后如果它的关注列表里面有大V，就会采用Pull Mode的方式，去数据库里面query这个大V的最新twitter.</li></ul><h2 id="05-Low-Level-Design"><a href="#05-Low-Level-Design" class="headerlink" title="05. Low Level Design"></a>05. Low Level Design</h2><p><img src="https://files.mdnice.com/user/1489/16a4e802-a559-449e-a77d-ee9867ad9caf.png"></p><p><img src="https://files.mdnice.com/user/1489/341a3107-f6d2-4860-aa06-275378f62d39.png"></p><h2 id="06-Scalability"><a href="#06-Scalability" class="headerlink" title="06. Scalability"></a>06. Scalability</h2><p><img src="https://files.mdnice.com/user/1489/affdc4eb-5815-40f6-9dee-2f077c384dae.png"></p><p><a href="https://www.bilibili.com/video/BV1Sf4y1e7wc?spm_id_from=333.999.0.0">着重介绍分表(Sharding) 和缓存(Caching)</a></p>]]></content>
    
    
    <summary type="html"> Design a Twitter </summary>
    
    
    
    <category term="系统设计" scheme="http://example.com/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="系统设计" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Notes of System Design No.03  — Design a PasteBin</title>
    <link href="http://example.com/2022/05/13/Notes-of-System-Design-No-03-%E2%80%94-Design-a-PasteBin/"/>
    <id>http://example.com/2022/05/13/Notes-of-System-Design-No-03-%E2%80%94-Design-a-PasteBin/</id>
    <published>2022-05-13T10:01:58.000Z</published>
    <updated>2022-05-14T01:52:49.023Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="00-What-is-Pastebin"><a href="#00-What-is-Pastebin" class="headerlink" title="00. What is Pastebin?"></a>00. What is Pastebin?</h2><p>这是一个网站</p><p>在输入框输入文本</p><p>网站上会生成一个URL链接</p><p>别人可以通过这个链接</p><p>访问到你输入的内容</p><h2 id="01-Functional-Requirement"><a href="#01-Functional-Requirement" class="headerlink" title="01.Functional Requirement"></a>01.Functional Requirement</h2><p><img src="https://files.mdnice.com/user/1489/12cb6936-b443-4f4c-a5af-2a9c52ebcb3e.png"></p><h2 id="02-Non-Functional-Requirement"><a href="#02-Non-Functional-Requirement" class="headerlink" title="02. Non-Functional Requirement"></a>02. Non-Functional Requirement</h2><p><img src="https://files.mdnice.com/user/1489/b596501a-c6ce-4eeb-b074-e9b90163ba7b.png"></p><h2 id="03-Assumptions"><a href="#03-Assumptions" class="headerlink" title="03. Assumptions"></a>03. Assumptions</h2><p><img src="https://files.mdnice.com/user/1489/ff094622-3609-44da-8463-7aeff7bf1482.png"></p><h2 id="04-Define-API"><a href="#04-Define-API" class="headerlink" title="04. Define API"></a>04. Define API</h2><p><img src="https://files.mdnice.com/user/1489/4dec94d3-399e-4bb8-8d99-17b005dab65d.png"></p><h2 id="05-High-Level-Design"><a href="#05-High-Level-Design" class="headerlink" title="05. High-Level Design"></a>05. High-Level Design</h2><ul><li><p>其实这个系统的设计和前面的TinyURL系统是大同小异的。本质上就相当于TinyURL的<code>长URL部分</code>变成用户输入的<code>内容部分</code>。所以可以先看一下前面的<a href="https://kyleandkelly.github.io/2022/05/05/Notes-of-System-Design-02-%E2%80%94-Design-a/">TinyURL设计</a>的部分，</p></li><li><p>和TinyURL的区别在于，TinyURL的用户输入会小一点，只是一个URL，但是PasteBin会用户输入的数据有可能会非常大，比如10M这样子的数量级 这样的如果还是用直接用普通的数据库去存的话，就会导致在用户读取时，整个链路过载，每次数据流动都是10M多数据。</p></li><li><p>优化措施1：</p></li></ul><ol><li>可以把大的文件直接存入对象存储数据库 比如S3，然后生成对象的链接 ，然后在Mapping DB里面存 S3-link 和短URL的 映射数据</li></ol><p>2.用户在取数据的时候，短URL 先到Mapping DB里面找到这个S3 link ，然后再通过S3 link 到S3里面找到实际的内容数据</p><ul><li>优化措施2：</li></ul><p>1.如果Content size &lt;10Kb，则可以直接存到Mapping DB里面<br>2.如果Content size &gt;10Kb，则可以通过S3来存储实际内容</p><ul><li>优化措施3：</li></ul><p>1.对于大文件数据 除了在Mapping DB里面存他的S3 link,还可以把preview data（ 大概10KB左右）存到Mapping DB里面，这样用户在访问的时候 就可以先把10kb的preview data 先读取出来 然后再通过S3 link 把剩下的数据读取出来</p><p><img src="https://files.mdnice.com/user/1489/059b9836-6bbf-4b7a-a34d-664bbe61a7e2.png"></p><h2 id="06-Low-Level-Design"><a href="#06-Low-Level-Design" class="headerlink" title="06. Low-Level Design"></a>06. Low-Level Design</h2><h3 id="1-DB"><a href="#1-DB" class="headerlink" title="1. DB"></a>1. DB</h3><p><img src="https://files.mdnice.com/user/1489/84638f38-0708-4e37-b3d7-d551c6926ede.png"></p><p><img src="https://files.mdnice.com/user/1489/84451bbd-277e-40b1-8a04-75f84b1b5eaa.png"></p><h3 id="2-Create-Workflow"><a href="#2-Create-Workflow" class="headerlink" title="2. Create Workflow"></a>2. Create Workflow</h3><p><img src="https://files.mdnice.com/user/1489/36251ea1-59f6-47f3-984b-48d4284d0ff1.png"></p><h3 id="3-Get-Workflow"><a href="#3-Get-Workflow" class="headerlink" title="3.Get Workflow"></a>3.Get Workflow</h3><p><img src="https://files.mdnice.com/user/1489/36d7952c-318d-4d15-8aa5-09a982f1d648.png"></p><h3 id="4-Expire-Workflow"><a href="#4-Expire-Workflow" class="headerlink" title="4.Expire Workflow"></a>4.Expire Workflow</h3><p><img src="https://files.mdnice.com/user/1489/c6a6979e-b3a7-4832-bbc5-e283cee8070b.png"></p><h2 id="07-Dive-Deep"><a href="#07-Dive-Deep" class="headerlink" title="07 . Dive Deep"></a>07 . Dive Deep</h2>]]></content>
    
    
    <summary type="html">Design a PasteBin </summary>
    
    
    
    <category term="系统设计" scheme="http://example.com/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="系统设计" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Notes of System Design No.02  — Design a TinyURL</title>
    <link href="http://example.com/2022/05/05/Notes-of-System-Design-02-%E2%80%94-Design-a/"/>
    <id>http://example.com/2022/05/05/Notes-of-System-Design-02-%E2%80%94-Design-a/</id>
    <published>2022-05-05T05:23:57.000Z</published>
    <updated>2022-05-13T07:41:54.502Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="1-Functional-Requirements"><a href="#1-Functional-Requirements" class="headerlink" title="1.Functional Requirements"></a>1.Functional Requirements</h2><p><img src="https://files.mdnice.com/user/1489/1efe7149-d6da-41c5-a004-63da6c991ae6.png"></p><ul><li>1.长链接-&gt;短链接(写)</li><li>2.短链接-&gt;长链接(读)</li><li>3.可以设置超时时间</li><li>4.相同的长链接映射到不同的短链接上 </li><li><ol start="5"><li>短链接的长度应该尽量短</li></ol></li><li>6.短链接应该不可预测</li></ul><h2 id="2-Non-Functional-Requirements"><a href="#2-Non-Functional-Requirements" class="headerlink" title="2.Non-Functional Requirements"></a>2.Non-Functional Requirements</h2><p><img src="https://files.mdnice.com/user/1489/bdb4dc03-930d-4db4-bc0a-71d3d4f8365e.png"></p><p>一般系统设计的非功能性指标都会从这几方面来考量</p><ul><li><p>1.高可用性 ：不能有单点失败</p></li><li><p>2.可扩展性 ：能够方便的针对大量请求扩充</p></li><li><p>3.低延迟性： 读写的延迟尽量低</p></li><li><p>4.强一致性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">强一致性：系统中的某个数据被成功更新后，</span><br><span class="line">后续任何对该数据的读取操作都将得到更新后的值；</span><br><span class="line"></span><br><span class="line">弱一致性：系统中的某个数据被更新后，</span><br><span class="line">后续对该数据的读取操作可能得到更新后的值，</span><br><span class="line">也可能是更改前的值。但经过“不一致时间窗口”这段时间后，</span><br><span class="line">后续对该数据的读取都是更新后的值；</span><br><span class="line"></span><br><span class="line">最终一致性：是弱一致性的特殊形式，</span><br><span class="line">存储系统保证在没有新的更新的条件下，</span><br><span class="line">最终所有的访问都是最后更新的值。</span><br></pre></td></tr></table></figure><p>在这个系统里面，要求的是强一致性。也就是说每次写请求更新完数据以后，进行读请求立马就能得到更新完的数据</p></li><li><p>5.持久性：不能丢数据</p></li><li><p>6.Read Heavy: 读写比例&#x3D; 100:1</p></li></ul><h2 id="3-Assumption"><a href="#3-Assumption" class="headerlink" title="3.Assumption"></a>3.Assumption</h2><p><img src="https://files.mdnice.com/user/1489/1b8ee4ff-130a-4d50-9168-e58683a1f464.png"></p><ul><li>假定短URL的字符组成-&gt;7个字符的Base64构成</li><li>假定每秒写100K次-&gt;1.4年可以耗尽7个字符长度的URL-&gt; 89.6年可以耗尽8个字符构成的URL</li><li>假定长URL 最多有2083个字符长度构成</li></ul><p>按照以上假设</p><ul><li>在数据库中整个长短链接映射数据长度为2095(8个字符长度的短URL+ 2083个字符长度的长URL+4个字符长度的超时时间设定)</li><li>每秒100K次写请求 则每年会写入6599TB的数据</li><li>这么大的数据需要做Partition</li></ul><h2 id="4-API"><a href="#4-API" class="headerlink" title="4. API"></a>4. API</h2><p><img src="https://files.mdnice.com/user/1489/054b31ab-721a-41e7-a2e6-04db302c17ad.png"></p><h2 id="5-High-Level-Design"><a href="#5-High-Level-Design" class="headerlink" title="5. High Level Design"></a>5. High Level Design</h2><p><img src="https://files.mdnice.com/user/1489/5dc18b16-4333-4898-b886-72aec961886a.png"></p><h3 id="写请求-长URL-gt-短URL"><a href="#写请求-长URL-gt-短URL" class="headerlink" title="写请求(长URL-&gt;短URL)"></a>写请求(长URL-&gt;短URL)</h3><ul><li><p>请求过来以后，负载均衡LB把请求分配到期中的一台App Server。为保证不会单点失败，App Server至少需要三台，因为如果是两台的话 如果其中一台正在升级维护，那么请i去就会全部的发到另外一台机器上 造成那台机器的过载.</p></li><li><p>Monitor监控每台App Server 的CPU 内存 网络 磁盘等等 ，达到某一个阈值的时候 动态的增加或者减少某一个机器的请求</p></li><li><p>DB存储长短链接映射的数据。需要对数据做Prtition，每个partition还需要做Replica复制备份，保证高可用</p></li><li><p>MemCache缓存数据库中产常见数据 减少延迟</p></li><li><p>App Server中由短链接映射生成长链接(Key Generation)的方式可以有以下几种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. Random String</span><br><span class="line">随机生成八位的字符串</span><br><span class="line"></span><br><span class="line">问题1：不同的AppServer处理相同的长URL的时候有可能会生成相同的字符串</span><br><span class="line"></span><br><span class="line">措施2： 可以对不同的App Server 分配一个两位不同的前缀，后六位随机生成。</span><br><span class="line"></span><br><span class="line">缺点： 相同的App Server</span><br><span class="line">重复处理相同的长URL的时候 有可能已经生成过了存在数据库里了 这个时候需要先检查数据库，再不断的重新用随机生成算法 直到生成一个不同的字符串</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2.MD5</span><br><span class="line">Long URL--&gt;MD5--&gt;128bits number --&gt;base64--&gt;21char string --&gt;Sub string --&gt;  前8 chars strign </span><br><span class="line"></span><br><span class="line">如果产生冲突 就在长URL的前面或者后面随机的增加一些字符，重新的走一遍这个过程</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/d6a6ce29-bf99-4d43-b9c8-49e8fdf448d8.png"></p><p>Ref: </p><p><a href="https://blog.csdn.net/qq_42992084/article/details/112252684">MD5</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017684507717184">Base64</a></p><p>先用MD5算法 处理原来的长链接 得到128bit的二进制数据</p><p>再用Base64编码这个128bit 二进制 ，得到一个大于21个字符的数据</p><p>在从这21左右字符里面 挑头6个或者8个作为最终的短链接编码</p><p>缺点：和上面一样 如果生成以后 检查数据库发现有冲突 那么就需要重新走一遍流程 再次生成随机串 直到没有冲突 ，增加了延迟</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3. 维护一个专门的 Key Generation服务</span><br><span class="line">用来专门生成短URL key</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/dee19773-44aa-4d29-bd3e-512af773bfbf.png"></p><p>机制：</p><ul><li>这个服务会提前在线下生成一堆短URL 存在数据库中，当App Server 需要一个新短URL的时候 就从这个数据库中获取 标记为已使用</li><li>这里增加的App Server也需要LB负载均衡和多个App Server 还有数据库也需要Partition和Replica.<br>优势：</li><li>这种方式把冲突放到了线下 而不是线上 减少了延迟</li></ul><p>改进：</p><ul><li>可以设定App Server 每次从Key Generation模块取短URL的时候 ，每次取批量的URL 存在自己的内存里 一直到它把自己的url用完才重新去 Key Generation模块取</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.维护一个全局的计数器</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/fe78f4d5-c85b-44b1-8015-eb52a51ad8ba.png"></p><p>机制：</p><ul><li>每一个App Server读取全局的计数器，更新计数。</li><li>然后在App Server里面<br>把读取到的计数器转换为64进制数，把64进制串作为新的短链</li><li>App Server 操作全局计数器的时候要加锁</li><li>这样的方式全局计数器的QPS比较高</li></ul><p>改进：</p><ul><li>App Server每一次不是取一个数，而是取一个范围.在某一个App Server<br>要素：</li><li>某一个App Server宕机了，损失了一部分范围数怎么半？</li></ul><p>不用担心，因为只是损失一部分 损失不大</p><ul><li>每个App server 读取时候设定的范围是多大呢？</li></ul><p>可以用每秒写的次数&#x2F;App server的机器数，比如每秒100000writes,有20个App server 则设定的范围可以是 100000&#x2F;20&#x3D;5000</p><ul><li>这种方式生成的短url是可被预测的吗？</li></ul><p>不是的 因为在用户发送请求到LB负载均衡的时候，分发到的App server是不确定的。不同的App server维护的计数范围是不同的</p><p>要实在担心会出现可预测的问题，可以在App server读取全局计数器生成范围的时候 用洗牌算法 把范围打乱，这样就不会按照顺序依次分配</p><p>全局计数器的实现方法：</p><ul><li>关系型数据库</li></ul><p>要保证读写串行化 以及加锁解锁方法 可以用关系型数据库实现。</p><ul><li>ZooKeeper</li></ul><p>Zookeeper有分布式的配置管理，可以实现上述的功能需求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对比</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/1489/38b6a951-a471-4572-9be3-c8addebb4bfb.png"></p><h2 id="6-Low-Level-Design"><a href="#6-Low-Level-Design" class="headerlink" title="6. Low Level Design"></a>6. Low Level Design</h2><h3 id="DB-Schema"><a href="#DB-Schema" class="headerlink" title="DB Schema"></a>DB Schema</h3><p><img src="https://files.mdnice.com/user/1489/cb9b6ca3-8628-46b5-b9a1-910e2c963462.png"></p><ul><li><p>只需要一张表 三个字段就可以</p></li><li><p>关系型数据库和非关系型数据库的比较</p></li></ul><p><img src="https://files.mdnice.com/user/1489/f78139d9-8f71-4f67-b04d-2151c59a4606.png"></p><ul><li>选择非关系型数据库的理由</li></ul><p><img src="https://files.mdnice.com/user/1489/e48af341-002d-4fbc-8cb7-7cf7ede7a37d.png"></p><h3 id="Workflow"><a href="#Workflow" class="headerlink" title="Workflow"></a>Workflow</h3><ul><li>由长URL创建一个短URL的流程</li></ul><p><img src="https://files.mdnice.com/user/1489/c621bef2-288a-4641-be28-40cf1f236002.png"></p><ul><li>由短URL读取一个长URL的流程</li></ul><p><img src="https://files.mdnice.com/user/1489/cd5772ae-0f10-45d9-be9f-eae5916df222.png"></p><h2 id="7-Dive-Deep"><a href="#7-Dive-Deep" class="headerlink" title="7. Dive Deep"></a>7. Dive Deep</h2>]]></content>
    
    
    <summary type="html"> Design a TinyURL</summary>
    
    
    
    <category term="系统设计" scheme="http://example.com/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="系统设计" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Notes of System Design No.01 —Answering the SDIs Step by Step</title>
    <link href="http://example.com/2022/05/04/Notes-of-System-Design-No-01-%E2%80%94Answering-the-SDIs-Step-by-Step/"/>
    <id>http://example.com/2022/05/04/Notes-of-System-Design-No-01-%E2%80%94Answering-the-SDIs-Step-by-Step/</id>
    <published>2022-05-04T06:52:06.000Z</published>
    <updated>2022-05-04T07:03:53.683Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>In this Article , </p><p>I will give a introduction to </p><p>the guildline of answering the SDIs(system design interviews) problem</p><p>lets get into it!</p><p>Mainly Reference:<a href="https://www.educative.io/courses/grokking-the-system-design-interview">https://www.educative.io/courses/grokking-the-system-design-interview</a> </p><h2 id="Step-1-Requirements-clarifications"><a href="#Step-1-Requirements-clarifications" class="headerlink" title="Step 1: Requirements clarifications"></a>Step 1: Requirements clarifications</h2><p>在一开始的时候问清楚设计的一些关键指标，缩小设计范围</p><p> Define the end goals And   clarifying ambiguities early in the interview is critical.</p><p><img src="https://files.mdnice.com/user/1489/df9c4df3-40ed-41bf-901d-68b0dbf29ddc.png"></p><h2 id="Step2-System-interface-Design"><a href="#Step2-System-interface-Design" class="headerlink" title="Step2 System interface Design"></a>Step2 System interface Design</h2><p>明确这个系统会需要哪些接口</p><p><img src="https://files.mdnice.com/user/1489/4b26cc35-f619-4a69-b844-4e995e377517.png"></p><h2 id="Step3-Back-of-the-envelope-estimation"><a href="#Step3-Back-of-the-envelope-estimation" class="headerlink" title="Step3   Back-of-the-envelope estimation"></a>Step3   Back-of-the-envelope estimation</h2><p>粗略的估计系统的规模</p><p><img src="https://files.mdnice.com/user/1489/ad5f1ed1-8a0b-4ac0-b64c-66f97b9158c3.png"></p><h2 id="Step4-Defining-data-model"><a href="#Step4-Defining-data-model" class="headerlink" title="Step4   Defining data model"></a>Step4   Defining data model</h2><p>确定数据结构</p><p><img src="https://files.mdnice.com/user/1489/7e82b4f9-b727-458f-b4bd-13fea0f80c47.png"></p><h2 id="Step5-High-level-design"><a href="#Step5-High-level-design" class="headerlink" title="Step5  High-level design"></a>Step5  High-level design</h2><p>顶层设计，用框图的形式画出系统的结构</p><p><img src="https://files.mdnice.com/user/1489/44e36158-cab9-4a0f-a55c-68769f20fe3b.png"></p><p><img src="https://files.mdnice.com/user/1489/811980f0-8214-4072-bb10-6383446d4c18.png"></p><h2 id="Step6-Detailed-Degisn"><a href="#Step6-Detailed-Degisn" class="headerlink" title="Step6  Detailed Degisn"></a>Step6  Detailed Degisn</h2><p>根据面试官感兴趣的方向,</p><p> 针对里面的2-3个模块作重点且细节的讨论</p><p>可以给出几种不同的设计方案 然后说出利弊 </p><p>然后说明为什么用目前的这个设计方案。</p><p><img src="https://files.mdnice.com/user/1489/72a6a418-8d62-4a09-82a5-753f4e732313.png"></p><h2 id="Step7-Identifying-and-resolving-bottlenecks"><a href="#Step7-Identifying-and-resolving-bottlenecks" class="headerlink" title="Step7  Identifying and resolving bottlenecks"></a>Step7  Identifying and resolving bottlenecks</h2><p>尽可能多的找到目前系统存在的弊端</p><p>然后给出不同的解决方案去处理它</p><p><img src="https://files.mdnice.com/user/1489/c6481036-7a54-4c42-a864-406366c8f2c7.png"></p>]]></content>
    
    
    <summary type="html">Answering the SDIs Step by Step </summary>
    
    
    
    <category term="系统设计" scheme="http://example.com/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="系统设计" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式的C++实现</title>
    <link href="http://example.com/2022/04/29/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/04/29/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-04-29T06:58:07.000Z</published>
    <updated>2022-05-19T06:07:29.031Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/83535678">ref:  工厂模式</a></p><h2 id="方法工厂"><a href="#方法工厂" class="headerlink" title="方法工厂"></a>方法工厂</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shoe</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Shoe</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NikeShoe</span>:<span class="keyword">public</span> Shoe&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;我是Nike&quot;</span>&lt;&lt;endl;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Factory</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Shoe* <span class="title">Makeshoe</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NikeFactory</span> : <span class="keyword">public</span> Factory&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Shoe* <span class="title">Makeshoe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Shoe* tmp = <span class="keyword">new</span> NikeShoe;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Step1 指定工厂</span></span><br><span class="line">    Factory* f = <span class="keyword">new</span> <span class="built_in">NikeFactory</span>();</span><br><span class="line">    <span class="comment">//Step2 工厂生产出鞋子</span></span><br><span class="line">     Shoe*  s  = f-&gt;<span class="built_in">Makeshoe</span>();   </span><br><span class="line">    <span class="comment">//Step3 打出口号</span></span><br><span class="line">    s-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;hello world&quot;&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shoe</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Shoe</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NikeShoe</span>:<span class="keyword">public</span> Shoe&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;我是Nike的鞋子&quot;</span>&lt;&lt;endl;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cloth</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Cloth</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NikeCloth</span>:<span class="keyword">public</span> Cloth&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;我是Nike的衣服&quot;</span>&lt;&lt;endl;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Factory</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Shoe* <span class="title">Makeshoe</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> Cloth* <span class="title">Makecloth</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NikeFactory</span> : <span class="keyword">public</span> Factory&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">Shoe* <span class="title">Makeshoe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Shoe* tmp = <span class="keyword">new</span> NikeShoe;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">Cloth* <span class="title">Makecloth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Cloth* tmp = <span class="keyword">new</span> NikeCloth;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Step1 指定工厂</span></span><br><span class="line">    Factory* f = <span class="keyword">new</span> <span class="built_in">NikeFactory</span>();</span><br><span class="line">    <span class="comment">//Step2 工厂生产出鞋子</span></span><br><span class="line">     Shoe*  s  = f-&gt;<span class="built_in">Makeshoe</span>();   </span><br><span class="line">    <span class="comment">//Step3 打出口号</span></span><br><span class="line">    s-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Step2 工厂生产衣服</span></span><br><span class="line">     Cloth*  c  = f-&gt;<span class="built_in">Makecloth</span>();   </span><br><span class="line">    <span class="comment">//Step3 打出口号</span></span><br><span class="line">    c-&gt;<span class="built_in">show</span>();</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板工厂"><a href="#模板工厂" class="headerlink" title="模板工厂"></a>模板工厂</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shoe</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Shoe</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NikeShoe</span>:<span class="keyword">public</span> Shoe&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;我是Nike的鞋子&quot;</span>&lt;&lt;endl;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cloth</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Cloth</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NikeCloth</span>:<span class="keyword">public</span> Cloth&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;我是Nike的衣服&quot;</span>&lt;&lt;endl;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">AbsProductType_t</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">virtual</span> ~<span class="built_in">Factory</span>()&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> AbsProductType_t* <span class="title">MakeProduct</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">AbsProductType_t</span>,<span class="keyword">class</span> <span class="title class_">ConcreatProductType_t</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreatFactory</span> : <span class="keyword">public</span> Factory&lt;AbsProductType_t&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">  </span><br><span class="line">        <span class="function">AbsProductType_t* <span class="title">MakeProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            AbsProductType_t* tmp = <span class="keyword">new</span> ConcreatProductType_t;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     ConcreatFactory&lt;Cloth,NikeCloth&gt; f;</span><br><span class="line">     Cloth* ns = f.<span class="built_in">MakeProduct</span>();</span><br><span class="line">     ns-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">工厂模式的C++实现</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>策略模式C++实现</title>
    <link href="http://example.com/2022/04/20/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/04/20/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8FC-%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-04-20T07:05:26.000Z</published>
    <updated>2022-04-29T06:52:52.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="没有用策略模式的场景"><a href="#没有用策略模式的场景" class="headerlink" title="没有用策略模式的场景"></a>没有用策略模式的场景</h2><p><em>Strategy_origin.cpp</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Runto</span><span class="params">(string country)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(country == <span class="string">&quot;Singpore&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Welcome to  Singpore&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(country == <span class="string">&quot;Canada&quot;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Welcome to  Canada&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(country == <span class="string">&quot;France&quot;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Welcome to  France&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(country == <span class="string">&quot;German&quot;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Welcome to  German&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Oops! no such choice&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string destination;</span><br><span class="line">    cin&gt;&gt;destination;</span><br><span class="line">    <span class="built_in">Runto</span>(destination);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用策略模式的场景"><a href="#使用策略模式的场景" class="headerlink" title="使用策略模式的场景"></a>使用策略模式的场景</h2><p><em>Strategy_modfied.cpp</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//策略类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CountryStrategy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printInfo</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singpore</span>: <span class="keyword">public</span> CountryStrategy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;welcome to Singpore &quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">France</span>: <span class="keyword">public</span> CountryStrategy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;welcome to France &quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Canada</span>: <span class="keyword">public</span> CountryStrategy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;welcome to Canada &quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上下文选择类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChooseCountry</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">          CountryStrategy* country;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      </span><br><span class="line">        <span class="built_in">ChooseCountry</span>(CountryStrategy* c):<span class="built_in">country</span>(c)&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">            country-&gt;<span class="built_in">printInfo</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Canada*  c = <span class="keyword">new</span> Canada;</span><br><span class="line">    Singpore*  s = <span class="keyword">new</span> Singpore;</span><br><span class="line">    <span class="function">ChooseCountry <span class="title">ch</span><span class="params">(s)</span></span>;</span><br><span class="line">    ch.<span class="built_in">printInfo</span>();</span><br><span class="line">    <span class="keyword">delete</span> c;</span><br><span class="line">    <span class="keyword">delete</span> s;</span><br><span class="line">    c= <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html"> 策略模式的一种简单实现C++</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单例模式的C++实现</title>
    <link href="http://example.com/2022/04/19/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84C-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/04/19/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84C-%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-04-19T12:06:56.000Z</published>
    <updated>2022-04-29T06:52:45.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><ul><li>采用懒汉式</li><li>使用垃圾回收器自动回收内存</li><li>使用双层锁进行线程同步</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">std::mutex m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">Singleton</span>()&#123;&#125;;</span><br><span class="line"><span class="type">static</span> Singleton* instance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> data = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// void Release();</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Deletor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Deletor</span>() &#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;now in the Deletor function&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">if</span>(Singleton::instance != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">delete</span> Singleton::instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> Deletor deletor;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton::Deletor Singleton::deletor;<span class="comment">//一定要加这段垃圾回收类初始化的代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// //此处不能使用析构函数进行内存释放!!</span></span><br><span class="line"><span class="comment">// //问题1</span></span><br><span class="line"><span class="comment">// //本质上instance是在 getInstance中使用new出来的一个对象 </span></span><br><span class="line"><span class="comment">// //所以在程序结束的时候 如果你不对他进行delete </span></span><br><span class="line"><span class="comment">// //它不会主动调用析构函数 这样就会造成内存泄漏</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// //问题2</span></span><br><span class="line"><span class="comment">// //在析构函数中delete进行内存释放的时候</span></span><br><span class="line"><span class="comment">// //会造成递归调用</span></span><br><span class="line"><span class="comment">// void Singleton::Release()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// cout&lt;&lt;&quot;DE<span class="doctag">BUG:</span> now in the destructor function &quot;&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">// if(instance != NULL)&#123;</span></span><br><span class="line"><span class="comment">// delete Singleton::instance;</span></span><br><span class="line"><span class="comment">// instance = NULL;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance  = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;DEBUG: now in getInstance &quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">m.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="literal">NULL</span>)&#123;</span><br><span class="line">instance  = <span class="keyword">new</span>  Singleton;</span><br><span class="line">&#125;</span><br><span class="line">m.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt;<span class="string">&quot;the address of instance &quot;</span> &lt;&lt; Singleton::instance&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Hello world&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span>  Singleton::<span class="built_in">getInstance</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ;i&lt;<span class="number">500</span> ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">thread <span class="title">th</span><span class="params">(GetInstance)</span></span>;</span><br><span class="line"></span><br><span class="line">th.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;LOG: end of main&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html"> 单例模式的一种简单实现C++</summary>
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>用C++实现简易版vector</title>
    <link href="http://example.com/2022/04/16/%E7%94%A8C++%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%89%88vector/"/>
    <id>http://example.com/2022/04/16/%E7%94%A8C++%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%89%88vector/</id>
    <published>2022-04-16T06:30:36.000Z</published>
    <updated>2022-04-29T06:53:00.490Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/KyleAndKelly/miniSTL"> https://github.com/KyleAndKelly/miniSTL</a></p><p>实现一个简易版的Vector</p><ul><li><em>miniVector.h</em></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;assert.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">miniVector</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">             </span><br><span class="line">        T* vectorArr;</span><br><span class="line">        <span class="type">int</span> capacity ;</span><br><span class="line">        <span class="type">int</span> size ;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">memoryExpand</span><span class="params">(<span class="type">const</span> <span class="type">int</span> elem)</span></span>;</span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        ~<span class="built_in">miniVector</span>();</span><br><span class="line">        <span class="built_in">miniVector</span>():<span class="built_in">vectorArr</span>(<span class="literal">NULL</span>),<span class="built_in">capacity</span>(<span class="number">2</span>),<span class="built_in">size</span>(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line">        <span class="built_in">miniVector</span>(<span class="type">const</span> <span class="type">int</span> cap);</span><br><span class="line">        <span class="built_in">miniVector</span>(<span class="type">const</span> <span class="type">int</span> ini_size,T ini_data);</span><br><span class="line">        <span class="built_in">miniVector</span>(<span class="type">const</span> miniVector&amp; vec);</span><br><span class="line">        miniVector&amp; <span class="keyword">operator</span>=(<span class="type">const</span> miniVector&amp; vec);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> T&amp; num)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">print_info</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        T&amp;  <span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">int</span>&amp; index) <span class="type">const</span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; index,<span class="type">const</span> T&amp; data)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><em>miniVector_Impl.h</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;miniVector.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> miniVector&lt;T&gt;::<span class="built_in">memoryExpand</span>(<span class="type">const</span> <span class="type">int</span> elem)&#123;</span><br><span class="line">    </span><br><span class="line">    T* newArr = <span class="keyword">new</span> T[elem*capacity];</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DEBUG: create newArr success&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">memcpy</span>(newArr,vectorArr,size*<span class="built_in">sizeof</span>(T));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] vectorArr;</span><br><span class="line">    vectorArr = newArr;</span><br><span class="line">    capacity = elem*capacity;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DEBUG:  capacity &quot;</span>&lt;&lt; capacity&lt;&lt;endl;     </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">miniVector&lt;T&gt;::<span class="built_in">miniVector</span>(<span class="type">const</span> <span class="type">int</span> cap)&#123;</span><br><span class="line">    capacity = cap;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    vectorArr = <span class="keyword">new</span> T[capacity];</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: capcity &quot;</span>&lt;&lt;capacity&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: size &quot;</span>&lt;&lt;size&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">miniVector&lt;T&gt;::<span class="built_in">miniVector</span>(<span class="type">const</span> <span class="type">int</span> ini_size,T ini_data)&#123;</span><br><span class="line">    </span><br><span class="line">    capacity = <span class="number">20</span>+ini_size;</span><br><span class="line">    size = ini_size;</span><br><span class="line">    vectorArr = <span class="keyword">new</span> T[capacity];</span><br><span class="line">    <span class="comment">// memset(vectorArr, ini_data,ini_size);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ini_size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vectorArr[i] = ini_data;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: capcity &quot;</span>&lt;&lt;capacity&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: size &quot;</span>&lt;&lt;size&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">miniVector&lt;T&gt;::~<span class="built_in">miniVector</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] vectorArr;</span><br><span class="line">    vectorArr = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> miniVector&lt;T&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> T&amp; num)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(vectorArr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        capacity = <span class="number">2</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        vectorArr = <span class="keyword">new</span> T[capacity];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(size &gt;= capacity)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">memoryExpand</span>(<span class="number">2</span>);<span class="comment">//2倍扩容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vectorArr[size] = num;</span><br><span class="line">    ++size;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DEBUG: size=&quot;</span>&lt;&lt;size&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DEBUG: vectorArr[&quot;</span>&lt;&lt;size<span class="number">-1</span>&lt;&lt;<span class="string">&quot;]=&quot;</span>&lt;&lt;vectorArr[size<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DEBUG: capacity&quot;</span>&lt;&lt;capacity&lt;&lt;endl;              </span><br><span class="line">    <span class="keyword">return</span>;    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> miniVector&lt;T&gt;::<span class="built_in">print_info</span>() <span class="type">const</span> </span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG vector capacity: &quot;</span>&lt;&lt; capacity&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG vector size: &quot;</span>&lt;&lt; size&lt;&lt;endl;   </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG vector data: &quot;</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">       cout&lt;&lt;vectorArr[i]&lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp;  miniVector&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">const</span> <span class="type">int</span>&amp; index) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(vectorArr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Error: Memory Not Initial!&quot;</span>&lt;&lt;endl;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( index &gt;= size || index &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Error: Out of Ranger!&quot;</span>&lt;&lt;endl;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vectorArr[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> miniVector&lt;T&gt;::<span class="built_in">insert</span>(<span class="type">const</span> <span class="type">int</span>&amp; index,<span class="type">const</span> T&amp; data)&#123;</span><br><span class="line">    <span class="keyword">if</span>(vectorArr == <span class="literal">NULL</span>)<span class="comment">//如果还没有初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Error: Vector is not Initial!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index &gt;= size<span class="number">-1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Error: The insert index should be from 0 to &quot;</span>&lt;&lt;size<span class="number">-1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(size&gt;=capacity)&#123;</span><br><span class="line">        <span class="built_in">memoryExpand</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = size<span class="number">-1</span>;i&gt;= index;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        vectorArr[i+<span class="number">1</span>]=vectorArr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    vectorArr[index]= data;</span><br><span class="line">    ++size;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DEBUG: vectorArr[&quot;</span>&lt;&lt;index&lt;&lt;<span class="string">&quot;]=&quot;</span>&lt;&lt;vectorArr[index]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> miniVector&lt;T&gt;::<span class="built_in">pop_back</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(vectorArr == <span class="literal">NULL</span> || size == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Error: Vector size is 0!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    --size;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: size &quot;</span>&lt;&lt; size&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: capacity &quot;</span>&lt;&lt;capacity&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">miniVector&lt;T&gt;::<span class="built_in">miniVector</span>(<span class="type">const</span> miniVector&amp; vec)&#123;</span><br><span class="line">    <span class="comment">//深拷贝</span></span><br><span class="line"></span><br><span class="line">    capacity = vec.capacity;</span><br><span class="line">    size = vec.size;</span><br><span class="line">    vectorArr = <span class="keyword">new</span> T[capacity];</span><br><span class="line">    <span class="built_in">memcpy</span>(vectorArr,vec.vectorArr,size*<span class="built_in">sizeof</span>(T));</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: now in miniVector(const miniVector&amp; vec)  &quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: size &quot;</span>&lt;&lt;size&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: capacity &quot;</span>&lt;&lt;capacity&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">miniVector&lt;T&gt;&amp; miniVector&lt;T&gt;::<span class="keyword">operator</span>=(<span class="type">const</span> miniVector&amp; vec)&#123;</span><br><span class="line">     <span class="comment">//深拷贝</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;vec) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">    capacity = vec.capacity;</span><br><span class="line">    size = vec.size;</span><br><span class="line">    <span class="keyword">delete</span>[] vectorArr;</span><br><span class="line">    vectorArr = <span class="keyword">new</span> T[capacity];</span><br><span class="line">    <span class="built_in">memcpy</span>(vectorArr,vec.vectorArr,size*<span class="built_in">sizeof</span>(T));</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: now in miniVector operator=  &quot;</span>&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: size &quot;</span>&lt;&lt;size&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: capacity &quot;</span>&lt;&lt;capacity&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> miniVector&lt;T&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;</span><br><span class="line">    size=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><em>mainTest.cpp</em></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;miniVector_impl.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">miniVectorTest_pushback_int</span><span class="params">()</span></span>&#123;</span><br><span class="line">    miniVector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">9</span>);    </span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">2</span>);    </span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">3</span>);    </span><br><span class="line">    vec.<span class="built_in">print_info</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DEBUG: vec[2] &quot;</span> &lt;&lt;vec[<span class="number">2</span>]&lt;&lt;endl;</span><br><span class="line">    vec[<span class="number">13</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">miniVectorTest_pushback_char</span><span class="params">()</span></span>&#123;</span><br><span class="line">    miniVector&lt;<span class="type">char</span>&gt; vec;</span><br><span class="line">    vec[<span class="number">1</span>];</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="string">&#x27;h&#x27;</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);    </span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="string">&#x27;p&#x27;</span>);    </span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="string">&#x27;y&#x27;</span>);    </span><br><span class="line">    vec.<span class="built_in">print_info</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DEBUG: vec[2] &quot;</span> &lt;&lt;vec[<span class="number">2</span>]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">miniVectorTest_insert</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">miniVector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">5</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    vec.<span class="built_in">insert</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    vec.<span class="built_in">print_info</span>();</span><br><span class="line">    vec.<span class="built_in">insert</span>(<span class="number">8</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">miniVectorTest_popback</span><span class="params">()</span></span>&#123;</span><br><span class="line">    miniVector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="function">miniVector&lt;<span class="type">int</span>&gt; <span class="title">vec1</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">miniVectorTest_copy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">miniVector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">miniVector&lt;<span class="type">int</span>&gt; <span class="title">vec1</span><span class="params">(vec)</span></span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: vec1[1] &quot;</span>&lt;&lt;vec1[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">    miniVector&lt;<span class="type">int</span>&gt; vec2 = vec1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">miniVectorTest_copyoperator</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">miniVector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">    miniVector&lt;<span class="type">int</span>&gt; vec1;</span><br><span class="line">    miniVector&lt;<span class="type">int</span>&gt; vec2;</span><br><span class="line">    vec2=vec1 = vec;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: vec1[1] &quot;</span>&lt;&lt;vec1[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;LOG: vec2[1] &quot;</span>&lt;&lt;vec2[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">miniVectorTest_copyoperator</span>();</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html"> 用C++实现简易版的Vector</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
</feed>
